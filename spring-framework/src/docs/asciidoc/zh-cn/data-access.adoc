[[spring-data-tier]]
= 数据访问
include::attributes.adoc[]

参考文档的这一部分涉及数据访问以及数据访问层与业务或服务层之间的交互.

详细介绍了Spring全面的事务管理支持,然后全面介绍了Spring框架所集成的各种数据访问框架和技术.

[[transaction]]
== 事务管理

全面的事务支持使用Spring框架最有说服力的原因之一. Spring框架为事务管理提供了一致性的抽象,具有以下优势:

* 跨不同事务API的一致性编程模式,例如JAVA 事务API(JTA) 、JDBC和JAVA持久化API(JPA) ;
* 支持 <<transaction-declarative, 声名式事务管理>>.
* 比复杂事务APIs,比如JTA,更简单的 <<transaction-programmatic, 编程式事务管理>>
* 与Spring的数据访问抽象化的完美集成

以下部分描述了Spring Framework的特性和实现技术:

* <<transaction-motivation, Spring Framework的事务支持模型优点 >> 描述了为什么要使用Spring Framework的事务抽象化,而不使用EJB的容器管理(CMT) 或者选择通过专有API(比如Hibernate)  来驱动本地事务;
* <<transaction-strategies, 理解Spring Framework的事务抽象化>>概述了核心类,以及如何配置并获取不同的数据源实例;
* <<tx-resource-synchronization, 事务和资源同步>> 描述了应用层代码如何确保正确地创建、使用和清理资源;
* <<transaction-declarative, 声名式事务管理>> 描述了对声明式事务管理的支持;
* <<transaction-programmatic, 编程式事务管理>> 描述了对编程式(即明确的编码) 事务管理的支持;
* <<transaction-event, 事务绑定事件>> 描述了如何在事务中使用应用程序事件.

(本章还包括对最佳实践、 <<transaction-application-server-integration, 应用程序服务器集成>> 和<<transaction-solutions-to-common-problems, 常见问题的解决方案>>的讨论. )


[[transaction-motivation]]
=== Spring Framework的事务支持模型优点

传统上,Java EE开发者在事务管理上有两种选择: 全局事务管理或者本地事务管理,两种事务都有很大的局限性.  在接下来的两小节中会对全局事务和本地事务进行介绍,并讨论在Spring Framework的事务管理支持中如何解决 全局事务和本地事务的局限性.


[[transaction-global]]
==== 全局事务

全局事务可以使用多事务源,通常是关系型数据库和消息队列. 应用程序服务器通过JTA管理全局事务,这是一 个繁琐的API(部分原因是它的异常模型) . 此外,JTA的 `UserTransaction` 通常从JNDI获取,这 意味着当你要使用JTA时,还需要使用JNDI. 全局事务的使用限制了应用程序代码的潜在重用性,因为JTA只有 在应用程序服务器环境中才有效.

以前,使用全局事务的首选方法是通过EJB CMT(容器管理事务) . CMT是一种声明式事务管理(不同于编程式事 务管理) . EJB CMT移除了与事务相关的JNDI查找的需求,尽管使用EJB需要使用到JNDI. 它移除了大部分需要编 写Java代码去控制事务的需要. 致命的缺点是CMT与JTA和应用程序服务器环境相关联. 此外,仅当选择在EJB中实 现业务逻辑时(或至少在事务性的EJB之后) ,它才可用. 一般来说,EJB的负面影响之大,以至于这不是一个有 吸引力的主张,尤其是在面对声明式事务管理的令人信服的替代方案时.

[[transaction-local]]
==== 本地事务

本地事务是资源特定的,例如与JDBC连接相关联的事务. 本地事务使用更简单,但是有一个明显的缺点: 它们无法 跨多个事务源工作. 例如,通过JDBC连接管理事务的代码不能在全局JTA事务中运行. 由于应用程序服务器不参与 事务管理,因此无法确保跨多个资源的正确性. (值得注意的是,大多数应用程序使用单个事务资源. ) 另一个缺点 是本地事务对编程模型是侵入式的.

[[transaction-programming-model]]
==== Spring Framework的一致性编程模式

Spring解决了全局事务和本地事务的缺点. 它使应用程序开发人员在任何环境中都使用一致的编程模式. 一次编码, 它可以在不同环境中的不同事务管理策略中使用. Spring Framework提供了声明式和编程式事务管理. 大多数用户 更喜欢声明式事务管理,我们也建议在大多数情况下使用声明式事务管理.

在编程式事务中,开发人员可以使用Spring Framework的事务抽象化,它可以在任何底层事务基础结构上运行. 在更 喜欢使用的声明式事务管理中,开发人员一般很少或者几乎不编写与事务相关的代码,因此,不会依赖于Spring Framework的事务API或者其他的事务API.

.你的应用程序需要事务管理吗?
****
Spring Framework的事务管理支持改变了关于企业Java应用程序何时需要应用程序服务器的传统规则.

特别是,你完全不需要使用一个通过EJB进行声明式事务的应用程序服务器.  实际上,即使您的应用程 序服务器具有强大的JTA功能,您也可以决定让Spring Framework的声明式事务提供比EJB CMT更强大 的功能和更高效的编程模型.

通常,只有当应用程序需要处理跨多个资源的事务时,才需要应用程序服务器的JTA功能,这对许多应 用程序来说并不是必需的. 许多高端应用程序使用单个高度可伸缩的数据库(例如Oracle RAC) .  独立的事务管理器(例如 https://www.atomikos.com/[Atomikos Transactions]  和 http://jotm.objectweb.org/[JOTM]) 是其他选择.  当然,您可能需要其他应用 程序服务器功能,例如Java消息服务(JMS) 和Java EE连接器体系结构(JCA) .

Spring Framework使您可以选择何时将应用程序扩展到完全加载的应用程序服务器.  使用EJB CMT或JTA 的唯一替代方法是使用本地事务(例如JDBC连接上的代码) 编写代码,并且如果您需要在全局容器管理 的事务中运行代码,则会面临大量的返工.  使用 Spring Framework,只需要更改配置文件中的一些 bean  定义(而不是代码) .
****

[[transaction-strategies]]
=== 理解 Spring Framework 的事务抽象化

Spring 事务抽象的关键是事务策略的概念. 事务策略由 `TransactionManager` 定义,特别是用于命令式事务管理的 `org.springframework.transaction.PlatformTransactionManager` 接口和用于响应式事务管理的 `org.springframework.transaction.ReactiveTransactionManager` 接口。 以下清单显示了 `PlatformTransactionManager` API的定义: 如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface PlatformTransactionManager extends TransactionManager {

		TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;

		void commit(TransactionStatus status) throws TransactionException;

		void rollback(TransactionStatus status) throws TransactionException;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface PlatformTransactionManager : TransactionManager {

		@Throws(TransactionException::class)
		fun getTransaction(definition: TransactionDefinition): TransactionStatus

		@Throws(TransactionException::class)
		fun commit(status: TransactionStatus)

		@Throws(TransactionException::class)
		fun rollback(status: TransactionStatus)
	}
---- 

这主要是服务提供者接口(SPI) ,尽管您可以从应用程序代码中以<<transaction-programmatic-ptm, 编程方式>> 使用它.  因为 `PlatformTransactionManager` 是一个接口,所以可以根据需要轻松地模拟或者存根. 它与查询策略无关,例如JNDI.
`PlatformTransactionManager` 实现的定义与Spring Framework IoC容器中的其他对象(或 bean ) 相同. 仅使用此优势使 Spring Framework事务成为一种有价值的抽象,即使您使用JTA也是如此.  与直接使用JTA相比,您可以更轻松地测试事务代码.

同样,为了与Spring的理念保持一致,可以取消选中任何 `PlatformTransactionManager` 接口的方法抛出的 `TransactionException`(即,它扩展了 `java.lang.RuntimeException` 类) . 事务基础故障总是致命的.  在极少数情况下,应用程序代码实际上可以从事务失败中恢复,应用程序开发人员仍然可以选择捕获并处理 `TransactionException`.  重点是开发人员不会被强迫这样做.

`getTransaction(..)` 方法返回 `TransactionStatus` 对象,它具体取决于 `TransactionDefinition` 参数.  如果当前调用的堆栈中存在匹配的事务,则返回的 `TransactionStatus` 可能表示新事务或可表示现有事务.  后一种情况的含义是,与Java EE事务上下文一样,`TransactionStatus` 与执行线程相关联.

从 Spring Framework 5.2 开始，Spring 还提供了一个抽象的事务管理用于使用响应式类型或 Kotlin 协程的响应式应用程序。 下列清单显示了由 `org.springframework.transaction.ReactiveTransactionManager` 定义的事务策略:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface ReactiveTransactionManager extends TransactionManager {

		Mono<ReactiveTransaction> getReactiveTransaction(TransactionDefinition definition) throws TransactionException;

		Mono<Void> commit(ReactiveTransaction status) throws TransactionException;

		Mono<Void> rollback(ReactiveTransaction status) throws TransactionException;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface ReactiveTransactionManager : TransactionManager {

		@Throws(TransactionException::class)
		fun getReactiveTransaction(definition: TransactionDefinition): Mono<ReactiveTransaction>

		@Throws(TransactionException::class)
		fun commit(status: ReactiveTransaction): Mono<Void>

		@Throws(TransactionException::class)
		fun rollback(status: ReactiveTransaction): Mono<Void>
	}
----

响应式事务管理主要是服务提供商接口(SPI)，尽管您可以从应用程序代码中以 <<transaction-programmatic-rtm, 编程>> 方式使用它。 但由于 `ReactiveTransactionManager` 是接口，因此可以根据需要轻松对其进行模拟或存根。

`TransactionDefinition` 接口规定:

* 传播: 通常,在事务范围内执行的所有代码都在该事务中运行.  但是,如果在事务上下文已存在时执行事务方法,则可以指定代码的执行行为.
例如,代码可以继续在现有事务中运行(常见情况) ,或者可以暂停现有事务并创建新事务.  Spring提供了EJB CMT熟悉的所有事务 传播选项.  要阅读有关Spring中事务传播的语义,请参阅<<tx-propagation,事务传播>>.
* 隔离: 此事务与其他事务的工作隔离的程度.  例如,此事务是否可以看到来自其他事务的未提交的写入?
* 超时: 此事务在超时并由底层事务基础结构自动回滚之前运行多长时间.
* 只读状态: 当你的代码只能读取但不能修改数据时,你可以使用只读事务.  在某些情况下,只读事务可能是一种有用的优化,例如当您使用Hibernate时.

这些设置反映了标准的事务概念.  如有必要,请参阅讨论事务隔离级别和其他核心事务概念的资源.  理解这些概念对于使用Spring Framework或其他任何事务管理解 决方案至关重要.

`TransactionStatus` 接口为事务代码提供了一种控制事务执行和查询事务状态的简单方法.  这些概念应该被熟知的,因为它们对于所有事务API都是通用的.  以下清单显示了 `TransactionStatus` 接口:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable {

		@Override
		boolean isNewTransaction();

		boolean hasSavepoint();

		@Override
		void setRollbackOnly();

		@Override
		boolean isRollbackOnly();

		void flush();

		@Override
		boolean isCompleted();
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface TransactionStatus : TransactionExecution, SavepointManager, Flushable {

		override fun isNewTransaction(): Boolean

		fun hasSavepoint(): Boolean

		override fun setRollbackOnly()

		override fun isRollbackOnly(): Boolean

		fun flush()

		override fun isCompleted(): Boolean
	}
----

无论您是在 Spring 中选择声明式还是程序化事务管理,定义正确的 `TransactionManager` 实现都是绝对必要的.  您通常通过依赖注入来定义此实现.

`TransactionManager` 实现通常需要了解它们工作的环境: JDBC,JTA,Hibernate 等.  以下示例显示了如何定义本地 `PlatformTransactionManager` 实现(在本例中,使用普通 JDBC) .

你可以通过创建一个类似与以下内容的 bean 来定义一个JDBC `DataSource`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="${jdbc.driverClassName}" />
		<property name="url" value="${jdbc.url}" />
		<property name="username" value="${jdbc.username}" />
		<property name="password" value="${jdbc.password}" />
	</bean>
----

然后,在相关的 `PlatformTransactionManagerbean` 的定义中引用 `DataSource` 的定义. 它应该类似与以下定义:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
		<property name="dataSource" ref="dataSource"/>
	</bean>
----

如果在Java EE容器中使用JTA,则使用通过JNDI获得的容器 `DataSource` 以及Spring的 `JtaTransactionManager`.  以下示例显示了JTA和JNDI查找版本:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:jee="http://www.springframework.org/schema/jee"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/jee
			https://www.springframework.org/schema/jee/spring-jee.xsd">

		<jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/>

		<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" />

		<!-- other <bean/> definitions here -->

	</beans>
----

`JtaTransactionManager` 不需要了解 `DataSource`(或任何其他特定资源) ,因为它使用容器的全局事务管理基础结构.

NOTE: `dataSource`  bean 的前面定义使用 `jee` 命名空间中的 `<jndi-lookup/>` 标签.  有关更多信息,请参阅<<integration.adoc#xsd-schemas-jee, 参阅 JEE 架构>>.

NOTE: 如果您使用JTA,那么无论您使用何种数据访问技术,无论是JDBC,Hibernate JPA还是任何其他支持的技术, 您的事务管理器定义都应该看起来相同.  这是因为JTA事务是全局事务,可以登记任何事务资源

在所有这些情况下,应用程序代码不需要更改.  您可以仅通过更改配置来更改事务的管理方式,即使该更改意味着从本地事务转移到全局事务,反之亦然. .

[[transaction-strategies-hibernate]]
==== Hibernate Transaction 设置

如以下示例所示,您还可以轻松使用 Hibernate 本地事务.  在这种情况下,您需要定义一个 Hibernate `LocalSessionFactoryBean`,您的应用程序 代码可以使用它来获取 Hibernate `Session` 实例.

NOTE: 如果 `DataSource`(由任何非JTA事务管理器使用) 通过 JNDI 查找并由 Java EE 容器管理,则它应该是非事务性的,因为Spring Framework (而不是Java EE容器) 管理事务.

在这种情况下,`txManager`  bean 是 `HibernateTransactionManager` 类型.  与 `DataSourceTransactionManager` 需要对 `DataSource` 的引用一样, `HibernateTransactionManager` 需要应用 `SessionFactory` 的引用.  以下示例声明了 `SessionFactory` 和 `txManager` bean:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
		<property name="dataSource" ref="dataSource"/>
		<property name="mappingResources">
			<list>
				<value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
			</list>
		</property>
		<property name="hibernateProperties">
			<value>
				hibernate.dialect=${hibernate.dialect}
			</value>
		</property>
	</bean>

	<bean id="txManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
		<property name="sessionFactory" ref="sessionFactory"/>
	</bean>
----

如果使用 Hibernate 和 Java EE 容器管理的 JTA 事务,则应使用与之前的 JDBC JTA 示例相同的 `JtaTransactionManager`,如以下示例所示，另外，建议让Hibernate 通过它的 JTA 了解事务协调器，可能还有其连接释放配置：

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
		<property name="dataSource" ref="dataSource"/>
		<property name="mappingResources">
			<list>
				<value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
			</list>
		</property>
		<property name="hibernateProperties">
			<value>
				hibernate.dialect=${hibernate.dialect}
				hibernate.transaction.coordinator_class=jta
				hibernate.connection.handling_mode=DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT
			</value>
		</property>
	</bean>

	<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
----

或者，您可以将 `JtaTransactionManager` 传递到 `LocalSessionFactoryBean` 中。 强制执行相同的操作

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="sessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
		<property name="dataSource" ref="dataSource"/>
		<property name="mappingResources">
			<list>
				<value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value>
			</list>
		</property>
		<property name="hibernateProperties">
			<value>
				hibernate.dialect=${hibernate.dialect}
			</value>
		</property>
		<property name="jtaTransactionManager" ref="txManager"/>
	</bean>

	<bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/>
----

[[tx-resource-synchronization]]
=== 事务和资源同步

现在应该清楚如何创建不同的事务管理器以及它们如何链接到需要与事务同步的相关资源(例如, 将 `DataSourceTransactionManager` 连接到JDBC `DataSource`,`HibernateTransactionManager` 连接到Hibernate `SessionFactory` 等等) .
本节描述应用程序代码(直接或间接使用诸如 JDBC,Hibernate 或 JPA 之类的持久化 API) 如何确保正确创建,重用和清理这些资源.  本节还讨论了如何(可选) 通过相关的 `TransactionManager` 触发事务同步.


[[tx-resource-synchronization-high]]
==== 高等级同步方法

首选方法是使用Spring最高级别的基于模板的持久化集成API,或者将本地ORM API与事务感知工厂 bean 或代理一起使用, 以管理本地资源工厂. 这些事务感知解决方案在内部处理资源创建、重用和清理,资源的可选事务同步以及异常映射.  因此,用户数据访问代码不必解决这些任务,而是可以完全专注于非样板持久化逻辑. 通常,您使用本地ORM API或使 用模板方法通过使用 `JdbcTemplate` 进行JDBC访问. 这些解决方案将在本参考文档的后续章节中详细介绍.

[[tx-resource-synchronization-low]]
==== 低等级同步方法

诸如 `DataSourceUtils`(用于JDBC) ,`EntityManagerFactoryUtils`(用于JPA) ,`SessionFactoryUtils`(用于Hibernate)  等的类存在于较低级别. 当您希望应用程序代码直接处理本地持久化API的资源类型时,
您可以使用这些类来确保获得正 确的Spring Framework托管实例、同步事务(可选) ,并且在此过程中发生的异常是被正确映射到一致的API.

例如,在使用JDBC的情况下,您可以使用Spring的 `org.springframework.jdbc.datasource.DataSourceUtils` 类, 而不是传统的JDBC方法来调用 `DataSource` 上的 `getConnection()` 方法,如下所示:

[source,java,indent=0,subs="verbatim,quotes"]
----
	Connection conn = DataSourceUtils.getConnection(dataSource);
----

如果现有事务已经与其同步(链接) 了连接,则返回该实例. 否则,方法调用会触发新连接的创建,该连接(可选) 与任何现有事务同步, 并可在随后的同一事务中重用.  如前所述,任何 `SQLException` 都包含在Spring Framework `CannotGetJdbcConnectionException` 中, Spring Framework是未经检查的 `DataAccessException` 类型的层次结构之一. 这种方法为您提供了比从 `SQLException` 轻松获得的更多信息, 并确保跨数据库甚至跨不同持久化技术的可移植性.

这种方法在没有Spring事务管理(事务同步是可选的) 的情况下也可以工作,因此无论您是否使用Spring进行事务管理,都可以使用它.

当然,一旦您使用了Spring的JDBC支持、JPA支持或Hibernate支持,您通常不希望使用 `DataSourceUtils` 或其他帮助类, 因为您通过Spring抽象化工作比直接使用相关API更快乐. 例如,如果您使用Spring `JdbcTemplate` 或 `jdbc.object` 包来简化JDBC的使用, 则在后台进行正确的连接检索,您无需编写任何特殊代码.


[[tx-resource-synchronization-tadsp]]
==== `TransactionAwareDataSourceProxy`

最低级别存在于 `TransactionAwareDataSourceProxy` 类.  这是目标 `DataSource` 的代理,它包装目标 `DataSource` 以添加对 Spring管理的事务的感知. 在这方面,它类似于Java EE服务器提供的事务性JNDI数据源.

您几乎从不需要或不想使用此类,除非必须调用现有代码并传递标准JDBC `DataSource` 接口实现.  在这种情况下,此代码可能可用但参与Spring管理的事务. 您可以使用前面提到的更高级别的抽象来编写新代码.

[[transaction-declarative]]
=== 声名式事务管理

NOTE: 大多数Spring Framework用户选择声明式事务管理.  此选项对应用程序代码的影响最小,因此与非侵入式轻量级容器的理想最为一致.

随着Spring面向方面编程(AOP) 的使用,Spring Framework的声明式事务管理成为可能. 但是,由于事务方面代码随Spring Framework发行 版一起提供并且可能以样板方式使用,因此通常不必理解AOP概念以有效使用此代码.

Spring Framework的声明式事务管理类似于EJB CMT,因为您可以将事务行为(或缺少它) 指定为单个方法级别.  如有必要,您可以在事务上下文中进行 `setRollbackOnly()` 调用.  两种类型的事务管理之间的区别是:

* 与绑定到JTA的EJB CMT不同,Spring Framework的声明式事务管理适用于任何环境.  它可以通过调整配置文件 使用JDBC、JPA或Hibernate来处理JTA事务或本地事务.
* 您可以将Spring Framework声明式事务管理应用于任何类,而不仅仅是EJB等特殊类.
* Spring Framework提供了声明式 <<transaction-declarative-rolling-back, 回滚规则>>,这是一个没有EJB的功能.  编程式事务和声明式事务都提供了对会滚准则的支持.
* Spring Framework允许您使用AOP自定义事务行为.  例如,您可以在事务回滚的情况下插入自定义行为.  您还可以添加 任意通知以及事务性的通知.  使用EJB CMT,除了使用 `setRollbackOnly()` 之外,您无法影响容器的事务管理.
* Spring框架像高端应用程序服务器那样,不支持跨远程调用传播事务上下文. 如果您需要此功能, 我们建议您使用EJB. 但是,在使用此类功能之前请仔细考虑,因为通常情况下,人们不希望事务跨越远程调用.

回滚规则的概念很重要. 它们允许您指定哪些异常(和throwables) 应该被自动回滚. 您可以在配置中以声明方式指定它, 而不是在Java代码中. 因此,尽管您仍然可以在 `TransactionStatus` 对象上调用 `setRollbackOnly()` 来回滚当前事务,
但大多 数情况下您可以指定 `MyApplicationException` 必须始终触发回滚的规则. 此选项的显着优势是业务对象不依赖于事务基础结构.  例如,它们通常不需要导入Spring事务API或其他Spring API.

虽然EJB容器默认行为会自动回滚系统异常(通常是运行时异常) 上的事务,但EJB CMT不会在应用程序异常(即 `java.rmi.RemoteException` 以外的已检查异常)  上自动回滚事务. 虽然声明式事务管理的Spring默认行为遵循EJB约定(回滚仅在未经检查的异常时自动进行) ,但定制此行为通常很有用.

[[tx-decl-explained]]
==== 理解Spring Framework的声明式事务的实现

仅仅通过 `@Transactional` 注解告诉您注解您的类是不够的,将 `@EnableTransactionManagement` 添加到您的配置中,并期望您 了解它是如何工作的.  为了更深入地理解,本节解释了在发生与事务相关的问题时 Spring Framework 的声明式事务基础结构的内部工作原理.

关于 Spring Framework 的声明式事务支持,最重要的概念是<<core.adoc#aop-understanding-aop-proxies, 通过AOP代理>>启用此支持,并且事务性 的通知由元数据(当前基于XML或基于注解) 驱动.
AOP与事务元数据的组合产生一个AOP代理,该代理使用 `TransactionInterceptor` 和适当的 `TransactionManager` 实现来驱动方法调用事务.

NOTE: Spring AOP 在<<core.adoc#aop,AOP部分>>介绍.

Spring Framework 的 `TransactionInterceptor` 为命令式和响应式编程模型提供事务管理。 拦截器通过检查方法返回类型来检测所需的事务管理风格。 返回诸如 `Publisher` 或 Kotlin `Flow`(或它们的子类型)之类的响应式的方法符合响应式事务管理的条件。
所有其他返回类型(包括 `void`)都将代码路径用于命令式事务管理。

[NOTE]
====
`@Transactional` 通常与由 `PlatformTransactionManager` 事务管理的线程绑定在一起使用 ，将事务暴露给所有内部正在执行数据访问操作的线程
。 注意：在方法内部不会 _not_ 传播到新启动的线程。

由 `ReactiveTransactionManager` 管理的响应式事务使用 Reactor 上下文而不是线程局部属性。 所以，所有执行数据访问的操作需要在相同的响应式 pipeline 中的相同 Reactor 上下文中执行。
====

下图显示了在事务代理上调用方法的概念视图:

image::{image-resource}/tx.png[]


[[transaction-declarative-first-example]]
==== 声明式事务实现的例子

请考虑以下接口及其附带实现. 此示例使用 `Foo` 和 `Bar` 类作为占位符,以便您可以专注于事务使用,而无需关注特定的 domain 模型.  出于此示例的目的,`DefaultFooService` 类在每个实现的方法的主体中抛出 `UnsupportedOperationException` 实例的行为是好的.
该行为允许您查看被创建的事务,然后回滚以响应 `UnsupportedOperationException` 实例.  以下清单显示了 `FooService` 接口的详情:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// the service interface that we want to make transactional

	package x.y.service;

	public interface FooService {

		Foo getFoo(String fooName);

		Foo getFoo(String fooName, String barName);

		void insertFoo(Foo foo);

		void updateFoo(Foo foo);

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// the service interface that we want to make transactional

	package x.y.service

	interface FooService {

		fun getFoo(fooName: String): Foo

		fun getFoo(fooName: String, barName: String): Foo

		fun insertFoo(foo: Foo)

		fun updateFoo(foo: Foo)
	}
----

下面的例子展示了以上接口的实现方式:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package x.y.service;

	public class DefaultFooService implements FooService {

		@Override
		public Foo getFoo(String fooName) {
			// ...
		}

		@Override
		public Foo getFoo(String fooName, String barName) {
			// ...
		}

		@Override
		public void insertFoo(Foo foo) {
			// ...
		}

		@Override
		public void updateFoo(Foo foo) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package x.y.service

	class DefaultFooService : FooService {

		override fun getFoo(fooName: String): Foo {
			// ...
		}

		override fun getFoo(fooName: String, barName: String): Foo {
			// ...
		}

		override fun insertFoo(foo: Foo) {
			// ...
		}

		override fun updateFoo(foo: Foo) {
			// ...
		}
	}
----

假设 `FooService` 接口的前两个方法 `getFoo(String)` 和 `getFoo(String, String)`, 必须在具有只读语义的事务上下文中执行,并且方法 `insertFoo(Foo)` 和 `updateFoo(Foo)`,必须 在具有读写语义的事务上下文中执行. 以下配置将在接下来的几段中详细说明:

[source,xml,indent=0,subs="verbatim"]
----
	<!-- from the file 'context.xml' -->
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- this is the service object that we want to make transactional -->
		<bean id="fooService" class="x.y.service.DefaultFooService"/>

		<!-- the transactional advice (what 'happens'; see the <aop:advisor/> bean below) -->
		<tx:advice id="txAdvice" transaction-manager="txManager">
			<!-- the transactional semantics... -->
			<tx:attributes>
				<!-- all methods starting with 'get' are read-only -->
				<tx:method name="get*" read-only="true"/>
				<!-- other methods use the default transaction settings (see below) -->
				<tx:method name="*"/>
			</tx:attributes>
		</tx:advice>

		<!-- ensure that the above transactional advice runs for any execution
			of an operation defined by the FooService interface -->
		<aop:config>
			<aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/>
			<aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/>
		</aop:config>

		<!-- don't forget the DataSource -->
		<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
			<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
			<property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>
			<property name="username" value="scott"/>
			<property name="password" value="tiger"/>
		</bean>

		<!-- similarly, don't forget the TransactionManager -->
		<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
			<property name="dataSource" ref="dataSource"/>
		</bean>

		<!-- other <bean/> definitions here -->

	</beans>
----

查看以上配置,它假定你要创建一个具有事务属性的服务对象,`fooService` bean, 要应用的事务语义在 `<tx:advice/>` 标签中定义. `<tx:advice/>` 中的定义为:  所有方法中,以 `get` 开始的方法,将在只读事务的上下文中执行,其他方法将在默认的事务语义下执行”.
`<tx:advice/>` 标签的 `transaction-manager` 的属性用来设置驱动事务的 `TransactionManager` 的名称. (在本例中为 `txManager` bean)

TIP: 如果要连接的 `TransactionManager` 的bean名称具有名称 `transactionManager`,则可以省略事务通知(`<tx:advice/>`)  中的 `transaction-manager` 属性.  如果要连接的 `TransactionManager` bean具有任何其他名称, 则必须显式使用 `transaction-manager` 属性进行指定,如上例所示.

`<aop:config/>` 定义确保txAdvice bean定义的事务性的通知在程序中的适当位置执行. 首先,定义一个切入点,该切入点与 `FooService` 接口(`fooServiceOperation`) 中定义的任何操作的执行相匹配. 然后使用通知者将切入点与 `txAdvice` 相关联.
结果表明,在执行 `fooServiceOperation` 时,将运行txAdvice定义的通知.

`<aop:pointcut/>` 元素中定义的表达式是切面切入点表达式.  有关Spring中切入点表达式的更多详细信息,请参阅<<core.adoc#aop, AOP 部分>>.

常见的要求是使整个服务层具有事务性. 执行此操作的最佳方法是更改切入点表达式以匹配服务层中的任何操作.  以下示例显示了如何执行此操作:

[source,xml,indent=0,subs="verbatim"]
----
	<aop:config>
		<aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/>
		<aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/>
	</aop:config>
----

NOTE: 在前面的示例中,假设您的所有服务接口都在 `x.y.service` 包中定义.  有关详细信息,请参阅<<core.adoc#aop, AOP 部分>> .

现在我们已经分析了配置,您可能会问自己,"所有这些配置实际上做了什么? "

前面显示的配置用于创建一个环绕对象的事务代理,此对象在 `fooService` bean中定义. 代理配置有事务性通知,以便在代理上调用适当的方法时, 根据与该方法关联的事务配置,将事务启动、挂起、标记为只读等操作. 思考以下程序,用来测试驱动前面显示的配置:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public final class Boot {

		public static void main(final String[] args) throws Exception {
			ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml", Boot.class);
			FooService fooService = (FooService) ctx.getBean("fooService");
			fooService.insertFoo (new Foo());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import org.springframework.beans.factory.getBean

	fun main() {
		val ctx = ClassPathXmlApplicationContext("context.xml")
		val fooService = ctx.getBean<FooService>("fooService")
		fooService.insertFoo(Foo())
	}
----

运行前面程序的输出应该类似于以下内容(为清楚起见,LogFJ 输出和 `DefaultFooService` 类的 `insertFoo(..)` 方法抛出的 `UnsupportedOperationException` 堆栈跟踪已被截断) :

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- the Spring container is starting up... -->
	[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy for bean 'fooService' with 0 common interceptors and 1 specific interceptors

	<!-- the DefaultFooService is actually proxied -->
	[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]

	<!-- ... the insertFoo(..) method is now being invoked on the proxy -->
	[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo

	<!-- the transactional advice kicks in here... -->
	[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]
	[DataSourceTransactionManager] - Acquired Connection [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction

	<!-- the insertFoo(..) method from DefaultFooService throws an exception... -->
	[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should rollback on java.lang.UnsupportedOperationException
	[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo due to throwable [java.lang.UnsupportedOperationException]

	<!-- and the transaction is rolled back (by default, RuntimeException instances cause rollback) -->
	[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection [org.apache.commons.dbcp.PoolableConnection@a53de4]
	[DataSourceTransactionManager] - Releasing JDBC Connection after transaction
	[DataSourceUtils] - Returning JDBC Connection to DataSource

	Exception in thread "main" java.lang.UnsupportedOperationException at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)
	<!-- AOP infrastructure stack trace elements removed for clarity -->
	at $Proxy0.insertFoo(Unknown Source)
	at Boot.main(Boot.java:11)
----

要使用响应式事务管理，代码必须使用响应式风格。

NOTE: Spring Framework 使用 `ReactiveAdapterRegistry` 来确定方法返回类型是否是响应式.

下面的代码使用以前的 `FooService` 的修改版本，但是这次代码使用了响应类型:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// the reactive service interface that we want to make transactional

	package x.y.service;

	public interface FooService {

		Flux<Foo> getFoo(String fooName);

		Publisher<Foo> getFoo(String fooName, String barName);

		Mono<Void> insertFoo(Foo foo);

		Mono<Void> updateFoo(Foo foo);

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// the reactive service interface that we want to make transactional

	package x.y.service

	interface FooService {

		fun getFoo(fooName: String): Flow<Foo>

		fun getFoo(fooName: String, barName: String): Publisher<Foo>

		fun insertFoo(foo: Foo) : Mono<Void>

		fun updateFoo(foo: Foo) : Mono<Void>
	}
----

以下示例显示了上述接口的实现:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package x.y.service;

	public class DefaultFooService implements FooService {

		@Override
		public Flux<Foo> getFoo(String fooName) {
			// ...
		}

		@Override
		public Publisher<Foo> getFoo(String fooName, String barName) {
			// ...
		}

		@Override
		public Mono<Void> insertFoo(Foo foo) {
			// ...
		}

		@Override
		public Mono<Void> updateFoo(Foo foo) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	package x.y.service

	class DefaultFooService : FooService {

		override fun getFoo(fooName: String): Flow<Foo> {
			// ...
		}

		override fun getFoo(fooName: String, barName: String): Publisher<Foo> {
			// ...
		}

		override fun insertFoo(foo: Foo): Mono<Void> {
			// ...
		}

		override fun updateFoo(foo: Foo): Mono<Void> {
			// ...
		}
	}
----

强制性和响应式事务管理对事务边界和事务属性定义共享语义。强制性事务和响应式事务之间的主要区别在于后者的延迟性质。 `TransactionInterceptor` 用事务运算符修饰返回的响应类型，以开始和清理事务。 因此，调用事务响应式方法将实际的事务管理推迟到激活响应式类型的处理的响应类型。

响应式事务管理的另一方面涉及数据转义，这是编程模型的自然结果。

成功终止方法后，从事务方法返回命令性事务的方法返回值，以使部分计算的结果不会逃脱方法的关闭。

响应式事务方法返回一个响应式包装器类型，该类型表示一个计算序列以及一个开始和完成计算的承诺。

当事务正在进行但不一定完成时， `Publisher` 可以发出数据。 因此，依赖于成功完成整个事务的方法需要确保完成并缓冲调用代码中的结果。

[[transaction-declarative-rolling-back]]
==== 回滚声明式事务

上一节概述了如何在应用程序中以声明方式指定类(通常是服务层类) 的事务设置的基础知识.  本节介绍如何以简单的声明方式控制事务回滚.

在Spring Framework的事务基础结构中指明事务的工作被回滚的推荐方法是在当前事务上下文中执行的代码中抛出 `Exception` Spring Framework的事务基础结构代码捕获任何未处理的 `Exception`,因为它冒泡调用堆栈并确定是否将事务标记为回滚.

在其默认配置中,Spring Framework的事务基础结构代码仅在运行时和未经检查的异常情况下标记事务回滚.  也就是说,抛出的异常是 `RuntimeException` 的实例或子类. (默认情况下,`Error` 实例也会导致回滚) . 默认配置中,事务方法中抛出的已检查异常不会导致事务回滚.

您可以准确配置哪些 `Exception` 类型标记用于回滚的事务,包括已检查的异常.  以下XML代码段演示了如何为已检查的特定于应用程序的 `Exception` 类型配置回滚:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tx:advice id="txAdvice" transaction-manager="txManager">
		<tx:attributes>
		<tx:method name="get*" read-only="true" rollback-for="NoProductInStockException"/>
		<tx:method name="*"/>
		</tx:attributes>
	</tx:advice>
----

如果您不希望在抛出异常时回滚事务,则还可以指定 "无回滚规则". 以下示例告诉Spring Framework的事务基础结构即使 面对未处理的 `InstrumentNotFoundException` 也要提交事务:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tx:advice id="txAdvice">
		<tx:attributes>
		<tx:method name="updateStock" no-rollback-for="InstrumentNotFoundException"/>
		<tx:method name="*"/>
		</tx:attributes>
	</tx:advice>
----

当Spring Framework的事务基础结构捕获异常并且它参考配置的回滚规则以确定是否将事务标记为回滚时,最先匹配的规则获胜.  因此,在以下配置的情况下,除了 `InstrumentNotFoundException` 之外的任何异常都会导致后续事务的回滚:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tx:advice id="txAdvice">
		<tx:attributes>
		<tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/>
		</tx:attributes>
	</tx:advice>
----

您还可以以编程方式指示所需的回滚. 虽然它很简单,但这个过程非常具有侵入性,并且会将您的代码紧密地耦合到Spring Framework的事务结构中.  以下示例显示如何以编程方式指示所需的回滚:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public void resolvePosition() {
		try {
			// some business logic...
		} catch (NoProductInStockException ex) {
			// trigger rollback programmatically
			TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun resolvePosition() {
		try {
			// some business logic...
		} catch (ex: NoProductInStockException) {
			// trigger rollback programmatically
			TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
		}
	}
----

如果可能的话,强烈建议您使用声明式方法进行回滚. 只有在必要的情况下,使用编程化回滚,但它的使用方式可以实现基于POJO的简洁体系结构.

[[transaction-declarative-diff-tx]]
==== 为不同的bean配置不同的事务语义

考虑具有多个服务层对象的情况,并且您希望对每个对象应用完全不同的事务配置.  您可以通过使用不同的 `pointcut` 和 `advice-ref` 属性值定义不同的 `<aop:advisor/>` 元素来实现.

作为比较,首先假设您的所有服务层类都在根 `x.y.service` 包中定义.  要使所有作为在该包(或子包中) 中定义的类的实例的bean以及以 `Service` 结尾的类具有默认的事务配置,您可以编写以下内容:

[source,xml,indent=0,subs="verbatim"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<aop:config>

			<aop:pointcut id="serviceOperation"
					expression="execution(* x.y.service..*Service.*(..))"/>

			<aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/>

		</aop:config>

		<!-- these two beans will be transactional... -->
		<bean id="fooService" class="x.y.service.DefaultFooService"/>
		<bean id="barService" class="x.y.service.extras.SimpleBarService"/>

		<!-- ... and these two beans won't -->
		<bean id="anotherService" class="org.xyz.SomeService"/> <!-- (not in the right package) -->
		<bean id="barManager" class="x.y.service.SimpleBarManager"/> <!-- (doesn't end in 'Service') -->

		<tx:advice id="txAdvice">
			<tx:attributes>
				<tx:method name="get*" read-only="true"/>
				<tx:method name="*"/>
			</tx:attributes>
		</tx:advice>

		<!-- other transaction infrastructure beans such as a TransactionManager omitted... -->

	</beans>
----

以下示例显示如何使用完全不同的事务设置配置两个不同的bean:

[source,xml,indent=0,subs="verbatim"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<aop:config>

			<aop:pointcut id="defaultServiceOperation"
					expression="execution(* x.y.service.*Service.*(..))"/>

			<aop:pointcut id="noTxServiceOperation"
					expression="execution(* x.y.service.ddl.DefaultDdlManager.*(..))"/>

			<aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/>

			<aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/>

		</aop:config>

		<!-- this bean will be transactional (see the 'defaultServiceOperation' pointcut) -->
		<bean id="fooService" class="x.y.service.DefaultFooService"/>

		<!-- this bean will also be transactional, but with totally different transactional settings -->
		<bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/>

		<tx:advice id="defaultTxAdvice">
			<tx:attributes>
				<tx:method name="get*" read-only="true"/>
				<tx:method name="*"/>
			</tx:attributes>
		</tx:advice>

		<tx:advice id="noTxAdvice">
			<tx:attributes>
				<tx:method name="*" propagation="NEVER"/>
			</tx:attributes>
		</tx:advice>

		<!-- other transaction infrastructure beans such as a TransactionManager omitted... -->

	</beans>
----


[[transaction-declarative-txadvice-settings]]
==== <tx:advice/> 配置

本节总结了使用 `<tx:advice/>` 标签指定各种事务的配置. 默认的 `<tx:advice/>` 的配置为:

* <<tx-propagation,  传播配置>> 是 `REQUIRED.`
* 隔离级别是 `DEFAULT.`
* 事务可读写
* 事务超时默认为底层事务的默认超时,若事务不支持超时,怎默认值为none.
* 任何 `RuntimeException` 都会触发回滚,任何未检查Exception都不会触发回滚.

你可以修改这些默认的设置. 下表总结了嵌套在 `<tx:advice/>` 和 `<tx:attributes/>` 标记内的 `<tx:method/>` 标记的各种属性:

[[tx-method-settings]]
.<tx:method/> 设置
|===
| Attribute| Required?| Default| Description

| `name`
| Yes
|
| 与事务属性关联的方法名称.  通配符(*) 字符可用于将相同的事务属性设置与多个方法相关联(例如, `get*`, `handle*`, `on*Event` 等) .

| `propagation`
| No
| `REQUIRED`
| 事务传播行为.

| `isolation`
| No
| `DEFAULT`
| 事务隔离级别. 仅适用于 `REQUIRED` 或 `REQUIRES_NEW` 的传播设置.

| `timeout`
| No
| -1
| 事务超时(秒) . 仅适用于传播 `REQUIRED` 或 `REQUIRES_NEW`.

| `read-only`
| No
| false
| 读写与只读事务. 仅适用于 `REQUIRED` 或 `REQUIRES_NEW`.

| `rollback-for`
| No
|
| 以逗号分隔的触发回滚的 `Exception` 实例列表.  例如, `com.foo.MyBusinessException,ServletException`.

| `no-rollback-for`
| No
|
| 以逗号分隔的 `Exception` 实例列表,不会触发回滚. 例如, `com.foo.MyBusinessException,ServletException`.
|===


[[transaction-declarative-annotations]]
==== 使用 `@Transactional`

除了基于XML的事务配置声明方法之外,您还可以使用基于注解的方法. 直接在Java源代码中声明式事务,使声明更接近受影响的代码.  没有太多过度耦合的危险,因为无论如何,用于事务处理的代码几乎总是以这种方式部署.

NOTE: 标准的 `javax.transaction.Transactional` 注解也支持Spring使用自己的注解. 有关更多详细信息,请参阅JTA 1.2文档.

使用 `@Transactional` 注解提供的易用性最好通过一个示例来说明,该示例将在后面的文本中进行说明.  考虑以下类定义:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// the service class that we want to make transactional
	@Transactional
	public class DefaultFooService implements FooService {

		Foo getFoo(String fooName) {
			// ...
		}

		Foo getFoo(String fooName, String barName) {
			// ...
		}

		void insertFoo(Foo foo) {
			// ...
		}

		void updateFoo(Foo foo) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// the service class that we want to make transactional
	@Transactional
	class DefaultFooService : FooService {

		override fun getFoo(fooName: String): Foo {
			// ...
		}

		override fun getFoo(fooName: String, barName: String): Foo {
			// ...
		}

		override fun insertFoo(foo: Foo) {
			// ...
		}

		override fun updateFoo(foo: Foo) {
			// ...
		}
	}
----

如上所述在类级别使用,注解指示声明类(及其子类) 的所有方法的默认值.  或者,每个方法都可以单独注解.  请注意,类级别注解不适用于类层次结构中的父类; 在这种情况下,需要在本地重新声明方法才能参与子类级别的注解.

当如上所述的POJO类在Spring上下文中定义为bean时,可以通过 `@Configuration` 类中的 `@EnableTransactionManagement` 注解使bean实例进行事务处理.  有关完整详细信息,请参阅 {api-spring-framework}/transaction/annotation/EnableTransactionManagement.html[javadoc].

在XML配置文件中,`<tx:annotation-driven/>` 标签提供了类似的便利:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<!-- from the file 'context.xml' -->
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- this is the service object that we want to make transactional -->
		<bean id="fooService" class="x.y.service.DefaultFooService"/>

		<!-- enable the configuration of transactional behavior based on annotations -->
		<tx:annotation-driven transaction-manager="txManager"/><!-- a TransactionManager is still required --> <1>

		<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
			<!-- (this dependency is defined somewhere else) -->
			<property name="dataSource" ref="dataSource"/>
		</bean>

		<!-- other <bean/> definitions here -->

	</beans>
----
<1> 使bean实例使用事务.

TIP: 如果要连接的 `TransactionManager` 的bean名称具有名称 `transactionManager`,则可以省略 `<tx:annotation-driven/>` 标记中的 `transaction-manager` 属性.  如果要依赖注入的 `TransactionManager` bean具有任何其他名称,则必须使用 `transaction-manager` 属性,如上例所示.

相对于命令式，响应式事务方法使用响应式返回类型，如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// the reactive service class that we want to make transactional
	@Transactional
	public class DefaultFooService implements FooService {

		Publisher<Foo> getFoo(String fooName) {
			// ...
		}

		Mono<Foo> getFoo(String fooName, String barName) {
			// ...
		}

		Mono<Void> insertFoo(Foo foo) {
			// ...
		}

		Mono<Void> updateFoo(Foo foo) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// the reactive service class that we want to make transactional
	@Transactional
	class DefaultFooService : FooService {

		override fun getFoo(fooName: String): Flow<Foo> {
			// ...
		}

		override fun getFoo(fooName: String, barName: String): Mono<Foo> {
			// ...
		}

		override fun insertFoo(foo: Foo): Mono<Void> {
			// ...
		}

		override fun updateFoo(foo: Foo): Mono<Void> {
			// ...
		}
	}
----

请注意，对于返回的  `Publisher`，在响应流取消信号方面有一些特殊注意事项。 有关更多详细信息，请参见 <<tx-prog-operator-cancel>> 部分。 有关更多详细信息，请 "使用 TransactionOperator"

.方法可见性与 `@Transactional`
****
使用代理时,只应将 `@Transactional` 注解应用于具有公共可见性的方法.  如果使用 `@Transactional` 注解对 protected,private或package-visible方法进行注解, 则不会引发错误,但带注解的方法不会显示已配置的事务设置. 如果需要对非公共方法使用注解,请考虑使用切面(稍后介绍) .
****

您可以将 `@Transactional` 注解应用于接口定义、接口上的方法、类定义或类上的公共方法.  但是,仅仅存在 `@Transactional` 注解不足以激活事务行为.  `@Transactional` 注解仅用于元数据, 某些运行时基础结构使用可使用 `@Transactional`-aware注解,
并且可以使用元数据来配置具有事 务行为的Bean. 在前面的示例中,`<tx:annotation-driven/>` 元素会切换事务行为.

TIP: Spring团队建议仅在具体类(以及具体类的方法) 上使用 `@Transactional` 注解,而不是在接口上.  你当然可以在接口(以及接口方法) 上使用 `@Transactional` 注解,但是只有你在使用基于接口的代理时才会工作.
Java注解不从接口继承的事实表明,如果你使用基于类的代理(`proxy-target-class="true"`) 或基于织入的切面(`mode="aspectj"`) , 代理和织入的结构将不会识别事务配置,并且对象未包含在事务中.

NOTE: 	在代理模式(默认) 下,代理只拦截外部方法.  这意味着即使被调用的方法用 `@Transactional` 标记,自调用(实际上是,目标对象的方法调用目标对象的另一个方法) 也不会在运行时产生实际事务.
此外,代理应该完全初始化以提供预期的行为,因此您不应该在初始化代码(即 `@PostConstruct`) 中依赖此功能.

如果你正在寻找使用事务包装的自我调用,请考虑使用AspectJ模式(下表为 `mode` 的属性) .  在这种情况下,首先没有代理. 相反,被织入的目标类(即修改字节码) 将 `@Transactional` 注解转换为任何方法的运行时行为.

[[tx-annotation-driven-settings]]
.注解驱动的事务配置
|===
| XML 属性| Annotation 属性| 默认| 描述

| `transaction-manager`
| N/A (see {api-spring-framework}/transaction/annotation/TransactionManagementConfigurer.html[`TransactionManagementConfigurer`] javadoc)
| `transactionManager`
| 用于事务管理的名称. 在之前的例子中,假如事务管理的名称不是 `transactionManager`,那么此属性是必须的.

| `mode`
| `mode`
| `proxy`
| 默认模式(`proxy`) 使用Spring的AOP框架处理要被注解的bean(遵循代理语义,如前所述,仅适用于通过代理进入的方法调用) .  替代模式(`aspectj`) 用Spring的AspectJ事务切面织入受影响的类,修改目标类字节代码以应用于任何类型的方法调用.
AspectJ织入需要类路径中的 `spring-aspects.jar` 以及启用加载时织入(或编译时织入) .  (有关如何设置加载时织入的详细信息,请参阅<<core.adoc#aop-aj-ltw-spring, Spring配置>>. )

| `proxy-target-class`
| `proxyTargetClass`
| `false`
| 仅适用于 `proxy` 模式. 控制使用 `@Transactional` 注解注解的类创建的事务代理类型. 如果 `proxy-target-class` 属性设置为 `true`, 则创建基于类的代理. 如果 `proxy-target-class` 为 `false` 或者省略了该属性,则会创建基于标准JDK接口的代理.  (参见代理机制,详细检查不同的<<core.adoc#aop-proxying, 代理类型>>. )

| `order`
| `order`
| `Ordered.LOWEST_PRECEDENCE`
| 定义使用 `@Transactional` 注解注解的bean的事务通知的顺序. (关于 <<core.adoc#aop-ataspectj-advice-ordering, AOP通知排序>>的相关规则的更多信息,请参考通知排序)  没有指定排序,意味着AOP子系统来决定通知的排序.
|===

NOTE: 处理 `@Transactional` 注解的默认通知模式是 `proxy`,它允许仅通过代理拦截调用.  这种方式不能拦截同一类中的本地方法调用. 对于更高级别的拦截模式,请考虑结合编译时或加载时织入切换到 `aspectj` 模式.

NOTE: `proxy-target-class` 属性控制着使用 `@Transactional` 注解注解的类创建的事务代理的类型.  如果 `proxy-target-class` 的值为 `true`,创建基于类的代理.  如果 `proxy-target-class` 的值为 `false` 或者此属性别省略,则创建基于标准JDK接口的代理.  (有关不同代理类型的讨论,请参阅 <<core.adoc#aop-proxying>> ) .

NOTE: `@EnableTransactionManagement` 和 `<tx:annotation-driven/>` 仅在定义它们的同一应用程序上下文的bean上查找 `@Transactional`.  这意味着,如果你将注解驱动的配置放在 `DispatcherServlet` 的 `WebApplicationContext` 中, 它只会在你的控制器而不是服务器中检查有 `@Transactional` 注解的beans. 有关更多信息,请参阅<<web.adoc#mvc-servlet, MVC>>.

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Transactional(readOnly = true)
	public class DefaultFooService implements FooService {

		public Foo getFoo(String fooName) {
			// ...
		}

		// these settings have precedence for this method
		@Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
		public void updateFoo(Foo foo) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Transactional(readOnly = true)
	class DefaultFooService : FooService {

		override fun getFoo(fooName: String): Foo {
			// ...
		}

		// these settings have precedence for this method
		@Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
		override fun updateFoo(foo: Foo) {
			// ...
		}
	}
----


[[transaction-declarative-attransactional-settings]]
===== `@Transactional` 配置

`@Transactional` 注解是指定接口、类或方法必须具有事务语义的元数据 (例如,"在调用此方法时启动全新的只读事务,暂停任何现有事务") .  默认的 `@Transactional` 设置如下:

* 传播设置为 `PROPAGATION_REQUIRED.`
* 隔离级别是 `ISOLATION_DEFAULT.`
* 事务可读写.
* 事务超时默认为基础事务系统的默认超时,如果不支持超时,则默认为none.
* 任何 `RuntimeException` 都触发回滚,任何受检查 `Exception` 都不触发回滚.

你可以修改这些默认值. 下表概述了 `@Transactional` 注解的各种属性:

[[tx-attransactional-properties]]
.@Transactional 配置
|===
| Property| Type| Description

| <<tx-multiple-tx-mgrs-with-attransactional,value>>
| `String`
| 可选限定符,指定要使用的事务管理器.

| <<tx-propagation,propagation>>
| `enum`: `Propagation`
| 可选的传播设置.

| `isolation`
| `enum`: `Isolation`
| 可选的隔离级别. 只有当传播值为 `REQUIRED` 或 `REQUIRES_NEW` 时可用.

| `timeout`
| `int` (in seconds of granularity)
| 可选的事务超时. 只有当传播值为 `REQUIRED` 或 `REQUIRES_NEW` 时可用.

| `readOnly`
| `boolean`
| 读写与只读事务. 只有在 `REQUIRED` 或 `REQUIRES_NEW` 下可用.

| `rollbackFor`
| Array of `Class` objects, which must be derived from `Throwable.`
| 必定导致回滚的可选异常类数组.

| `rollbackForClassName`
| Array of class names. The classes must be derived from `Throwable.`
| 必定导致回滚的可选异常类数组.

| `noRollbackFor`
| Array of `Class` objects, which must be derived from `Throwable.`
| 必定不会导致回滚的可选异常类数组.

| `noRollbackForClassName`
| Array of `String` class names, which must be derived from `Throwable.`
| 必定不会导致回滚的可选异常类数组.
|===

目前,你无法明确的控制事务的名称, 'name' 意味着在事务监视器(如果可适用,例如WebLogic的事务监视器) 和输出日志中的事物名称, 对于声明式事务,事务名称始终是完全限定的类名+ `.`+事务通知类的方法名.  例如,如果 `BusinessService` 类的方法 `handlePayment(..)`  开始一个事务,
那么事务的名称将是:  `com.example.BusinessService.handlePayment`.

[[tx-multiple-tx-mgrs-with-attransactional]]
===== `@Transactional` 的多事务管理

大多数 Spring 应用程序只需要一个事务管理器,但在某些情况下,您可能需要在单个应用程序中使用多个独立的事务管理器.  您可以使用 `@Transactional` 注解的 `value` 和 `transactionManager` 属性来选择性地指定要使用的 `TransactionManager` 的标识.
这可以是 bean 名称或事务管理器 bean 的限定符值. 例如,使用限定符表示法,您可以将以下 Java 代码 与应用程序上下文中的以下事务管理器bean声明组合在一起:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class TransactionalService {

		@Transactional("order")
		public void setSomething(String name) { ... }

		@Transactional("account")
		public void doSomething() { ... }

        @Transactional("reactive-account")
		public Mono<Void> doSomethingReactive() { ... }
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	class TransactionalService {

		@Transactional("order")
		fun setSomething(name: String) {
			// ...
		}

		@Transactional("account")
		fun doSomething() {
			// ...
		}

		@Transactional("reactive-account")
		fun doSomethingReactive(): Mono<Void> {
			// ...
		}
	}
----

以下清单显示了bean的声明:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<tx:annotation-driven/>

		<bean id="transactionManager1" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
			...
			<qualifier value="order"/>
		</bean>

		<bean id="transactionManager2" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
			...
			<qualifier value="account"/>
		</bean>

		<bean id="transactionManager3" class="org.springframework.data.r2dbc.connectionfactory.R2dbcTransactionManager">
			...
			<qualifier value="reactive-account"/>
		</bean>
----

在这个例子中,`TransactionalService` 上的各个方法在单独的事务管理器下运行,由 `order` 和 `account` 和 `reactive-account` 限定符区分.  如果未找到特定限定符的 `TransactionManager` bean,则仍将使用默认的 `<tx:annotation-driven>` 目标bean名称 `transactionManager`.

[[tx-custom-attributes]]
===== 自定义组合注解

如果您发现在许多不同方法上重复使用与 `@Transactional` 相同的属性, <<core.adoc#beans-meta-annotations, Spring 的元注解支持>> 允许您为特定用例定义自定义组合注解.  例如,请思考以下注解定义:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Target({ElementType.METHOD, ElementType.TYPE})
	@Retention(RetentionPolicy.RUNTIME)
	@Transactional("order")
	public @interface OrderTx {
	}

	@Target({ElementType.METHOD, ElementType.TYPE})
	@Retention(RetentionPolicy.RUNTIME)
	@Transactional("account")
	public @interface AccountTx {
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@Transactional("order")
	annotation class OrderTx

	@Target(AnnotationTarget.FUNCTION, AnnotationTarget.TYPE)
	@Retention(AnnotationRetention.RUNTIME)
	@Transactional("account")
	annotation class AccountTx
----

前面的注解允许我们编写上一节中的示例,如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class TransactionalService {

		@OrderTx
		public void setSomething(String name) {
			// ...
		}

		@AccountTx
		public void doSomething() {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	class TransactionalService {

		@OrderTx
		fun setSomething(name: String) {
			// ...
		}

		@AccountTx
		fun doSomething() {
			// ...
		}
	}
----

在前面的示例中,我们使用语法来定义事务管理器限定符,但我们也可以包含传播行为、回滚规则、超时和其他功能.

[[tx-propagation]]
==== 事务传播属性

本节描述了Spring中事务传播的一些语义. 请注意,本节不是粗略地介绍事务传播.  相反,它详细介绍了Spring中有关事务传播的一些语义.

在Spring管理的事务中,要注意物理和逻辑事务之间的区别,以及在这两种事务中如何应用事务传播.

[[tx-propagation-required]]
===== 理解 `PROPAGATION_REQUIRED`

image::{image-resource}/tx_prop_required.png[]

如果在当前范围内未存在事务或参与为更大范围定义的现有 "外部" 事务,`PROPAGATION_REQUIRED` 会在当前范围内强制执行物理事务.  这是同一线程内公共调用堆栈安排的一个很好的默认值(例如,委托给几个存储库方法的服务,其中所有底层资源都必须参与服务级事务) .

NOTE: 默认情况下,参与的事务加入外部作用域的特征,默认忽略本地隔离级别、超时值或只读标志(如果有) .  如果希望在参与具有不同隔离级别的现有事务时拒绝隔离级别声明, 请考虑在事务管理器上将 `validateExistingTransactions` 标志切换为 `true`.  此非宽松模式还拒绝只读不匹配(即,尝试参与只读外部作用域的内部读写事务) .

当传播设置为 `PROPAGATION_REQUIRED` 时,将为应用该设置的每个方法创建逻辑事务范围.  每个这样的逻辑事务范围可以单独确定仅回滚状态,外部事务范围在逻辑上独立于内部事务范围.  在标准 `PROPAGATION_REQUIRED` 行为的情况下,所有这些范围都映射到同一物理事务.  因此,内部事务范围中的仅回滚标记确实会影响外部事务实际提交的机会.

但是,在内部事务作用域设置仅回滚标记的情况下,外部事务尚未决定回滚本身,因此回滚(由内部事务作用域静默触发) 是意外的.  此时抛出相应的 `UnexpectedRollbackException`.  这是预期的行为,因此事务的调用者永远不会被误导以假设在实际上没有执行提交.  因此,如果内部事务(外部调用者不知道) 以静默方式将事务标记为仅回滚,则外部调用者仍会调用commit.  外部调用者需要接收 `UnexpectedRollbackException` 以清楚地指示已执行回滚.

[[tx-propagation-requires_new]]
===== 理解 `PROPAGATION_REQUIRES_NEW`

image::{image-resource}/tx_prop_requires_new.png[]

与 `PROPAGATION_REQUIRED` 相反,`PROPAGATION_REQUIRES_NEW` 始终对每个受影响的事务范围使用独立的物理事务,从不参与外部范围的现有事务.  在这样的设置中,底层资源事务是不同的,因此可以独立地提交或回滚,外部事务不受内部事务的回滚状态的影响,并且内部事务的锁在完成后立即释放.  这样一个独立的内部事务也可以声明它自己的隔离级别、超时和只读设置,而不是继承外部事务的特性.

[[tx-propagation-nested]]
===== 理解 `PROPAGATION_NESTED`

`PROPAGATION_NESTED` 使用具有多个保存点的单个物理事务,它可以回滚到该事务.  这种部分回滚允许内部事务作用域触发其作用域的回滚,外部事务能够继续使用物理事务,尽管已经回滚了一些操作.  此设置通常映射到JDBC保存点,因此它仅适用于JDBC资源事务.  请参阅Spring的 {api-spring-framework}/jdbc/datasource/DataSourceTransactionManager.html[`DataSourceTransactionManager`].

[[transaction-declarative-applying-more-than-just-tx-advice]]
==== 为事务操作提供咨询

假设您要执行事务操作和一些基本概要分析通知.  你如何在 `<tx:annotation-driven/>` 的上下文中实现这一点?

当你调用 `updateFoo(Foo)` 方法,你希望看到以下操作:

* 配置分析切面的开始.
* 事务性通知的执行.
* 通知对象方法的执行.
* 事务的提交.
* 分析切面报告整个事务方法在执行期间的确切时间.

NOTE: 本章不涉及详细解释AOP(除非它适用于事务) .  有关AOP配置和AOP的详细信息,请参阅 <<core.adoc#aop,AOP 部分>> .

以下代码显示了前面讨论的简单分析切面:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	package x.y;

	import org.aspectj.lang.ProceedingJoinPoint;
	import org.springframework.util.StopWatch;
	import org.springframework.core.Ordered;

	public class SimpleProfiler implements Ordered {

		private int order;

		// allows us to control the ordering of advice
		public int getOrder() {
			return this.order;
		}

		public void setOrder(int order) {
			this.order = order;
		}

		// this method is the around advice
		public Object profile(ProceedingJoinPoint call) throws Throwable {
			Object returnValue;
			StopWatch clock = new StopWatch(getClass().getName());
			try {
				clock.start(call.toShortString());
				returnValue = call.proceed();
			} finally {
				clock.stop();
				System.out.println(clock.prettyPrint());
			}
			return returnValue;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim",role="secondary"]
.Kotlin
----
	class SimpleProfiler : Ordered {

		private var order: Int = 0

		// allows us to control the ordering of advice
		override fun getOrder(): Int {
			return this.order
		}

		fun setOrder(order: Int) {
			this.order = order
		}

		// this method is the around advice
		fun profile(call: ProceedingJoinPoint): Any {
			var returnValue: Any
			val clock = StopWatch(javaClass.name)
			try {
				clock.start(call.toShortString())
				returnValue = call.proceed()
			} finally {
				clock.stop()
				println(clock.prettyPrint())
			}
			return returnValue
		}
	}
----

通过 `Ordered` 接口控制通知的顺序.  有关通知顺序的完整详细信息,请参阅<<core.adoc#aop-ataspectj-advice-ordering,通知顺序>>.

以下配置创建了一个 `fooServicebean`,它以所需的顺序对其应用了分析和事务切面:

[source,xml,indent=0,subs="verbatim"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<bean id="fooService" class="x.y.service.DefaultFooService"/>

		<!-- this is the aspect -->
		<bean id="profiler" class="x.y.SimpleProfiler">
			<!-- run before the transactional advice (hence the lower order number) -->
			<property name="order" value="1"/>
		</bean>

		<tx:annotation-driven transaction-manager="txManager" order="200"/>

		<aop:config>
				<!-- this advice runs around the transactional advice -->
				<aop:aspect id="profilingAspect" ref="profiler">
					<aop:pointcut id="serviceMethodWithReturnValue"
							expression="execution(!void x.y..*Service.*(..))"/>
					<aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/>
				</aop:aspect>
		</aop:config>

		<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
			<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
			<property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/>
			<property name="username" value="scott"/>
			<property name="password" value="tiger"/>
		</bean>

		<bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
			<property name="dataSource" ref="dataSource"/>
		</bean>

	</beans>
----

您可以以类似的方式配置任意数量的其他切面.

以下示例创建与前两个示例相同的设置,但使用纯XML声明方法:

[source,xml,indent=0,subs="verbatim"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<bean id="fooService" class="x.y.service.DefaultFooService"/>

		<!-- the profiling advice -->
		<bean id="profiler" class="x.y.SimpleProfiler">
			<!-- run before the transactional advice (hence the lower order number) -->
			<property name="order" value="1"/>
		</bean>

		<aop:config>
			<aop:pointcut id="entryPointMethod" expression="execution(* x.y..*Service.*(..))"/>
			<!-- runs after the profiling advice (c.f. the order attribute) -->

			<aop:advisor advice-ref="txAdvice" pointcut-ref="entryPointMethod" order="2"/>
			<!-- order value is higher than the profiling aspect -->

			<aop:aspect id="profilingAspect" ref="profiler">
				<aop:pointcut id="serviceMethodWithReturnValue"
						expression="execution(!void x.y..*Service.*(..))"/>
				<aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/>
			</aop:aspect>

		</aop:config>

		<tx:advice id="txAdvice" transaction-manager="txManager">
			<tx:attributes>
				<tx:method name="get*" read-only="true"/>
				<tx:method name="*"/>
			</tx:attributes>
		</tx:advice>

		<!-- other <bean/> definitions such as a DataSource and a TransactionManager here -->

	</beans>
----

前面配置的结果是一个 `fooService` bean,它具有按顺序应用于它的分析和事务切面.  如果希望在事务性通知之后执行性能分析通知, 则可以交换性能分析切面bean的 `order` 属性的值,使其高于事务性通知的顺序值.

你也可以以相似的方式配置其他切面.

[[transaction-declarative-aspectj]]
==== 将 `@Transactional` 与AspectJ一起使用

您还可以通过AspectJ切面在Spring容器外部使用Spring Framework的 `@Transactional` 注解支持.  为此,首先使用 `@Transactional` 注解注解您的类(以及可选的类的方法) ,
然后使用 `spring-aspects.jar` 文件中定义的 `org.springframework.transaction.aspectj.AnnotationTransactionAspect` 链接(织入) 您的应用程序.
您还必须使用事务管理器配置切面. 您可以使用Spring Framework的IoC容器来处理依赖注入的切面.  配置事务管理方面的最简单方法是使用 `<tx:annotation-driven/>` 元素并将 `mode` 属性指定为 `aspectj`,如 使用 <<transaction-declarative-annotations,@Transactional>> 中所述.
因为我们专注于在Spring容器之外运行的应用程序,所以我们将向您展示如何以编程方式执行此操作.

NOTE: 在继续之前,你可能希望分别阅读 使用<<transaction-declarative-annotations,@Transactional>> 和 <<core.adoc#aop, AOP >> .

以下示例显示如何创建事务管理器并配置 `AnnotationTransactionAspect` 以使用它:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// construct an appropriate transaction manager
	DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());

	// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods
	AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// construct an appropriate transaction manager
	val txManager = DataSourceTransactionManager(getDataSource())

	// configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods
	AnnotationTransactionAspect.aspectOf().transactionManager = txManager
----

NOTE: 使用此切面时,必须注解实现类(或该类中的方法或两者) ,而不是类实现的(如果有) 接口.  AspectJ遵循Java的规则,即接口上的注解不会被继承.

类上的 `@Transactional` 注解指定了在类中执行任何公共方法的默认事务语义.

类中方法的 `@Transactional` 注解会覆盖类注解(如果存在) 给出的默认事务语义. 无论可见性如何,您都可以注解任何方法.

将 `AnnotationTransactionAspect` 织入应用程序,必须使用AspectJ构建应用程序 (请参阅 https://www.eclipse.org/aspectj/doc/released/devguide/index.html[AspectJ开发指南]) 或使用加载时织入.  有关使用AspectJ进行加载时编织的讨论,请参阅 <<core.adoc#aop-aj-ltw,Spring Framework中使用AspectJ进行加载时织入>>.

[[transaction-programmatic]]
=== 编程式事务管理

Spring Framework 提供了两种编程式事务管理,通过使用:

* `TransactionTemplate` 或 `TransactionalOperator`.
* 直接使用 `TransactionManager`.

Spring 团队通常建议对于命令式使用 `TransactionTemplate` 进行程序化事务管理.对于响应式推荐使用 `TransactionalOperator`,   第二种方法类似于使用JTA UserTransaction API,尽管异常处理不那么麻烦.

[[tx-prog-template]]
==== 使用 `TransactionTemplate`

`TransactionTemplate` 采用与其他Spring模板相同的方法,例如 `JdbcTemplate`.  它使用回调方法(使应用程序代码免于必须进行样板采集和释放事务资源) 并产生意向驱动的代码,因为您的代码仅关注您想要做的事情.

NOTE: 如下面的示例所示,使用 `TransactionTemplate` 绝对将您与Spring的事务基础结构和API结合在一起.  编程式事务管理是否适合您的开发需求是您必须自己做出的决定.

必须在事务上下文中执行并且显式使用 `TransactionTemplate` 的应用程序代码类似于下一个示例.  作为应用程序开发人员,您可以编写一个 `TransactionCallback` 实现(通常表示为匿名内部类) ,该实现包含您需要在事务上下文中执行的代码.  然后,您可以将自定义 `TransactionCallback` 的实例传递给 `TransactionTemplate` 上暴露的 `execute(..)` 方法.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleService implements Service {

		// single TransactionTemplate shared amongst all methods in this instance
		private final TransactionTemplate transactionTemplate;

		// use constructor-injection to supply the PlatformTransactionManager
		public SimpleService(PlatformTransactionManager transactionManager) {
			this.transactionTemplate = new TransactionTemplate(transactionManager);
		}

		public Object someServiceMethod() {
			return transactionTemplate.execute(new TransactionCallback() {
				// the code in this method runs in a transactional context
				public Object doInTransaction(TransactionStatus status) {
					updateOperation1();
					return resultOfUpdateOperation2();
				}
			});
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// use constructor-injection to supply the PlatformTransactionManager
	class SimpleService(transactionManager: PlatformTransactionManager) : Service {

		// single TransactionTemplate shared amongst all methods in this instance
		private val transactionTemplate = TransactionTemplate(transactionManager)

		fun someServiceMethod() = transactionTemplate.execute<Any?> {
			updateOperation1()
			resultOfUpdateOperation2()
		}
	}
----


如果没有返回值,则可以在匿名类中使用方便的 `TransactionCallbackWithoutResult` 类,如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	transactionTemplate.execute(new TransactionCallbackWithoutResult() {
		protected void doInTransactionWithoutResult(TransactionStatus status) {
			updateOperation1();
			updateOperation2();
		}
	});
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	transactionTemplate.execute(object : TransactionCallbackWithoutResult() {
		override fun doInTransactionWithoutResult(status: TransactionStatus) {
			updateOperation1()
			updateOperation2()
		}
	})
----

回调中的代码可以通过调用提供的 `TransactionStatus` 对象上的 `setRollbackOnly()` 方法来回滚事务,如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	transactionTemplate.execute(new TransactionCallbackWithoutResult() {

		protected void doInTransactionWithoutResult(TransactionStatus status) {
			try {
				updateOperation1();
				updateOperation2();
			} catch (SomeBusinessException ex) {
				status.setRollbackOnly();
			}
		}
	});
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	transactionTemplate.execute(object : TransactionCallbackWithoutResult() {

		override fun doInTransactionWithoutResult(status: TransactionStatus) {
			try {
				updateOperation1()
				updateOperation2()
			} catch (ex: SomeBusinessException) {
				status.setRollbackOnly()
			}
		}
	})
----

[[tx-prog-template-settings]]
===== 指定事务设置

您可以通过编程方式或在配置中指定 `TransactionTemplate` 的事务设置(例如传播模式、隔离级别、超时等) .  默认情况下,`TransactionTemplate` 实例具有<<transaction-declarative-txadvice-settings,默认的事务设置>>.  以下示例显示了编程式用户自定义指定 `TransactionTemplate` 的事务设置:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleService implements Service {

		private final TransactionTemplate transactionTemplate;

		public SimpleService(PlatformTransactionManager transactionManager) {
			this.transactionTemplate = new TransactionTemplate(transactionManager);

			// the transaction settings can be set here explicitly if so desired
			this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
			this.transactionTemplate.setTimeout(30); // 30 seconds
			// and so forth...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleService(transactionManager: PlatformTransactionManager) : Service {

		private val transactionTemplate = TransactionTemplate(transactionManager).apply {
			// the transaction settings can be set here explicitly if so desired
			isolationLevel = TransactionDefinition.ISOLATION_READ_UNCOMMITTED
			timeout = 30 // 30 seconds
			// and so forth...
		}
	}
----

以下示例使用Spring XML定义具有一些自定义事务设置的 `TransactionTemplate`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="sharedTransactionTemplate"
			class="org.springframework.transaction.support.TransactionTemplate">
		<property name="isolationLevelName" value="ISOLATION_READ_UNCOMMITTED"/>
		<property name="timeout" value="30"/>
	</bean>
----

然后,您可以将 `sharedTransactionTemplate` 注入所需的各种服务.

最后,`TransactionTemplate` 类的实例是线程安全的,因为实例不保持任何会话状态.  但是,`TransactionTemplate` 实例会保持配置状态.  因此,虽然许多类可以共享 `TransactionTemplate` 的单个实例, 但如果类需要使用具有不同设置的 `TransactionTemplate`(例如,不同的隔离级别) ,则需要创建两个不同的 `TransactionTemplate` 实例.

[[tx-prog-operator]]
==== Using the `TransactionOperator`

`TransactionOperator` 遵循类似于其他响应式操作的设计。 它使用一种回调方法(使应用程序代码不必进行样板获取和释放事务性资源)，并生成意向驱动的代码，因为您的代码仅专注于您要执行的操作。

NOTE: 如以下示例所示，使用 `TransactionOperator` 绝对可以使您与 Spring 的事务基础结构和 API 结合。 程序化事务管理是否适合您的开发需求是您必须自己做的决定。

必须在事务上下文中执行并且显式使用 `TransactionOperator` 的应用程序代码类似于下一个示例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleService implements Service {

		// single TransactionOperator shared amongst all methods in this instance
		private final TransactionalOperator transactionalOperator;

		// use constructor-injection to supply the ReactiveTransactionManager
		public SimpleService(ReactiveTransactionManager transactionManager) {
			this.transactionOperator = TransactionalOperator.create(transactionManager);
		}

		public Mono<Object> someServiceMethod() {

			// the code in this method runs in a transactional context

            Mono<Object> update = updateOperation1();

			return update.then(resultOfUpdateOperation2).as(transactionalOperator::transactional);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// use constructor-injection to supply the ReactiveTransactionManager
	class SimpleService(transactionManager: ReactiveTransactionManager) : Service {

		// single TransactionalOperator shared amongst all methods in this instance
		private val transactionalOperator = TransactionalOperator.create(transactionManager)

		suspend fun someServiceMethod() = transactionalOperator.executeAndAwait<Any?> {
			updateOperation1()
			resultOfUpdateOperation2()
		}
	}
----

`TransactionalOperator` 可以以两种方式使用:

* 使用 Project Reactor 类型的操作符样式 (`mono.as(transactionalOperator::transactional)`)
* 其他所有情况的回调样式 (`transactionalOperator.execute(TransactionCallback<T>)`)

回调中的代码可以通过在提供的 `ReactiveTransaction` 对象上调用 `setRollbackOnly()` 方法来回滚事务，如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	transactionalOperator.execute(new TransactionCallback<>() {

		public Mono<Object> doInTransaction(ReactiveTransaction status) {
			return updateOperation1().then(updateOperation2)
						.doOnError(SomeBusinessException.class, e -> status.setRollbackOnly());
			}
		}
	});
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	transactionalOperator.execute(object : TransactionCallback() {

		override fun doInTransactionWithoutResult(status: ReactiveTransaction) {
			updateOperation1().then(updateOperation2)
						.doOnError(SomeBusinessException.class, e -> status.setRollbackOnly())
		}
	})
----

[[tx-prog-operator-cancel]]
===== 取消信号

在 Reactive Streams 中，`Subscriber` 可以取消其 `Subscription` 并终止其 `Publisher`。 Project Reactor 以及其他库中的操作，例如 `next()`，`take(long)`, `timeout(Duration)` 等，都可以发出取消操作。 没有办法知道取消的原因，无论是由于错误还是仅仅是出于进一步消费的兴趣，
并且在 5.2 版本中，`TransactionalOperator` 默认在取消时提交事务。 在 5.3 版本中，此行为将更改，并且取消事务回滚以创建可靠的确定性结果。 因此，重要的是要考虑 `Publisher` 下游使用的运算符。 特别是在 `Flux` 或其他多值 `Publisher` 的情况下，全部输出必须消耗以允许事务完成。

[[tx-prog-operator-settings]]
===== 指定事务设置

您可以为 `TransactionalOperator` 指定事务设置(例如传播模式，隔离级别，超时等)。 默认情况下，`TransactionalOperator` 实例具有<<transaction-declarative-txadvice-settings,默认的事务设置>>。 以下示例显示了针对特定 `TransactionalOperator` 的事务设置的自定义:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class SimpleService implements Service {

		private final TransactionalOperator transactionalOperator;

		public SimpleService(ReactiveTransactionManager transactionManager) {
			DefaultTransactionDefinition definition = new DefaultTransactionDefinition();

			// the transaction settings can be set here explicitly if so desired
			definition.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
			definition.setTimeout(30); // 30 seconds
			// and so forth...

			this.transactionalOperator = TransactionalOperator.create(transactionManager, definition);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class SimpleService(transactionManager: ReactiveTransactionManager) : Service {

		private val definition = DefaultTransactionDefinition().apply {
			// the transaction settings can be set here explicitly if so desired
			isolationLevel = TransactionDefinition.ISOLATION_READ_UNCOMMITTED
			timeout = 30 // 30 seconds
			// and so forth...
		}
		private val transactionalOperator = TransactionalOperator(transactionManager, definition)
	}
----

[[transaction-programmatic-tm]]
==== 使用 `TransactionManager`

以下各节说明命令式和响应式事务管理器的用法。


[[transaction-programmatic-ptm]]
==== 使用 `PlatformTransactionManager`

您还可以直接使用 `org.springframework.transaction.PlatformTransactionManager` 来管理您的事务.  为此,请通过bean引用将您使用的 `PlatformTransactionManager` 的实现传递给bean.
然后,通过使用 `TransactionDefinition` 和 `TransactionStatus` 对象,您可以初始化事务、回滚和提交.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	DefaultTransactionDefinition def = new DefaultTransactionDefinition();
	// explicitly setting the transaction name is something that can be done only programmatically
	def.setName("SomeTxName");
	def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

	TransactionStatus status = txManager.getTransaction(def);
	try {
		// put your business logic here
	}
	catch (MyException ex) {
		txManager.rollback(status);
		throw ex;
	}
	txManager.commit(status);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val def = DefaultTransactionDefinition()
	// explicitly setting the transaction name is something that can be done only programmatically
	def.setName("SomeTxName")
	def.propagationBehavior = TransactionDefinition.PROPAGATION_REQUIRED

	val status = txManager.getTransaction(def)
	try {
		// put your business logic here
	} catch (ex: MyException) {
		txManager.rollback(status)
		throw ex
	}

	txManager.commit(status)
----

[[transaction-programmatic-rtm]]
===== Using the `ReactiveTransactionManager`

使用响应式事务时，可以直接使用 `org.springframework.transaction.ReactiveTransactionManager` 来管理事务。 因此，请通过 bean 引用将您使用的 `ReactiveTransactionManager` 的实现传递给 bean。 然后，通过使用 `TransactionDefinition` 和 `ReactiveTransaction` 对象，可以启动事务，回滚和提交。 以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	DefaultTransactionDefinition def = new DefaultTransactionDefinition();
	// explicitly setting the transaction name is something that can be done only programmatically
	def.setName("SomeTxName");
	def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

	Mono<ReactiveTransaction> reactiveTx = txManager.getReactiveTransaction(def);

	reactiveTx.flatMap(status -> {

		Mono<Object> tx = ...; // put your business logic here

		return tx.then(txManager.commit(status))
				.onErrorResume(ex -> txManager.rollback(status).then(Mono.error(ex)));
	});
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val def = DefaultTransactionDefinition()
	// explicitly setting the transaction name is something that can be done only programmatically
	def.setName("SomeTxName")
	def.propagationBehavior = TransactionDefinition.PROPAGATION_REQUIRED

	val reactiveTx = txManager.getReactiveTransaction(def)
	reactiveTx.flatMap { status ->

		val tx = ... // put your business logic here

		tx.then(txManager.commit(status))
				.onErrorResume { ex -> txManager.rollback(status).then(Mono.error(ex)) }
	}
----

[[tx-decl-vs-prog]]
=== 在编程式和声明式事务管理之间进行选择

只有在进行少量事务操作时,编程式事务管理通常才是一个好主意.  例如,如果您的Web应用程序仅需要针对某些更新操作进行事务处理,则可能不希望使用Spring或任何其他技术来设置事务代理.  在这种情况下,使用 `TransactionTemplate` 可能是一个很好的方法.  能够明确地设置事务名称,也只能通过使用编程式方法进行事务管理.

另一方面,如果您的应用程序有许多事务操作,那么使用声明式事务管理通常是值得的.  它将事务与业务逻辑分离并且配置简单. 使用Framework而不是EJB CMT时,声明式事务的配置成本大大降低.

[[transaction-event]]
=== 事务绑定事件

从Spring 4.2开始,事件的监听器可以绑定到事务的一个阶段.  典型示例是在事务成功完成时处理事件. 这样做可以在当前事务的结果对于监听器实际上很重要时,更灵活地使用事件.

您可以使用 `@EventListener` 注解注册常规事件监听器. 如果需要将其绑定到事务,请使用 `@TransactionalEventListener`.  执行此操作时,默认情况下,监听器将绑定到事务的提交阶段.

下一个例子展示了这个概念. 假设一个组件发布一个订单创建的事件, 并且我们想要定义一个只应该在发布它的事务成功提交后才应该处理该事件的监听器.  以下示例设置此类事件监听器:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Component
	public class MyComponent {

		@TransactionalEventListener
		public void handleOrderCreatedEvent(CreationEvent<Order> creationEvent) {
			// ...
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Component
	class MyComponent {

		@TransactionalEventListener
		fun handleOrderCreatedEvent(creationEvent: CreationEvent<Order>) {
			// ...
		}
	}
----

`@TransactionalEventListener` 注解暴露了一个 phase 属性,该属性允许您自定义监听器应绑定到的事务的阶段.  有效阶段是 `BEFORE_COMMIT`、`AFTER_COMMIT`(默认值) 、 `AFTER_ROLLBACK` 和 `AFTER_COMPLETION`,它们聚合事务完成(无论是提交还是回滚) .

如果没有事务正在运行,那么根本不会被调用监听器,因为我们无法遵守所需的语义.  然而,你可以通过设置注解的 `fallbackExecution` 属性值为 `true` 来覆盖该行为.

[NOTE]
====
`@TransactionalEventListener` 仅适用于由 `PlatformTransactionManager` 管理的线程绑定事务。 由 `ReactiveTransactionManager` 管理的响应式事务使用的是 Reactor 上下文而不是线程局部属性，因此事件侦听器，没有可以参与的活动事务。
====

[[transaction-application-server-integration]]
=== 应用程序服务器集成

Spring的事务抽象通常与应用程序服务器无关.  此外,Spring的 `JtaTransactionManager` 类 (可以选择对 JTA `UserTransaction` 和 `TransactionManager` 对象执行JNDI查找) 自动检测后一个对象的位置,该位置因应用程序服务器而异.
有权访问JTA `TransactionManager` 允许增强的事务语义--特别是支持事务挂起.  有关详细信息,请参阅 {api-spring-framework}/transaction/jta/JtaTransactionManager.html[`JtaTransactionManager`]文档.

Spring的 `JtaTransactionManager` 是在Java EE应用程序服务器上运行的标准选择,并且已知可在所有常见服务器上运行.  高级功能(例如事务挂起) 也适用于许多服务器(包括 GlassFish、JBoss和Geronimo) ,无需任何特殊配置.  但是,对于完全支持的事务挂起和进一步的高级集成,Spring包含用于WebLogic Server和WebSphere的特殊适配器.  以下各节将讨论这些适配器.

对于标准方案(包括WebLogic Server和WebSphere) ,请考虑使用方便的 `<tx:jta-transaction-manager/>` 配置元素.  配置后,此元素会自动检测基础服务器并选择可用于平台的最佳事务管理器.  这意味着您无需显式配置特定于服务器的适配器类(如以下部分所述) .  相反,它们是自动选择的,标准的 `JtaTransactionManager` 作为默认的退出.

[[transaction-application-server-integration-websphere]]
==== IBM WebSphere

在WebSphere 6.1.0.9及更高版本中,要使用的推荐Spring JTA事务管理器是 `WebSphereUowTransactionManager`.  此特殊适配器使用IBM的 `UOWManager` API,该API在WebSphere应用程序服务器6.1.0.9及更高版本中可用.  使用此适配器,IBM正式支持Spring驱动的事务挂起(由 `PROPAGATION_REQUIRES_NEW` 启动的事务的挂起和恢复) .

[[transaction-application-server-integration-weblogic]]
==== Oracle WebLogic Server

在WebLogic Server 9.0或更高版本上,通常使用 `WebLogicJtaTransactionManager` 而不是原有的 `JtaTransactionManager` 类.  这个普通 `JtaTransactionManager` 的特殊WebLogic特定子类在WebLogic管理的事务环境中支持Spring定义的事务的全部功能,超出了标准的JTA语义.  这些功能包括事务名称,事务隔离级别以及在所有情况下正确恢复事务.

[[transaction-solutions-to-common-problems]]
=== 常见问题的解决方案

本节介绍了一些常见问题的解决方案.

[[transaction-solutions-to-common-problems-wrong-ptm]]
==== 使用错误的事务管理器来获取特定的 `DataSource`

根据您选择的事务技术和要求,使用正确的 `PlatformTransactionManager` 实现.  如果使用得当,Spring Framework只提供了简单易用的抽象.  如果使用全局事务,则必须对所有事务操作使用 `org.springframework.transaction.jta.JtaTransactionManager` 类(或它的<<transaction-application-server-integration,特定于应用程序服务器的子类>> ) .  否则,事务基础结构尝试在诸如容器 `DataSource` 实例之类的资源上执行本地事务.  这样的本地事务没有意义,好的应用程序服务器将它们视为错误.

[[transaction-resources]]
=== 更多资源

有关Spring Framework的事务支持的更多信息,请参阅:

* https://www.javaworld.com/javaworld/jw-01-2009/jw-01-spring-transactions.html[Spring中的分布式事务] 有或没有XA是一个JavaWorld演示文稿, 其中Spring的David Syer将引导您完成Spring应用程序中分布式事务的七种模式,其中三种使用XA,四种不使用.
* https://www.infoq.com/minibooks/JTDS[_Java事务设计策略_] 是
  available from https://www.infoq.com/[InfoQ] 提供的一本书,它提供了对Java中事务的快速介绍.  它还包括如何使用Spring Framework和EJB3配置和使用事务的并排示例.

[[dao]]
== DAO 支持

Spring中的数据访问对象(DAO) 支持旨在使您能够以一致的方式轻松使用数据访问技术(如JDBC,Hibernate或JPA) .  这使您可以非常轻松地在上述持久性技术之间切换,并且还可以让您编写代码而无需担心捕获特定于每种技术的异常.

[[dao-exceptions]]
=== 一致的异常层次结构

Spring 提供了从特定于技术的异常(例如 `SQLException`) 到其自己的异常类层次结构的便捷转换, 该异常类层次结构将 `DataAccessException` 作为父异常.  这些异常包装了原始异常,因此您可能永远不会丢失任何可能出错的信息.

除了 JDBC 异常之外,Spring 还可以包装特定于 JPA 和 Hibernate 的异常,将它们转换为一组集中的运行时异常.  这使您可以仅在适当的层中处理大多数不可恢复的持久性异常,而无需在 DAO 中使用恼人的样板 catch-and-throw 块和异常声明.  (您仍然可以在任何需要的位置捕获和处理异常. ) 如上所述,JDBC 异常(包括特定于数据库的方言) 也会转换为相同的层次结构, 这意味着您可以在一致的编程模型中使用JDBC执行某些操作.

前面的讨论适用于Spring对各种ORM框架的支持中的各种模板类.  如果使用基于拦截器的类, 则应用程序必须关心处理 `HibernateExceptions` 和 `PersistenceExceptions` 本身, 最好分别委托 `SessionFactoryUtils` 的 `convertHibernateAccessException(..)`
或 `convertJpaAccessException()` 方法.  这些方法将异常转换为与 `org.springframework.dao` 异常层次结构中兼容的异常.  由于 `PersistenceExceptions` 未被检测的异常,它们也可能被抛出(尽管就异常而言牺牲了通用DAO抽象) .

下图显示了Spring提供的异常层次结构.  (请注意,图像中详细说明的类层次结构仅显示整个 `DataAccessException` 层次结构的子集. )

image::{image-resource}/DataAccessException.png[]


[[dao-annotations]]
=== 用于配置 DAO 或存储库类的注解

保证数据访问对象(DAO) 或存储库提供异常转换的最佳方法是使用 `@Repository` 注解.  此注解还允许组件扫描支持查找和配置DAO和存储库,而无需为它们提供XML配置.  以下示例显示如何使用 `@Repository` 注解:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Repository // <1>
	public class SomeMovieFinder implements MovieFinder {
		// ...
	}
----
<1> `@Repository` 注解.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Repository // <1>
	class SomeMovieFinder : MovieFinder {
		// ...
	}
----
<1> `@Repository` 注解.


任何 DAO 或存储库实现都需要访问持久化资源,这具体取决于所使用的持久性技术.  例如,基于 JDBC 的存储库需要访问 JDBC `DataSource`,而基于 JPA 的存储库需要访问 `EntityManager`.
完成此操作的最简单方法是使用 `@Autowired`、`@Inject`、 `@Resource` 或 `@PersistenceContext` 注解之一注入此资源依赖.  以下示例适用于 JPA 存储库:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Repository
	public class JpaMovieFinder implements MovieFinder {

		@PersistenceContext
		private EntityManager entityManager;

		// ...
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Repository
	class JpaMovieFinder : MovieFinder {

		@PersistenceContext
		private lateinit var entityManager: EntityManager

		// ...
	}
----

如果您使用经典的Hibernate API,则可以注入 `SessionFactory`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Repository
	public class HibernateMovieFinder implements MovieFinder {

		private SessionFactory sessionFactory;

		@Autowired
		public void setSessionFactory(SessionFactory sessionFactory) {
			this.sessionFactory = sessionFactory;
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Repository
	class HibernateMovieFinder(private val sessionFactory: SessionFactory) : MovieFinder {
		// ...
	}
----

我们在这里展示的最后一个例子是典型的JDBC支持.  您可以将 `DataSource` 注入到初始化方法中, 您可以使用此 `DataSource` 创建 `JdbcTemplate` 和其他数据访问支持类(如 `SimpleJdbcCall` 等) .  以下示例自动装配 `DataSource`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Repository
	public class JdbcMovieFinder implements MovieFinder {

		private JdbcTemplate jdbcTemplate;

		@Autowired
		public void init(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		// ...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Repository
	class JdbcMovieFinder(dataSource: DataSource) : MovieFinder {
		
		private val jdbcTemplate = JdbcTemplate(dataSource)

		// ...
	}
----

NOTE: 有关如何配置应用程序上下文以利用这些注解的详细信息,请参阅每种持久性技术的具体内容.

[[jdbc]]
== 使用JDBC进行数据访问

Spring Framework JDBC抽象提供的值通过下表中列出的操作序列显示.  该表显示了Spring负责的操作以及您负责的操作.

[[jdbc-who-does-what]]
.Spring JDBC - who does what?
|===
| Action| Spring| You

| 定义连接参数
|
| X

| 打开连接
| X
|

| 指定 SQL 语句
|
| X

| 声明参数并提供参数的值
|
| X

| 准备并执行语句
| X
|

| 通过结果集(如果有) 设置迭代器循环
| X
|

| 为每次迭代做好工作.
|
| X

| 处理任务异常
| X
|

| 处理事务.
| X
|

| 关闭连接、语句和结果集
| X
|
|===

Spring Framework负责处理所有可能使JDBC成为繁琐API的低级细节.

[[jdbc-choose-style]]
=== 选择JDBC数据库访问方法

您可以选择多种方法来构成JDBC数据库访问的基础.  除了三种类型的 `JdbcTemplate` 之外, 新的 `SimpleJdbcInsert` 和 `SimpleJdbcCall` 方法还优化了数据库元数据, 而RDBMS Object样式采用了类似于JDO Query设计的面向对象方法.  一旦开始使用这些方法之一,您仍然可以混合和匹配以包含来自不同方法的功能.  所有方法都需要JDBC 2.0兼容的驱动程序,而某些高级功能需要JDBC 3.0驱动程序.

* `JdbcTemplate` 是经典且最流行的Spring JDBC方法.  这种 "最低级别" 的方法和所有其他方法都使用了 JdbcTemplate.
* `NamedParameterJdbcTemplate` 包装 `JdbcTemplate` 以提供命名参数而不是传统的JDBC `?` 占位符.  当您有多个SQL语句参数时,此方法可提供更好的文档和易用性.
* `SimpleJdbcInsert` 和 `SimpleJdbcCall` 优化数据库元数据以限制必要的配置量.  此方法简化了编码,因此您只需提供表或过程的名称,并提供与列名匹配的参数映射.  仅当数据库提供足够的元数据时,这才有效.  如果数据库未提供此元数据,则必须提供参数的显式配置.
* RDBMS - 对象(包括 `MappingSqlQuery`、`SqlUpdate` 和 `StoredProcedure`) 要求您在数据访问层初始化期间创建可重用且线程安全的对象.  此方法以 JDO Query 为模型,其中您定义查询字符串、声明参数和编译查询.  执行此操作后,可以使用各种参数值多次调用   `execute(...)`, `update(...)`, 和 `findObject(...)` 方法.

[[jdbc-packages]]
=== 包层次结构

Spring Framework的JDBC抽象框架由四个不同的包组成:

* `core`: `org.springframework.jdbc.core` 包中包含 `JdbcTemplate` 类及其各种回调接口,以及各种相关类.  名为 `org.springframework.jdbc.core.simple` 的子包包含 `SimpleJdbcInsert` 和 `SimpleJdbcCall` 类.
另一个名为 `org.springframework.jdbc.core.namedparam` 的子包包含 `NamedParameterJdbcTemplate` 类和相关的支持类.  请参阅<<jdbc-core,使用JDBC核心类控制基本JDBC处理和错误处理>>,  <<jdbc-advanced-jdbc,JDBC批处理操作>>以及<<jdbc-simple-jdbc,使用SimpleJdbc类简化JDBC操作>>.

* `datasource`: `org.springframework.jdbc.datasource` 包中包含一个用于轻松访问 `DataSource` 的实用程序类 和各种简单的 `DataSource` 实现,可用于在Java EE容器外测试和运行未修改的JDBC代码.
名为 `org.springfamework.jdbc.datasource.embedded` 的子包提供了使用Java数据库引擎(如HSQL,H2和Derby) 创建嵌入式数据库的支持.  请参阅<<jdbc-connections,控制数据库连接>>和<<jdbc-embedded-database-support,嵌入式数据库支持>>.

* `object`: `org.springframework.jdbc.object` 包中包含将RDBMS查询,更新和存储过程表示为线程安全,可重用对象的类.  请参阅将<<jdbc-object,JDBC操作建模为Java对象>>.
这种方法由JDO建模,尽管查询返回的对象自然与数据库断开连接.  这种更高级别的JDBC抽象取决于 `org.springframework.jdbc.core` 包中的低级抽象.

* `support`: `org.springframework.jdbc.support` 包提供 `SQLException` 转换功能和一些实用程序类.  JDBC处理期间抛出的异常将转换为 `org.springframework.dao` 包中定义的异常.  这意味着使用Spring JDBC抽象层的代码不需要实现JDBC或RDBMS特定的错误处理.
所有已转换的异常都是未被检测的,这使您可以选择捕获可恢复的异常,同时将其他异常传播给调用方.  请参阅使用 <<jdbc-SQLExceptionTranslator, `SQLExceptionTranslator`>>.

[[jdbc-core]]
=== 使用JDBC核心类控制基本JDBC处理和错误处理

本节介绍如何使用 JDBC 核心类来控制基本的JDBC处理,包括错误处理. 它包括以下主题:

* <<jdbc-JdbcTemplate,使用 `JdbcTemplate`>>
* <<jdbc-NamedParameterJdbcTemplate, 使用 `NamedParameterJdbcTemplate`>>
* <<jdbc-SQLExceptionTranslator,使用 `SQLExceptionTranslator`>>
* <<jdbc-statements-executing,执行语句>>
* <<jdbc-statements-querying,执行查询>>
* <<jdbc-updates,更新数据库>>
* <<jdbc-auto-generated-keys,检索自动生成的密钥>>


[[jdbc-JdbcTemplate]]
==== 使用 `JdbcTemplate`

`JdbcTemplate` 是JDBC核心包中的中心类. 它处理资源的创建和释放,帮助您避免常见错误,例如忘记关闭连接.  它执行核心JDBC工作流的基本任务(例如语句创建和执行) ,留下应用程序代码以提供SQL并提取结果. `JdbcTemplate` 类:

* 执行SQL查询
* 更新语句和存储过程调用
* 对 `ResultSet` 实例执行迭代并提取返回的参数值.
* 捕获 JDBC 异常并将它们转换为 `org.springframework.dao` 包中定义的通用的、信息量更大的异常层次结构.  (请参阅<<dao-exceptions,一致的异常层次结构>>. )

当您为代码使用 `JdbcTemplate` 时,您只需要实现回调接口,为它们提供明确定义的合同.  给定 `JdbcTemplate` 类提供的 `Connection`,`PreparedStatementCreator` 回调接口创建一个预准备语句,提供SQL和任何必要的参数.  `CallableStatementCreator` 接口也是如此,它创建了可调用语句.  `RowCallbackHandler` 接口从 `ResultSet` 的每一行中提取值.

您可以通过引用 `DataSource` 的直接实例,在DAO实现中使用 `JdbcTemplate`, 也可以在Spring IoC容器中对其进行配置,并将其作为bean引用提供给DAO.

NOTE: 应始终将 `DataSource` 配置为Spring IoC容器中的bean.  在第一种情况下,bean直接提供给服务; 在第二种情况下,它被给予准备好的模板.

此类发出的所有SQL都记录在与模板实例的完全限定类名对应的类别下的DEBUG级别 (通常为 `JdbcTemplate`,但如果使用 `JdbcTemplate` 类的自定义子类,则可能会有所不同) .

以下部分提供了一些JdbcTemplate用法的示例. 这些示例并不是 `JdbcTemplate` 暴露的所有功能的详尽列表.  具体请参阅 {api-spring-framework}/jdbc/core/JdbcTemplate.html[javadoc].

[[jdbc-JdbcTemplate-examples-query]]
===== 查询 (`SELECT`)

以下查询获取相关的行数:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	int rowCount = this.jdbcTemplate.queryForObject("select count(*) from t_actor", Integer.class);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val rowCount = jdbcTemplate.queryForObject<Int>("select count(*) from t_actor")!!
----

以下查询使用绑定变量:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	int countOfActorsNamedJoe = this.jdbcTemplate.queryForObject(
			"select count(*) from t_actor where first_name = ?", Integer.class, "Joe");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val countOfActorsNamedJoe = jdbcTemplate.queryForObject<Int>(
			"select count(*) from t_actor where first_name = ?", arrayOf("Joe"))!!
----


以下查询查找 `String`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	String lastName = this.jdbcTemplate.queryForObject(
			"select last_name from t_actor where id = ?",
			String.class, 1212L);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val lastName = this.jdbcTemplate.queryForObject<String>(
			"select last_name from t_actor where id = ?",
			arrayOf(1212L))!!
----

以下查询查找并填充单个域对象:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	Actor actor = jdbcTemplate.queryForObject(
			"select first_name, last_name from t_actor where id = ?",
			(resultSet, rowNum) -> {
				Actor newActor = new Actor();
				newActor.setFirstName(resultSet.getString("first_name"));
				newActor.setLastName(resultSet.getString("last_name"));
				return newActor;
			},
			1212L);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val actor = jdbcTemplate.queryForObject(
				"select first_name, last_name from t_actor where id = ?",
				arrayOf(1212L)) { rs, _ ->
			Actor(rs.getString("first_name"), rs.getString("last_name"))
		}
----

以下查询查找并填充多个域对象:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	List<Actor> actors = this.jdbcTemplate.query(
			"select first_name, last_name from t_actor",
			(resultSet, rowNum) -> {
				Actor actor = new Actor();
				actor.setFirstName(resultSet.getString("first_name"));
				actor.setLastName(resultSet.getString("last_name"));
				return actor;
			});
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val actors = jdbcTemplate.query("select first_name, last_name from t_actor") { rs, _ ->
			Actor(rs.getString("first_name"), rs.getString("last_name"))
----

如果最后两个代码片段实际存在于同一个应用程序中,那么删除两个 `RowMapper` lambda 表达式中重复的代码段并将他们提取到一个字段 ,当需要时通过 DAO 方法引用它.  例如,最好重写前面的代码片段,如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	private final RowMapper<Actor> actorRowMapper = (resultSet, rowNum) -> {
		Actor actor = new Actor();
		actor.setFirstName(resultSet.getString("first_name"));
		actor.setLastName(resultSet.getString("last_name"));
		return actor;
	};

	public List<Actor> findAllActors() {
		return this.jdbcTemplate.query( "select first_name, last_name from t_actor", actorRowMapper);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val actorMapper = RowMapper<Actor> { rs: ResultSet, rowNum: Int ->
		Actor(rs.getString("first_name"), rs.getString("last_name"))
	}

	fun findAllActors(): List<Actor> {
		return jdbcTemplate.query("select first_name, last_name from t_actor", actorMapper)
	}
----

[[jdbc-JdbcTemplate-examples-update]]
===== 使用 `JdbcTemplate` 更新  (`INSERT`, `UPDATE`, and `DELETE`)

您可以使用 `update(..)` 方法执行插入,更新和删除操作.  参数值通常作为变量参数提供,或者作为对象数组提供.

一下例子是插入一个新的纪录:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	this.jdbcTemplate.update(
			"insert into t_actor (first_name, last_name) values (?, ?)",
			"Leonor", "Watling");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	jdbcTemplate.update(
			"insert into t_actor (first_name, last_name) values (?, ?)",
			"Leonor", "Watling")
----

以下例子是更新已存在的纪录:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	this.jdbcTemplate.update(
			"update t_actor set last_name = ? where id = ?",
			"Banjo", 5276L);
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	jdbcTemplate.update(
			"update t_actor set last_name = ? where id = ?",
			"Banjo", 5276L)
----

以下例子是删除一条纪录:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	this.jdbcTemplate.update(
			"delete from t_actor where id = ?",
			Long.valueOf(actorId));
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	jdbcTemplate.update("delete from t_actor where id = ?", actorId.toLong())
----

[[jdbc-JdbcTemplate-examples-other]]
===== `JdbcTemplate` 的其他操作

您可以使用 `execute(..)` 方法运行任意SQL.  因此,该方法通常用于DDL语句. 它重载了带有回调接口,绑定变量数组等的变体. 以下示例创建一个表:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	jdbcTemplate.execute("create table mytable (id integer, name varchar(100))")
----

以下示例调用存储过程:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	this.jdbcTemplate.update(
			"call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",
			Long.valueOf(unionId));
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	jdbcTemplate.update(
			"call SUPPORT.REFRESH_ACTORS_SUMMARY(?)",
			unionId.toLong())
----


<<jdbc-StoredProcedure, 稍后>>将介绍更复杂的存储过程支持.

[[jdbc-JdbcTemplate-idioms]]
===== `JdbcTemplate` 最佳实践

一旦配置,`JdbcTemplate` 类的实例就是线程安全的.  这很重要,因为这意味着您可以配置 `JdbcTemplate` 的单个实例,然后将此共享引用安全地注入多个 DAO (或存储库) .  `JdbcTemplate` 是有状态的,因为它维护对 `DataSource` 的引用,但此状态不是会话状态.

使用 `JdbcTemplate` 类(以及关联的<<jdbc-NamedParameterJdbcTemplate, `NamedParameterJdbcTemplate`>> class) 类)  时的常见做法是在 Spring 配置文件中配置 `DataSource`, 然后将共享 `DataSource` bean依赖注入到DAO类中.  `JdbcTemplate` 是在 `DataSource` 的setter中创建的. 这导致DAO类似于以下内容:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcCorporateEventDao implements CorporateEventDao {

		private JdbcTemplate jdbcTemplate;

		public void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		// JDBC-backed implementations of the methods on the CorporateEventDao follow...
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcCorporateEventDao(dataSource: DataSource) : CorporateEventDao {

		private val jdbcTemplate = JdbcTemplate(dataSource)

		// JDBC-backed implementations of the methods on the CorporateEventDao follow...
	}
----

以下示例显示了相应的XML配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<bean id="corporateEventDao" class="com.example.JdbcCorporateEventDao">
			<property name="dataSource" ref="dataSource"/>
		</bean>

		<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
			<property name="driverClassName" value="${jdbc.driverClassName}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.username}"/>
			<property name="password" value="${jdbc.password}"/>
		</bean>

		<context:property-placeholder location="jdbc.properties"/>

	</beans>
----

显式配置的替代方法是使用组件扫描和注解支持依赖注入.  在这种情况下,您可以使用 `@Repository` 注解该类(这使其成为组件扫描的候选者)  并使用 `@Autowired` 注解 `DataSource` 的setter方法.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Repository // <1>
	public class JdbcCorporateEventDao implements CorporateEventDao {

		private JdbcTemplate jdbcTemplate;

		@Autowired // <2>
		public void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource); // <3>
		}

		// JDBC-backed implementations of the methods on the CorporateEventDao follow...
	}
----
<1> 使用 `@Repository` 注解类
<2> 使用 `@Autowired` 注解 `DataSource` 的setter方法
<3> 使用 `DataSource` 创建一个新的 `JdbcTemplate`.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Repository // <1>
	class JdbcCorporateEventDao(dataSource: DataSource) : CorporateEventDao { // <2>

		private val jdbcTemplate = JdbcTemplate(dataSource) // <3>
		
		// JDBC-backed implementations of the methods on the CorporateEventDao follow...
	}
----
<1> 使用 `@Repository` 注解类
<2> 使用 `@Autowired` 注解 `DataSource` 的setter方法
<3> 使用 `DataSource` 创建一个新的 `JdbcTemplate`.


以下示例显示了相关的XML配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:context="http://www.springframework.org/schema/context"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/context
			https://www.springframework.org/schema/context/spring-context.xsd">

		<!-- Scans within the base package of the application for @Component classes to configure as beans -->
		<context:component-scan base-package="org.springframework.docs.test" />

		<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
			<property name="driverClassName" value="${jdbc.driverClassName}"/>
			<property name="url" value="${jdbc.url}"/>
			<property name="username" value="${jdbc.username}"/>
			<property name="password" value="${jdbc.password}"/>
		</bean>

		<context:property-placeholder location="jdbc.properties"/>

	</beans>
----

如果使用Spring的 `JdbcDaoSupport` 类,并且各种JDBC支持的DAO类从它扩展,则子类从 `JdbcDaoSupport` 类继承 `setDataSource(..)` 方法.  您可以选择是否继承此类.  `JdbcDaoSupport` 类仅为方便起见而提供.

无论您选择使用(或不使用) 上述哪种模板初始化样式,每次要运行SQL时,很少需要创建 `JdbcTemplate` 类的新实例.  配置完成后, `JdbcTemplate` 实例是线程安全的. 如果您的应用程序访问多个数据库, 您可能需要多个 `JdbcTemplate` 实例,这需要多个 `DataSources`, 随后需要多个不同配置的 `JdbcTemplate` 实例.


[[jdbc-NamedParameterJdbcTemplate]]
==== 使用 `NamedParameterJdbcTemplate`

`NamedParameterJdbcTemplate` 类通过使用命名参数添加了对编写JDBC语句的支持, 而不是仅使用经典占位符( `'?'`) 参数编写JDBC语句.  `NamedParameterJdbcTemplate` 类包装 `JdbcTemplate` 并委托包装的 `JdbcTemplate` 来完成其大部分工作.
本节仅描述 `NamedParameterJdbcTemplate` 类与 `JdbcTemplate` 本身不同的区域 - 即使用命名参数编写JDBC语句.  以下示例显示如何使用 `NamedParameterJdbcTemplate`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// some JDBC-backed DAO class...
	private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

	public void setDataSource(DataSource dataSource) {
		this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
	}

	public int countOfActorsByFirstName(String firstName) {

		String sql = "select count(*) from T_ACTOR where first_name = :first_name";

		SqlParameterSource namedParameters = new MapSqlParameterSource("first_name", firstName);

		return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
	}
----

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

	fun countOfActorsByFirstName(firstName: String): Int {
		val sql = "select count(*) from T_ACTOR where first_name = :first_name"
		val namedParameters = MapSqlParameterSource("first_name", firstName)
		return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!
	}
----

请注意在分配给 `sql` 变量的值中使用命名参数表示法以及插入 `namedParameters` 变量(`MapSqlParameterSource` 类型) 的相应值.

或者,您可以使用基于 `Map` 的样式将命名参数及其对应值传递给 `NamedParameterJdbcTemplate` 实例.  `NamedParameterJdbcOperations` 暴露并由 `NamedParameterJdbcTemplate` 类实现的其余方法遵循类似的模式,此处不再介绍.

以下示例显示了基于 `Map` 的样式的使用:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// some JDBC-backed DAO class...
	private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

	public void setDataSource(DataSource dataSource) {
		this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
	}

	public int countOfActorsByFirstName(String firstName) {

		String sql = "select count(*) from T_ACTOR where first_name = :first_name";

		Map<String, String> namedParameters = Collections.singletonMap("first_name", firstName);

		return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters,  Integer.class);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// some JDBC-backed DAO class...
	private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

	fun countOfActorsByFirstName(firstName: String): Int {
		val sql = "select count(*) from T_ACTOR where first_name = :first_name"
		val namedParameters = mapOf("first_name" to firstName)
		return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!
	}
----

与 `NamedParameterJdbcTemplate` 相关的一个很好的功能(并且存在于同一个Java包中) 是 `SqlParameterSource` 接口.  您已经在之前的一个代码片段(`MapSqlParameterSource` 类) 中看到了此接口的实现示例.  `SqlParameterSource` 是 `NamedParameterJdbcTemplate` 的命名参数值的来源.  `MapSqlParameterSource` 类是一个简单的实现,它是 `java.util.Map` 的适配器,其中键是参数名称,值是参数值.

另一个 `SqlParameterSource` 实现是 `BeanPropertySqlParameterSource` 类.  此类包装任意JavaBean(即,遵循 https://www.oracle.com/technetwork/java/javase/documentation/spec-136004.html[JavaBean约定]的类的实例) , 并使用包装的JavaBean的属性作为命名参数值的来源.

以下示例展示了典型的JavaBean:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Actor {

		private Long id;
		private String firstName;
		private String lastName;

		public String getFirstName() {
			return this.firstName;
		}

		public String getLastName() {
			return this.lastName;
		}

		public Long getId() {
			return this.id;
		}

		// setters omitted...

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	data class Actor(val id: Long, val firstName: String, val lastName: String)
----

以下示例使用 `NamedParameterJdbcTemplate` 返回上一示例中显示的类成员的计数:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	// some JDBC-backed DAO class...
	private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

	public void setDataSource(DataSource dataSource) {
		this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
	}

	public int countOfActors(Actor exampleActor) {

		// notice how the named parameters match the properties of the above 'Actor' class
		String sql = "select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName";

		SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);

		return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// some JDBC-backed DAO class...
	private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

	private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

	fun countOfActors(exampleActor: Actor): Int {
		// notice how the named parameters match the properties of the above 'Actor' class
		val sql = "select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName"
		val namedParameters = BeanPropertySqlParameterSource(exampleActor)
		return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!!
	}
----

请记住,`NamedParameterJdbcTemplate` 类包装了一个经典的 `JdbcTemplate` 模板.  如果需要访问包装的 `JdbcTemplate` 实例以访问仅存在于 `JdbcTemplate` 类中的功能, 则可以使用 `getJdbcOperations()` 方法通过 `JdbcOperations` 接口访问包装的 `JdbcTemplate`.

有关在应用程序上下文中使用 `NamedParameterJdbcTemplate` 类的指导,另请参阅 <<jdbc-JdbcTemplate-idioms,JdbcTemplate最佳实践>>.

[[jdbc-SQLExceptionTranslator]]
==== 使用 `SQLExceptionTranslator`

`SQLExceptionTranslator` 是一个由类实现的接口, 可以在 `SQLExceptions` 和Spring自己的 `org.springframework.dao.DataAccessException` 之间进行转换,这与数据访问策略无关.  此实现可以是通用的(例如,使用JDBC的 `SQLState` 代码) 或专有的(例如,使用Oracle错误代码) 以获得更高的精度.

`SQLErrorCodeSQLExceptionTranslator` 是默认使用的 `SQLExceptionTranslator` 的实现.  此实现使用特定供应商代码.  它比 `SQLState` 实现更精确.  错误代码转换基于名为 `SQLErrorCodes` 的JavaBean类型类中保存的代码.  此类由 `SQLErrorCodesFactory` 创建和填充,`SQLErrorCodesFactory`(顾名思义) 是一个工厂, 用于根据名为 `sql-error-codes.xml` 的配置文件的内容创建 `SQLErrorCodes`.  此文件使用供应商代码填充,并基于从 `DatabaseMetaData` 获取的 `DatabaseProductName`.  使用您正在使用的实际数据库的代码.

`SQLErrorCodeSQLExceptionTranslator` 按以下顺序应用匹配规则:

. 由子类实现的任何自定义转换.  通常,使用提供的具体 `SQLErrorCodeSQLExceptionTranslator`, 因此该规则不适用.  仅当您实际提供了子类实现时才适用.
. `SQLExceptionTranslator` 接口的任何自定义实现,提供给 `SQLErrorCodes` 类的 `customSqlExceptionTranslator` 属性.
. 将搜索 `CustomSQLErrorCodesTranslation` 类的实例列表(为 `SQLErrorCodes` 类的 `customTranslations` 属性提供) 以查找匹配项.
. 应用错误代码匹配.
. 使用后备转换器.  `SQLExceptionSubclassTranslator` 是默认的回退转换器.  如果此转换不可用,则下一个后备转换器是 `SQLStateSQLExceptionTranslator`.

NOTE: 默认情况下,`SQLErrorCodesFactory` 用于定义 `Error` 代码和自定义异常转换.  从类路径中查找名为 `sql-error-codes.xml` 的文件, 并根据正在使用的数据库的数据库元数据中的数据库名称找到匹配的 `SQLErrorCodes` 实例.

您可以继承 `SQLErrorCodeSQLExceptionTranslator`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {

		protected DataAccessException customTranslate(String task, String sql, SQLException sqlEx) {
			if (sqlEx.getErrorCode() == -12345) {
				return new DeadlockLoserDataAccessException(task, sqlEx);
			}
			return null;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class CustomSQLErrorCodesTranslator : SQLErrorCodeSQLExceptionTranslator() {

		override fun customTranslate(task: String, sql: String?, sqlEx: SQLException): DataAccessException? {
			if (sqlEx.errorCode == -12345) {
					return DeadlockLoserDataAccessException(task, sqlEx)
				}
				return null;
		}
	}
----

在前面的示例中,特定错误代码(`-12345`) 被转换,而其他错误由默认转换器的实现转换.  要使用此自定义转换程序,必须通过方法 `setExceptionTranslator` 将其传递给 `JdbcTemplate`, 并且必须将此 `JdbcTemplate` 用于需要此转换程序的所有数据访问处理.
以下示例显示了如何使用此自定义转换器:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	private JdbcTemplate jdbcTemplate;

	public void setDataSource(DataSource dataSource) {

		// create a JdbcTemplate and set data source
		this.jdbcTemplate = new JdbcTemplate();
		this.jdbcTemplate.setDataSource(dataSource);

		// create a custom translator and set the DataSource for the default translation lookup
		CustomSQLErrorCodesTranslator tr = new CustomSQLErrorCodesTranslator();
		tr.setDataSource(dataSource);
		this.jdbcTemplate.setExceptionTranslator(tr);

	}

	public void updateShippingCharge(long orderId, long pct) {
		// use the prepared JdbcTemplate for this update
		this.jdbcTemplate.update("update orders" +
			" set shipping_charge = shipping_charge * ? / 100" +
			" where id = ?", pct, orderId);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	// create a JdbcTemplate and set data source
	private val jdbcTemplate = JdbcTemplate(dataSource).apply {
		// create a custom translator and set the DataSource for the default translation lookup
		exceptionTranslator = CustomSQLErrorCodesTranslator().apply {
			this.dataSource = dataSource 
		}
	}
	
	fun updateShippingCharge(orderId: Long, pct: Long) {
		// use the prepared JdbcTemplate for this update
		this.jdbcTemplate!!.update("update orders" +
				" set shipping_charge = shipping_charge * ? / 100" +
				" where id = ?", pct, orderId)
	}
----

自定义转换器传递一个数据源,以便在 `sql-error-codes.xml` 中查找错误代码.


[[jdbc-statements-executing]]
==== 执行语句

运行SQL语句只需要很少的代码.  您需要一个 `DataSource` 和一个 `JdbcTemplate`,包括 `JdbcTemplate` 提供的便捷方法.  以下示例显示了为创建新表的最小但功能齐全的类所需要包含的内容:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import javax.sql.DataSource;
	import org.springframework.jdbc.core.JdbcTemplate;

	public class ExecuteAStatement {

		private JdbcTemplate jdbcTemplate;

		public void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		public void doExecute() {
			this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import javax.sql.DataSource
	import org.springframework.jdbc.core.JdbcTemplate

	class ExecuteAStatement(dataSource: DataSource) {

		private val jdbcTemplate = JdbcTemplate(dataSource)

		fun doExecute() {
			jdbcTemplate.execute("create table mytable (id integer, name varchar(100))")
		}
	}
----


[[jdbc-statements-querying]]
==== 执行查询

某些查询方法返回单个值.  要从一行检索计数或特定值,请使用 `queryForObject(..)`.  后者将返回的JDBC Type转换为作为参数传入的Java类.  如果类型转换无效,则抛出 `InvalidDataAccessApiUsageException`.  以下示例包含两个查询方法,一个用于int,另一个用于查询 `String`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import javax.sql.DataSource;
	import org.springframework.jdbc.core.JdbcTemplate;

	public class RunAQuery {

		private JdbcTemplate jdbcTemplate;

		public void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		public int getCount() {
			return this.jdbcTemplate.queryForObject("select count(*) from mytable", Integer.class);
		}

		public String getName() {
			return this.jdbcTemplate.queryForObject("select name from mytable", String.class);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
import javax.sql.DataSource
import org.springframework.jdbc.core.JdbcTemplate

class RunAQuery(dataSource: DataSource) {

	private val jdbcTemplate = JdbcTemplate(dataSource)

	val count: Int
		get() = jdbcTemplate.queryForObject("select count(*) from mytable")!!

	val name: String?
		get() = jdbcTemplate.queryForObject("select name from mytable")
}
----

除了单个结果查询方法之外,还有几个方法返回一个列表,其中包含查询返回的每一行的条目.  最通用的方法是 `queryForList(..)`, 它返回一个 `List`,其中每个元素都是一个包含每列的一个条目的 `Map`,使用列名作为键.  如果向前面的示例添加方法以检索所有行的列表,则可能如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	private JdbcTemplate jdbcTemplate;

	public void setDataSource(DataSource dataSource) {
		this.jdbcTemplate = new JdbcTemplate(dataSource);
	}

	public List<Map<String, Object>> getList() {
		return this.jdbcTemplate.queryForList("select * from mytable");
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	private val jdbcTemplate = JdbcTemplate(dataSource)

	fun getList(): List<Map<String, Any>> {
		return jdbcTemplate.queryForList("select * from mytable")
	}
----

返回的列表将类似于以下内容:

[literal,subs="verbatim,quotes"]
----
[{name=Bob, id=1}, {name=Mary, id=2}]
----


[[jdbc-updates]]
==== 更新数据库

以下示例更新某个主键的列:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import javax.sql.DataSource;
	import org.springframework.jdbc.core.JdbcTemplate;

	public class ExecuteAnUpdate {

		private JdbcTemplate jdbcTemplate;

		public void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		public void setName(int id, String name) {
			this.jdbcTemplate.update("update mytable set name = ? where id = ?", name, id);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import javax.sql.DataSource
	import org.springframework.jdbc.core.JdbcTemplate

	class ExecuteAnUpdate(dataSource: DataSource) {

		private val jdbcTemplate = JdbcTemplate(dataSource)

		fun setName(id: Int, name: String) {
			jdbcTemplate.update("update mytable set name = ? where id = ?", name, id)
		}
	}
----

在前面的示例中,SQL语句具有行参数的占位符.  您可以将参数值作为可变参数传递,或者作为对象数组传递.  因此,您应该在原始包装类中显式包装原语,或者您应该使用自动装箱.


[[jdbc-auto-generated-keys]]
==== 检索自动生成的密钥

`update()` 方便方法支持检索数据库生成的主键.  此支持是JDBC 3.0标准的一部分.  有关详细信息,请参阅规范的第13.6章. 该方法将 `PreparedStatementCreator` 作为其第一个参数,这是指定所需 `insert` 语句的方式.  另一个参数是 `KeyHolder`,
它包含从更新成功返回时生成的密钥.  没有标准的单一方法来创建适当的 `PreparedStatement` (这解释了为什么方法签名就是这样) . 以下示例适用于Oracle,但可能无法在其他平台上运行:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	final String INSERT_SQL = "insert into my_test (name) values(?)";
	final String name = "Rob";

	KeyHolder keyHolder = new GeneratedKeyHolder();
	jdbcTemplate.update(connection -> {
		PreparedStatement ps = connection.prepareStatement(INSERT_SQL, new String[] { "id" });
		ps.setString(1, name);
		return ps;
	}, keyHolder);

	// keyHolder.getKey() now contains the generated key
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val INSERT_SQL = "insert into my_test (name) values(?)"
	val name = "Rob"

	val keyHolder = GeneratedKeyHolder()
	jdbcTemplate.update({
		it.prepareStatement (INSERT_SQL, arrayOf("id")).apply { setString(1, name) }
	}, keyHolder)

	// keyHolder.getKey() now contains the generated key
----



[[jdbc-connections]]
=== 控制数据库连接

本节包括:

* <<jdbc-datasource,使用DataSource>>
* <<jdbc-DataSourceUtils,使用DataSourceUtils>>
* <<jdbc-SmartDataSource,实现SmartDataSource>>
* <<jdbc-AbstractDataSource,继承AbstractDataSource>>
* <<jdbc-SingleConnectionDataSource,使用SingleConnectionDataSource>>
* <<jdbc-DriverManagerDataSource,使用DriverManagerDataSource>>
* <<jdbc-TransactionAwareDataSourceProxy,使用TransactionAwareDataSourceProxy>>
* <<jdbc-DataSourceTransactionManager,使用DataSourceTransactionManager>>


[[jdbc-datasource]]
==== 使用 `DataSource`

Spring通过 `DataSource` 获取与数据库的连接.  `DataSource` 是JDBC规范的一部分,是一个通用的连接工厂.  它允许容器或框架从应用程序代码中隐藏连接池和事务管理问题.  作为开发人员,您无需了解有关如何连接到数据库的详细信息.  这是设置数据源的管理员的责任.  您最有可能在开发和测试代码时填充这两个角色,但您不必知道如何配置生产数据源.

使用Spring的JDBC层时,可以从JNDI获取数据源,也可以使用第三方提供的连接池实现配置自己的数据源.  传统的实现是Apache Commons DBCP和C3P0.  对于现代JDBC连接池,请考虑使用 `HikariCP`.


NOTE: 您应该仅将 `DriverManagerDataSource` 和 `SimpleDriverDataSource` 类用于测试目的,因为它不提供连接池,并且在发出多个连接请求时性能很差.

以下部分使用Spring的 `DriverManagerDataSource` 实现.
稍后将介绍其他 `DataSource` 变体.

配置 `DriverManagerDataSource`:

. 通常获取JDBC连接时,获取与 `DriverManagerDataSource` 的连接.
. 指定JDBC驱动程序的完全限定类名,以便 `DriverManager` 可以加载驱动程序类.
. 供不同JDBC驱动程序之间的URL. (有关正确的值,请参阅驱动程序的文档. )
. 提供连接到数据库的用户名和密码.

以下示例显示了如何在Java中配置 `DriverManagerDataSource`

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	DriverManagerDataSource dataSource = new DriverManagerDataSource();
	dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
	dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");
	dataSource.setUsername("sa");
	dataSource.setPassword("");
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val dataSource = DriverManagerDataSource().apply {
		setDriverClassName("org.hsqldb.jdbcDriver")
		url = "jdbc:hsqldb:hsql://localhost:"
		username = "sa"
		password = ""
	}
----

以下示例显示了相关的XML配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
		<property name="driverClassName" value="${jdbc.driverClassName}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>

	<context:property-placeholder location="jdbc.properties"/>
----

接下来的两个示例显示了DBCP和C3P0的基本连接和配置.  要了解有助于控制连接池功能的更多选项,请参阅相应连接池实现的产品文档.

以下示例展示了DBCP的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
		<property name="driverClassName" value="${jdbc.driverClassName}"/>
		<property name="url" value="${jdbc.url}"/>
		<property name="username" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>

	<context:property-placeholder location="jdbc.properties"/>
----

以下示例展示了C3P0的配置:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close">
		<property name="driverClass" value="${jdbc.driverClassName}"/>
		<property name="jdbcUrl" value="${jdbc.url}"/>
		<property name="user" value="${jdbc.username}"/>
		<property name="password" value="${jdbc.password}"/>
	</bean>

	<context:property-placeholder location="jdbc.properties"/>
----


[[jdbc-DataSourceUtils]]
==== 使用 `DataSourceUtils`

`DataSourceUtils` 类是一个方便且功能强大的辅助类,它提供 `static` 方法以在必要时从JNDI获取连接并关闭连接.  它支持线程绑定连接,例如,`DataSourceTransactionManager`.

[[jdbc-SmartDataSource]]
==== 实现 `SmartDataSource`

`SmartDataSource` 接口应该由可以提供与关系数据库的连接的类实现.  它继承了 `DataSource` 接口,让使用它的类查询是否应该在给定操作后关闭连接.  当您知道需要重用连接时,此用法很有效.

[[jdbc-AbstractDataSource]]
==== 继承 `AbstractDataSource`

`AbstractDataSource` 是Spring的 `DataSource` 实现的 `abstract` 基类.  它实现了所有 `DataSource` 共有的代码. 如果编写自己的DataSource实现,则应继承 `AbstractDataSource` 类.


[[jdbc-SingleConnectionDataSource]]
==== 使用 `SingleConnectionDataSource`

`SingleConnectionDataSource` 类是 `SmartDataSource` 接口的一个实现,它包装了每次使用后未关闭的单个 `Connection`.  这不是多线程的.

如果任何客户端代码在连接池时调用 `close`(如使用持久性工具时) ,则应将 `suppressClose` 属性设置为 `true`.  此设置返回一个包装物理连接的禁止关闭代理. 请注意,您不能再将其强制转换为本机Oracle Connection或类似对象.

`SingleConnectionDataSource` 主要是一个测试类.  例如,它可以在简单的JNDI环境中轻松测试应用程序服务器外部的代码.  与 `DriverManagerDataSource` 相比,它始终重用相同的连接,避免过度创建物理连接.

[[jdbc-DriverManagerDataSource]]
==== 使用 `DriverManagerDataSource`

`DriverManagerDataSource` 类是标准 `DataSource` 接口的实现, 它通过 bean 属性配置普通JDBC驱动程序,并且每次都返回一个新的Connection.

此实现对于Java EE容器外部的测试和独立环境非常有用,可以作为 Spring IoC 容器中的 `DataSource` bean, 也可以与简单的JNDI环境结合使用.  连接池调用 `Connection.close()` 关闭连接, 因此任何支持 `DataSource` 的持久性代码都应该有效.
但是,即使在测试环境中,使用JavaBean样式的连接池(例如 `commons-dbcp`) 也非常容易, 因此使用这样的连接池几乎总是优先于 `DriverManagerDataSource`.

[[jdbc-TransactionAwareDataSourceProxy]]
==== 使用 `TransactionAwareDataSourceProxy`

`TransactionAwareDataSourceProxy` 是目标 `DataSource` 的代理.  代理包装目标 `DataSource` 以添加对Spring管理的事务的感知.  在这方面,它类似于Java EE服务器提供的事务性JNDI `DataSource`.

NOTE: 除非必须调用已经存在的代码并传递标准JDBC `DataSource` 接口实现,否则很少需要使用此类.  在这种情况下,您仍然可以使用此代码,同时让此代码参与Spring管理事务.  通常最好使用更高级别的资源抽象化管理,编写自己的新代码,例如 `JdbcTemplate` 或 `DataSourceUtils`.

更多详细资料,请参阅 {api-spring-framework}/jdbc/datasource/TransactionAwareDataSourceProxy.html[`TransactionAwareDataSourceProxy`] javadoc


[[jdbc-DataSourceTransactionManager]]
==== 使用 `DataSourceTransactionManager`

`DataSourceTransactionManager` 类是单个JDBC数据源的 `PlatformTransactionManager` 实现.  它将JDBC连接从指定的数据源绑定到当前正在执行的线程,可能允许每个数据源连接一个线程.

需要应用程序代码来通过 `DataSourceUtils.getConnection(DataSource)` 而不是Java EE的标准 `DataSource.getConnection` 来检索JDBC连接.  它会抛出未经检查的 `org.springframework.dao` 异常,而不是受检查的 `SQLExceptions`.  所有框架类(例如 `JdbcTemplate`) 都隐式使用此策略.  如果未与此事务管理器一起使用,则查找策略的行为与常见策略完全相同. 因此,它可以在任何情况下使用.

`DataSourceTransactionManager` 类支持自定义隔离级别和超时,这些隔离级别和超时将作为适当的JDBC语句查询超时应用.  要支持后者,应用程序代码必须使用 `JdbcTemplate` 或为每个创建的语句调用 `DataSourceUtils.applyTransactionTimeout(..)` 方法.

您可以在单资源情况下使用此实现而不是 `JtaTransactionManager`,因为它不需要容器支持JTA.  如果您坚持所需的连接查找模式,则在两者之间切换只是配置问题.  JTA 不支持自定义隔离级别.

[[jdbc-advanced-jdbc]]
=== JDBC批处理操作

如果批量多次调用同一个预准备语句,则大多数JDBC驱动程序都可以提高性能.  通过将更新分组到批次中,可以限制程序到数据库的往返次数.

[[jdbc-batch-classic]]
==== 使用 `JdbcTemplate` 进行基础的批处理操作

您可以通过实现特殊接口 `BatchPreparedStatementSetter` 的两个方法来完成 `code>JdbcTemplate` 批处理, 并将该实现作为 `batchUpdate` 方法调用中的第二个参数传递.  您可以使用 `getBatchSize` 方法提供当前批次的大小.
您可以使用 `setValues` 方法设置预准备语句的参数值.  此方法您在 `getBatchSize` 调用中指定的次数.  以下示例根据列表中的条目更新 `t_actor` 表,并将整个列表用作批处理:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private JdbcTemplate jdbcTemplate;

		public void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		public int[] batchUpdate(final List<Actor> actors) {
			return this.jdbcTemplate.batchUpdate(
					"update t_actor set first_name = ?, last_name = ? where id = ?",
					new BatchPreparedStatementSetter() {
						public void setValues(PreparedStatement ps, int i) throws SQLException {
							Actor actor = actors.get(i);
							ps.setString(1, actor.getFirstName());
							ps.setString(2, actor.getLastName());
							ps.setLong(3, actor.getId().longValue());
						}
						public int getBatchSize() {
							return actors.size();
						}
					});
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private val jdbcTemplate = JdbcTemplate(dataSource)

		fun batchUpdate(actors: List<Actor>): IntArray {
			return jdbcTemplate.batchUpdate(
					"update t_actor set first_name = ?, last_name = ? where id = ?",
					object: BatchPreparedStatementSetter {
						override fun setValues(ps: PreparedStatement, i: Int) {
							ps.setString(1, actors[i].firstName)
							ps.setString(2, actors[i].lastName)
							ps.setLong(3, actors[i].id)
						}

						override fun getBatchSize() = actors.size
					})
		}

		// ... additional methods
	}
----

如果您处理更新流或从文件读取,则可能具有首选的批次大小,但最后一批可能没有该数量的条目.  在这种情况下,您可以使用 `InterruptibleBatchPreparedStatementSetter` 接口,该接口允许您在输入源耗尽时中断批处理.  `isBatchExhausted` 方法允许您发出批处理结束的信号.

[[jdbc-batch-list]]
==== 使用对象列表进行批处理操作

`JdbcTemplate` 和 `NamedParameterJdbcTemplate` 都提供了另一种提供批量更新的方法.  您可以将调用中的所有参数值作为列表提供,而不是实现特殊的批处理接口.  框架循环遍历这些值并使用内部预处理的setter语句.
API会有所不同,具体取决于您是否使用命名参数.  对于命名参数,您提供了一个 `SqlParameterSource` 数组,该批处理的每个成员都有一个条目.  您可以使用 `SqlParameterSourceUtils.createBatch` 方便方法来创建此数组, 传入一个bean样式对象数组(使用与参数对应的getter方法) ,String关键字的 `Map` 实例(包含相应参数作为值) ,或者两者混合使用.

一下示例展示使用命名参数的批量更新:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private NamedParameterTemplate namedParameterJdbcTemplate;

		public void setDataSource(DataSource dataSource) {
			this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
		}

		public int[] batchUpdate(List<Actor> actors) {
			return this.namedParameterJdbcTemplate.batchUpdate(
					"update t_actor set first_name = :firstName, last_name = :lastName where id = :id",
					SqlParameterSourceUtils.createBatch(actors));
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource)

		fun batchUpdate(actors: List<Actor>): IntArray {
			return this.namedParameterJdbcTemplate.batchUpdate(
					"update t_actor set first_name = :firstName, last_name = :lastName where id = :id",
					SqlParameterSourceUtils.createBatch(actors));
		}

			// ... additional methods
	}
----

对于使用经典的SQL语句 `?` 在占位符中,传入包含具有更新值的对象数组的列表.  此对象数组必须在SQL语句中为每个占位符分配一个条目,并且它们的顺序必须与SQL语句中定义的顺序相同.

以下示例与前面的示例相同,只是它使用经典JDBC `?` 占位符:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private JdbcTemplate jdbcTemplate;

		public void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		public int[] batchUpdate(final List<Actor> actors) {
			List<Object[]> batch = new ArrayList<Object[]>();
			for (Actor actor : actors) {
				Object[] values = new Object[] {
						actor.getFirstName(), actor.getLastName(), actor.getId()};
				batch.add(values);
			}
			return this.jdbcTemplate.batchUpdate(
					"update t_actor set first_name = ?, last_name = ? where id = ?",
					batch);
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private val jdbcTemplate = JdbcTemplate(dataSource)

		fun batchUpdate(actors: List<Actor>): IntArray {
			val batch = mutableListOf<Array<Any>>()
			for (actor in actors) {
				batch.add(arrayOf(actor.firstName, actor.lastName, actor.id))
			}
			return jdbcTemplate.batchUpdate(
					"update t_actor set first_name = ?, last_name = ? where id = ?", batch)
		}

		// ... additional methods
	}
----

我们之前描述的所有批处理更新方法都返回一个 `int` 数组,其中包含每个批处理条目的受影响行数.  JDBC驱动程序报告此计数.  如果计数不可用,则JDBC驱动程序返回值 `-2`.

[NOTE]
====

在这种情况下,通过在底层 `PreparedStatement` 上自动设置值,需要从给定的Java类型扩展每个值的相应JDBC类型.  虽然这通常很有效,但是存在潜在的问题(例如,使用包含Map的null值) .
默认情况下,Spring会在这种情况下调用 `ParameterMetaData.getParameterType`,这对于JDBC驱动程序来说可能开销很大.  您应该使用最新的驱动程序版本并考虑将 `spring.jdbc.getParameterType.ignore` 属性设置为 `true` (作为JVM系统属性或类路径根目录中的 `spring.properties` 文件) , 如果遇到性能问题 - 例如 ,如 Oracle 12c JBoss and PostgreSQL 所述.

或者您可以考虑通过 `BatchPreparedStatementSetter`(如前所示) ;  或者通过给予基于 `List <Object[]>` 的调用的显式类型数组; 或者通过在自定义 `MapSqlParameterSource` 的实例上 调用 `registerSqlType`;  或者通过从Java声明的属性类型扩展SQL类型- `BeanPropertySqlParameterSource`(即使对于空值) 来显式指定相应的 JDBC 类型.
====


[[jdbc-batch-multi]]
==== 多批次批处理操作

前面的批量更新示例处理的批量非常大,您希望将它们分成几个较小的批次.  您可以通过多次调用 `batchUpdate` 方法,使用前面提到的方法执行此操作,但现在有一种更方便的方法.
除了SQL语句之外,此方法还包含一个包含参数的 `Collection` 对象,为每个批处理生成更新的数量, 以及一个 `ParameterizedPreparedStatementSetter`,用于设置预准备语句的参数值.  框架循环提供的值,并将更新调用分解为指定大小的批处理.

以下示例显示批处理更新,批处理大小为100:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private JdbcTemplate jdbcTemplate;

		public void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
		}

		public int[][] batchUpdate(final Collection<Actor> actors) {
			int[][] updateCounts = jdbcTemplate.batchUpdate(
					"update t_actor set first_name = ?, last_name = ? where id = ?",
					actors,
					100,
					(PreparedStatement ps, Actor actor) -> {
						ps.setString(1, actor.getFirstName());
						ps.setString(2, actor.getLastName());
						ps.setLong(3, actor.getId().longValue());
					});
			return updateCounts;
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private val jdbcTemplate = JdbcTemplate(dataSource)

		fun batchUpdate(actors: List<Actor>): Array<IntArray> {
			return jdbcTemplate.batchUpdate(
						"update t_actor set first_name = ?, last_name = ? where id = ?",
						actors, 100) { ps, argument ->
				ps.setString(1, argument.firstName)
				ps.setString(2, argument.lastName)
				ps.setLong(3, argument.id)
			}
		}

		// ... additional methods
	}
----

此调用的批处理更新方法返回一个 `int` 数组的数组,其中包含每个批处理的数组条目,和每次更新的受影响行数的数组.  顶级数组的长度表示执行的批次数,第二级数组的长度表示该批次中的更新数.
每个批次中的更新数量应该是由整个批处理提供的批次大小(最后一个批次可能更少) ,具体取决于提供的更新对象总数.  每个更新语句的更新计数是由JDBC驱动程序报告的. 如果计数不可用,则JDBC驱动程序返回值 `-2`.

[[jdbc-simple-jdbc]]
=== 使用 `SimpleJdbc` 类简化JDBC操作

`SimpleJdbcInsert` 和 `SimpleJdbcCall` 类通过利用可通过JDBC驱动程序检索的数据库元数据来提供简化的配置.  这意味着您可以减少预先配置,但如果您希望提供代码中的所有详细信息,则可以覆盖或关闭元数据处理.

[[jdbc-simple-jdbc-insert-1]]
==== 使用 `SimpleJdbcInsert` 插入数据

我们首先使用最少量的配置选项查看 `SimpleJdbcInsert` 类.  您应该在数据访问层的初始化方法中实例化 `SimpleJdbcInsert`.  对于此示例,初始化方法是 `setDataSource` 方法. 您不需要继承 `SimpleJdbcInsert` 类的子类.
相反,您可以使用 `withTableName` 方法创建新实例并设置表名.  此类的配置方法遵循返回 `SimpleJdbcInsert` 实例的 `fluid` 样式,该样式允许您链接所有配置方法.  以下示例仅使用一种配置方法(稍后我们将显示多个方法的示例) :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private SimpleJdbcInsert insertActor;

		public void setDataSource(DataSource dataSource) {
			this.insertActor = new SimpleJdbcInsert(dataSource).withTableName("t_actor");
		}

		public void add(Actor actor) {
			Map<String, Object> parameters = new HashMap<String, Object>(3);
			parameters.put("id", actor.getId());
			parameters.put("first_name", actor.getFirstName());
			parameters.put("last_name", actor.getLastName());
			insertActor.execute(parameters);
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private val insertActor = SimpleJdbcInsert(dataSource).withTableName("t_actor")

		fun add(actor: Actor) {
			val parameters = mutableMapOf<String, Any>()
			parameters["id"] = actor.id
			parameters["first_name"] = actor.firstName
			parameters["last_name"] = actor.lastName
			insertActor.execute(parameters)
		}

		// ... additional methods
	}
----

这里使用的 `execute` 方法将普通的 `java.util.Map` 作为唯一参数.  这里要注意的重要事项是,用于 `Map` 的键必须与表的列名匹配,如数据库中所定义.  这是因为我们读取了元数据来构造实际的insert语句.

[[jdbc-simple-jdbc-insert-2]]
==== 使用 `SimpleJdbcInsert` 检索自动生成的密钥

下一个示例使用与前面示例相同的插入,但是,它不是传入 `id`,而是检索自动生成的键并将其设置在新的 `Actor` 对象上.  在创建 `SimpleJdbcInsert` 时,除了指定表名外,它还使用 `usingGeneratedKeyColumns` 方法指定生成的键列的名称.  以下清单显示了它的工作原理:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private SimpleJdbcInsert insertActor;

		public void setDataSource(DataSource dataSource) {
			this.insertActor = new SimpleJdbcInsert(dataSource)
					.withTableName("t_actor")
					.usingGeneratedKeyColumns("id");
		}

		public void add(Actor actor) {
			Map<String, Object> parameters = new HashMap<String, Object>(2);
			parameters.put("first_name", actor.getFirstName());
			parameters.put("last_name", actor.getLastName());
			Number newId = insertActor.executeAndReturnKey(parameters);
			actor.setId(newId.longValue());
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private val insertActor = SimpleJdbcInsert(dataSource)
				.withTableName("t_actor").usingGeneratedKeyColumns("id")

		fun add(actor: Actor): Actor {
			val parameters = mapOf(
					"first_name" to actor.firstName,
					"last_name" to actor.lastName)
			val newId = insertActor.executeAndReturnKey(parameters);
			return actor.copy(id = newId.toLong())
		}

		// ... additional methods
	}
----

使用第二种方法运行插入时的主要区别在于,您不用将 `id` 添加到 `Map`,并调用 `executeAndReturnKey` 方法.  这将返回一个 `java.lang.Number` 对象,您可以使用该对象创建域类中使用的数字类型的实例.
您不能依赖所有数据库来返回特定的Java类. `java.lang.Number` 是您可以依赖的基类.  如果您有多个自动生成的列或生成的值是非数字的,则可以使用从 `executeAndReturnKeyHolder` 方法返回的 `KeyHolder`.

[[jdbc-simple-jdbc-insert-3]]
==== 为 `SimpleJdbcInsert` 指定列

您可以通过使用 `usingColumns` 方法指定列名列表来限制插入的列,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private SimpleJdbcInsert insertActor;

		public void setDataSource(DataSource dataSource) {
			this.insertActor = new SimpleJdbcInsert(dataSource)
					.withTableName("t_actor")
					.usingColumns("first_name", "last_name")
					.usingGeneratedKeyColumns("id");
		}

		public void add(Actor actor) {
			Map<String, Object> parameters = new HashMap<String, Object>(2);
			parameters.put("first_name", actor.getFirstName());
			parameters.put("last_name", actor.getLastName());
			Number newId = insertActor.executeAndReturnKey(parameters);
			actor.setId(newId.longValue());
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private val insertActor = SimpleJdbcInsert(dataSource)
				.withTableName("t_actor")
				.usingColumns("first_name", "last_name")
				.usingGeneratedKeyColumns("id")

		fun add(actor: Actor): Actor {
			val parameters = mapOf(
					"first_name" to actor.firstName,
					"last_name" to actor.lastName)
			val newId = insertActor.executeAndReturnKey(parameters);
			return actor.copy(id = newId.toLong())
		}

		// ... additional methods
	}
----

插入的执行与您依赖元数据确定要使用的列相同.

[[jdbc-simple-jdbc-parameters]]
==== 使用 `SqlParameterSource` 提供参数值

使用 `Map` 提供参数值工作是正常的,但它不是最方便使用的类.  Spring提供了几个可以使用的 `SqlParameterSource` 接口实现.  第一个是 `BeanPropertySqlParameterSource`,如果你有一个包含你的值的JavaBean兼容类,这是一个非常方便的类.
它使用相应的getter方法来提取参数值.  以下示例显示如何使用 `BeanPropertySqlParameterSource`:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private SimpleJdbcInsert insertActor;

		public void setDataSource(DataSource dataSource) {
			this.insertActor = new SimpleJdbcInsert(dataSource)
					.withTableName("t_actor")
					.usingGeneratedKeyColumns("id");
		}

		public void add(Actor actor) {
			SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);
			Number newId = insertActor.executeAndReturnKey(parameters);
			actor.setId(newId.longValue());
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private val insertActor = SimpleJdbcInsert(dataSource)
				.withTableName("t_actor")
				.usingGeneratedKeyColumns("id")

		fun add(actor: Actor): Actor {
			val parameters = BeanPropertySqlParameterSource(actor)
			val newId = insertActor.executeAndReturnKey(parameters)
			return actor.copy(id = newId.toLong())
		}

		// ... additional methods
	}
----

另一个选项是类似于 `Map` 的 `MapSqlParameterSource`,但提供了一个可以被链接的更方便的 `addValue` 方法.  以下示例显示了如何使用它:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private SimpleJdbcInsert insertActor;

		public void setDataSource(DataSource dataSource) {
			this.insertActor = new SimpleJdbcInsert(dataSource)
					.withTableName("t_actor")
					.usingGeneratedKeyColumns("id");
		}

		public void add(Actor actor) {
			SqlParameterSource parameters = new MapSqlParameterSource()
					.addValue("first_name", actor.getFirstName())
					.addValue("last_name", actor.getLastName());
			Number newId = insertActor.executeAndReturnKey(parameters);
			actor.setId(newId.longValue());
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private val insertActor = SimpleJdbcInsert(dataSource)
				.withTableName("t_actor")
				.usingGeneratedKeyColumns("id")

		fun add(actor: Actor): Actor {
			val parameters = MapSqlParameterSource()
						.addValue("first_name", actor.firstName)
						.addValue("last_name", actor.lastName)
			val newId = insertActor.executeAndReturnKey(parameters)
			return actor.copy(id = newId.toLong())
		}

		// ... additional methods
	}
----

如您所见,配置是相同的. 只有更改执行代码才能使用这些替代输入类.

[[jdbc-simple-jdbc-call-1]]
==== 使用 `SimpleJdbcCall` 调用存储过程

`SimpleJdbcCall` 类使用数据库中的元数据来查找in和out参数的名称,这样您就不必显式声明它们.  如果您愿意这样做,或者如果您有没有自动映射到Java类的参数(例如 `ARRAY` 或 `STRUCT`) ,则可以声明参数.
第一个示例显示了一个简单的存储过程,该过程仅从MySQL数据库返回 `VARCHAR` 和 `DATE` 格式的标量值.  示例存储过程读取指定的 `actor` 条目,并以out参数的形式返回 `first_name`、`last_name` 和 `birth_date` 列.  以下清单显示了第一个示例:

[source,sql,indent=0,subs="verbatim,quotes"]
----
	CREATE PROCEDURE read_actor (
		IN in_id INTEGER,
		OUT out_first_name VARCHAR(100),
		OUT out_last_name VARCHAR(100),
		OUT out_birth_date DATE)
	BEGIN
		SELECT first_name, last_name, birth_date
		INTO out_first_name, out_last_name, out_birth_date
		FROM t_actor where id = in_id;
	END;
----

`in_id` 参数包含您正在查找的 `actor` 的 `id`. `out` 参数返回从表中读取的数据.

您可以用类似于声明 `SimpleJdbcInsert` 的方式声明 `SimpleJdbcCall`.  您应该在数据访问层的初始化方法中实例化和配置类.  与 `StoredProcedure` 类相比,您无需创建子类,也无需声明可在数据库元数据中查找的参数.  以下 `SimpleJdbcCall` 配置示例使用前面的存储过程(除了 `DataSource` 之外,唯一的配置选项是存储过程的名称) :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private SimpleJdbcCall procReadActor;

		public void setDataSource(DataSource dataSource) {
			this.procReadActor = new SimpleJdbcCall(dataSource)
					.withProcedureName("read_actor");
		}

		public Actor readActor(Long id) {
			SqlParameterSource in = new MapSqlParameterSource()
					.addValue("in_id", id);
			Map out = procReadActor.execute(in);
			Actor actor = new Actor();
			actor.setId(id);
			actor.setFirstName((String) out.get("out_first_name"));
			actor.setLastName((String) out.get("out_last_name"));
			actor.setBirthDate((Date) out.get("out_birth_date"));
			return actor;
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private val procReadActor = SimpleJdbcCall(dataSource)
				.withProcedureName("read_actor")


		fun readActor(id: Long): Actor {
			val source = MapSqlParameterSource().addValue("in_id", id)
			val output = procReadActor.execute(source)
			return Actor(
					id,
					output["out_first_name"] as String,
					output["out_last_name"] as String,
					output["out_birth_date"] as Date)
		}

			// ... additional methods
	}
----

为执行调用所写的代码而创建一个包含IN参数的 `SqlParameterSource`.  您必须将为输入值提供的名称与存储过程中声明的参数名称的名称相匹配.  该案例不必匹配,因为您使用元数据来确定应如何在存储过程中引用数据库对象.  存储过程的源中指定的内容不一定是它存储在数据库中的方式.  某些数据库将名称转换为全部大写,而其他数据库使用小写或使用指定的大小写.

`execute` 方法接受IN参数并返回一个 `Map`,该 `Map` 包含由存储过程中指定的名称输入的任何 `out` 参数.  在这种情况下,它们是 `out_first_name`、`out_last_name` 和 `out_birth_date`.

`execute` 方法的最后一部分创建一个 `Actor` 实例,用于返回检索到的数据.  同样,在存储过程中声明它们时,使用 `out` 参数的名称很重要.  此外,结果映射中存储的out参数名称中的情况与数据库中 `out` 参数名称的情况相匹配,这可能因数据库而异.  为了使代码更具可移植性,您应该进行不区分大小写的查找或指示Spring使用 `LinkedCaseInsensitiveMap`.  要执行后者,您可以创建自己的 `JdbcTemplate` 并将 `setResultsMapCaseInsensitive` 属性设置为 `true`.  然后,您可以将此自定义 `JdbcTemplate` 实例传递给 `SimpleJdbcCall` 的构造函数.  以下示例显示了此配置:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private SimpleJdbcCall procReadActor;

		public void setDataSource(DataSource dataSource) {
			JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
			jdbcTemplate.setResultsMapCaseInsensitive(true);
			this.procReadActor = new SimpleJdbcCall(jdbcTemplate)
					.withProcedureName("read_actor");
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private var procReadActor = SimpleJdbcCall(JdbcTemplate(dataSource).apply {
			isResultsMapCaseInsensitive = true
		}).withProcedureName("read_actor")
		
		// ... additional methods
	}
----

通过执行此操作,可以避免在用于返回的 `out` 参数名称的情况下发生冲突.


[[jdbc-simple-jdbc-call-2]]
==== 显式声明用于 `SimpleJdbcCall` 的参数

在本章的前面部分,我们描述了如何从元数据中推导出参数,但如果您愿意,可以明确声明它们.  您可以通过使用 `declareParameters` 方法创建和配置 `SimpleJdbcCall` 来实现, 该方法将可变数量的 `SqlParameter` 对象作为输入.  有关如何定义 `SqlParameter` 的详细信息,请参阅<<jdbc-params, 下一节>>.

NOTE: 	如果您使用的数据库不是Spring支持的数据库,则必须使用显式声明.  目前,Spring支持以下数据库的存储过程调用的元数据查找: Apache Derby,DB2,MySQL,Microsoft SQL Server,Oracle和Sybase.  我们还支持MySQL,Microsoft SQL Server和Oracle的存储函数的元数据查找.

您可以选择显式声明一个,部分或全部参数. 在未明确声明参数的情况下,仍会使用参数元数据.  要绕过对潜在参数的元数据查找的所有处理并仅使用声明的参数, 可以将方法调用 `withoutProcedureColumnMetaDataAccess` 作为声明的一部分.  假设您为数据库函数声明了两个或多个不同的调用签名.  在这种情况下,您调用 `useInParameterNames` 来指定要包含给定签名的IN参数名称列表.

以下示例显示了完全声明的存储过程调用,并使用前面示例中的信息:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private SimpleJdbcCall procReadActor;

		public void setDataSource(DataSource dataSource) {
			JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
			jdbcTemplate.setResultsMapCaseInsensitive(true);
			this.procReadActor = new SimpleJdbcCall(jdbcTemplate)
					.withProcedureName("read_actor")
					.withoutProcedureColumnMetaDataAccess()
					.useInParameterNames("in_id")
					.declareParameters(
							new SqlParameter("in_id", Types.NUMERIC),
							new SqlOutParameter("out_first_name", Types.VARCHAR),
							new SqlOutParameter("out_last_name", Types.VARCHAR),
							new SqlOutParameter("out_birth_date", Types.DATE)
					);
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

			private val procReadActor = SimpleJdbcCall(JdbcTemplate(dataSource).apply {
				isResultsMapCaseInsensitive = true
			}).withProcedureName("read_actor")
					.withoutProcedureColumnMetaDataAccess()
					.useInParameterNames("in_id")
					.declareParameters(
							SqlParameter("in_id", Types.NUMERIC),
							SqlOutParameter("out_first_name", Types.VARCHAR),
							SqlOutParameter("out_last_name", Types.VARCHAR),
							SqlOutParameter("out_birth_date", Types.DATE)
		)

			// ... additional methods
	}
----

两个示例的执行和结束结果是相同的.  第二个示例明确指定所有详细信息,而不是依赖于元数据.

[[jdbc-params]]
==== 如何定义 `SqlParameters`

要为 `SimpleJdbc` 类以及RDBMS操作类定义参数(在将<<jdbc-object,JDBC操作建模为Java对象>>中) ,您可以使用 `SqlParameter` 或其某一子类.  为此,通常在构造函数中指定参数名称和SQL类型.  SQL类型是使用 `java.sql.Types` 常量指定的. 在本章前面,我们看到了类似于以下内容的声明:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	new SqlParameter("in_id", Types.NUMERIC),
	new SqlOutParameter("out_first_name", Types.VARCHAR),
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	SqlParameter("in_id", Types.NUMERIC),
	SqlOutParameter("out_first_name", Types.VARCHAR),
----

`SqlParameter` 的第一行声明了一个IN参数.  您可以通过使用 `SqlQuery` 及其子类(在 <<jdbc-SqlQuery,了解SqlQuery>>中介绍) 为存储过程调用和查询使用IN参数.

第二行(使用 `SqlOutParameter`) 声明要在存储过程调用中使用的out参数.  `InOut` 参数还有一个 `SqlInOutParameter`(为过程提供IN值并且还返回值的参数) .

NOTE: 	只有声明为 `SqlParameter` 和 `SqlInOutParameter` 的参数才用于提供输入值.  这与 `StoredProcedure` 类不同,后者(为了向后兼容性) 允许为声明为 `SqlOutParameter` 的参数提供输入值.

对于IN参数,除了名称和SQL类型之外,还可以指定数字数据的比例或自定义数据库类型的类型名称.  对于 `out` 参数,您可以提供 `RowMapper` 来处理从REF游标返回的行的映射.  另一个选项是指定一个 `SqlReturnType`,它提供了定义返回值的自定义处理的机会.


[[jdbc-simple-jdbc-call-3]]
==== 使用 `SimpleJdbcCall` 调用存储函数

除了提供函数名称而不是过程名称之外,您可以使用与调用存储过程几乎相同的方式调用存储函数.  您可以使用 `withFunctionName` 方法作为配置的一部分,以指示您要对函数进行调用,并生成函数调用的相应字符串.
专有的执行调用(`executeFunction`) 用于执行函数,它将函数返回值作为指定类型的对象返回,这意味着您不必从结果映射中检索返回值.  类似的便捷方法(名为 `executeObject`) 也可用于只有一个 `out` 参数的存储过程.
以下示例(对于MySQL) 基于名为 `get_actor_name` 的存储函数,该函数返回 `actor` 的全名:

[source,sql,indent=0,subs="verbatim,quotes"]
----
	CREATE FUNCTION get_actor_name (in_id INTEGER)
	RETURNS VARCHAR(200) READS SQL DATA
	BEGIN
		DECLARE out_name VARCHAR(200);
		SELECT concat(first_name, ' ', last_name)
			INTO out_name
			FROM t_actor where id = in_id;
		RETURN out_name;
	END;
----

为了调用此函数,我们再次在初始化方法中创建 `SimpleJdbcCall`,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private JdbcTemplate jdbcTemplate;
		private SimpleJdbcCall funcGetActorName;

		public void setDataSource(DataSource dataSource) {
			this.jdbcTemplate = new JdbcTemplate(dataSource);
			JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
			jdbcTemplate.setResultsMapCaseInsensitive(true);
			this.funcGetActorName = new SimpleJdbcCall(jdbcTemplate)
					.withFunctionName("get_actor_name");
		}

		public String getActorName(Long id) {
			SqlParameterSource in = new MapSqlParameterSource()
					.addValue("in_id", id);
			String name = funcGetActorName.executeFunction(String.class, in);
			return name;
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

		private val jdbcTemplate = JdbcTemplate(dataSource).apply {
			isResultsMapCaseInsensitive = true
		}
		private val funcGetActorName = SimpleJdbcCall(jdbcTemplate)
				.withFunctionName("get_actor_name")

		fun getActorName(id: Long): String {
			val source = MapSqlParameterSource().addValue("in_id", id)
			return funcGetActorName.executeFunction(String::class.java, source)
		}

		// ... additional methods
	}
----

使用的 `executeFunction` 方法返回一个 `String`,该 `String` 包含函数调用的返回值.


[[jdbc-simple-jdbc-call-4]]
==== 从 `SimpleJdbcCall` 返回 `ResultSet` 或REF游标

调用返回结果集的存储过程或函数有点棘手.  某些数据库在JDBC结果处理期间返回结果集,而其他数据库则需要显式注册的特定类型的 `out` 参数.  这两种方法都需要额外的处理来循环结果集并处理返回的行.
使用 `SimpleJdbcCall`,您可以使用 `returningResultSet` 方法并声明 `RowMapper` 实现用于特定参数.  如果在结果处理期间返回结果集,则不会定义任何名称,因此返回的结果必须与声明 `RowMapper` 实现的顺序相匹配.
指定的名称仍用于将处理的结果列表存储在从 `execute` 语句返回的结果映射中.

下一个示例(对于MySQL) 使用不带IN参数的存储过程,并返回 `t_actor` 表中的所有行:

[source,sql,indent=0,subs="verbatim,quotes"]
----
	CREATE PROCEDURE read_all_actors()
	BEGIN
	 SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;
	END;
----

要调用此过程,可以声明 `RowMapper`.  因为要映射到的类遵循JavaBean规则,所以可以使用通过传入必需的类来映射到 `newInstance` 方法而创建的 `BeanPropertyRowMapper`.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class JdbcActorDao implements ActorDao {

		private SimpleJdbcCall procReadAllActors;

		public void setDataSource(DataSource dataSource) {
			JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
			jdbcTemplate.setResultsMapCaseInsensitive(true);
			this.procReadAllActors = new SimpleJdbcCall(jdbcTemplate)
					.withProcedureName("read_all_actors")
					.returningResultSet("actors",
					BeanPropertyRowMapper.newInstance(Actor.class));
		}

		public List getActorsList() {
			Map m = procReadAllActors.execute(new HashMap<String, Object>(0));
			return (List) m.get("actors");
		}

		// ... additional methods
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class JdbcActorDao(dataSource: DataSource) : ActorDao {

			private val procReadAllActors = SimpleJdbcCall(JdbcTemplate(dataSource).apply {
				isResultsMapCaseInsensitive = true
			}).withProcedureName("read_all_actors")
					.returningResultSet("actors",
							BeanPropertyRowMapper.newInstance(Actor::class.java))

		fun getActorsList(): List<Actor> {
			val m = procReadAllActors.execute(mapOf<String, Any>())
			return m["actors"] as List<Actor>
		}

		// ... additional methods
	}
----

调用 `execute` 传入一个空 `Map`,因为此调用不接受任何参数.  然后从结果映射中检索 `actor` 列表并返回给调用者.

[[jdbc-object]]
=== 将JDBC操作建模为Java对象

`org.springframework.jdbc.object` 包中包含的类允许您以面向对象的方式访问数据库.  例如,您可以执行查询并将结果作为包含业务对象的列表返回,其中关系列数据映射到业务对象的属性.  您还可以运行存储过程并运行update,delete和insert语句.

[NOTE]
====
许多Spring开发人员认为下面描述的各种RDBMS操作类(<<jdbc-StoredProcedure, `StoredProcedure`>> 类除外) 通常可以用直接的 `JdbcTemplate` 调用替换.  通常,编写直接在 `JdbcTemplate` 上调用方法的DAO方法(而不是将查询封装为完整的类) 更简单.

但是,如果您从使用RDBMS操作类获得可测量的值,则应继续使用这些类.
====


[[jdbc-SqlQuery]]
==== 了解 `SqlQuery`

`SqlQuery` 是一个可重用的、线程安全的类,它封装了一个SQL查询.  子类必须实现 `newRowMapper(..)` 方法以提供 `RowMapper` 实例,该实例可以通过迭代在查询执行期间创建的 `ResultSet` 获得每行创建一个对象.
`SqlQuery` 类很少直接使用,因为 `MappingSqlQuery` 子类为将行映射到Java类提供了更方便的实现.  继承 `SqlQuery` 的其他实现是 `MappingSqlQueryWithParameters` 和 `UpdatableSqlQuery`.

[[jdbc-MappingSqlQuery]]
==== 使用 `MappingSqlQuery`

`MappingSqlQuery` 是一个可重用的查询,其中具体的子类必须实现抽象的 `mapRow(..)` 方法,以将提供的 `ResultSet` 的每一行转换为指定类型的对象.  以下示例显示了一个自定义查询,该查询将 `t_actor` 关系中的数据映射到 `Actor` 类的实例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ActorMappingQuery extends MappingSqlQuery<Actor> {

		public ActorMappingQuery(DataSource ds) {
			super(ds, "select id, first_name, last_name from t_actor where id = ?");
			declareParameter(new SqlParameter("id", Types.INTEGER));
			compile();
		}

		@Override
		protected Actor mapRow(ResultSet rs, int rowNumber) throws SQLException {
			Actor actor = new Actor();
			actor.setId(rs.getLong("id"));
			actor.setFirstName(rs.getString("first_name"));
			actor.setLastName(rs.getString("last_name"));
			return actor;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ActorMappingQuery(ds: DataSource) : MappingSqlQuery<Actor>(ds, "select id, first_name, last_name from t_actor where id = ?") {

		init {
			declareParameter(SqlParameter("id", Types.INTEGER))
			compile()
		}

		override fun mapRow(rs: ResultSet, rowNumber: Int) = Actor(
				rs.getLong("id"),
				rs.getString("first_name"),
				rs.getString("last_name")
		)
	}

----

该类扩展了使用 `Actor` 类型参数化的 `MappingSqlQuery`.  此自定义查询的构造函数将 `DataSource` 作为唯一参数.  在此构造函数中,您可以使用 `DataSource` 和应执行的SQL调用超类上的构造函数来检索此查询的行.
此SQL用于创建 `PreparedStatement`,因此它可能包含在执行期间传递的任何参数的占位符.  您必须使用传入 `SqlParameter的declareParameter` 方法声明每个参数.  `SqlParameter` 带有名称,以及 `java.sql.Types` 中定义的JDBC类型.
定义所有参数后,可以调用 `compile()` 方法,以便可以准备并稍后运行该语句.  这个类在编译后是线程安全的,因此,只要在初始化DAO时创建这些实例,它们就可以作为实例变量保存并重用.  以下示例显示如何定义此类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	private ActorMappingQuery actorMappingQuery;

	@Autowired
	public void setDataSource(DataSource dataSource) {
		this.actorMappingQuery = new ActorMappingQuery(dataSource);
	}

	public Customer getCustomer(Long id) {
		return actorMappingQuery.findObject(id);
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	private val actorMappingQuery = ActorMappingQuery(dataSource)

	fun getCustomer(id: Long) = actorMappingQuery.findObject(id)
----

前面示例中的方法使用作为唯一参数传入的 `id` 检索客户. 由于我们只想返回一个对象,因此我们使用id作为参数调用 `findObject` 方法.  如果我们改为返回一个对象列表并获取其他参数的查询,我们将使用一个 `execute` 方法,该方法将传入的参数值数组作为可变参数.
以下示例显示了这样一种方法:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public List<Actor> searchForActors(int age, String namePattern) {
		List<Actor> actors = actorSearchMappingQuery.execute(age, namePattern);
		return actors;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	fun searchForActors(age: Int, namePattern: String) =
				actorSearchMappingQuery.execute(age, namePattern)
----


[[jdbc-SqlUpdate]]
==== 使用 `SqlUpdate`

`SqlUpdate` 类封装了SQL更新. 与查询一样,更新对象是可重用的,并且与所有 `RdbmsOperation` 类一样,更新可以具有参数并在SQL中定义.  此类提供了许多类似于查询对象的 `execute(..)` 方法的 `update(..)` 方法.  `SqlUpdate` 类是具体的. 它可以是子类 - 例如,添加自定义更新方法.
但是,您不必为 `SqlUpdate` 类创建子类,因为可以通过设置SQL和声明参数来轻松地对其进行参数化.  以下示例创建名为 `execute` 的自定义更新方法:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import java.sql.Types;
	import javax.sql.DataSource;
	import org.springframework.jdbc.core.SqlParameter;
	import org.springframework.jdbc.object.SqlUpdate;

	public class UpdateCreditRating extends SqlUpdate {

		public UpdateCreditRating(DataSource ds) {
			setDataSource(ds);
			setSql("update customer set credit_rating = ? where id = ?");
			declareParameter(new SqlParameter("creditRating", Types.NUMERIC));
			declareParameter(new SqlParameter("id", Types.NUMERIC));
			compile();
		}

		/**
		 * @param id for the Customer to be updated
		 * @param rating the new value for credit rating
		 * @return number of rows updated
		 */
		public int execute(int id, int rating) {
			return update(rating, id);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import java.sql.Types
	import javax.sql.DataSource
	import org.springframework.jdbc.core.SqlParameter
	import org.springframework.jdbc.`object`.SqlUpdate

	class UpdateCreditRating(ds: DataSource) : SqlUpdate() {

		init {
			setDataSource(ds)
			sql = "update customer set credit_rating = ? where id = ?"
			declareParameter(SqlParameter("creditRating", Types.NUMERIC))
			declareParameter(SqlParameter("id", Types.NUMERIC))
			compile()
		}

		/**
		* @param id for the Customer to be updated
		* @param rating the new value for credit rating
		* @return number of rows updated
		*/
		fun execute(id: Int, rating: Int): Int {
			return update(rating, id)
		}
	}
----


[[jdbc-StoredProcedure]]
==== 使用 `StoredProcedure`

`StoredProcedure` 类是RDBMS存储过程的对象抽象的超类.  这个类是 `abstract` 的,它的各种 `execute(..)` 方法具有 `protected` 的访问权限,防止除了通过提供更严格类型的子类之外的其他用途.

继承的 `sql` 属性是RDBMS中存储过程的名称.

要为 `StoredProcedure` 类定义参数,可以使用 `SqlParameter` 或其某一子类.  您必须在构造函数中指定参数名称和SQL类型,如以下代码段所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	new SqlParameter("in_id", Types.NUMERIC),
	new SqlOutParameter("out_first_name", Types.VARCHAR),
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	SqlParameter("in_id", Types.NUMERIC),
	SqlOutParameter("out_first_name", Types.VARCHAR),
----

使用 `java.sql.Types` 常量指定SQL类型.

第一行(使用 `SqlParameter`) 声明一个IN参数.  您可以将IN参数用于存储过程调用和使用 `SqlQuery` 及其子类的查询(在 <<jdbc-SqlQuery,了解SqlQuery>>中介绍) .

第二行(使用 `SqlOutParameter`) 声明要在存储过程调用中使用的 `out` 参数.  `InOut` 参数还有一个 `SqlInOutParameter`(为存储过程提供一个 `in` 值和返回值的参数) .

对于 `in` 参数,除了名称和SQL类型之外,还可以为自定义数据库类型指定数字数据的比例或类型名称.  对于 `out` 参数,您可以提供 `RowMapper` 来处理从REF游标返回的行的映射.  另一个选项是指定一个 `SqlReturnType`,它允许您定义返回值的自定义处理.

简单DAO的下一个示例使用 `StoredProcedure` 来调用函数(`sysdate()`) ,该函数随任何Oracle数据库一起提供.  要使用存储过程功能,您必须创建一个继承 `StoredProcedure` 的类. 在此示例中,`StoredProcedure` 类是内部类.  但是,如果需要重用 `StoredProcedure`,可以将其声明为顶级类.
此示例没有输入参数,但通过使用 `SqlOutParameter` 类将输出参数声明为日期类型. `execute()` 方法运行该过程并从结果 `Map` 中提取返回的日期.  结果 `Map` 通过使用参数名称作为键,为每个声明的输出参数(在本例中只有一个) 提供了一个条目.  以下清单显示了我们的自定义 `StoredProcedure` 类:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import java.sql.Types;
	import java.util.Date;
	import java.util.HashMap;
	import java.util.Map;
	import javax.sql.DataSource;
	import org.springframework.beans.factory.annotation.Autowired;
	import org.springframework.jdbc.core.SqlOutParameter;
	import org.springframework.jdbc.object.StoredProcedure;

	public class StoredProcedureDao {

		private GetSysdateProcedure getSysdate;

		@Autowired
		public void init(DataSource dataSource) {
			this.getSysdate = new GetSysdateProcedure(dataSource);
		}

		public Date getSysdate() {
			return getSysdate.execute();
		}

		private class GetSysdateProcedure extends StoredProcedure {

			private static final String SQL = "sysdate";

			public GetSysdateProcedure(DataSource dataSource) {
				setDataSource(dataSource);
				setFunction(true);
				setSql(SQL);
				declareParameter(new SqlOutParameter("date", Types.DATE));
				compile();
			}

			public Date execute() {
				// the 'sysdate' sproc has no input parameters, so an empty Map is supplied...
				Map<String, Object> results = execute(new HashMap<String, Object>());
				Date sysdate = (Date) results.get("date");
				return sysdate;
			}
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import java.sql.Types
	import java.util.Date
	import java.util.Map
	import javax.sql.DataSource
	import org.springframework.jdbc.core.SqlOutParameter
	import org.springframework.jdbc.object.StoredProcedure

	class StoredProcedureDao(dataSource: DataSource) {

		private val SQL = "sysdate"

		private val getSysdate = GetSysdateProcedure(dataSource)

		val sysdate: Date
			get() = getSysdate.execute()

		private inner class GetSysdateProcedure(dataSource: DataSource) : StoredProcedure() {

			init {
				setDataSource(dataSource)
				isFunction = true
				sql = SQL
				declareParameter(SqlOutParameter("date", Types.DATE))
				compile()
			}

			fun execute(): Date {
				// the 'sysdate' sproc has no input parameters, so an empty Map is supplied...
				val results = execute(mutableMapOf<String, Any>())
				return results["date"] as Date
			}
		}
	}
----

以下 `StoredProcedure` 示例有两个输出参数(在本例中为Oracle REF游标) :

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import java.util.HashMap;
	import java.util.Map;
	import javax.sql.DataSource;
	import oracle.jdbc.OracleTypes;
	import org.springframework.jdbc.core.SqlOutParameter;
	import org.springframework.jdbc.object.StoredProcedure;

	public class TitlesAndGenresStoredProcedure extends StoredProcedure {

		private static final String SPROC_NAME = "AllTitlesAndGenres";

		public TitlesAndGenresStoredProcedure(DataSource dataSource) {
			super(dataSource, SPROC_NAME);
			declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
			declareParameter(new SqlOutParameter("genres", OracleTypes.CURSOR, new GenreMapper()));
			compile();
		}

		public Map<String, Object> execute() {
			// again, this sproc has no input parameters, so an empty Map is supplied
			return super.execute(new HashMap<String, Object>());
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import java.util.HashMap
	import javax.sql.DataSource
	import oracle.jdbc.OracleTypes
	import org.springframework.jdbc.core.SqlOutParameter
	import org.springframework.jdbc.`object`.StoredProcedure

	class TitlesAndGenresStoredProcedure(dataSource: DataSource) : StoredProcedure(dataSource, SPROC_NAME) {

		companion object {
			private const val SPROC_NAME = "AllTitlesAndGenres"
		}

		init {
			declareParameter(SqlOutParameter("titles", OracleTypes.CURSOR, TitleMapper()))
			declareParameter(SqlOutParameter("genres", OracleTypes.CURSOR, GenreMapper()))
			compile()
		}

		fun execute(): Map<String, Any> {
			// again, this sproc has no input parameters, so an empty Map is supplied
			return super.execute(HashMap<String, Any>())
		}
	}
----

请注意在 `TitlesAndGenresStoredProcedure` 构造函数中使用的 `declareParameter(..)` 方法的重载是如何传递 `RowMapper` 实现实例的.  这是重用现有功能的一种非常方便和强大的方法.  接下来的两个示例提供了两个 `RowMapper` 实现的代码.

`TitleMapper` 类将 `ResultSet` 映射到提供的 `ResultSet` 中每一行的 `Title` 域对象,如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import com.foo.domain.Title;
	import org.springframework.jdbc.core.RowMapper;

	public final class TitleMapper implements RowMapper<Title> {

		public Title mapRow(ResultSet rs, int rowNum) throws SQLException {
			Title title = new Title();
			title.setId(rs.getLong("id"));
			title.setName(rs.getString("name"));
			return title;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import java.sql.ResultSet
	import com.foo.domain.Title
	import org.springframework.jdbc.core.RowMapper

	class TitleMapper : RowMapper<Title> {

		override fun mapRow(rs: ResultSet, rowNum: Int) =
				Title(rs.getLong("id"), rs.getString("name"))
	}
----

`GenreMapper` 类将 `ResultSet` 映射到提供的 `ResultSet` 中每一行的 `Genre` 域对象,如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import java.sql.ResultSet;
	import java.sql.SQLException;
	import com.foo.domain.Genre;
	import org.springframework.jdbc.core.RowMapper;

	public final class GenreMapper implements RowMapper<Genre> {

		public Genre mapRow(ResultSet rs, int rowNum) throws SQLException {
			return new Genre(rs.getString("name"));
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import java.sql.ResultSet
	import com.foo.domain.Genre
	import org.springframework.jdbc.core.RowMapper

	class GenreMapper : RowMapper<Genre> {
		
		override fun mapRow(rs: ResultSet, rowNum: Int): Genre {
			return Genre(rs.getString("name"))
		}
	}
----

要将参数传递给在RDBMS的定义中具有一个或多个输入参数的存储过程, 您可以编写一个强类型的 `execute(..)` 方法,该方法将委托给超类中的无类型 `execute(Map)` 方法,如以下例子所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import java.sql.Types;
	import java.util.Date;
	import java.util.HashMap;
	import java.util.Map;
	import javax.sql.DataSource;
	import oracle.jdbc.OracleTypes;
	import org.springframework.jdbc.core.SqlOutParameter;
	import org.springframework.jdbc.core.SqlParameter;
	import org.springframework.jdbc.object.StoredProcedure;

	public class TitlesAfterDateStoredProcedure extends StoredProcedure {

		private static final String SPROC_NAME = "TitlesAfterDate";
		private static final String CUTOFF_DATE_PARAM = "cutoffDate";

		public TitlesAfterDateStoredProcedure(DataSource dataSource) {
			super(dataSource, SPROC_NAME);
			declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);
			declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
			compile();
		}

		public Map<String, Object> execute(Date cutoffDate) {
			Map<String, Object> inputs = new HashMap<String, Object>();
			inputs.put(CUTOFF_DATE_PARAM, cutoffDate);
			return super.execute(inputs);
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	import java.sql.Types
	import java.util.Date
	import javax.sql.DataSource
	import oracle.jdbc.OracleTypes
	import org.springframework.jdbc.core.SqlOutParameter
	import org.springframework.jdbc.core.SqlParameter
	import org.springframework.jdbc.`object`.StoredProcedure

	class TitlesAfterDateStoredProcedure(dataSource: DataSource) : StoredProcedure(dataSource, SPROC_NAME) {

		companion object {
			private const val SPROC_NAME = "TitlesAfterDate"
			private const val CUTOFF_DATE_PARAM = "cutoffDate"
		}

		init {
			declareParameter(SqlParameter(CUTOFF_DATE_PARAM, Types.DATE))
			declareParameter(SqlOutParameter("titles", OracleTypes.CURSOR, TitleMapper()))
			compile()
		}

		fun execute(cutoffDate: Date) = super.execute(
				mapOf<String, Any>(CUTOFF_DATE_PARAM to cutoffDate))
	}
----



[[jdbc-parameter-handling]]
=== 参数和数据值处理的常见问题

Spring Framework的JDBC支持提供的不同方法中存在参数和数据值的常见问题.  本节介绍如何解决这些问题.

[[jdbc-type-information]]
==== 为参数提供SQL类型信息

通常,Spring根据传入的参数类型确定参数的SQL类型. 可以显式提供设置参数值时要使用的SQL类型.  有时需要正确设置 `NULL` 值.

您可以通过多种方式提供SQL类型信息:

* `JdbcTemplate` 的许多更新和查询方法都采用 `int` 数组形式的附加参数.  此数组用于通过使用 `java.sql.Types` 类中的常量值来指示相应参数的SQL类型.  为每个参数提供一个条目.
* 您可以使用 `SqlParameterValue` 类来包装需要此附加信息的参数值.  为此,请为每个值创建一个新实例,并在构造函数中传入SQL类型和参数值.  您还可以为数值提供可选的缩放参数
* 对于使用命名参数的方法,可以使用 `SqlParameterSource` 类,`BeanPropertySqlParameterSource` 或 `MapSqlParameterSource`.  它们都具有为任何命名参数值注册SQL类型的方法.

[[jdbc-lob]]
==== 处理BLOB和CLOB对象

您可以在数据库中存储图像,其他二进制数据和大块文本.  这些大对象称为二进制数据的BLOB(二进制大对象) 和字符数据的CLOB(字符大对象) .  在Spring中,您可以直接使用 `JdbcTemplate` 处理这些大对象,也可以在使用RDBMS对象和 `JdbcTemplate` 类提供的更高抽象时处理这些大对象.
所有这些方法都使用 `LobHandler` 接口的实现来实际的管理LOB(大对象) 数据.  `LobHandler` 通过 `getLobCreator` 方法提供对 `LobCreator` 类的访问,该方法用于创建要插入的新LOB对象.

`LobCreator` 和 `LobHandler` 为LOB输入和输出提供以下支持:

* BLOB
** `byte[]`: `getBlobAsBytes` and `setBlobAsBytes`
** `InputStream`: `getBlobAsBinaryStream` and `setBlobAsBinaryStream`
* CLOB
** `String`: `getClobAsString` and `setClobAsString`
** `InputStream`: `getClobAsAsciiStream` and `setClobAsAsciiStream`
** `Reader`: `getClobAsCharacterStream` and `setClobAsCharacterStream`

下一个示例显示如何创建和插入BLOB对象. 稍后我们将展示如何从数据库中读取它.

此示例使用 `JdbcTemplate` 和 `AbstractLobCreatingPreparedStatementCallback` 的实现.  它实现了一个方法: `setValues`. 此方法提供了一个 `LobCreator`,我们用它来设置SQL `insert` 语句中LOB列的值.

对于此示例,我们假设有一个变量 `lobHandler`,它已经设置为 `DefaultLobHandler` 的一个实例.  您通常通过依赖注入设置此值.

以下示例展示了如何创建并插入一个BLOB对象:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	final File blobIn = new File("spring2004.jpg");
	final InputStream blobIs = new FileInputStream(blobIn);
	final File clobIn = new File("large.txt");
	final InputStream clobIs = new FileInputStream(clobIn);
	final InputStreamReader clobReader = new InputStreamReader(clobIs);

	jdbcTemplate.execute(
		"INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)",
		new AbstractLobCreatingPreparedStatementCallback(lobHandler) {  // <1>
			protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException {
				ps.setLong(1, 1L);
				lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length());  // <2>
				lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length());  // <3>
			}
		}
	);

	blobIs.close();
	clobReader.close();
----
<1> 在本例中,传入的 `lobHandler` 是一个普通的 `DefaultLobHandler`.
<2> 使用 `setClobAsCharacterStream` 方法传入CLOB的内容.
<3> 使用 `setBlobAsBinaryStream` 方法传入BLOB的内容.

[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val blobIn = File("spring2004.jpg")
	val blobIs = FileInputStream(blobIn)
	val clobIn = File("large.txt")
	val clobIs = FileInputStream(clobIn)
	val clobReader = InputStreamReader(clobIs)

	jdbcTemplate.execute(
			"INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)",
			object: AbstractLobCreatingPreparedStatementCallback(lobHandler) {  // <1>
				override fun setValues(ps: PreparedStatement, lobCreator: LobCreator) {
					ps.setLong(1, 1L)
					lobCreator.setClobAsCharacterStream(ps, 2, clobReader, clobIn.length().toInt())  // <2>
					lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, blobIn.length().toInt())  // <3>
				}
			}
	)
	blobIs.close()
	clobReader.close()
----
<1> 在本例中,传入的 `lobHandler` 是一个普通的 `DefaultLobHandler`.
<2> 使用 `setClobAsCharacterStream` 方法传入CLOB的内容.
<3> 使用 `setBlobAsBinaryStream` 方法传入BLOB的内容.


[NOTE]
====

如果从 `DefaultLobHandler.getLobCreator()` 返回的 `LobCreator` 上调用 `setBlobAsBinaryStream`, `setClobAsAsciiStream` 或 `setClobAsCharacterStream` 方法,则可以选择为 `contentLength` 参数指定负值.
如果指定的内容长度为负,则 `DefaultLobHandler` 使用 `set-stream` 方法的JDBC 4.0变体而不使用length参数.  否则,它将指定的长度传递给驱动程序.

请参阅用于验证它是否支持在不提供内容长度的情况下流式传输LOB的JDBC驱动程序的文档.
====

现在是时候从数据库中读取LOB数据了.  同样,您使用具有相同实例变量 `lobHandler` 的 `JdbcTemplate` 和对 `DefaultLobHandler` 的引用.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	List<Map<String, Object>> l = jdbcTemplate.query("select id, a_clob, a_blob from lob_table",
		new RowMapper<Map<String, Object>>() {
			public Map<String, Object> mapRow(ResultSet rs, int i) throws SQLException {
				Map<String, Object> results = new HashMap<String, Object>();
				String clobText = lobHandler.getClobAsString(rs, "a_clob");  // <1>
				results.put("CLOB", clobText);
				byte[] blobBytes = lobHandler.getBlobAsBytes(rs, "a_blob");  // <2>
				results.put("BLOB", blobBytes);
				return results;
			}
		});
----
<1> 使用 `getClobAsString` 方法检索CLOB的内容.
<2> 使用 `getBlobAsBytes` 方法检索BLOB的内容.


[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val l = jdbcTemplate.query("select id, a_clob, a_blob from lob_table") { rs, _ ->
		val clobText = lobHandler.getClobAsString(rs, "a_clob")  // <1>
		val blobBytes = lobHandler.getBlobAsBytes(rs, "a_blob")  // <2>
		mapOf("CLOB" to clobText, "BLOB" to blobBytes)
	}
----
<1> 使用 `getClobAsString` 方法检索CLOB的内容.
<2> 使用 `getBlobAsBytes` 方法检索BLOB的内容.


[[jdbc-in-clause]]
==== 传入Lists值到IN子句

SQL标准允许基于包含列表变量值的表达式来选择行.  一个典型的例子是 `select * from T_ACTOR where id in
(1, 2, 3)`. JDBC标准对预准备语句不直接支持此列表变量.  您不能声明可变数量的占位符. 您需要准备好所需占位符数量的多种变体,或者一旦知道需要多少占位符,
就需要动态生成SQL字符串.  `NamedParameterJdbcTemplate` 和 `JdbcTemplate` 中提供的命名参数支持采用后一种方法.  您可以将值作为原始对象的 `java.util.List` 传递. 此列表用于插入所需的占位符,并在语句执行期间传入值.

NOTE: 传递许多值时要小心. JDBC标准不保证您可以为 `in` 列表表达式使用100个以上的值.  各种数据库超过此数量,但它们通常对允许的值有多少硬性限制. 例如,Oracle的限制为1000.

除了值列表中的原始值之外,您还可以创建对象数组的 `java.util.List`. 此列表可以支持为 `in` 子句定义的多个表达式, 例如 `select * from T_ACTOR where (id, last_name) in \((1, 'Johnson'), (2,
'Harrop'\))`. 当然,这要求您的数据库支持此语法.

[[jdbc-complex-types]]
==== 处理存储过程调用的复杂类型

调用存储过程时,有时可以使用特定于数据库的复杂类型.  为了容纳这些类型,Spring提供了一个 `SqlReturnType`,用于从存储过程调用中返回时处理这些类型, 和一个 `SqlTypeValue`,当这些类型作为参数出入存储过程中时处理他们.

`SqlReturnType` 接口有一个必须实现的方法(名为 `getTypeValue`) .  此接口用作 `SqlOutParameter` 声明的一部分. 以下示例显示返回用户声明的类型为 `ITEM_TYPE` 的 Oracle `STRUCT` 对象的值:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class TestItemStoredProcedure extends StoredProcedure {

		public TestItemStoredProcedure(DataSource dataSource) {
			// ...
			declareParameter(new SqlOutParameter("item", OracleTypes.STRUCT, "ITEM_TYPE",
				(CallableStatement cs, int colIndx, int sqlType, String typeName) -> {
					STRUCT struct = (STRUCT) cs.getObject(colIndx);
					Object[] attr = struct.getAttributes();
					TestItem item = new TestItem();
					item.setId(((Number) attr[0]).longValue());
					item.setDescription((String) attr[1]);
					item.setExpirationDate((java.util.Date) attr[2]);
					return item;
				}));
			// ...
		}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class TestItemStoredProcedure(dataSource: DataSource) : StoredProcedure() {

		init {
			// ...
			declareParameter(SqlOutParameter("item", OracleTypes.STRUCT, "ITEM_TYPE") { cs, colIndx, sqlType, typeName ->
				val struct = cs.getObject(colIndx) as STRUCT
				val attr = struct.getAttributes()
				TestItem((attr[0] as Long, attr[1] as String, attr[2] as Date)
			})
			// ...
		}
	}
----

您可以使用 `SqlTypeValue` 将Java对象(例如 `TestItem`) 的值传递给存储过程.  `SqlTypeValue` 接口有一个必须实现的单例方法(名为 `createTypeValue`) .  传入 active 连接,您可以使用它来创建特定于数据库的对象,
例如 `ArrayDescriptor` 实例或 `ArrayDescriptor` 实例.  以下示例创建 `StructDescriptor` 实例:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	final TestItem testItem = new TestItem(123L, "A test item",
			new SimpleDateFormat("yyyy-M-d").parse("2010-12-31"));

	SqlTypeValue value = new AbstractSqlTypeValue() {
		protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException {
			StructDescriptor itemDescriptor = new StructDescriptor(typeName, conn);
			Struct item = new STRUCT(itemDescriptor, conn,
			new Object[] {
				testItem.getId(),
				testItem.getDescription(),
				new java.sql.Date(testItem.getExpirationDate().getTime())
			});
			return item;
		}
	};
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val (id, description, expirationDate) = TestItem(123L, "A test item",
			SimpleDateFormat("yyyy-M-d").parse("2010-12-31"))

	val value = object : AbstractSqlTypeValue() {
		override fun createTypeValue(conn: Connection, sqlType: Int, typeName: String?): Any {
			val itemDescriptor = StructDescriptor(typeName, conn)
			return STRUCT(itemDescriptor, conn,
					arrayOf(id, description, java.sql.Date(expirationDate.time)))
		}
	}
----

您现在可以将此 `SqlTypeValue` 添加到为存储过程调用的 `execute` 方法的包含输入参数的 `Map`.

`SqlTypeValue` 的另一个用途是将值数组传递给Oracle存储过程.  在这种情况下,必须使用Oracle自己的内部 `ARRAY` 类,您可以使用 `SqlTypeValue` 创建Oracle `ARRAY` 的实例, 并使用Java `ARRAY` 中的值填充它,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	final Long[] ids = new Long[] {1L, 2L};

	SqlTypeValue value = new AbstractSqlTypeValue() {
		protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException {
			ArrayDescriptor arrayDescriptor = new ArrayDescriptor(typeName, conn);
			ARRAY idArray = new ARRAY(arrayDescriptor, conn, ids);
			return idArray;
		}
	};
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class TestItemStoredProcedure(dataSource: DataSource) : StoredProcedure() {

		init {
			val ids = arrayOf(1L, 2L)
			val value = object : AbstractSqlTypeValue() {
				override fun createTypeValue(conn: Connection, sqlType: Int, typeName: String?): Any {
					val arrayDescriptor = ArrayDescriptor(typeName, conn)
					return ARRAY(arrayDescriptor, conn, ids)
				}
			}
		}
	}
----



[[jdbc-embedded-database-support]]
=== 嵌入式数据库支持

`org.springframework.jdbc.datasource.embedded` 包提供对嵌入式Java数据库引擎的支持.  本机提供对http://www.hsqldb.org[HSQL],
https://www.h2database.com[H2], 和 https://db.apache.org/derby[Derby]的支持.  您还可以使用可扩展API来插入新的嵌入式数据库类型和 `DataSource` 实现.

[[jdbc-why-embedded-database]]
==== 为什么使用嵌入式数据库?

嵌入式数据库在项目的开发阶段非常有用,因为它具有轻量级特性.  优点包括易于配置,快速启动时间,可测试性以及在开发过程中快速发展SQL的能力.

[[jdbc-embedded-database-xml]]
==== 使用Spring XML创建嵌入式数据库

如果你在 `ApplicationContext` 中想暴露一个嵌入式数据库的实例作为bean,那么你可以在 `spring-jdbc` 命名空间中使用 `embedded-database` 标签.

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<jdbc:embedded-database id="dataSource" generate-name="true">
		<jdbc:script location="classpath:schema.sql"/>
		<jdbc:script location="classpath:test-data.sql"/>
	</jdbc:embedded-database>
----

上述配置创建一个嵌入式HSQL数据库,该数据库使用类路径根目录中的 `schema.sql` 和 `test-data.sql` 来填充数据.  此外,作为最佳实践,将为嵌入式数据库分配唯一生成的名称.  嵌入式数据库作为 `javax.sql.DataSource` 类型的bean可用于Spring容器,
然后可以根据需要将其注入数据访问对象.

[[jdbc-embedded-database-java]]
==== 以编程方式创建嵌入式数据库

`EmbeddedDatabaseBuilder` 类提供了一个流式的API,用于以编程方式构建嵌入式数据库.  当您需要在独立环境或独立集成测试中创建嵌入式数据库时,可以使用此方法,如以下示例所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	EmbeddedDatabase db = new EmbeddedDatabaseBuilder()
			.generateUniqueName(true)
			.setType(H2)
			.setScriptEncoding("UTF-8")
			.ignoreFailedDrops(true)
			.addScript("schema.sql")
			.addScripts("user_data.sql", "country_data.sql")
			.build();

	// perform actions against the db (EmbeddedDatabase extends javax.sql.DataSource)

	db.shutdown()
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	val db = EmbeddedDatabaseBuilder()
			.generateUniqueName(true)
			.setType(H2)
			.setScriptEncoding("UTF-8")
			.ignoreFailedDrops(true)
			.addScript("schema.sql")
			.addScripts("user_data.sql", "country_data.sql")
			.build()

	// perform actions against the db (EmbeddedDatabase extends javax.sql.DataSource)

	db.shutdown()
----

为了进一步了解其所支持的所有可选项,请参阅  {api-spring-framework}/jdbc/datasource/embedded/EmbeddedDatabaseBuilder.html[javadoc for `EmbeddedDatabaseBuilder`] Java文档

你也可以使用 `EmbeddedDatabaseBuilder` 通过Java配置创建一个嵌入式数据库,如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Configuration
	public class DataSourceConfig {

		@Bean
		public DataSource dataSource() {
			return new EmbeddedDatabaseBuilder()
					.generateUniqueName(true)
					.setType(H2)
					.setScriptEncoding("UTF-8")
					.ignoreFailedDrops(true)
					.addScript("schema.sql")
					.addScripts("user_data.sql", "country_data.sql")
					.build();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Configuration
	class DataSourceConfig {

		@Bean
		fun dataSource(): DataSource {
			return EmbeddedDatabaseBuilder()
					.generateUniqueName(true)
					.setType(H2)
					.setScriptEncoding("UTF-8")
					.ignoreFailedDrops(true)
					.addScript("schema.sql")
					.addScripts("user_data.sql", "country_data.sql")
					.build()
		}
	}
----


[[jdbc-embedded-database-types]]
==== 选择嵌入式数据库类型

本节介绍如何选择Spring支持的三个嵌入式数据库中的某一个. 它包括以下主题:

* <<jdbc-embedded-database-using-HSQL,使用HSQL>>
* <<jdbc-embedded-database-using-H2,使用H2>>
* <<jdbc-embedded-database-using-Derby,使用Derby>>

[[jdbc-embedded-database-using-HSQL]]
===== 使用HSQL

Spring支持HSQL 1.8.0及更高版本. 如果未明确指定类型,HSQL是默认的嵌入式数据库.  要显式指定HSQL,请将 `embedded-database` 标记的 `type` 属性设置为 `HSQL`.  如果使用构建器API,请使用 `EmbeddedDatabaseType.HSQL` 调用 `setType(EmbeddedDatabaseType)` 方法.

[[jdbc-embedded-database-using-H2]]
===== 使用 H2

Spring支持H2数据库. 要启用H2,请将 `embedded-database` 标记的 `type` 属性设置为 `H2`.  如果使用构建器API,请使用 `EmbeddedDatabaseType.H2` 调用 `setType(EmbeddedDatabaseType)` 方法.

[[jdbc-embedded-database-using-Derby]]
===== 使用 Derby

Spring支持Apache Derby 10.5及更高版本. 要启用Derby,请将 `embedded-database` 标记的 `type` 属性设置为 `DERBY`.  如果使用构建器API,请使用 `EmbeddedDatabaseType.DERBY` 调用 `setType(EmbeddedDatabaseType)` 方法.

[[jdbc-embedded-database-dao-testing]]
==== 使用嵌入式数据库测试数据访问逻辑

嵌入式数据库提供了一种轻量级的方法来测试数据访. 下一个示例是使用嵌入式数据库的数据访问集成测试模板.  当嵌入式数据库不需要跨测试类重用时,使用这样的模板可以用于一次性. 但是,如果您希望创建在测试套件中共享的嵌入式数据库,
请考虑使用 <<testing.adoc#testcontext-framework, Spring TestContext Framework>>并将嵌入式数据库配置为Spring `ApplicationContext` 中的bean, 在使用Spring <<jdbc-embedded-database-xml, XML创建嵌入式数据库>> 和 <<jdbc-embedded-database-java,编程方式创建嵌入式数据库>>.  以下清单显示了测试模板:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class DataAccessIntegrationTestTemplate {

		private EmbeddedDatabase db;

		@BeforeEach
		public void setUp() {
			// creates an HSQL in-memory database populated from default scripts
			// classpath:schema.sql and classpath:data.sql
			db = new EmbeddedDatabaseBuilder()
					.generateUniqueName(true)
					.addDefaultScripts()
					.build();
		}

		@Test
		public void testDataAccess() {
			JdbcTemplate template = new JdbcTemplate(db);
			template.query( /* ... */ );
		}

		@AfterEach
		public void tearDown() {
			db.shutdown();
		}

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class DataAccessIntegrationTestTemplate {

		private lateinit var db: EmbeddedDatabase

		@BeforeEach
		fun setUp() {
			// creates an HSQL in-memory database populated from default scripts
			// classpath:schema.sql and classpath:data.sql
			db = EmbeddedDatabaseBuilder()
					.generateUniqueName(true)
					.addDefaultScripts()
					.build()
		}

		@Test
		fun testDataAccess() {
			val template = JdbcTemplate(db)
			template.query( /* ... */)
		}

		@AfterEach
		fun tearDown() {
			db.shutdown()
		}
	}
----


[[jdbc-embedded-database-unique-names]]
==== 为嵌入式数据库生成唯一名称

如果测试套件无意中尝试重新创建同一数据库的其他实例,则开发团队经常会遇到嵌入式数据库的错误.  如果XML配置文件或 `@Configuration` 类负责创建嵌入式数据库,并且相应的配置随后在同一测试套件中的多个测试场景中重复使用(即在同一JVM进程中) , 那么这一错误很容易发生. 例如 ,针对嵌入式数据库的集成测试,其 `ApplicationContext` 配置仅与配置文件处于 active 状态的bean的定义有所不同.

导致此类错误的根本原因是,如果没有另外指定嵌入式数据库名称,Spring的 `EmbeddedDatabaseFactory` (由 `<jdbc:embedded-database>` XML命名空间元素和Java配置的 `EmbeddedDatabaseBuilder` 在内部使用) 将嵌入数据库的名称设置为 `testdb`.  对于 `<jdbc:embedded-database>` 的情况,通常会为嵌入式数据库分配一个等于bean的id的名称(通常类似于 `dataSource`) .  因此,随后尝试创建嵌入式数据库时不会产生新的数据库.  相反,重用相同的JDBC连接URL,并且试图创建新的嵌入式数据库实际上是指向从相同配置创建的现有嵌入式数据库.

为了解决这个常见问题,Spring Framework 4.2支持为嵌入式数据库生成唯一名称. 要启用生成的名称,请使用以下选项之一.

* `EmbeddedDatabaseFactory.setGenerateUniqueDatabaseName()`
* `EmbeddedDatabaseBuilder.generateUniqueName()`
* `<jdbc:embedded-database generate-name="true" ... >`


[[jdbc-embedded-database-extension]]
==== 扩展嵌入式数据库的支持

您可以通过两种方式扩展Spring JDBC嵌入式数据库支持:

* 实现 `EmbeddedDatabaseConfigurer` 以支持新的嵌入式数据库的类型.
* 实现 `DataSourceFactory` 以支持新的 `DataSource` 实现,例如用于管理嵌入式数据库连接的连接池.

我们鼓励您在 https://github.com/spring-projects/spring-framework/issues[GitHub Issues] 上为Spring社区贡献扩展.

[[jdbc-initializing-datasource]]
=== 初始化 `DataSource`

`org.springframework.jdbc.datasource.init` 包提供对初始化现有 `DataSource` 的支持.  嵌入式数据库支持提供了一个用于为应用程序创建和初始化 `DataSource` 的选项.  但是,您有时可能需要初始化在某个服务器上运行的实例.

[[jdbc-initializing-datasource-xml]]
==== 使用Spring XML初始化数据库

如果要初始化数据库并且提供对 `DataSource` bean的引用,可以在 `spring-jdbc` 命名空间中使用 `initialize-database` 标记:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<jdbc:initialize-database data-source="dataSource">
		<jdbc:script location="classpath:com/foo/sql/db-schema.sql"/>
		<jdbc:script location="classpath:com/foo/sql/db-test-data.sql"/>
	</jdbc:initialize-database>
----

上面的示例针对数据库运行两个指定的脚本. 第一个脚本创建一个模式,第二个脚本使用测试数据集填充表.  脚本位置也可以是带有通配符的模式,这些通配符用于Spring中的资源(例如 `classpath{asterisk}:/com/foo/{asterisk}{asterisk}/sql/{asterisk}-data.sql`) .  如果使用模式,脚本将按其URL或文件名的词法顺序运行.

数据库初始化程序的默认行为是无条件运行提供的脚本. 这可能并不总是您想要的 - 例如,如果您针对已经包含测试数据的数据库运行脚本.  首先通过创建表然后插入数据的公共模式(如前所示) ,减少了意外删除数据的可能性. 如果表已经存在,则第一步失败.

但是,为了更好地控制现有数据的创建和删除,XML命名空间提供了一些其他选项. 第一个是打开和关闭初始化的标志.  您可以根据环境设置它(例如从系统属性或环境bean中提取布尔值) .  以下示例从系统属性获取值:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<jdbc:initialize-database data-source="dataSource"
		enabled="#{systemProperties.INITIALIZE_DATABASE}"> <1>
		<jdbc:script location="..."/>
	</jdbc:initialize-database>
----
<1> Get the value for `enabled` from a system property called `INITIALIZE_DATABASE`.


控制现有数据发生情况的第二个选择是更容忍失败. 为此,您可以控制初始化程序忽略它从脚本执行的SQL中的某些错误的能力,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<jdbc:initialize-database data-source="dataSource" ignore-failures="DROPS">
		<jdbc:script location="..."/>
	</jdbc:initialize-database>
----

在前面的示例中,我们说我们希望脚本有时会针对空数据库运行,并且脚本中有一些 `DROP` 语句因此会失败.  因此失败的SQL `DROP` 语句将被忽略,但其他失败将导致异常. 如果您的SQL方言不支持 `DROP ... IF EXISTS` 或类似) ,
但您希望在重新创建之前无条件地删除所有测试数据,这将非常有用.  在这种情况下,第一个脚本通常是一组DROP语句,后跟一组 `CREATE` 语句.

ignore-`failures` 选项可以被设置为 `NONE`(默认值) 、`DROPS` (忽略删除失败) 或者ALL (忽略所有的失败) .

每条语句应该由 `;` 分隔,如果 `;` 字符根本不存在与脚本中,则每条语句应该新起一行.  你可以通过脚本控制全局或脚本,如下例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<jdbc:initialize-database data-source="dataSource" separator="@@"> <1>
		<jdbc:script location="classpath:com/myapp/sql/db-schema.sql" separator=";"/> <2>
		<jdbc:script location="classpath:com/myapp/sql/db-test-data-1.sql"/>
		<jdbc:script location="classpath:com/myapp/sql/db-test-data-2.sql"/>
	</jdbc:initialize-database>
----
<1> 将脚本分隔符设置为 `@@`.
<2> 将 `db-schema.sql` 的分隔符设置为 `;`.

在此示例中,两个 `test-data` 脚本使用 `@@` 作为语句分隔符,并且只有 `db-schema.sql` 使用 `;`.  此配置指定默认分隔符为 `@@` 并覆盖 `db-schema` 脚本的默认分隔符.

如果您需要比从XML命名空间获得的更多控制,则可以直接使用 `DataSourceInitializer` 并将其定义为应用程序中的组件.

[[jdbc-client-component-initialization]]
===== 初始化依赖于数据库的其他组件

应用程序大多数类(那些在Spring上下文启动之后才使用数据库的应用程序) 可以使用数据库初始化程序而不用进一步的复杂化初始数据库.  如果您的应用程序不是其中之一,则可能需要阅读本节的其余部分.

数据库初始化程序依赖于 `DataSource` 实例并运行其初始化回调中提供的脚本(类似于XML bean定义中的 `init-method`, 组件中的 `@PostConstruct` 方法或实现 `InitializingBean` 的组件中的 `afterPropertiesSet()` 方法) ) .
如果其他bean依赖于相同的数据源并在初始化回调中使用数据源,则可能存在问题,因为数据尚未初始化.  一个常见的例子是缓存,它在应用程序启动时急切地初始化并从数据库加载数据.

要解决此问题,您有两个选择: 将缓存初始化策略更改为稍后执行或确保首先初始化数据库初始化程序.

如果应用程序在您的控制范围内而不是其他方式,则更改缓存初始化策略可能很容易.  关于如何实现这一点的一些建议如下:

* 在首次使用时使缓存初始化懒加载,这可以缩短应用程序启动时间.
* 拥有缓存或初始化缓存的单独组件实现 `Lifecycle` 或 `SmartLifecycle`.  当应用程序上下文启动时,您可以通过设置其 `autoStartup` 标志自动启动 `SmartLifecycle`, 并且可以通过在封闭上下文中调用 `ConfigurableApplicationContext.start()` 来手动启动 `Lifecycle`.
* 使用Spring `ApplicationEvent` 或类似的自定义观察器机制来触发缓存初始化.  `ContextRefreshedEvent` 总是在上下文准备好使用时发布(在所有bean初始化之后) ,因此这通常是一个有用的钩子(这是 `SmartLifecycle` 默认工作的方式) .

确保首先初始化数据库初始化程序也很容易. 关于如何实现这一点的一些建议如下:

* 依赖于Spring `BeanFactory` 的默认行为,即bean按注册顺序初始化.  您可以通过采用XML配置中的一组 `<import/>` 元素的通用实践来轻松安排初始化顺序, 这些元素可以对应用程序模块进行排序,并确保首先列出数据库和数据库初始化.
* 将 `DataSource` 和使用它的业务组件分开并通过将它们放在单独的 `ApplicationContext` 实例中来控制它们的启动顺序 (例如,父上下文包含 `DataSource`,子上下文包含业务组件) .  这种结构在Spring Web应用程序中很常见,但可以更普遍地应用.

[[orm]]
== 对象关系映射(ORM) 数据访问

本节介绍使用对象关系映射(ORM) 时的数据访问.

[[orm-introduction]]
=== 介绍ORM与Spring

Spring Framework支持与Java Persistence API(JPA) 的集成,并支持本机Hibernate用于资源管理、数据访问对象(DAO) 实现和事务策略.  例如,对于Hibernate有一些一流的支持,它具有几个方便的IoC功能,可以解决许多典型的Hibernate集成问题.  您可以通过依赖注入为OR(对象关系) 映射工具配置所有支持的功能.  他们可以参与Spring的资源和事务管理,并且遵守Spring的通用事务和DAO异常层次结构.  推荐的集成方式是针对普通的Hibernate或JPA API编写DAO代码.

在创建数据访问应用程序时,Spring会为您选择的ORM层添加重要的增强功能.  您可以根据需要利用尽可能多的集成支持,并且您应该将此集成工作与内部构建类似基础架构的成本和风险进行比较.  您可以像使用库一样使用大部分ORM支持,无论技术如何,因为所有内容都设计为一组可重用的JavaBean.  Spring IoC容器中的ORM有助于配置和部署.  因此,本节中的大多数示例都显示了Spring容器内的配置.

使用Spring Framework创建ORM DAO的好处包括:

* *Easier testing.* Spring的IoC方法可以轻松交换Hibernate SessionFactory实例、 JDBC DataSource实例、事务管理器和映射对象实现(如果需要) 的实现和配置位置.  这反过来使得单独测试每个与持久性相关的代码变得更加容易.
* *Common data access exceptions.* Spring可以从ORM工具中包装异常,将它们从专有(可能已检查) 的异常转换为公共运行时的 `DataAccessException` 层次结构.  此功能允许您处理大多数不可恢复的持久性异常,仅在适当的层中处理,而不会产生令人讨厌的样板捕获、抛出和异常声明.  您仍然可以根据需要捕获和处理异常. 请记住,JDBC异常(包括特定于DB的方言) 也会转换为相同的层次结构, 这意味着您可以在相同的编程模型中使用JDBC执行某些操作.
* *General resource management.* Spring应用程序上下文可以处理Hibernate `SessionFactory` 实例、JPA `EntityManagerFactory` 实例、 JDBC `DataSource` 实例和其他相关资源的位置和配置. 这使得这些值易于管理和更改. Spring提供高效、简单和安全的持久化资源处理.  例如,使用Hibernate的相关代码通常需要使用相同的Hibernate `Session` 来确保效率和正确的事务处理.  Spring通过Hibernate `SessionFactory` 暴露当前 `Session`,可以轻松、透明地创建 `Session` 并将其绑定到当前线程.  因此,Spring解决了许多典型Hibernate使用的慢性问题,适用于任何本地或JTA事务环境.
* *Integrated transaction management.* 您可以通过 `@Transactional` 注解或通过在XML配置文件中显式配置事务AOP通知, 使用声明式的、面向切面编程(AOP) 样式的方法拦截器包装ORM代码. 在这两种情况下,都会为您处理事务语义和异常处理(回滚等) .  如<<orm-resource-mngmnt,资源和事务管理>>中所述,您还可以交换各种事务管理器,而不会影响与ORM相关的代码.  例如,例如,您可以在本地事务和JTA之间进行交换,并在两种方案中使用完全相同的 `services`(例如声明式事务) .  此外,与JDBC相关的代码可以与您用于执行ORM的代码进行完全事务集成. 这对数据访问和游泳但不适合ORM(例如批处理和BLOB流) , 但仍需要与ORM操作共享公共事务.

TIP: 	有关更全面的ORM支持,包括对MongoDB等替代数据库技术的支持,您可能需要查看项目的 https://projects.spring.io/spring-data/[Spring Data] .  如果您是JPA用户,则 https://spring.io/guides/gs/accessing-data-jpa/[Getting Started Accessing
Data with JPA] 上的入门使用JPA访问数据指南提供了很好的介绍.

[[orm-general]]
=== 通用ORM集成注意事项

本节重点介绍适用于所有ORM技术的注意事项.  <<orm-hibernate,Hibernate>> 部分提供了更多详细信息,并在具体上下文中显示了这些功能和配置.

Spring的ORM集成的主要目标是清晰的应用程序分层(使用任何数据访问和事务技术) 以及应用程序对象的松散耦合 - 不再需要对数据访问或事务策略的业务服务依赖性、不再需要硬编码的资源查找、更难以替换的单例、没有更多的定制服务注册表.  它的目标是使用一种简单而一致的方法来连接应用程序对象,使它们保持可重用性并尽可能避免容器依赖.  所有独立的数据访问功能都可以在它们自己的方法中使用,但与Spring的应用程序上下文概念有很好地集成, 提供基于XML的配置和不需要Spring感知的普通JavaBean实例的交叉引用.  在典型的Spring应用程序中,许多重要的对象是JavaBeans: 数据访问模板、数据访问对象、事务管理器、 使用数据访问对象和事务管理器的业务services、Web视图解析器、使用业务services的Web控制器等等.

[[orm-resource-mngmnt]]
==== 资源与事务管理器

典型的业务应用程序混杂着重复的资源管理代码. 许多项目试图发明自己的解决方案,有时为了方便编程而牺牲正确的故障处理.  Spring提出了适当资源处理的简单解决方案,即在JDBC的情况下通过模板化IoC并为ORM技术应用AOP拦截器.

基础结构提供适当的资源处理以及将特定API异常适当转换为未经检查的基础异常层次结构.  Spring引入了DAO异常层次结构,适用于任何数据访问策略.  对于直接JDBC,<<jdbc-JdbcTemplate, 上一节>>中提到的 `JdbcTemplate` 类提供了连接处理 和 `SQLException` 到 `DataAccessException` 层次结构的正确转换, 包括将特定于数据库的SQL错误代码转换为有意义的异常类.  对于ORM技术,请参阅<<orm-exception-translation, 下一节>>,了解如何获得相同的异常转换优势.

在事务管理方面,`JdbcTemplate` 类通过各自的Spring事务管理器挂钩Spring事务支持并支持JTA和JDBC事务.  对于支持的ORM技术,Spring通过 Hibernate 和JPA事务管理器以及JTA支持提供Hibernate和JPA支持.  有关事务支持的详细信息,请参阅<<transaction,事务管理一章>> .

[[orm-exception-translation]]
==== 转换异常

在DAO中使用Hibernate或JPA时,必须决定如何处理持久性技术的本机异常类.  DAO会抛出 `HibernateException` 或 `PersistenceException` 的子类,具体取决于技术. 这些异常都是运行时异常, 不必声明或捕获. 您可能还必须处理 `IllegalArgumentException` 和 `IllegalStateException`.
这意味着调用者通常只能将异常视为致命的,除非他们想要依赖持久性技术的异常结构.  如果不将调用者与实现策略联系起来,则无法捕获特定原因(例如乐观锁定失败) .  对于强烈基于ORM或不需要任何特殊异常处理(或两者) 的应用程序,这种权衡可能是可以接受的.
但是,Spring允许通过 `@Repository` 注解透明地应用异常转换.  以下示例(一个基于Java配置,一个基于XML配置) 显示如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	@Repository
	public class ProductDaoImpl implements ProductDao {

		// class body here...

	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	@Repository
	class ProductDaoImpl : ProductDao {
		// class body here...
	}
----

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>

		<!-- Exception translation bean post processor -->
		<bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/>

		<bean id="myProductDao" class="product.ProductDaoImpl"/>

	</beans>
----

后置处理器自动查找所有异常转换器(`PersistenceExceptionTranslator` 接口的实现) , 并建议标记所有 `@Repository` 注解的bean,以便发现的转换器可以拦截并对抛出的异常应用适当的转换.

总之,您可以基于普通持久性技术的API和注解实现DAO, 同时仍然可以从Spring管理的事务、依赖注入和Spring的自定义异常层次结构的透明异常转换(如果需要) 中受益.

[[orm-hibernate]]
=== Hibernate

我们首先在Spring环境中介绍 https://hibernate.org/[Hibernate 5] ,然后使用它来演示Spring对集成OR映射器的方法.  本节详细介绍了许多问题,并展示了DAO实现和事务划分的不同变体. 大多数这些模式可以直接转换为所有其他支持的ORM工具.  然后,本章后面的部分将介绍其他ORM技术并展示简要示例.

NOTE: 从 Spring Framework 5.0 开始,Spring 需要 Hibernate ORM 4.3 或更高版本来支持 JPA,甚至还需要 Hibernate ORM 5.0+ 来针对本地 Hibernate Session API 进行编程.  请注意,Hibernate 团队不再维护 5.1 之前的任何版本,很可能很快就会专注于 5.4+.


[[orm-session-factory-setup]]
==== 在Spring容器中设置 `SessionFactory`

为避免将应用程序对象绑定到硬编码资源查找,您可以将资源(例如JDBC `DataSource` 或Hibernate `SessionFactory`) 定义为Spring容器中的bean.  需要访问资源的应用程序对象通过bean引用接收对此类预定义实例的引用,如<<orm-hibernate-straight, 下一节>>中的DAO定义所示.

以下摘自XML应用程序上下文定义显示了如何在其上设置JDBC `DataSource` 和Hibernate `SessionFactory`:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>

		<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
			<property name="driverClassName" value="org.hsqldb.jdbcDriver"/>
			<property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/>
			<property name="username" value="sa"/>
			<property name="password" value=""/>
		</bean>

		<bean id="mySessionFactory" class="org.springframework.orm.hibernate5.LocalSessionFactoryBean">
			<property name="dataSource" ref="myDataSource"/>
			<property name="mappingResources">
				<list>
					<value>product.hbm.xml</value>
				</list>
			</property>
			<property name="hibernateProperties">
				<value>
					hibernate.dialect=org.hibernate.dialect.HSQLDialect
				</value>
			</property>
		</bean>

	</beans>
----

从本地Jakarta Commons DBCP `BasicDataSource` 切换到位于JNDI的 `DataSource`(通常由应用程序服务器管理) 只是配置问题,如下例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<jee:jndi-lookup id="myDataSource" jndi-name="java:comp/env/jdbc/myds"/>
	</beans>
----

您还可以使用Spring的 `JndiObjectFactoryBean` 或 `<jee:jndi-lookup>` 来访问位于JNDI的 `SessionFactory`,以检索并暴露它.  但是,这通常在EJB上下文之外并不常见.

[NOTE]
====
Spring还提供了 `LocalSessionFactoryBuilder` 变体,与 `@Bean` 样式配置和程序设置无缝集成(不涉及 `FactoryBean`) .

`LocalSessionFactoryBean` 和 `LocalSessionFactoryBuilder` 都支持后台引导, Hibernate初始化与给定引导执行程序(例如 `SimpleAsyncTaskExecutor`) 上的应用程序引导线程并行运行.  在 `LocalSessionFactoryBean` 上,可以通过 `bootstrapExecutor` 属性获得引导程序.
在编程式的 `LocalSessionFactoryBuilder` 上,有一个重载的 `buildSessionFactory` 方法,它接受一个 bootstrap executor参数.

从Spring Framework 5.1开始,这样的本地Hibernate设置还可以在本地Hibernate访问时暴露JPA `EntityManagerFactory` 以进行标准JPA交互.  有关详细信息,请参阅<<orm-jpa-hibernate, JPA的本地Hibernate设置>>.
====


[[orm-hibernate-straight]]
==== 基于普通的Hibernate API实现DAO

Hibernate有一个称为上下文会话的功能,其中Hibernate本身管理每个事务的一个当前 `Session`.  这大致相当于Spring每次事务同步一个Hibernate `Session`. 相应的DAO实现类似于以下示例,它是基于普通的Hibernate API:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ProductDaoImpl implements ProductDao {

		private SessionFactory sessionFactory;

		public void setSessionFactory(SessionFactory sessionFactory) {
			this.sessionFactory = sessionFactory;
		}

		public Collection loadProductsByCategory(String category) {
			return this.sessionFactory.getCurrentSession()
					.createQuery("from test.Product product where product.category=?")
					.setParameter(0, category)
					.list();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ProductDaoImpl(private val sessionFactory: SessionFactory) : ProductDao {
		
		fun loadProductsByCategory(category: String): Collection<*> {
			return sessionFactory.currentSession
					.createQuery("from test.Product product where product.category=?")
					.setParameter(0, category)
					.list()
		}
	}
----

除了将 `SessionFactory` 保存在实例变量中之外,此样式类似于Hibernate参考文档和示例的样式.  我们强烈建议在Hibernate的 CaveatEmptor 示例应用程序中使用老式 `static` `HibernateUtil` 类进行基于实例的设置.
(一般情况下,除非绝对必要,否则不要将任何资源保留在 `static` 变量中. )

前面的DAO示例遵循依赖注入模式. 它非常适合Spring IoC容器,就像在Spring的 `HibernateTemplate` 中编码一样.  您还可以在普通Java中设置这样的DAO(例如,在单元测试中) .  为此,请实例化它并使用所需的工厂引用调用 `setSessionFactory(..)`.
作为Spring bean定义,DAO将类似于以下内容:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>

		<bean id="myProductDao" class="product.ProductDaoImpl">
			<property name="sessionFactory" ref="mySessionFactory"/>
		</bean>

	</beans>
----

这种DAO风格的主要优点是它仅依赖于Hibernate API. 不需要导入任何Spring类. 这从非侵入性的角度来看很吸引人,并且可能对Hibernate开发人员来说更自然.

但是,DAO抛出普通的 `HibernateException`(未经检查,因此不必声明或捕获) , 这意味着调用者通常只能将异常视为致命的,除非他们想要依赖Hibernate自己的异常层次结构.  如果不将调用者与实现策略联系起来,则无法捕获特定原因(例如乐观锁定失败) .  对于基于Hibernate的强大应用程序,不需要任何特殊异常处理或两者兼而有之,这种权衡可能是可以接受的.

幸运的是,Spring的 `LocalSessionFactoryBean` 支持任何Spring事务策略的Hibernate的 `SessionFactory.getCurrentSession()` 方法, 返回当前Spring管理的事务 `Session`,即使使用 `HibernateTransactionManager` 也是如此.  该方法的标准行为仍然是返回与正在进行的JTA事务关联的当前 `Session`(如果有) .  无论您使用的是Spring的 `JtaTransactionManager`、EJB容器管理事务(CMT) 还是JTA,此行为都适用.

总之,您可以基于普通的Hibernate API实现DAO,同时仍然可以参与Spring管理的事务.

[[orm-hibernate-tx-declarative]]
==== 声明式事务划分

我们建议您使用Spring的声明式事务支持,它允许您使用AOP事务拦截器替换Java代码中的显式事务划分API的调用.  您可以使用Java注解或XML在Spring容器中配置此事务拦截器.  这种声明式事务功能使您可以保持业务服务不受重复的事务划分代码的影响,并专注于添加业务逻辑,这是您的应用程序的真正价值.

NOTE: 	在继续之前,我们强烈建议您阅读 <<transaction-declarative,声名式事务管理>>(如果尚未这样做) .

您可以使用 `@Transactional` 注解来注解服务层,并指示Spring容器查找这些注解并为这些带注解的方法提供事务语义.  以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ProductServiceImpl implements ProductService {

		private ProductDao productDao;

		public void setProductDao(ProductDao productDao) {
			this.productDao = productDao;
		}

		@Transactional
		public void increasePriceOfAllProductsInCategory(final String category) {
			List productsToChange = this.productDao.loadProductsByCategory(category);
			// ...
		}

		@Transactional(readOnly = true)
		public List<Product> findAllProducts() {
			return this.productDao.findAllProducts();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ProductServiceImpl(private val productDao: ProductDao) : ProductService {

		@Transactional
		fun increasePriceOfAllProductsInCategory(category: String) {
			val productsToChange = productDao.loadProductsByCategory(category)
			// ...
		}

		@Transactional(readOnly = true)
		fun findAllProducts() = productDao.findAllProducts()
	}
----

在容器中,您需要设置 `PlatformTransactionManager` 实现(作为bean) 和 `<tx:annotation-driven/>` 条目,在运行时选择 `@Transactional` 处理.  以下示例显示了如何执行此操作:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:aop="http://www.springframework.org/schema/aop"
		xmlns:tx="http://www.springframework.org/schema/tx"
		xsi:schemaLocation="
			http://www.springframework.org/schema/beans
			https://www.springframework.org/schema/beans/spring-beans.xsd
			http://www.springframework.org/schema/tx
			https://www.springframework.org/schema/tx/spring-tx.xsd
			http://www.springframework.org/schema/aop
			https://www.springframework.org/schema/aop/spring-aop.xsd">

		<!-- SessionFactory, DataSource, etc. omitted -->

		<bean id="transactionManager"
				class="org.springframework.orm.hibernate5.HibernateTransactionManager">
			<property name="sessionFactory" ref="sessionFactory"/>
		</bean>

		<tx:annotation-driven/>

		<bean id="myProductService" class="product.SimpleProductService">
			<property name="productDao" ref="myProductDao"/>
		</bean>

	</beans>
----


[[orm-hibernate-tx-programmatic]]
==== 编程式事务划分

除了跨越任意数量操作的低级数据访问服务之外,您还可以在更高级别的应用程序中划分事务.  对周围业务服务的实现也没有限制. 它只需要一个Spring `PlatformTransactionManager`.  同样,后者可以来自任何地方,但最好通过 `setTransactionManager(..)` 方法作为bean引用.
此外,`productDAO应该由setProductDao(..)` 方法设置.  以下一对片段在Spring应用程序上下文中显示事务管理器和业务服务定义,以及业务方法实现的示例:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>

		<bean id="myTxManager" class="org.springframework.orm.hibernate5.HibernateTransactionManager">
			<property name="sessionFactory" ref="mySessionFactory"/>
		</bean>

		<bean id="myProductService" class="product.ProductServiceImpl">
			<property name="transactionManager" ref="myTxManager"/>
			<property name="productDao" ref="myProductDao"/>
		</bean>

	</beans>
----

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ProductServiceImpl implements ProductService {

		private TransactionTemplate transactionTemplate;
		private ProductDao productDao;

		public void setTransactionManager(PlatformTransactionManager transactionManager) {
			this.transactionTemplate = new TransactionTemplate(transactionManager);
		}

		public void setProductDao(ProductDao productDao) {
			this.productDao = productDao;
		}

		public void increasePriceOfAllProductsInCategory(final String category) {
			this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {
				public void doInTransactionWithoutResult(TransactionStatus status) {
					List productsToChange = this.productDao.loadProductsByCategory(category);
					// do the price increase...
				}
			});
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ProductServiceImpl(transactionManager: PlatformTransactionManager,
							private val productDao: ProductDao) : ProductService {
		
		private val transactionTemplate = TransactionTemplate(transactionManager)

		fun increasePriceOfAllProductsInCategory(category: String) {
			transactionTemplate.execute {
				val productsToChange = productDao.loadProductsByCategory(category)
				// do the price increase...
			}
		}
	}
----

Spring的 `TransactionInterceptor` 允许使用回调代码抛出任何已检查的应用程序异常,而 `TransactionTemplate` 仅限于回调中未经检查的异常.  如果未经检查的应用程序异常或者事务被应用程序标记为仅回滚(通过设置 `TransactionStatus`) ,`TransactionTemplate` 将触发回滚.
默认情况下,`TransactionInterceptor` 的行为方式相同,但每个方法允许可配置的回滚策略.

[[orm-hibernate-tx-strategies]]
==== 事务管理策略

`TransactionTemplate` 和 `TransactionInterceptor` 都将实际的事务处理委托给一个 `PlatformTransactionManager` 实例 (可以是一个 `HibernateTransactionManager`(用于单个Hibernate `SessionFactory`) ,
通过使用引擎下的 `ThreadLocal` `Session`)  或者一个 `JtaTransactionManager`(委托给容器的JTA子系统) 来实现Hibernate应用.  您甚至可以使用自定义的 `PlatformTransactionManager` 实现.
从本机Hibernate事务管理切换到JTA(例如,当应用程序的某些部署时面临分布式事务要求) 只是配置问题. 您可以使用Spring的JTA事务实现替换Hibernate事务管理器.  事务划分和数据访问代码都可以无变化地工作,因为它们使用通用事务管理APIs.

对于跨多个Hibernate会话工厂的分布式事务,您可以将 `JtaTransactionManager` 作为事务策略与多个 `LocalSessionFactoryBean` 定义相结合.  然后,每个DAO都会将一个特定的 `SessionFactory` 引用传递到其相应的bean属性中.
如果所有基础JDBC数据源都是事务性容器, 则业务服务可以跨越任意数量的DAO和任意数量的会话工厂划分事务,而无需特别考虑,只要它使用JtaTransactionManager作为策略.

`HibernateTransactionManager` 和 `JtaTransactionManager` 都允许使用Hibernate进行正确的JVM级缓存处理, 无需特定于容器的事务管理器查找或JCA连接器(如果不使用EJB来启动事务) .

`HibernateTransactionManager` 可以将Hibernate JDBC Connection导出为特定 `DataSource` 的普通JDBC访问代码.  如果您只访问一个数据库,则此功能允许在没有JTA的情况下完全混合Hibernate和JDBC数据访问的高级事务划分.
如果您通过 `LocalSessionFactoryBean` 类的 `dataSource` 属性设置了传入的 `SessionFactory` 和 `DataSource`, `HibernateTransactionManager` 会自动将Hibernate事务暴露为JDBC事务.
或者,您可以通过 `HibernateTransactionManager` 类的 `dataSource` 属性显式指定应该为其暴露事务的 `DataSource`.

[[orm-hibernate-resources]]
==== 比较容器管理和本地定义的资源

您可以在容器管理的JNDI `SessionFactory` 和本地定义的JNDI `SessionFactory` 之间切换,而无需更改单行应用程序代码.  是将资源定义保留在容器中还是本地保存在应用程序中主要取决于您使用的事务策略.
与Spring定义的本地 `SessionFactory` 相比,手动注册的JNDI `SessionFactory` 不提供任何好处.  通过Hibernate的JCA连接器部署 `SessionFactory` 提供了参与Java EE服务器管理基础结构的附加价值,但不会增加实际价值.

Spring的事务支持不限于容器. 使用除JTA之外的任何策略进行配置时,事务支持也可以在独立或测试环境中运行.  特别是在单数据库事务的典型情况下,Spring的单资源本地事务支持是JTA的轻量级和强大的替代方案.
当您使用本地EJB无状态会话bean来驱动事务时,您既依赖于EJB容器又依赖于JTA,即使您只访问单个数据库并且仅使用无状态会话bean来通过容器管理的事务提供声明式事务.  以编程方式直接使用JTA还需要Java EE环境.
JTA不仅包含对JTA本身的容器依赖性,还有对JNDI `DataSource` 实例的依赖性.  对于非Spring,JTA驱动的Hibernate事务,您必须使用Hibernate JCA连接器或额外的Hibernate事务代码,并将 `TransactionManagerLookup` 配置为正确的JVM级缓存.

Spring驱动的事务也可以与本地定义的Hibernate `SessionFactory` 一样工作,就像它们使用本地JDBC `DataSource` 一样, 前提是它们访问单个数据库. 因此,当您具有分布式事务要求时,只需使用Spring的JTA事务策略.
JCA连接器需要特定于容器的部署步骤,并且首先需要JCA支持. 与使用本地资源定义和Spring驱动的事务部署简单Web应用程序相比,此配置需要更多工作.  此外,如果您使用的是不提供JCA的 WebLogic Express,则通常需要容器的Enterprise Edition.
具有跨越单个数据库的本地资源和事务的Spring应用程序可在任何Java EE Web容器(无JTA,JCA或EJB) 中工作,例如Tomcat,Resin甚至普通Jetty.  此外,您可以轻松地在桌面应用程序或测试套件中重用这样的中间层.

考虑到所有事情,如果您不使用EJB,请坚持使用本地 `SessionFactory` 设置和Spring的 `HibernateTransactionManager` 或 `JtaTransactionManager`.  您可以获得所有好处,包括正确的事务性JVM级缓存和分布式事务,而不会给容器部署带来不便.
只有在与EJB结合使用时才会添加值,以通过JCA连接器对Hibernate `SessionFactory` 进行JNDI注册.

[[orm-hibernate-invalid-jdbc-access-error]]
==== Hibernate的虚假应用程序服务器警告

在一些具有非常严格的 `XADataSource` 实现的 JTA 环境中(当前只有一些 WebLogic Server 和 WebSphere 版本) , 当配置 Hibernate 而不考虑该环境的 JTA 事务管理时,虚假警告或异常可以显示在应用程序服务器日志中.  这些警告或异常表明正在访问的连接不再有效或JDBC访问不再有效,可能是因为事务不再处于 active 状态.  例如,以下是WebLogic的实际异常:

[literal]
[subs="verbatim,quotes"]
----
java.sql.SQLException: The transaction is no longer active - status: 'Committed'. No
further JDBC access is allowed within this transaction.
----

Another common problem is a connection leak after JTA transactions, with Hibernate
sessions (and potentially underlying JDBC connections) not getting closed properly.

您可以通过让 Hibernate 知道它同步的 JTA `PlatformTransactionManager` 实例(以及Spring) 来解决此警告. 您有两种选择:

You can resolve such issues by making Hibernate aware of the JTA transaction manager,
to which it synchronizes (along with Spring). You have two options for doing this:

* Pass your Spring `JtaTransactionManager` bean to your Hibernate setup. The easiest
way is a bean reference into the `jtaTransactionManager` property for your
`LocalSessionFactoryBean` bean (see <<transaction-strategies-hibernate>>).
Spring then makes the corresponding JTA strategies available to Hibernate.
* You may also configure Hibernate's JTA-related properties explicitly, in particular
"hibernate.transaction.coordinator_class", "hibernate.connection.handling_mode"
and potentially "hibernate.transaction.jta.platform" in your "hibernateProperties"
on `LocalSessionFactoryBean` (see Hibernate's manual for details on those properties).

The remainder of this section describes the sequence of events that occur with and
without Hibernate's awareness of the JTA `PlatformTransactionManager`.

When Hibernate is not configured with any awareness of the JTA transaction manager,
the following events occur when a JTA transaction commits:

* 如果在您的应用程序上下文中,您已经直接获取 JTA `PlatformTransactionManager` 对象(可能是从JNDI到 `JndiObjectFactoryBean` 或 `<jee:jndi-lookup>`)  并将其提供给Spring的 `JtaTransactionManager`,最简单的方法是指定对定义此JTA `PlatformTransactionManager` 实例的bean, 作为 `LocalSessionFactoryBean` 的 `jtaTransactionManager` 属性的值.  Spring然后使该对象可用于Hibernate.
* 更有可能的是,您还没有JTA `PlatformTransactionManager` 实例,因为Spring的 `JtaTransactionManager` 可以自己找到它.  因此,您需要配置Hibernate以直接查找 JTA `PlatformTransactionManager`.  您可以通过在Hibernate配置中配置特定于应用程序服务器的 `TransactionManagerLookup` 类来完成此操作,如Hibernate手册中所述.

当 Hibernate 配置为不知道JTA 事务管理 时,JTA事务提交时会发生以下事件:

* JTA事务提交.
* Spring的 `JtaTransactionManager` 与JTA事务同步,因此JTA事务管理器通过 `afterCompletion` 回调调用它.
* 在其他 active 中,这种同步可以触发 Spring 对 Hibernate 的回调,通过 Hibernate 的 `afterTransactionCompletion` 方法回调(用于清除 Hibernate 缓存) , 然后在 Hibernate 会话上进行显式的 `close()` 调用,这会导致 Hibernate 尝试调用 `close()` 关闭 JDBC 连接.
* 在某些环境中,此 `Connection.close()` 调用会触发警告或错误,因为应用程序服务器不再认为 `Connection` 可用,因为事务已经提交.

当 Hibernate 配置为知道 JTA 事务管理 时,JTA 事务提交时会发生以下事件:

* JTA事务已准备好提交.
* Spring的 `JtaTransactionManager` 与JTA事务同步,因此JTA事务管理器通过 `beforeCompletion` 回调方法调用该事务.
* Spring知道Hibernate本身与JTA事务同步,其行为与前一个场景不同. 特别是它与 Hibernate 的事务性资源管理。
* JTA事务提交.
* Hibernate与JTA事务同步,因此事务由JTA事务管理器通过 `afterCompletion` 回调调用,并可以正确清除其缓存.

[[orm-jpa]]
=== JPA

Spring JPA在 `org.springframework.orm.jpa` 包下提供,以类似于与Hibernate集成的方式提供对 https://www.oracle.com/technetwork/articles/javaee/jpa-137156.html[Java持久化API] 的全面支持,同时了解底层实现以提供其他功能.

[[orm-jpa-setup]]
==== Spring环境中JPA设置的三个选项

Spring JPA支持提供了三种设置JPA `EntityManagerFactory` 的方法,该方法由应用程序用于获取实体管理器.

* <<orm-jpa-setup-lemfb,使用 `LocalEntityManagerFactoryBean`>>
* <<orm-jpa-setup-jndi,从JNDI获取 `EntityManagerFactory`>>
* <<orm-jpa-setup-lcemfb,使用 `LocalContainerEntityManagerFactoryBean`>>

[[orm-jpa-setup-lemfb]]
===== 使用 `LocalEntityManagerFactoryBean`

您只能在简单的部署环境中使用此选项,例如独立应用程序和集成测试.

`LocalEntityManagerFactoryBean` 创建一个适用于简单部署环境的 `EntityManagerFactory`, 其中应用程序仅使用JPA进行数据访问. 工厂bean使用JPA `PersistenceProvider` 自动检测机制(根据JPA的Java SE引导) , 并且在大多数情况下,要求您仅指定持久性单元名称. 以下XML示例配置了这样一个bean:


[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="myEmf" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean">
			<property name="persistenceUnitName" value="myPersistenceUnit"/>
		</bean>
	</beans>
----

这种形式的JPA部署是最简单和最受限的. 您不能引用现有的JDBC `DataSource` bean定义,也不存在对全局事务的支持.  此外,持久化类的织入(字节码转换) 是特定于提供者的,通常需要在启动时指定特定的JVM代理.  此选项仅适用于为其设计JPA规范的独立应用程序和测试环境.

[[orm-jpa-setup-jndi]]
===== 从JNDI获取EntityManagerFactory

部署到Java EE服务器时,可以使用此选项.  检查服务器的文档,了解如何将自定义JPA提供程序部署到服务器中,从而允许使用与服务器默认提供程序不同的提供程序.

从JNDI获取 `EntityManagerFactory`(例如在Java EE环境中) ,需要更改XML配置,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<jee:jndi-lookup id="myEmf" jndi-name="persistence/myPersistenceUnit"/>
	</beans>
----

此操作假定标准Java EE引导. Java EE服务器自动检测Java EE部署描述符中的持久性单元 (实际上是应用程序jar中的 `META-INF/persistence.xml` 文件) 和 `persistence-unit-ref` 条目 (例如,`web.xml`) 并定义这些持久性单元命名的上下文位置环境.

在这种情况下,整个持久化单元的部署,包括持久化类的织入(字节码转换) ,都是由Java EE服务器决定.  JDBC `DataSource` 是通过 `META-INF/persistence.xml` 文件中的JNDI位置定义的. `EntityManager` 事务与服务器的JTA子系统集成在一起.  Spring仅使用获取的 `EntityManagerFactory`,通过依赖注入将其传递给应用程序对象,并管理持久化单元的事务(通常通过 `JtaTransactionManager`) .

如果在同一个应用程序中使用多个持久性单元, 则此类JNDI检索的持久化单元的bean名称应与应用程序用于引用它们的持久化单元名称匹配 (例如,在 `@PersistenceUnit` 和 `@PersistenceContext` 注解中) .

[[orm-jpa-setup-lcemfb]]
===== 使用 `LocalContainerEntityManagerFactoryBean`

您可以在基于Spring的应用程序环境中将此选项用于完整的JPA功能.  这包括Web容器,如Tomcat、独立应用程序以及具有复杂持久性要求的集成测试.

NOTE:
如果你想专门配置一个 Hibernate 设置,一个直接的选择是使用 Hibernate 5.2/5.3/5.4  并设置一个本机 Hibernate `LocalSessionFactoryBean` 而不是一个普通的JPA `LocalContainerEntityManagerFactoryBean`, 让它与JPA访问代码以及本地 Hibernate 访问代码交互.  有关详细信息,请参阅<<orm-jpa-hibernate,本地JPAHibernate设置>>.

`LocalContainerEntityManagerFactoryBean` 完全控制 `EntityManagerFactory` 配置,适用于需要细粒度自定义的环境.  `LocalContainerEntityManagerFactoryBean` 基于 `persistence.xml` 文件, 提供的 `dataSourceLookup` 策略和指定的 `loadTimeWeaver` 创建 `PersistenceUnitInfo` 实例.
因此,可以使用JNDI之外的自定义数据源并控制织入过程.  以下示例显示了 `LocalContainerEntityManagerFactoryBean` 的典型bean定义:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="myEmf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
			<property name="dataSource" ref="someDataSource"/>
			<property name="loadTimeWeaver">
				<bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/>
			</property>
		</bean>
	</beans>
----

以下示例显示了典型的 `persistence.xml` 文件:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0">
		<persistence-unit name="myUnit" transaction-type="RESOURCE_LOCAL">
			<mapping-file>META-INF/orm.xml</mapping-file>
			<exclude-unlisted-classes/>
		</persistence-unit>
	</persistence>
----

NOTE: `<exclude-unlisted-classes/>` 快捷方式表示不应扫描带注解的实体类.  显式的 `true` 值(`<exclude-unlisted-classes>true</exclude-unlisted-classes/>`) 也意味着没有扫描.
`<exclude-unlisted-classes>false</exclude-unlisted-classes/>` 会触发扫描.  但是,如果要进行实体类扫描,我们建议省略 `exclude-unlisted-classes` 元素.

使用 `LocalContainerEntityManagerFactoryBean` 是最强大的JPA设置选项,允许在应用程序中进行灵活的本地配置.  它支持指向现有JDBC `DataSource` 的链接,支持本地和全局事务等.  但是,它还对运行时环境施加了要求,例如,如果持久化提供程序需要字节码转换,则可以使用具有编织功能的类加载器.

此选项可能与Java EE服务器的内置JPA功能冲突. 在完整的Java EE环境中,请考虑从JNDI获取 `EntityManagerFactory`.  或者,在 `LocalContainerEntityManagerFactoryBean` 定义上指定自定义 `persistenceXmlLocation`(例如,`META-INF/persistence.xml`) ,
并在应用程序jar文件中仅包含具有该名称的描述符. 由于Java EE服务器仅查找默认的 `META-INF/persistence.xml` 文件, 因此它会忽略此类自定义持久化单元,因此可以避免与Spring驱动的JPA设置发生冲突. (例如,这适用于Resin 3.1. )

.何时需要加载时织入?
****
并非所有JPA提供程序都需要JVM代理.  Hibernate就是一个没有的例子.  如果您的提供程序不需要代理或您有其他替代方法,例如通过自定义编译器或Ant任务在构建时应用增强功能,则不应使用加载时编织器.
****

`LoadTimeWeaver` 接口是Spring提供的类,它允许以特定方式插入JPA `ClassTransformer` 实例,具体取决于环境是Web容器还是应用程序服务器.  通过 https://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html[agent] 挂钩 `ClassTransformer` 通常效率不高.  代理程序可以对整个虚拟机进行操作,并检查所加载的每个类,这在生产服务器环境中通常是不受欢迎的.

Spring为各种环境提供了许多 `LoadTimeWeaver` 实现,允许 `ClassTransformer` 实例仅应用于每个类加载器而不是每个VM.

有关 `LoadTimeWeave` r实现及其设置的更多信息,请参阅AOP章节中的<<core.adoc#aop-aj-ltw-spring, Spring配置>> , 这些实现可以是通用的,也可以是针对各种平台(例如Tomcat,WebLogic,GlassFish,Resin和JBoss) 定制的.

如<<core.adoc#aop-aj-ltw-spring, Spring配置>>中所述,您可以使用 `context:load-time-weaver` XML元素的 `@EnableLoadTimeWeaving` 注解配置上下文范围的 `LoadTimeWeaver`.  所有JPA `LocalContainerEntityManagerFactoryBean` 实例都会自动选择这样的全局编织器.  以下示例显示了设置加载时织入器的首选方法,提供对平台(WebLogic,GlassFish,Tomcat,Resin,JBoss或VM代理) 的自动检测以及将织入器自动传播到所有 `weaver-aware` bean:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<context:load-time-weaver/>
	<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		...
	</bean>
----

但是,如果需要,您可以通过 `loadTimeWeaver` 属性手动指定专用的weaver,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		<property name="loadTimeWeaver">
			<bean class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/>
		</property>
	</bean>
----

无论如何配置LTW,通过使用此技术,依赖于检测的JPA应用程序可以在目标平台(例如,Tomcat) 中运行,而无需代理.  当托管应用程序依赖于不同的JPA实现时,这一点尤为重要,因为JPA转换器仅应用于类加载器级别,因此彼此隔离.

[[orm-jpa-setup-multiple]]
===== 处理多个持久化单元

对于依赖于多个持久性单元位置的应用程序(例如,存储在类路径中的各种JARS中) , Spring提供 `PersistenceUnitManager` 作为中央存储库并避免持久化单元发现过程,这可能很昂贵.  默认实现允许指定多个位置. 解析这些位置,然后通过持久化单元名称检索这些位置.  (默认情况下,会在类路径中搜索 `META-INF/persistence.xml` 文件. ) 以下示例配置多个位置:

[source,xml,indent=0,subs="verbatim"]
----
	<bean id="pum" class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager">
		<property name="persistenceXmlLocations">
			<list>
				<value>org/springframework/orm/jpa/domain/persistence-multi.xml</value>
				<value>classpath:/my/package/**/custom-persistence.xml</value>
				<value>classpath*:META-INF/persistence.xml</value>
			</list>
		</property>
		<property name="dataSources">
			<map>
				<entry key="localDataSource" value-ref="local-db"/>
				<entry key="remoteDataSource" value-ref="remote-db"/>
			</map>
		</property>
		<!-- if no datasource is specified, use this one -->
		<property name="defaultDataSource" ref="remoteDataSource"/>
	</bean>

	<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		<property name="persistenceUnitManager" ref="pum"/>
		<property name="persistenceUnitName" value="myCustomUnit"/>
	</bean>
----

默认实现允许自定义 `PersistenceUnitInfo` 实例(在它们被提供给JPA提供者之前) ,以声明方式(通过其属性,影响所有托管单元)  或以编程方式(通过 `PersistenceUnitPostProcessor`,允许持久化单元选择) 进行定义.
如果未指定 `PersistenceUnitManager`,则由 `LocalContainerEntityManagerFactoryBean` 在内部创建并使用一个 `PersistenceUnitInfo` 实例.

[[orm-jpa-setup-background]]
===== 后台引导

`LocalContainerEntityManagerFactoryBean` 通过 `bootstrapExecutor` 属性支持后台引导,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
		<property name="bootstrapExecutor">
			<bean class="org.springframework.core.task.SimpleAsyncTaskExecutor"/>
		</property>
	</bean>
----

实际的JPA提供程序引导传递给指定的执行程序,然后并行运行到应用程序引导程序线程.  暴露的 `EntityManagerFactory` 代理可以注入其他应用程序组件,甚至能够响应 `EntityManagerFactoryInfo` 配置检查.
但是,一旦其他组件访问了实际的 JPA 提供程序(例如,调用 `createEntityManager`) ,这些调用将阻塞,直到后台引导完成.  特别是,当您使用 Spring Data JPA 时,请确保为其存储库设置延迟引导.

[[orm-jpa-dao]]
==== 基于 JPA 实现 DAO: `EntityManagerFactory` 和 `EntityManager`

NOTE:
虽然 `EntityManagerFactory` 实例是线程安全的,但 `EntityManager` 实例不是安全的.  注入的JPA `EntityManager` 的行为类似于从应用程序服务器的JNDI环境获取的 `EntityManager`,正如JPA规范所定义.  它将所有的调用委托给当前事务式的 `EntityManager`(如果有) . 否则,它会回退到每个操作新创建的 `EntityManager`,实际上使其使用线程安全.

通过使用注入的 `EntityManagerFactory` 或 `EntityManager`,可以在没有任何 Spring 依赖性的情况下针对普通 JPA 编写代码.  如果启用了 `PersistenceAnnotationBeanPostProcessor`,Spring可以在字段和方法级别理解 `@PersistenceUnit` 和 `@PersistenceContext` 注解.  以下示例显示了使用 `@PersistenceUnit` 注解的普通JPA DAO实现:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ProductDaoImpl implements ProductDao {

		private EntityManagerFactory emf;

		@PersistenceUnit
		public void setEntityManagerFactory(EntityManagerFactory emf) {
			this.emf = emf;
		}

		public Collection loadProductsByCategory(String category) {
			try (EntityManager em = this.emf.createEntityManager()) {
				Query query = em.createQuery("from Product as p where p.category = ?1");
				query.setParameter(1, category);
				return query.getResultList();
			}
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ProductDaoImpl : ProductDao {

		private lateinit var emf: EntityManagerFactory

		@PersistenceUnit
		fun setEntityManagerFactory(emf: EntityManagerFactory) {
			this.emf = emf
		}

		fun loadProductsByCategory(category: String): Collection<*> {
			val em = this.emf.createEntityManager()
			val query = em.createQuery("from Product as p where p.category = ?1");
			query.setParameter(1, category);
			return query.resultList;
		}
	}
----

前面的DAO不依赖于Spring,仍然适合Spring应用程序上下文. 此外,DAO利用注解来要求注入默认的 `EntityManagerFactory`,如下面的示例bean定义所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>

		<!-- bean post-processor for JPA annotations -->
		<bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/>

		<bean id="myProductDao" class="product.ProductDaoImpl"/>

	</beans>
----

作为显式定义 `PersistenceAnnotationBeanPostProcessor` 的替代方法,请考虑在应用程序上下文配置中使用Spring的 `context:annotation-config` XML元素.  这样做会自动注册所有Spring标准的后处理器以进行基于注解的配置,包括 `CommonAnnotationBeanPostProcessor` 等.

请考虑以下示例:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>

		<!-- post-processors for all standard config annotations -->
		<context:annotation-config/>

		<bean id="myProductDao" class="product.ProductDaoImpl"/>

	</beans>
----

这种DAO的主要问题是它总是通过工厂创建一个新的 `EntityManager`. 您可以通过请求事务式的 `EntityManager` (也称为 "`shared EntityManager`",因为它是实际事务性 `EntityManager` 的共享,线程安全代理) 而不是工厂来避免这种情况. 以下示例显示了如何执行此操作:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class ProductDaoImpl implements ProductDao {

		@PersistenceContext
		private EntityManager em;

		public Collection loadProductsByCategory(String category) {
			Query query = em.createQuery("from Product as p where p.category = :category");
			query.setParameter("category", category);
			return query.getResultList();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class ProductDaoImpl : ProductDao {

		@PersistenceContext
		private lateinit var em: EntityManager

		fun loadProductsByCategory(category: String): Collection<*> {
			val query = em.createQuery("from Product as p where p.category = :category")
			query.setParameter("category", category)
			return query.resultList
		}
	}
----

`@PersistenceContext` 注解有一个名为type的可选属性,默认为 `PersistenceContextType.TRANSACTION`.  您可以使用此默认值来接收共享的 `EntityManager` 代理. 相反的,`PersistenceContextType.EXTENDED` 是一个完全不同的事情.
这导致了一个所谓的扩展 `EntityManager`,它不是线程安全的,因此不能在并发访问的组件中使用,例如Spring管理的单例bean.  扩展的 `EntityManager` 实例仅应用于有状态组件,例如,驻留在会话中,`EntityManager` 的生命周期不依赖于当前事务,而是完全取决于应用程序.

.方法和字段级的注入
****
您可以在类中的字段或方法上应用指示依赖注入的注解(例如 `@PersistenceUnit` 和 `@PersistenceContext`)  - 因此表达式为 "方法级注入" 和 "字段级注入".
字段级注解简洁且易于使用,而方法级注解允许进一步处理注入的依赖. 在这两种情况下,成员可见性(公共,受保护或私有) 都无关紧要.

什么是类级别注解?

在Java EE平台上,它们用于依赖的声明,而不用于资源注入.
****

注入的 `EntityManager` 是Spring管理的(了解正在进行的事务) .  即使新的DAO实现使用 `EntityManager` 的方法级注入而不是 `EntityManagerFactory`,但由于注解的使用,在应用程序上下文的XML文件中不需要进行任何更改.

这种DAO风格的主要优点是它仅依赖于Java持久化API. 不需要导入任何Spring类.  此外,当理解JPA注解时,注入由Spring容器自动应用. 从非侵入性的角度来看,这很有吸引力,并且对于JPA开发人员来说感觉更自然.

[[orm-jpa-tx]]
==== Spring驱动的JPA事务

NOTE: 我们强烈建议您阅读<<transaction-declarative,声名式事务管理>>(如果您还没有这样做) ,以获得有关Spring声明式事务支持的更详细的介绍. ,

JPA的推荐策略是通过JPA的本机事务支持进行本地事务.  Spring的 `JpaTransactionManager` 针对任何常规JDBC连接池(无XA要求) 提供了许多本地JDBC事务(例如特定于事务的隔离级别和资源级只读优化) 的功能.

Spring JPA还允许配置的 `JpaTransactionManager` 将JPA事务暴露给访问相同 `DataSource` 的JDBC访问代码, 前提是已注册的 `JpaDialect` 支持检索基础JDBC `Connection`.  Spring为 `EclipseLink` 和 Hibernate JPA实现提供了方言.
有关 `JpaDialect` 机制的详细信息,请参阅<<orm-jpa-dialect, 下一节>>.

NOTE:
作为一种直接替代方案,Spring的本机 `HibernateTransactionManager` 能够与Spring Framework 5.1和Hibernate 5.2/5.3/5.4 中的JPA访问代码交互,适应多种特定的Hibernate细节并提供JDBC交互.  这与 `LocalSessionFactoryBean` 设置结合使用特别有意义.
有关详细信息,请参阅<<orm-jpa-hibernate, JPA交互的本地Hibernate设置>> .
b
[[orm-jpa-dialect]]
==== 了解 `JpaDialect` 和 `JpaVendorAdapter`

作为一项高级功能,`JpaTransactionManager` 和 `AbstractEntityManagerFactoryBean` 的子类允许将自定义 `JpaDialect` 传递给 `JpaDialect` bean属性.  `JpaDialect` 实现可以启用Spring支持的以下高级功能,通常以特定于供应商的方式:

* 应用特定的事务语义(例如自定义隔离级别或事务超时)
* 检索事务JDBC `Connection`(用于暴露基于JDBC的DAO)
* `PersistenceExceptions` 到Spring `DataAccessExceptions` 的高级转换

这对于特殊事务语义和异常的高级转换特别有用. 默认实现(`DefaultJpaDialect`) 不提供任何特殊功能,如果需要前面列出的功能,则必须指定相应的方言.

TIP: 	作为一个更广泛的提供者适配工具,主要用于Spring的全功能 `LocalContainerEntityManagerFactoryBean` 设置, `JpaVendorAdapter` 将 `JpaDialect` 的功能与其他特定于提供者的默认设置相结合.  指定 `HibernateJpaVendorAdapter` 或 `EclipseLinkJpaVendorAdapter` 是分别为 `Hibernate或EclipseLink` 自动配置 `EntityManagerFactory` 设置的最便捷方式.
请注意,这些提供程序适配器主要设计用于Spring驱动的事务管理(即,与 `JpaTransactionManager` 一起使用) .

有关其操作的更多详细信息以及如何在Spring的JPA支持中使用它们,请参阅  {api-spring-framework}/orm/jpa/JpaDialect.html[`JpaDialect`] 和 {api-spring-framework}/orm/jpa/JpaVendorAdapter.html[`JpaVendorAdapter`]  javadoc.

[[orm-jpa-jta]]
==== 使用JTA事务管理设置JPA

作为 `JpaTransactionManager` 的替代方案,Spring还允许通过JTA进行多资源事务协调,无论是在Java EE环境中还是在独立的事务协调器(如Atomikos) 上.  除了选择Spring的 `JtaTransactionManager` 而不是 `JpaTransactionManager` 之外,您还需要采取以下几个步骤:

* 底层JDBC连接池需要具备XA功能,并与事务协调器集成. 这在Java EE环境中通常很简单,通过JNDI暴露不同类型的 `DataSource`.  有关详细信息,请参阅应用程序服器文档. 类似地,独立的事务协调器通常带有特殊的XA集成的 `DataSource` 实现. 再次检查其文档.
* 需要为JTA配置JPA `EntityManagerFactory` 设置. 这是特定于提供者的, 通常通过在 `LocalContainerEntityManagerFactoryBean` 上指定为 `jpaProperties` 的特殊属性.  在Hibernate的情况下,这些属性甚至是特定于版本的. 有关详细信息,请参阅Hibernate文档.
* Spring的 `HibernateJpaVendorAdapter` 强制执行某些面向 Spring 的默认设置,例如连接释放模式 on-close, 它与Hibernate在Hibernate 5.0 中的默认设置相匹配,但在 5.1+ 中则不再匹配.
对于 JTA 设置,确保声明您的持久性单元事务类型为 "JTA".  或者,将 Hibernate 5.2的 `hibernate.connection.handling_mode` 属性 设置为 `DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT` 以恢复 Hibernate 自己的默认值.
有关 WebLogic 的相关说明,请参阅 <<orm-hibernate-invalid-jdbc-access-error,Hibernate的虚假应用程序服务器警告>> .
* 或者,考虑从应用程序服务器本身获取 `EntityManagerFactory`(即,通过JNDI查找而不是本地声明的 `LocalContainerEntityManagerFactoryBean`) .  服务器提供的 `EntityManagerFactory` 可能需要在服务器配置中使用特殊的定义(使部署不那么可移植) ,而是由服务器的JTA环境设置.

[[orm-jpa-hibernate]]
==== 用于JPA交互的本地Hibernate设置和本地Hibernate事务

从Spring Framework 5.1 和 Hibernate 5.2/5.3/5.4 开始,本机 `LocalSessionFactoryBean` 设置与 `HibernateTransactionManager` 结合使用, 可以与 `@PersistenceContext` 和其他JPA访问代码进行交互.
Hibernate `SessionFactory` 现在在本地实现JPA的 `EntityManagerFactory` 接口,而Hibernate Session句柄本身就是JPA `EntityManager`.  Spring的JPA支持工具自动检测本机Hibernate会话.

因此,在许多场景中,这种本机Hibernate设置可以替代标准JPA `LocalContainerEntityManagerFactoryBean` 和 `JpaTransactionManager` 组合, 允许在同一本地事务中与 `@PersistenceContext` `EntityManager` 旁边的 `SessionFactory.getCurrentSession()`(以及 `HibernateTemplate`) 进行交互.  这样的设置还提供了更强大的Hibernate集成和更多的配置灵活性,因为它不受JPA引导程序契约的约束.

在这种情况下,您不需要 `HibernateJpaVendorAdapter` 配置,因为Spring的本机Hibernate设置提供了更多功能 (例如,自定义Hibernate Integrator设置,Hibernate 5.3 bean容器集成以及对只读事务的更强优化) .  最后但同样重要的是,您还可以通过 `LocalSessionFactoryBuilder` 表达本机Hibernate设置,与 `@Bean` 样式配置无缝集成(不涉及 `FactoryBean`) .

[NOTE]
====

`LocalSessionFactoryBean` 和 `LocalSessionFactoryBuilder` 支持后台引导, 就像JPA `LocalContainerEntityManagerFactoryBean` 一样. 有关简介,请参阅<<orm-jpa-setup-background, 后台引导>>.

在 `LocalSessionFactoryBean上`,可以通过 `bootstrapExecutor` 属性获得.  在编程式的 `LocalSessionFactoryBuilder` 上,重载的 `buildSessionFactory` 方法采用 bootstrap executor参数来获得后台引导.
====

[[oxm]]
== 使用Object-XML Mappers编组XML

[[oxm-introduction]]
=== 简介

本章介绍Spring的Object-XML Mapping支持. Object-XML Mapping(简称O-X映射) 是将XML文档转换为对象或从对象转换XML文档的行为.  此转换过程也称为XML编组或XML序列化. 本章可互换使用这些术语.

在O-X映射领域,编组器负责将对象(图形) 序列化为XML. 以类似的方式,解组器将XML反序列化为对象图. 此XML可以采用DOM文档、输入或输出流或SAX处理程序的形式

使用Spring满足O/X映射需求的一些好处是:

* <<oxm-ease-of-configuration,易于配置>>
* <<oxm-consistent-interfaces,一致的接口>>
* <<oxm-consistent-exception-hierarchy,一致的异常层次>>


[[oxm-ease-of-configuration]]
==== 易于配置

Spring的bean工厂可以轻松配置编组器,而无需构建JAXB上下文、JiBX绑定工厂等.  您可以像应用程序上下文中的任何其他bean一样配置编组器. 此外,基于XML命名空间的配置可用于许多编组器,使配置更简单.

[[oxm-consistent-interfaces]]
==== 一致的接口

Spring的O-X映射通过两个全局接口进行操作:   {api-spring-framework}/oxm/Marshaller.html[`Marshaller`] 和 {api-spring-framework}/oxm/Unmarshaller.html[`Unmarshaller`]. 这些抽象允许您相对轻松地切换O-X映射框架,对执行编组的类几乎不需要更改.
这种方法的另一个好处是可以使用混合匹配方法进行XML编组(例如,使用JAXB执行某些编组操作,而使用Castor执行某些编组操作) 以非侵入方式执行,使您可以使用每种技术的优势.

[[oxm-consistent-exception-hierarchy]]
==== 一致的异常层次

Spring提供从底层O-X映射工具的异常到其自己的异常层次结构的转换,其中 `XmlMappingException` 作为根异常. 这些运行时异常包装原始异常,因此不会丢失任何信息.

[[oxm-marshaller-unmarshaller]]
=== `Marshaller` 和 `Unmarshaller`

如<<oxm-introduction, 简介>>中所述,编组器将对象序列化为XML,而解组器将XML流反序列化为对象. 本节介绍用于此目的的两个Spring接口.

[[oxm-marshaller]]
==== 了解 `Marshaller`

Spring抽象了 `org.springframework.oxm.Marshaller` 接口后面的所有编组操作,其主要方法如下:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface Marshaller {

		/**
		 * Marshal the object graph with the given root into the provided Result.
		 */
		void marshal(Object graph, Result result) throws XmlMappingException, IOException;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface Marshaller {

		/**
		* Marshal the object graph with the given root into the provided Result.
		*/
		@Throws(XmlMappingException::class, IOException::class)
		fun marshal(
				graph: Any,
				result: Result
		)
	}
----

`Marshaller` 接口有一个主方法,它将给定对象封送到给定的 `javax.xml.transform.Result`.  结果是一个标记接口,它基本上代表XML输出抽象. 具体实现包装各种XML表示,如下表所示:

[[oxm-marshller-tbl]]
|===
| Result implementation| Wraps XML representation

| `DOMResult`
| `org.w3c.dom.Node`

| `SAXResult`
| `org.xml.sax.ContentHandler`

| `StreamResult`
| `java.io.File`, `java.io.OutputStream`, or `java.io.Writer`
|===

NOTE: 尽管 `marshal()` 方法接受普通对象作为其第一个参数,但大多数 `Marshaller` 实现都无法处理任意对象.  相反,对象类必须映射到映射文件中,使用注解标记,向编组器注册或具有公共基类. 请参阅本章后面的章节,以确定O-X技术如何管理它.

[[oxm-unmarshaller]]
==== 了解 `Unmarshaller`

与 `Marshaller` 类似,我们有 `org.springframework.oxm.Unmarshaller` 接口,如下所示:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public interface Unmarshaller {

		/**
		 * Unmarshal the given provided Source into an object graph.
		 */
		Object unmarshal(Source source) throws XmlMappingException, IOException;
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	interface Unmarshaller {

		/**
		* Unmarshal the given provided Source into an object graph.
		*/
		@Throws(XmlMappingException::class, IOException::class)
		fun unmarshal(source: Source): Any
	}
----

此接口还有一个方法,它从给定的 `javax.xml.transform.Source`(XML输入抽象) 中读取并返回读取的对象.  与 `Result` 一样,`Source` 是一个标记接口,具有三个具体实现. 每个包装一个不同的XML表示,如下表所示:

[[oxm-unmarshller-tbl]]
|===
| Source implementation| Wraps XML representation

| `DOMSource`
| `org.w3c.dom.Node`

| `SAXSource`
| `org.xml.sax.InputSource`, and `org.xml.sax.XMLReader`

| `StreamSource`
| `java.io.File`, `java.io.InputStream`, or `java.io.Reader`
|===

即使有两个独立的编组接口(`Marshaller` 和 `Unmarshaller`) ,Spring-WS中的所有实现都在一个类中实现.  这意味着您可以连接一个编组器类并引用它,并将其作为编组器和 `applicationContext.xml` 中的解组器.

[[oxm-xmlmappingexception]]
==== 了解 `XmlMappingException`

Spring将基础O-X映射工具中的异常转换为其自己的异常层次结构,并将 `XmlMappingException` 作为根异常.  这些运行时异常包装原始异常,因此不会丢失任何信息.

此外,`MarshallingFailureException` 和 `UnmarshallingFailureException` 提供了编组和解组操作之间的区别, 即使底层的O-X映射工具不这样做.

O-X Mapping异常层次结构如下图所示:

image::{image-resource}/oxm-exceptions.png[]

[[oxm-usage]]
=== 使用 `Marshaller` 和 `Unmarshaller`

您可以在各种情况下使用Spring的OXM. 在下面的示例中,我们使用它将Spring托管应用程序的设置编组为XML文件. 在以下示例中,我们使用简单的JavaBean来表示设置:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	public class Settings {

		private boolean fooEnabled;

		public boolean isFooEnabled() {
			return fooEnabled;
		}

		public void setFooEnabled(boolean fooEnabled) {
			this.fooEnabled = fooEnabled;
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class Settings {
		var isFooEnabled: Boolean = false
	}
----

应用程序类使用此bean来存储其设置. 除了主方法之外,该类还有两个方法:  `saveSettings()` 将设置bean保存到名为 `settings.xml` 的文件中,`loadSettings()` 再次加载这些设置.  以下 `main()` 方法构造Spring应用程序上下文并调用这两个方法:

[source,java,indent=0,subs="verbatim,quotes",role="primary"]
.Java
----
	import java.io.FileInputStream;
	import java.io.FileOutputStream;
	import java.io.IOException;
	import javax.xml.transform.stream.StreamResult;
	import javax.xml.transform.stream.StreamSource;
	import org.springframework.context.ApplicationContext;
	import org.springframework.context.support.ClassPathXmlApplicationContext;
	import org.springframework.oxm.Marshaller;
	import org.springframework.oxm.Unmarshaller;

	public class Application {

		private static final String FILE_NAME = "settings.xml";
		private Settings settings = new Settings();
		private Marshaller marshaller;
		private Unmarshaller unmarshaller;

		public void setMarshaller(Marshaller marshaller) {
			this.marshaller = marshaller;
		}

		public void setUnmarshaller(Unmarshaller unmarshaller) {
			this.unmarshaller = unmarshaller;
		}

		public void saveSettings() throws IOException {
			try (FileOutputStream os = new FileOutputStream(FILE_NAME)) {
				this.marshaller.marshal(settings, new StreamResult(os));
			}
		}

		public void loadSettings() throws IOException {
			try (FileInputStream is = new FileInputStream(FILE_NAME)) {
				this.settings = (Settings) this.unmarshaller.unmarshal(new StreamSource(is));
			}
		}

		public static void main(String[] args) throws IOException {
			ApplicationContext appContext =
					new ClassPathXmlApplicationContext("applicationContext.xml");
			Application application = (Application) appContext.getBean("application");
			application.saveSettings();
			application.loadSettings();
		}
	}
----
[source,kotlin,indent=0,subs="verbatim,quotes",role="secondary"]
.Kotlin
----
	class Application {

		lateinit var marshaller: Marshaller

		lateinit var unmarshaller: Unmarshaller

		fun saveSettings() {
			FileOutputStream(FILE_NAME).use { outputStream -> marshaller.marshal(settings, StreamResult(outputStream)) }
		}

		fun loadSettings() {
			FileInputStream(FILE_NAME).use { inputStream -> settings = unmarshaller.unmarshal(StreamSource(inputStream)) as Settings }
		}
	}

	private const val FILE_NAME = "settings.xml"

	fun main(args: Array<String>) {
		val appContext = ClassPathXmlApplicationContext("applicationContext.xml")
		val application = appContext.getBean("application") as Application
		application.saveSettings()
		application.loadSettings()
	}
----

`Application` 需要设置 `marshaller` 和 `unmarshaller` 属性. 我们可以使用以下 `applicationContext.xml` 来实现:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="application" class="Application">
			<property name="marshaller" ref="xstreamMarshaller" />
			<property name="unmarshaller" ref="xstreamMarshaller" />
		</bean>
		<bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller"/>
	</beans>
----

此应用程序上下文使用Castor,但我们可以使用本章后面介绍的任何其他 `marshaller` 实例.  请注意,默认情况下,Castor不需要任何进一步的配置,因此bean定义相当简单.  另请注意,`CastorMarshaller` 实现了 `Marshaller` 和 `Unmarshaller`,
因此我们可以在应用程序的 `Marshaller` 和 `Unmarshaller` 属性中引用 `castorMarshaller` bean.

此示例应用程序生成以下 `settings.xml` 文件:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<settings foo-enabled="false"/>
----



[[oxm-schema-based-config]]
=== XML配置命名空间

您可以使用OXM命名空间中的标记更简洁地配置编组器. 要使这些标记可用,必须首先在XML配置文件的命名空间中引用相应的模式. 以下示例显示了如何执行此操作:

[source,xml,indent=0]
[subs="verbatim,quotes"]
----
	<?xml version="1.0" encoding="UTF-8"?>
	<beans xmlns="http://www.springframework.org/schema/beans"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xmlns:oxm="http://www.springframework.org/schema/oxm" <1>
    xsi:schemaLocation="http://www.springframework.org/schema/beans
      https://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/oxm https://www.springframework.org/schema/oxm/spring-oxm.xsd"> <2>
----
<1> 引用 the `oxm` schema.
<2> 指定 the `oxm` schema 位置.


目前,此模式使以下元素可用:

* <<oxm-jaxb2-xsd, `jaxb2-marshaller`>>
* <<oxm-jibx-xsd, `jibx-marshaller`>>

每个标签都在其各自的编组部分中进行了解释. 但是,作为示例,JAXB2的编组器的配置可能类似于以下内容:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<oxm:jaxb2-marshaller id="marshaller" contextPath="org.springframework.ws.samples.airline.schema"/>
----

[[oxm-jaxb]]
=== JAXB

JAXB绑定编译器将W3C XML Schema转换为一个或多个Java类、`jaxb.properties` 文件以及可能的某些资源文件.  JAXB还提供了一种从带有注解的Java类生成模式的方法.

Spring支持JAXB 2.0 API作为XML编组策略,遵循 `Marshaller` 和 `Unmarshaller` 中描述的 <<oxm-marshaller-unmarshaller, `Marshaller` 和 `Unmarshaller` 接口>>.  相应的集成类驻留在 `org.springframework.oxm.jaxb` 包中.

[[oxm-jaxb2]]
==== 使用 `Jaxb2Marshaller`

`Jaxb2Marshaller` 类实现了Spring的 `Marshaller` 和 `Unmarshaller` 接口.  它需要一个上下文路径来运行. 您可以通过设置 `contextPath` 属性来设置上下文路径.  上下文路径是包含模式扩展类的冒号分隔的Java包名称列表.
它还提供了 `classesToBeBound` 属性,允许您设置编组器支持的类数组.  通过为bean指定一个或多个模式资源来执行模式验证,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="jaxb2Marshaller" class="org.springframework.oxm.jaxb.Jaxb2Marshaller">
			<property name="classesToBeBound">
				<list>
					<value>org.springframework.oxm.jaxb.Flight</value>
					<value>org.springframework.oxm.jaxb.Flights</value>
				</list>
			</property>
			<property name="schema" value="classpath:org/springframework/oxm/schema.xsd"/>
		</bean>

		...

	</beans>
----

[[oxm-jaxb2-xsd]]
===== XML配置命名空间

`jaxb2-marshaller` 元素配置 `org.springframework.oxm.jaxb.Jaxb2Marshaller`,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<oxm:jaxb2-marshaller id="marshaller" contextPath="org.springframework.ws.samples.airline.schema"/>
----

或者,你可以使用 `class-to-be-bound` 子元素提供要绑定到编组器的类列表:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<oxm:jaxb2-marshaller id="marshaller">
		<oxm:class-to-be-bound name="org.springframework.ws.samples.airline.schema.Airport"/>
		<oxm:class-to-be-bound name="org.springframework.ws.samples.airline.schema.Flight"/>
		...
	</oxm:jaxb2-marshaller>
----

下表描述了可用的属性:

|===
| Attribute| Description| Required

| `id`
| The ID of the marshaller
| No

| `contextPath`
| The JAXB Context path
| No
|===



[[oxm-jibx]]
=== JiBX

JiBX框架提供了类似于Hibernate为ORM提供的解决方案: 绑定的定义定义了Java对象如何转换为XML或从XML转换的规则.  在准备绑定和编译类之后,JiBX绑定编译器增强了类文件,并添加了代码来处理从XML转换类的实例或将类示例转换为XML文件.

有关JiBX的更多信息,请参见  http://jibx.sourceforge.net/[JiBX网站].  Spring集成类驻留在 `org.springframework.oxm.jibx` 包中.

[[oxm-jibx-marshaller]]
==== 使用 `JibxMarshaller`

`JibxMarshaller` 类同时实现了 `Marshaller` 和 `Unmarshaller`.
接口.  要进行操作,需要编组的班级名称,您可以
使用 `targetClass` 属性设置.  (可选) 您可以通过设置
`bindingName` 属性.  在下面的示例中,我们绑定 `Flights` 类:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="jibxFlightsMarshaller" class="org.springframework.oxm.jibx.JibxMarshaller">
			<property name="targetClass">org.springframework.oxm.jibx.Flights</property>
		</bean>
		...
	</beans>
----

`JibxMarshaller` 配置为单个类. 如果要编组多个类,则必须使用不同的 `targetClass` 属性值配置多个 `JibxMarshaller` 实例.

[[oxm-jibx-xsd]]
===== XML配置命名空间

`jibx-marshaller` 标签配置 `org.springframework.oxm.jibx.JibxMarshaller`,如下例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<oxm:jibx-marshaller id="marshaller" target-class="org.springframework.ws.samples.airline.schema.Flight"/>
----

下表描述了可用的属性 :

|===
| Attribute| Description| Required

| `id`
| The ID of the marshaller
| No

| `target-class`
| The target class for this marshaller
| Yes

| `bindingName`
| The binding name used by this marshaller
| No
|===



[[oxm-xstream]]
=== XStream

XStream是一个简单的库,用于将对象序列化为XML并再次返回. 它不需要任何映射并生成干净的XML.

关于XStream的更多信息,请参阅 https://x-stream.github.io/[XStream网站]. Spring集成的类驻留在 `org.springframework.oxm.xstream` 包中.

[[oxm-xstream-marshaller]]
==== 使用 `XStreamMarshaller`

`XStreamMarshaller` 不需要任何配置,可以直接在应用程序上下文中进行配置.  要进一步自定义XML,您可以设置别名映射,该映射由映射到类的字符串别名组成,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<beans>
		<bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller">
			<property name="aliases">
				<props>
					<prop key="Flight">org.springframework.oxm.xstream.Flight</prop>
				</props>
			</property>
		</bean>
		...
	</beans>
----

[WARNING]
=====

默认情况下,XStream允许任意类被解组,这可能导致不安全的Java序列化效果.  因此,我们不建议使用 `XStreamMarshaller` 从外部源(即Web) 解组XML,因为这可能导致安全漏洞.

如果选择使用 `XStreamMarshaller` 从外部源解组XML, 请在 `XStreamMarshaller` 上设置 `supportedClasses` 属性,如以下示例所示:

[source,xml,indent=0,subs="verbatim,quotes"]
----
	<bean id="xstreamMarshaller" class="org.springframework.oxm.xstream.XStreamMarshaller">
		<property name="supportedClasses" value="org.springframework.oxm.xstream.Flight"/>
		...
	</bean>
----

这样做可确保只有已注册的类才有资格进行解组.

此外,您可以注册 {api-spring-framework}/oxm/xstream/XStreamMarshaller.html#setConverters(com.thoughtworks.xstream.converters.ConverterMatcher...)[自定义转换器], 以确保只能对您支持的类进行解组.  除了明确支持应支持的域类的转换器之外,您可能还希望将 `CatchAllConverter` 添加为列表中的最后一个转换器.  因此,不会调用具有较低优先级和可能的安全漏洞的默认XStream转换器.
=====

NOTE: 请注意,XStream是XML序列化库,而不是数据绑定库. 因此,它具有有限的命名空间支持. 因此,它非常不适合在Web服务中使用.

include::data-access/data-access-appendix.adoc[leveloffset=+1]

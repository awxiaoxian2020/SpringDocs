<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>Spring Data JPA - 参考文档</title>
<style>
@import 'http://resources.jcohy.com/css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			selectedIndex = $(this).index()
			$(".switch--item").filter(function() { return ($(this).text() === selectedText) }).each(function() {
				$(this).addClass('selected');
				$(this).siblings().removeClass('selected');
				selectedContent = $(this).parent().siblings(".content").eq(selectedIndex)
				selectedContent.removeClass('hidden');
				selectedContent.siblings().addClass('hidden');
			});
		});
	});
}

$(addBlockSwitches);
$(globalSwitch);

</script>

</head>
<body id="spring-data-jpa" class="book toc2 toc-left">
<div id="header">
<h1>Spring Data JPA - 参考文档</h1>
<div class="details">
<span id="revnumber">version 2.3.6.RELEASE,</span>
<span id="revdate">2021-05-14</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#preface">1. 前言</a>
<ul class="sectlevel2">
<li><a href="#project">1.1. 项目元数据</a></li>
</ul>
</li>
<li><a href="#new-features">2. 新的＆值得注意的</a>
<ul class="sectlevel2">
<li><a href="#new-features.1-11-0">2.1. Spring Data JPA 1.11中的新特性</a></li>
<li><a href="#new-features.1-10-0">2.2. Spring Data JPA 1.10 中的新特性</a></li>
</ul>
</li>
<li><a href="#dependencies">3. 依赖</a>
<ul class="sectlevel2">
<li><a href="#dependencies.spring-boot">3.1. Spring Boot 的依赖管理</a></li>
<li><a href="#dependencies.spring-framework">3.2. Spring Framework</a></li>
</ul>
</li>
<li><a href="#repositories">4. 使用 Spring Data Repositories</a>
<ul class="sectlevel2">
<li><a href="#repositories.core-concepts">4.1. 核心概念</a></li>
<li><a href="#repositories.query-methods">4.2. 查询方法</a></li>
<li><a href="#repositories.definition">4.3. 定义 Repository  接口</a>
<ul class="sectlevel3">
<li><a href="#repositories.definition-tuning">4.3.1. 微调 Repository  定义</a></li>
<li><a href="#repositories.multiple-modules">4.3.2. 将 Repositories  与多个 Spring Data 模块一起使用</a></li>
</ul>
</li>
<li><a href="#repositories.query-methods.details">4.4. 定义查询方法</a>
<ul class="sectlevel3">
<li><a href="#repositories.query-methods.query-lookup-strategies">4.4.1. 查询策略</a></li>
<li><a href="#repositories.query-methods.query-creation">4.4.2. 查询创建</a></li>
<li><a href="#repositories.query-methods.query-property-expressions">4.4.3. 属性表达式</a></li>
<li><a href="#repositories.special-parameters">4.4.4. 特殊参数处理</a>
<ul class="sectlevel4">
<li><a href="#repositories.paging-and-sorting">Paging 和 Sorting</a></li>
</ul>
</li>
<li><a href="#repositories.limit-query-result">4.4.5. 限制查询结果</a></li>
<li><a href="#repositories.collections-and-iterables">4.4.6. 存储库方法返回集合或可迭代对象</a>
<ul class="sectlevel4">
<li><a href="#repositories.collections-and-iterables.streamable">使用 Streamable 作为查询方法返回类型</a></li>
<li><a href="#repositories.collections-and-iterables.streamable-wrapper">返回自定义 Streamable 包装器类型</a></li>
<li><a href="#repositories.collections-and-iterables.vavr">支持 Vavr 集合</a></li>
</ul>
</li>
<li><a href="#repositories.nullability">4.4.7. 存储库方法的空处理</a>
<ul class="sectlevel4">
<li><a href="#repositories.nullability.annotations">可空性注解</a></li>
<li><a href="#repositories.nullability.kotlin">基于 Kotlin 的存储库中的可空性</a></li>
</ul>
</li>
<li><a href="#repositories.query-streaming">4.4.8. 流查询结果</a></li>
<li><a href="#repositories.query-async">4.4.9. 异步查询结果</a></li>
</ul>
</li>
<li><a href="#repositories.create-instances">4.5. 创建存储库实例</a>
<ul class="sectlevel3">
<li><a href="#repositories.create-instances.spring">4.5.1. XML 配置</a>
<ul class="sectlevel4">
<li><a href="#repositories.using-filters">使用过滤器</a></li>
</ul>
</li>
<li><a href="#repositories.create-instances.java-config">4.5.2. Java 配置</a></li>
<li><a href="#repositories.create-instances.standalone">4.5.3. 独立使用</a></li>
</ul>
</li>
<li><a href="#repositories.custom-implementations">4.6. Spring Data 存储库的自定义实现</a>
<ul class="sectlevel3">
<li><a href="#repositories.single-repository-behavior">4.6.1. 自定义单个存储库</a>
<ul class="sectlevel4">
<li><a href="#repositories.configuration">配置</a></li>
</ul>
</li>
<li><a href="#repositories.customize-base-repository">4.6.2. 自定义基础存储库</a></li>
</ul>
</li>
<li><a href="#core.domain-events">4.7. 从聚合根发布事件</a></li>
<li><a href="#core.extensions">4.8. Spring Data 扩展</a>
<ul class="sectlevel3">
<li><a href="#core.extensions.querydsl">4.8.1. Querydsl 扩展</a></li>
<li><a href="#core.web">4.8.2. Web 支持</a>
<ul class="sectlevel4">
<li><a href="#core.web.basic">Basic Web 支持</a></li>
<li><a href="#core.web.pageables">超媒体对页面的支持</a></li>
<li><a href="#core.web.binding">Web 数据绑定支持</a></li>
<li><a href="#core.web.type-safe">Querydsl Web 支持</a></li>
</ul>
</li>
<li><a href="#core.repository-populators">4.8.3. 存储库填充器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">5. 参考文档</a></li>
<li><a href="#jpa.repositories">6. JPA 存储库</a>
<ul class="sectlevel2">
<li><a href="#jpa.introduction">6.1. 简介</a>
<ul class="sectlevel3">
<li><a href="#jpa.namespace">6.1.1. Spring 命名空间</a>
<ul class="sectlevel4">
<li><a href="#自定义命名空间属性">自定义命名空间属性</a></li>
</ul>
</li>
<li><a href="#jpa.java-config">6.1.2. 基于注解的配置</a></li>
<li><a href="#jpa.bootstrap-mode">6.1.3. 引导模式</a>
<ul class="sectlevel4">
<li><a href="#推荐建议">推荐建议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jpa.entity-persistence">6.2. 持久化实体</a>
<ul class="sectlevel3">
<li><a href="#jpa.entity-persistence.saving-entites">6.2.1. 保存实体</a>
<ul class="sectlevel4">
<li><a href="#jpa.entity-persistence.saving-entites.strategies">实体状态检测策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jpa.query-methods">6.3. 查询方法</a>
<ul class="sectlevel3">
<li><a href="#jpa.sample-app.finders.strategies">6.3.1. 查询策略</a>
<ul class="sectlevel4">
<li><a href="#声明查询">声明查询</a></li>
</ul>
</li>
<li><a href="#jpa.query-methods.query-creation">6.3.2. 查询创建</a></li>
<li><a href="#jpa.query-methods.named-queries">6.3.3. 使用 JPA 命名查询</a>
<ul class="sectlevel4">
<li><a href="#xml-命名查询定义">XML 命名查询定义</a></li>
<li><a href="#基于注解的配置">基于注解的配置</a></li>
<li><a href="#声明接口">声明接口</a></li>
</ul>
</li>
<li><a href="#jpa.query-methods.at-query">6.3.4. 使用 <code>@Query</code></a>
<ul class="sectlevel4">
<li><a href="#使用高级-like-表达式">使用高级 <code>LIKE</code> 表达式</a></li>
<li><a href="#本地查询">本地查询</a></li>
</ul>
</li>
<li><a href="#jpa.query-methods.sorting">6.3.5. 使用排序</a></li>
<li><a href="#jpa.named-parameters">6.3.6. 使用命名参数</a></li>
<li><a href="#jpa.query.spel-expressions">6.3.7. 使用 SpEL 表达式</a></li>
<li><a href="#jpa.modifying-queries">6.3.8. 修改查询</a>
<ul class="sectlevel4">
<li><a href="#jpa.modifying-queries.derived-delete">扩展删除查询</a></li>
</ul>
</li>
<li><a href="#jpa.query-hints">6.3.9. 应用查询提示</a></li>
<li><a href="#jpa.entity-graph">6.3.10. 配置 Fetch- 和 LoadGraphs</a></li>
<li><a href="#projections">6.3.11. 投影</a>
<ul class="sectlevel4">
<li><a href="#projections.interfaces">基于接口的投影</a></li>
<li><a href="#projections.dtos">基于类的投影 (DTO)</a></li>
<li><a href="#projection.dynamic">动态投影</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jpa.stored-procedures">6.4. 存储过程</a></li>
<li><a href="#specifications">6.5. Specification</a></li>
<li><a href="#query-by-example">6.6. 查询例子</a>
<ul class="sectlevel3">
<li><a href="#query-by-example.introduction">6.6.1. 简介</a></li>
<li><a href="#query-by-example.usage">6.6.2. 使用</a></li>
<li><a href="#query-by-example.matchers">6.6.3. Example 匹配</a></li>
<li><a href="#query-by-example.running">6.6.4. 执行一个例子</a></li>
</ul>
</li>
<li><a href="#transactions">6.7. 事务性</a>
<ul class="sectlevel3">
<li><a href="#transactional-query-methods">6.7.1. 事务查询方法</a></li>
</ul>
</li>
<li><a href="#locking">6.8. 锁</a></li>
<li><a href="#auditing">6.9. 审计</a>
<ul class="sectlevel3">
<li><a href="#auditing.basics">6.9.1. 基础</a>
<ul class="sectlevel4">
<li><a href="#auditing.annotations">基于注解的审核元数据</a></li>
<li><a href="#auditing.interfaces">基于接口的审核元数据</a></li>
<li><a href="#auditing.auditor-aware"><code>AuditorAware</code></a></li>
</ul>
</li>
<li><a href="#jpa.auditing">6.9.2. JPA 审计</a>
<ul class="sectlevel4">
<li><a href="#jpa.auditing.configuration">通用审核配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jpa.misc">6.10. 其他注意事项</a>
<ul class="sectlevel3">
<li><a href="#jpa.misc.jpa-context">6.10.1. 在自定义实现中使用 <code>JpaContext</code></a></li>
<li><a href="#jpa.misc.merging-persistence-units">6.10.2. 合并持久性单元</a>
<ul class="sectlevel4">
<li><a href="#jpa.misc.entity-scanning">@Entity 类和 JPA 映射文件的类路径扫描</a></li>
</ul>
</li>
<li><a href="#jpd.misc.cdi-integration">6.10.3. CDI 集成</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix">7. 附录</a></li>
<li><a href="#repositories.namespace-reference">Appendix A: 命名空间参考</a>
<ul class="sectlevel2">
<li><a href="#populator.namespace-dao-config"><code>&lt;repositories /&gt;</code> 元素</a></li>
</ul>
</li>
<li><a href="#populator.namespace-reference">Appendix B: Populators  命名空间参考</a>
<ul class="sectlevel2">
<li><a href="#namespace-dao-config">&lt;populator /&gt; element</a></li>
</ul>
</li>
<li><a href="#repository-query-keywords">Appendix C: 存储库查询关键字</a>
<ul class="sectlevel2">
<li><a href="#appendix.query.method.subject">支持的查询方法主题关键字</a></li>
<li><a href="#appendix.query.method.predicate">支持的查询方法断言关键字和修饰符</a></li>
</ul>
</li>
<li><a href="#repository-query-return-types">Appendix D: 储存库查询返回类型</a>
<ul class="sectlevel2">
<li><a href="#appendix.query.return.types">支持的查询返回类型</a></li>
</ul>
</li>
<li><a href="#faq">Appendix E: 常见问题</a>
<ul class="sectlevel2">
<li><a href="#通用">通用</a></li>
<li><a href="#基础">基础</a></li>
<li><a href="#审计">审计</a></li>
</ul>
</li>
<li><a href="#glossary">Appendix F: 词汇表</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>&#169; 2008-2019 The original authors.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
本文档的副本可以供您自己使用,也可以分发给其他人,但前提是您不对此类副本收取任何费用,并且还应确保每份副本均包含本版权声明(无论是印刷版本还是电子版本) .
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>1. 前言</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data JPA 为 Java 持久性 API(JPA) 提供存储库支持. 它简化了需要访问 JPA 数据源的应用程序的开发.</p>
</div>
<div class="sect2">
<h3 id="project"><a class="anchor" href="#project"></a>1.1. 项目元数据</h3>
<div class="ulist">
<ul>
<li>
<p>版本控制 - <a href="https://github.com/spring-projects/spring-data-jpa" class="bare">github.com/spring-projects/spring-data-jpa</a></p>
</li>
<li>
<p>Bugtracker - <a href="https://jira.spring.io/browse/DATAJPA" class="bare">jira.spring.io/browse/DATAJPA</a></p>
</li>
<li>
<p>发行版本库 - <a href="https://repo.spring.io/libs-release" class="bare">repo.spring.io/libs-release</a></p>
</li>
<li>
<p>里程碑存储库 - <a href="https://repo.spring.io/libs-milestone" class="bare">repo.spring.io/libs-milestone</a></p>
</li>
<li>
<p>快照存储库 - <a href="https://repo.spring.io/libs-snapshot" class="bare">repo.spring.io/libs-snapshot</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="new-features"><a class="anchor" href="#new-features"></a>2. 新的＆值得注意的</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="new-features.1-11-0"><a class="anchor" href="#new-features.1-11-0"></a>2.1. Spring Data JPA 1.11中的新特性</h3>
<div class="paragraph">
<p>Spring Data JPA 1.11 增加了以下功能:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>改进与 Hibernate 5.2 的兼容性.</p>
</li>
<li>
<p>通过<a href="#query-by-example">示例</a>支持任意匹配模式.  .</p>
</li>
<li>
<p>分页查询执行优化.</p>
</li>
<li>
<p>支持 <code>exists</code> 存储库查询扩展中的投影.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-features.1-10-0"><a class="anchor" href="#new-features.1-10-0"></a>2.2. Spring Data JPA 1.10 中的新特性</h3>
<div class="paragraph">
<p>Spring Data JPA 1.10 增加了以下功能:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>支持存储库查询方法中的 <a href="#projections">Projections(投影)</a>.</p>
</li>
<li>
<p>通过<a href="#query-by-example">示例</a>支持查询.</p>
</li>
<li>
<p>已启用以下注解构建组合注解: <code>@EntityGraph</code>, <code>@Lock</code>, <code>@Modifying</code>, <code>@Query</code>, <code>@QueryHints</code>, 和 <code>@Procedure</code>.</p>
</li>
<li>
<p>支持 <code>Contains</code> 集合表达式的关键字.</p>
</li>
<li>
<p>JSR-310 和 ThreeTenBP  <code>ZoneId</code> 的 <code>AttributeConverter</code> 实现.</p>
</li>
<li>
<p>升级到 Querydsl 4, Hibernate 5, OpenJPA 2.4, 和 EclipseLink 2.6.1.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dependencies"><a class="anchor" href="#dependencies"></a>3. 依赖</h2>
<div class="sectionbody">
<div class="paragraph">
<p>由于各个 Spring Data 模块的初始日期不同,它们中的大多数都带有不同的主版本号和次版本号. 寻找兼容版本的最简单方法是依靠我们随定义的兼容版本提供的 Spring Data Release BOM.
在 Maven 项目中,您将在 <code>&lt;dependencyManagement /&gt;</code> POM 的部分声明这种依赖,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. 使用 Spring Data 发行版 BOM</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
      &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt;
      &lt;version&gt;Moore-SR8&lt;/version&gt;
      &lt;scope&gt;import&lt;/scope&gt;
      &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
</div>
</div>
<div id="dependencies.train-names" class="paragraph">
<p>目前的发行版本是  <code>Moore-SR8</code>. 名称按字母顺序上升,目前可用的 列车在  <a href="https://github.com/spring-projects/spring-data-commons/wiki/Release-planning">此处</a> 列出. 版本名称遵循以下模式: <code>${name}-${release}</code>,其中发布可以是下列之一:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BUILD-SNAPSHOT</code>: 当前快照</p>
</li>
<li>
<p><code>M1</code>, <code>M2</code>, 等: 里程碑</p>
</li>
<li>
<p><code>RC1</code>, <code>RC2</code>, 发布候选</p>
</li>
<li>
<p><code>RELEASE</code>: GA 版本</p>
</li>
<li>
<p><code>SR1</code>, <code>SR2</code>, 等: 服务版本</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在我们的 <a href="https://github.com/spring-projects/spring-data-examples/tree/master/bom">Spring Data 示例存储库</a> 中可以找到使用 BOM 的一个工作示例. 有了这个,你可以在你的模块中声明 Spring Data 模块而不需要版本 <code>&lt;dependencies /&gt;</code>,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. 声明一个依赖 Spring Data 模块</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;dependencies&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dependencies.spring-boot"><a class="anchor" href="#dependencies.spring-boot"></a>3.1. Spring Boot 的依赖管理</h3>
<div class="paragraph">
<p>Spring Boot 为您选择最新版本的 Spring Data 模块. 如果您仍想升级到较新版本,请将该属性配置为您要使用  <code>spring-data-releasetrain.version</code>  的 <a href="#dependencies.train-names">火车名称迭代</a> .</p>
</div>
</div>
<div class="sect2">
<h3 id="dependencies.spring-framework"><a class="anchor" href="#dependencies.spring-framework"></a>3.2. Spring Framework</h3>
<div class="paragraph">
<p>当前版本的 Spring Data 模块需要版本  5.2.12.RELEASE  或更高版本的 Spring Framework. 这些模块也可能与该次要版本的旧版错误修复版本一起工作. 但是,强烈建议使用该代中的最新版本.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repositories"><a class="anchor" href="#repositories"></a>4. 使用 Spring Data Repositories</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data 存储库抽象层的目标是减少为各种持久性存储实现数据访问所需的样板代码数量.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><em>Spring数据存储库文档和你的模块</em></p>
</div>
<div class="paragraph">
<p>本章介绍 Spring Data 存储库的核心概念和接口. 本章中的信息来自 Spring Data Commons 模块. 它使用 Java 持久性 API (JPA) 模块的配置和代码示例. 您应该将 XML 命名空间声明和要扩展的类型调整为您使用的特定模块的等同项. &#8220;<a href="#repositories.namespace-reference">命名空间参考</a>&#8221; 涵盖了所有支持存储库API的 Spring Data 模块支持的XML配置.
&#8220;<a href="#repository-query-keywords">存储库查询关键字</a>&#8221; 一般涵盖了存储库抽象支持的查询方法关键字. 有关模块特定功能的详细信息,请参阅本文档的该模块章节.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="repositories.core-concepts"><a class="anchor" href="#repositories.core-concepts"></a>4.1. 核心概念</h3>
<div class="paragraph">
<p>Spring Data 存储库抽象中的中心接口是 <code>Repository</code>. 它需要 domain 类以及 domain 的 ID 类型作为类型参数. 该接口主要作为标记接口来捕获要使用的类型,并帮助您发现该接口的子接口.  <code>CrudRepository</code> 实现了实体类复杂的 CRUD 功能.</p>
</div>
<div id="repositories.repository" class="exampleblock">
<div class="title">Example 3. <code>CrudRepository</code> 接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; {

  &lt;S extends T&gt; S save(S entity);      <i class="conum" data-value="1"></i><b>(1)</b>

  Optional&lt;T&gt; findById(ID primaryKey); <i class="conum" data-value="2"></i><b>(2)</b>

  Iterable&lt;T&gt; findAll();               <i class="conum" data-value="3"></i><b>(3)</b>

  long count();                        <i class="conum" data-value="4"></i><b>(4)</b>

  void delete(T entity);               <i class="conum" data-value="5"></i><b>(5)</b>

  boolean existsById(ID primaryKey);   <i class="conum" data-value="6"></i><b>(6)</b>

  // … more functionality omitted.
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>保存给定的实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>返回由给定ID标识的实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>返回所有实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>返回实体的数量.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>删除给定的实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>判断是否存在具有给定ID的实体.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
我们还提供持久性技术的特定抽象,如 <code>JpaRepository</code> 或 <code>MongoRepository</code>. 这些接口扩展 <code>CrudRepository</code> 并暴露了持久化技术的基本功能,以及通用的持久化技术,例如 <code>CrudRepository</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>除此之外 <code>CrudRepository</code>,还有一个 <a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html"><code>PagingAndSortingRepository</code></a> 的抽象的接口,来简化对实体的分页操作:</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. <code>PagingAndSortingRepository</code> 接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; {

  Iterable&lt;T&gt; findAll(Sort sort);

  Page&lt;T&gt; findAll(Pageable pageable);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要访问 <code>User</code> 第二页,每页 20,您可以执行以下操作:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean
Page&lt;User&gt; users = repository.findAll(PageRequest.of(1, 20));</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了查询方法外,count 和 delete 查询的相关扩展都是可用的. 以下列表扩展 count 查询的接口定义:</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. 扩展 count 查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt; {

  long countByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下列表扩展 delete 查询的接口定义:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. 扩展删除查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt; {

  long deleteByLastname(String lastname);

  List&lt;User&gt; removeByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.query-methods"><a class="anchor" href="#repositories.query-methods"></a>4.2. 查询方法</h3>
<div class="paragraph">
<p>标准CRUD功能通常会在底层数据存储上进行查询. 使用 Spring Data,声明这些查询需要四步:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>声明一个扩展 <code>Repository</code> 或其子接口的接口,并输入它应该处理的 domain 类和 <code>ID</code> 类型,如以下示例所示:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, Long&gt; { … }</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>在接口上声明查询方法.</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, Long&gt; {
  List&lt;Person&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>使用 Spring  <a href="#repositories.create-instances.java-config">JavaConfig</a> 或 <a href="#repositories.create-instances">XML 配置</a> 为这些接口创建代理实例.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>要使用 Java 配置,请创建类似于以下的类:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

@EnableJpaRepositories
class Config { … }</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>要使用XML配置,请定义一个类似于以下的bean:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:jpa="http://www.springframework.org/schema/data/jpa"
   xsi:schemaLocation="http://www.springframework.org/schema/beans
     https://www.springframework.org/schema/beans/spring-beans.xsd
     http://www.springframework.org/schema/data/jpa
     https://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

   &lt;jpa:repositories base-package="com.acme.repositories"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个例子中使用了 JPA 命名空间. 如果您想使用其他的存储库,则需要将其更改为相应的命名空间声明. 换句话说,你应该替换 jpa,例如 <code>mongodb</code>.
另请注意,JavaConfig 不会显式配置包,因为默认情况下会使用注解类的包. 定制要扫描的软件包,请使用 <code>basePackage…</code> 特定于数据存储库的 <code>@Enable${store}Repositories</code> 注解的一个属性.</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>注入资源库实例并使用它,如以下示例所示:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class SomeClient {

  private final PersonRepository repository;

  SomeClient(PersonRepository repository) {
    this.repository = repository;
  }

  void doSomething() {
    List&lt;Person&gt; persons = repository.findByLastname("Matthews");
  }
}</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下部分详细解释每一步:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#repositories.definition">定义 Repository  接口</a></p>
</li>
<li>
<p><a href="#repositories.query-methods.details">定义查询方法</a></p>
</li>
<li>
<p><a href="#repositories.create-instances">创建存储库实例</a></p>
</li>
<li>
<p><a href="#repositories.custom-implementations">Spring Data Repository  的自定义实现</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="repositories.definition"><a class="anchor" href="#repositories.definition"></a>4.3. 定义 Repository  接口</h3>
<div class="paragraph">
<p>首先,定义一个 domain 类特定的 repository 接口. 该接口必须扩展 <code>Repository</code> 并且输入 domain 类和 <code>ID</code> 类型. 如果您想暴露该 domain 类型的 CRUD 方法,请扩展 <code>CrudRepository</code> 而不是 <code>Repository</code>.</p>
</div>
<div class="sect3">
<h4 id="repositories.definition-tuning"><a class="anchor" href="#repositories.definition-tuning"></a>4.3.1. 微调 Repository  定义</h4>
<div class="paragraph">
<p>通常情况下,您的 Repository  接口扩展了 <code>Repository</code>,<code>CrudRepository</code> 或 <code>PagingAndSortingRepository</code>. 如果您不想扩展 Spring Data 接口,也可以使用 <code>@RepositoryDefinition</code> 注解您的 Repository 接口.
扩展 <code>CrudRepository</code> 暴露了一套完整的方法来操纵你的实体. 如果您想选择暴露的方法,请复制 <code>CrudRepository</code> 中要暴露的方法 到您的实体类 Repository 中.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这样做可以让您在提供的 Spring Data Repositories 功能之上定义自己的抽象.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示如何选择性地暴露 CRUD方法 (<code>findById</code> 以及 <code>save</code> 在这种情况下) :</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. 选择性地暴露 CRUD 方法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NoRepositoryBean
interface MyBaseRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; {

  Optional&lt;T&gt; findById(ID id);

  &lt;S extends T&gt; S save(S entity);
}

interface UserRepository extends MyBaseRepository&lt;User, Long&gt; {
  User findByEmailAddress(EmailAddress emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中,您为所有 domain Repository 定义了一个通用的基本接口,并暴露了 <code>findById(…)</code> 和  <code>save(…)</code> 方法. 这些方法被路由到 Spring Data 提供的所选存储的基本存储库实现中 (例如,如果使用JPA,则实现为 <code>SimpleJpaRepository</code>,因为它们与 <code>CrudRepository</code> 中的方法签名匹配.
因此,<code>UserRepository</code> 现在可以保存用户,通过ID查找单个用户,并触发查询以通过电子邮件地址查找 <code>Users</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
中间的 repository 接口用 <code>@NoRepositoryBean</code> 注解. 确保添加了该注解的 repository 接口不会在  Spring Data 运行时被创建实例.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.multiple-modules"><a class="anchor" href="#repositories.multiple-modules"></a>4.3.2. 将 Repositories  与多个 Spring Data 模块一起使用</h4>
<div class="paragraph">
<p>在您的应用程序中使用唯一的 Spring Data 模块很简单,因为已定义范围中的所有存储库接口均已绑定到该 Spring Data 模块.  有时,应用程序需要使用多个 Spring Data 模块.  在这种情况下,存储库定义必须区分使用哪个.
当它在类路径上检测到多个存储库工厂时,Spring Data 进入严格的存储库配置模式.  严格的配置使用 repository  或 domain 类上的详细信息来决定有关存储库定义的 Spring Data 模块绑定:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果存储库定义扩展了<a href="#repositories.multiple-modules.types">特定于模块的存储库</a>,则它是特定 Spring Data 模块的有效候选者.</p>
</li>
<li>
<p>如果 domain 类使用模块<a href="#repositories.multiple-modules.annotations">特定的注解类型进行注解</a>,则它是特定 Spring Data 模块的有效候选者.  Spring Data 模块可以接受第三方注解 (例如JPA的 <code>@Entity</code>) ,也可以提供自己的注解 (例如 Spring Data MongoDB的 <code>@Document</code> 和 Spring Data Elasticsearch) .</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下示例显示使用特定于模块的接口 (在这种情况下为 JPA) 的存储库:</p>
</div>
<div id="repositories.multiple-modules.types" class="exampleblock">
<div class="title">Example 8. 使用模块特定接口的存储库定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface MyRepository extends JpaRepository&lt;User, Long&gt; { }

@NoRepositoryBean
interface MyBaseRepository&lt;T, ID&gt; extends JpaRepository&lt;T, ID&gt; { … }

interface UserRepository extends MyBaseRepository&lt;User, Long&gt; { … }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MyRepository</code> 和 <code>UserRepository</code> 继承 <code>JpaRepository</code> .  它们是 Spring Data JPA 模块的有效候选者.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的例子展示了一个使用通用接口的存储库:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. 使用通用接口的存储库定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface AmbiguousRepository extends Repository&lt;User, Long&gt; { … }

@NoRepositoryBean
interface MyBaseRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; { … }

interface AmbiguousUserRepository extends MyBaseRepository&lt;User, Long&gt; { … }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AmbiguousRepository</code> 和 <code>AmbiguousUserRepository</code> 仅在其类型层次结构中扩展 <code>Repository</code> 和 <code>CrudRepository</code>.  尽管在使用唯一的 Spring Data 模块时没有什么问题,但是多个模块无法区分这些存储库应绑定到哪个特定的 Spring Data.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了使用带注解的 domain  类的存储库:</p>
</div>
<div id="repositories.multiple-modules.annotations" class="exampleblock">
<div class="title">Example 10. 使用带有注解的 domain 类的存储库定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, Long&gt; { … }

@Entity
class Person { … }

interface UserRepository extends Repository&lt;User, Long&gt; { … }

@Document
class User { … }</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PersonRepository</code> 引用使用JPA <code>@Entity</code> 注解进行注解的 <code>Person</code>,因此该存储库显然属于 Spring Data JPA.  <code>UserRepository</code> 引用 <code>User</code>,该 User 使用 Spring Data MongoDB 的 <code>@Document</code> 注解进行注解.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>以下错误的示例显示了使用带有混和注解的 domian 类的存储库:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. 使用带有混合注解的 domain 类的存储库定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface JpaPersonRepository extends Repository&lt;Person, Long&gt; { … }

interface MongoDBPersonRepository extends Repository&lt;Person, Long&gt; { … }

@Entity
@Document
class Person { … }</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例显示了同时使用 JPA 和 Spring Data MongoDB 注解的 domain 类.  它定义了两个存储库,<code>JpaPersonRepository</code> 和 <code>MongoDBPersonRepository</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#repositories.multiple-modules.types">存储库类型详细信息</a> 和<a href="#repositories.multiple-modules.annotations">可区分的 domain 类注解</a> 用于配置严格的存储库,以标识特定 Spring Data 模块的存储库候选者.
在同一个 domain 类型上使用多个特定于持久性技术的注解是可能的,并且可以跨多种持久性技术重用 domain 类型.  但是,Spring Data 无法再确定用于绑定存储库的唯一模块.</p>
</div>
<div class="paragraph">
<p>区分存储库的最后一种方法是确定存储库 <code>basePackages</code> 的范围.  <code>basePackages</code> 包定义了扫描存储库接口定义的起点,这意味着将存储库定义放在适当的软件包中.  默认情况下,注解驱动的配置使用配置类的包.
 <a href="#repositories.create-instances.spring">基于 XML 的配置中</a>中的 <code>basePackages</code> 是必需的.</p>
</div>
<div class="paragraph">
<p>以下示例显示了基础包的注解驱动配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. <code>basePackages</code> 的注解驱动配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableJpaRepositories(basePackages = "com.acme.repositories.jpa")
@EnableMongoRepositories(basePackages = "com.acme.repositories.mongo")
class Configuration { … }</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.query-methods.details"><a class="anchor" href="#repositories.query-methods.details"></a>4.4. 定义查询方法</h3>
<div class="paragraph">
<p>存储库代理有两种从方法名称扩展特定查询的方式:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过直接从方法名称扩展查询.</p>
</li>
<li>
<p>通过使用手动定义的查询</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可用选项取决于实际存储. 但是,必须有一种策略可以决定要创建的实际查询. 下一节将介绍可用的选项.</p>
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-lookup-strategies"><a class="anchor" href="#repositories.query-methods.query-lookup-strategies"></a>4.4.1. 查询策略</h4>
<div class="paragraph">
<p>以下策略可用于存储库基础结构来解决查询. 使用 XML 配置,您可以通过 <code>query-lookup-strategy</code> 属性在命名空间中配置策略. 对于 Java 配置,可以使用 <code>Enable${store}Repositories</code> 注解的 <code>queryLookupStrategy</code> 属性. 某些数据存储可能不支持某些策略.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CREATE</code> 尝试从查询方法名称构造特定于存储的查询. 通用方法是从方法名称中删除一组给定的前缀,然后解析该方法的其余部分. 您可以在 &#8220;<a href="#repositories.query-methods.query-creation">查询创建</a>&#8221; 中阅读有关查询构造的更多信息.</p>
</li>
<li>
<p><code>USE_DECLARED_QUERY</code> 尝试查找已声明的查询,如果找不到则抛出异常. 该查询可以通过某处的注解定义,也可以通过其他方式声明. 请查阅特定存储的文档以找到该存储方式的可用选项. 如果在查询时找不到该方法的声明查询,则它将失败.</p>
</li>
<li>
<p><code>CREATE_IF_NOT_FOUND</code> (默认) 结合 <code>CREATE</code> 和 <code>USE_DECLARED_QUERY</code>. 它首先查找一个声明的查询,如果找不到声明的查询,它将创建一个基于名称的自定义方法查询. 这是默认的查找策略,因此,如果未显式配置任何内容,则使用该策略. 它允许通过方法名称快速定义查询,也可以通过根据需要引入已声明的查询来自定义调整这些查询.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-creation"><a class="anchor" href="#repositories.query-methods.query-creation"></a>4.4.2. 查询创建</h4>
<div class="paragraph">
<p>Spring Data 内置的查询机制对于在存储库实体上构建查询约束很有用. 该机制的前缀  <code>find…By</code>, <code>read…By</code>, <code>query…By</code>, <code>count…By</code>, 和 <code>get…By</code> 从所述方法和开始解析它的其余部分. <code>Introduction</code> 子句可以包含其他表达式,
例如,<code>Distinct</code> 以在要创建的查询上设置不同的标志. 但是,第一个 <code>By</code> 充当分隔符以指示实际查询的开始. 在此级别上,您可以定义实体属性的条件,并将其与 <code>And</code> 和 <code>Or</code> 串联 . 下面的示例演示如何创建许多查询:</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. 从方法名查询创建</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, Long&gt; {

  List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

  // Enables the distinct flag for the query
  List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
  List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);

  // Enabling ignoring case for an individual property
  List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);
  // Enabling ignoring case for all suitable properties
  List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);

  // Enabling static ORDER BY for a query
  List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);
  List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>解析查询方法的名称分为主题和断言.第一部分  (<code>find…By</code>, <code>exists…By</code>)  定义查询的主题,第二部分形成断言.
Introduction子句 (主题) 可以包含其他表达式. 任何在 <code>find</code> (或其他 introducing 关键字) 和 <code>By</code> 之间的任何文本都被视为描述性语句,除非使用结果限制关键字之一 (例如,<code>Distinct</code> ) 在要创建的查询上设置 distinct 的标记,或者 <a href="#repositories.limit-query-result"><code>Top</code>/<code>First</code>  以限制查询结果</a>.</p>
</div>
<div class="paragraph">
<p>附录包含 <a href="#appendix.query.method.subject">查询方法主题关键字的完整列表</a> 和 <a href="#appendix.query.method.predicate">包括排序和字母大小写修饰符的查询方法断言关键字</a>.
但是,第一个 <code>By</code> 充当分隔符,以指示实际标准断言的开始. 在此基础上,您可以定义实体属性的条件,并将其与 <code>And</code> 和 <code>Or</code> 连接起来.</p>
</div>
<div class="paragraph">
<p>解析该方法的实际结果取决于您为其创建查询的持久性存储. 但是,需要注意一些一般事项:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>表达式通常是属性遍历,并带有可串联的运算符.  您可以将属性表达式与 <code>AND</code> 和 <code>OR</code> 结合使用.  您还将获得属性表达式的支持,例如 <code>between</code>,<code>LessThan</code>,<code>GreaterThan</code> 和 <code>Like</code>.  支持的运算符可能因数据存储而异,因此请参考参考文档的相应部分.</p>
</li>
<li>
<p>方法解析器支持为单个属性 (例如,<code>findByLastnameIgnoreCase(…)</code>) 或支持忽略大小写的类型的所有属性 (通常为 <code>String</code> 实例,例如, <code>findByLastnameAndFirstnameAllIgnoreCase(…)</code>) 设置 <code>IgnoreCase</code> 标志.  是否支持忽略大小写可能因存储而异,因此请参考参考文档中有关存储特定查询方法的相关部分.</p>
</li>
<li>
<p>您可以通过将 <code>OrderBy</code> 子句附加到引用属性的查询方法并提供排序方向 (<code>Asc</code> 或 <code>Desc</code>) 来应用静态排序.  要创建支持动态排序的查询方法,请参见 &#8220;<a href="#repositories.special-parameters">特殊参数处理</a>&#8221;.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-property-expressions"><a class="anchor" href="#repositories.query-methods.query-property-expressions"></a>4.4.3. 属性表达式</h4>
<div class="paragraph">
<p>如上例所示,属性表达式只能引用实体的直接属性.  在查询创建时,您需要确保已解析的属性是被管理 domain 类的属性.  但是,您也可以通过遍历嵌套属性来定义约束.  考虑以下方法签名:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;Person&gt; findByAddressZipCode(ZipCode zipCode);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设一个 <code>Person</code> (人) 的 <code>Address</code> (地址) 带有 <code>ZipCode</code> (邮政编码).  在这种情况下,该方法将创建遍历属性 <code>x.address.zipCode</code>.  解析算法首先将整个部分 (<code>AddressZipCode</code>) 解释为属性,然后在 domain 类中检查具有该名称的属性 (未大写) .
如果算法成功,它将使用该属性.  如果不是,该算法将按驼峰解析为头和尾,并尝试找到对应的属性,在我们的示例中为 <code>AddressZip</code> 和 <code>Code</code>.  如果该算法找到了具有该头部的属性,则它将采用该头部,并继续从那里开始构建,以刚才描述的方式将尾部向上拆分.  如果第一个拆分不匹配,则算法会将拆分点移到左侧 (<code>Address</code>, <code>ZipCode</code>) 并继续.</p>
</div>
<div class="paragraph">
<p>尽管这在大多数情况下应该可行,但是算法可能会选择错误的属性.  假设 <code>Person</code> 类也具有 <code>addressZip</code> 属性.  该算法将在第一轮拆分中匹配,选择错误的属性,然后失败 (因为 <code>addressZip</code> 的类型可能没有 <code>code</code> 属性) .</p>
</div>
<div class="paragraph">
<p>要解决这种歧义,您可以在方法名称中使用 <code>_</code> 手动定义遍历点.  因此,我们的方法名称如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;Person&gt; findByAddress_ZipCode(ZipCode zipCode);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因为我们将下划线字符视为保留字符,所以我们强烈建议您遵循以下标准 Java 命名约定 (即,在属性名称中不使用下划线,而使用驼峰大小写) .</p>
</div>
</div>
<div class="sect3">
<h4 id="repositories.special-parameters"><a class="anchor" href="#repositories.special-parameters"></a>4.4.4. 特殊参数处理</h4>
<div class="paragraph">
<p>要处理查询中的参数,请定义方法参数,如前面的示例所示.  除此之外,基本架构还可以识别某些特定类型,例如 <code>Pageable</code> 和 <code>Sort</code>,以将分页和排序动态应用于您的查询.  以下示例演示了这些功能:</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. 在查询方法中使用 <code>Pageable</code>, <code>Slice</code>, 和 <code>Sort</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);

Slice&lt;User&gt; findByLastname(String lastname, Pageable pageable);

List&lt;User&gt; findByLastname(String lastname, Sort sort);

List&lt;User&gt; findByLastname(String lastname, Pageable pageable);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
采用 <code>Sort</code> 和 <code>Pageable</code> 的 API 期望将非 <code>null</code> 值传递到方法中.  如果您不想应用任何排序或分页,请使用 <code>Sort.unsorted()</code> 和 <code>Pageable.unpaged()</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>第一种方法使您可以将 <code>org.springframework.data.domain.Pageable</code> 实例传递给查询方法,以将分页动态添加到静态定义的查询中.  页面知道可用元素和页面的总数.  它是通过基础结构触发计数查询来计算总数来实现的.
由于这可能很耗时 (取决于所使用的存储) ,因此您可以返回一个 <code>Slice</code>.  切片仅知道下一个切片是否可用,当遍历较大的结果集时这可能就足够了.</p>
</div>
<div class="paragraph">
<p>排序选项也通过 <code>Pageable</code> 实例处理.  如果只需要排序,则将 <code>org.springframework.data.domain.Sort</code> 参数添加到您的方法中.  如您所见,返回列表也是可能的.  在这种情况下,将不会创建构建实际的 <code>Page</code> 实例所需的其他元数据 (这反过来意味着不会发出本来必要的其他计数查询) .  而是,它将查询限制为仅查找给定范围的实体.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
要找出整个查询可获得多少页,您必须触发其他计数查询.  默认情况下,此查询扩展自您实际触发的查询.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="repositories.paging-and-sorting"><a class="anchor" href="#repositories.paging-and-sorting"></a>Paging 和 Sorting</h5>
<div class="paragraph">
<p>可以使用属性名称定义简单的排序表达式.  可以将表达式连接起来,以将多个条件收集到一个表达式中.</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. 定义排序表达式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Sort sort = Sort.by("firstname").ascending()
  .and(Sort.by("lastname").descending());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于排序表达式的类型安全性更高的方法,请从该类型开始为定义排序表达式,然后使用方法引用来定义要进行排序的属性.</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. 使用类型安全的 API 定义排序表达式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TypedSort&lt;Person&gt; person = Sort.sort(Person.class);

TypedSort&lt;Person&gt; sort = person.by(Person::getFirstname).ascending()
  .and(person.by(Person::getLastname).descending());</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>TypedSort.by(…)</code> 通过 (通常) 使用 CGlib 来使用运行时代理,这在使用 Graal VM Native 等工具时可能会影响本地镜像的编译.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您的存储实现支持 Querydsl,则还可以使用生成的元模型类型来定义排序表达式:</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. 使用Querydsl API定义排序表达式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">QSort sort = QSort.by(QPerson.firstname.asc())
  .and(QSort.by(QPerson.lastname.desc()));</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.limit-query-result"><a class="anchor" href="#repositories.limit-query-result"></a>4.4.5. 限制查询结果</h4>
<div class="paragraph">
<p>可以通过使用 <code>first</code> 或 <code>top</code> 关键字来限制查询方法的结果,这些关键字可以互换使用.  可以在 <code>top</code> 或 <code>first</code>  附加可选的数值,以指定要返回的最大结果大小.  如果省略数字,则假定结果大小为 <code>1</code>.  以下示例显示了如何限制查询大小:</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. 使用 <code>first</code> 和 <code>top</code> 限制查询的结果大小</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">User findFirstByOrderByLastnameAsc();

User findTopByOrderByAgeDesc();

Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);

Slice&lt;User&gt; findTop3ByLastname(String lastname, Pageable pageable);

List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);

List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>限制表达式还支持 <code>Distinct</code> 关键字.  另外,对于将结果集限制为一个实例的查询,支持使用 <code>Optional</code> 关键字将结果包装到其中.</p>
</div>
<div class="paragraph">
<p>如果将分页或切片应用于限制查询分页 (以及对可用页面数的计算) ,则会在限制结果内应用分页或切片.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通过使用 <code>Sort</code> 参数将结果限制与动态排序结合使用,可以让您表达对最小的 "K" 元素和对 "K" 的最大元素的查询方法.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.collections-and-iterables"><a class="anchor" href="#repositories.collections-and-iterables"></a>4.4.6. 存储库方法返回集合或可迭代对象</h4>
<div class="paragraph">
<p>返回多个结果的查询方法可以使用标准的 Java <code>Iterable</code>,<code>List</code>,<code>Set</code>.  除此之外,我们还支持返回 Spring Data 的 <code>Streamable</code>,<code>Iterable</code> 的自定义扩展以及  <a href="https://www.vavr.io/">Vavr</a> 提供的集合类型.请参阅附录,了解所有可能的 <a href="#appendix.query.return.types">查询方法返回类型</a>.</p>
</div>
<div class="sect4">
<h5 id="repositories.collections-and-iterables.streamable"><a class="anchor" href="#repositories.collections-and-iterables.streamable"></a>使用 Streamable 作为查询方法返回类型</h5>
<div class="paragraph">
<p><code>Streamable</code> 可用作 <code>Iterable</code> 或任何集合类型的替代.  它提供了方便的方法来访问非并行流 (缺少 <code>Iterable</code>) ,可以直接在元素上进行  <code>….filter(…)</code> 和  <code>….map(…)</code> 并将 <code>Streamable</code> 连接到其他元素:</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. 使用 Streamable 合并查询方法结果</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, Long&gt; {
  Streamable&lt;Person&gt; findByFirstnameContaining(String firstname);
  Streamable&lt;Person&gt; findByLastnameContaining(String lastname);
}

Streamable&lt;Person&gt; result = repository.findByFirstnameContaining("av")
  .and(repository.findByLastnameContaining("ea"));</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="repositories.collections-and-iterables.streamable-wrapper"><a class="anchor" href="#repositories.collections-and-iterables.streamable-wrapper"></a>返回自定义 Streamable 包装器类型</h5>
<div class="paragraph">
<p>为集合提供专用的包装器类型是一种常用的模式,用于在返回多个元素的查询执行结果上提供 API.  通常,这些类型是通过调用存储库方法来返回类似集合的类型并手动创建包装类型的实例来使用的.  如果 Spring Data 满足以下条件,则可以将这些包装器类型用作查询方法返回类型,因此可以避免执行附加步骤:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>该类型实现 <code>Streamable</code>.</p>
</li>
<li>
<p>该类型以  <code>Streamable</code> 作为参数暴露构造函数或名为 <code>of(…)</code> 或 <code>valueOf(…)</code> 的静态工厂方法.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>示例用例如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Product {                                         <i class="conum" data-value="1"></i><b>(1)</b>
  MonetaryAmount getPrice() { … }
}

@RequiredArgConstructor(staticName = "of")
class Products implements Streamable&lt;Product&gt; {         <i class="conum" data-value="2"></i><b>(2)</b>

  private Streamable&lt;Product&gt; streamable;

  public MonetaryAmount getTotal() {                    <i class="conum" data-value="3"></i><b>(3)</b>
    return streamable.stream()
      .map(Priced::getPrice)
      .reduce(Money.of(0), MonetaryAmount::add);
  }


  @Override
  public Iterator&lt;Product&gt; iterator() {                 <i class="conum" data-value="4"></i><b>(4)</b>
    return streamable.iterator();
  }
}

interface ProductRepository implements Repository&lt;Product, Long&gt; {
  Products findAllByDescriptionContaining(String text); <i class="conum" data-value="5"></i><b>(5)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>暴露 API 以访问产品价格的 <code>Product</code> 实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>可以通过 <code>Products.of(…)</code>  (通过 Lombok 注解创建的工厂方法) 构造的 <code>Streamable&lt;Product&gt;</code>  的包装器类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>包装器类型在 <code>Streamable&lt;Product&gt;</code> 上暴露其他用于计算新值的API.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>实现 <code>Streamable</code> 接口并且委托给实际结果.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>该包装器类型 <code>Products</code> 可以直接用作查询方法返回类型.  无需返回  <code>Stremable&lt;Product&gt;</code>  并在查询之后将其手动包装在存储库客户端中.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="repositories.collections-and-iterables.vavr"><a class="anchor" href="#repositories.collections-and-iterables.vavr"></a>支持 Vavr 集合</h5>
<div class="paragraph">
<p><a href="https://www.vavr.io/">Vavr</a> 是一个包含 Java 中函数式编程概念的库. 它附带一组可作为查询方法返回类型使用的自定义集合类型.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Vavr 集合类型</th>
<th class="tableblock halign-left valign-top">使用 Vavr 实现类型</th>
<th class="tableblock halign-left valign-top">验证 Java source 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.Seq</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.List</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Iterable</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.Set</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.LinkedHashSet</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Iterable</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.Map</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.LinkedHashMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>第一列中的类型 (或其子类型) 可以用作查询方法返回类型,并将根据实际查询结果的 Java 类型 (第三列) 获取第二列中的类型作为实现类型.  或者,可以声明 <code>Traversable</code> (等效于 Vavr <code>Iterable</code>) ,然后从实际返回值扩展实现类,即 <code>java.util.List</code> 将变成 Vavr  <code>List</code>/<code>Seq</code>,而 <code>java.util.Set</code> 变为Vavr <code>LinkedHashSet</code>/<code>Set</code> 等</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.nullability"><a class="anchor" href="#repositories.nullability"></a>4.4.7. 存储库方法的空处理</h4>
<div class="paragraph">
<p>从 Spring Data 2.0 开始,返回单个聚合实例的存储库 CRUD 方法使用 Java 8 的 <code>Optional</code> 来指示可能缺少值.  除此之外,Spring Data 支持在查询方法上返回以下包装器类型:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.google.common.base.Optional</code></p>
</li>
<li>
<p><code>scala.Option</code></p>
</li>
<li>
<p><code>io.vavr.control.Option</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另外,查询方法可以选择不使用包装器类型.  然后,通过返回 <code>null</code> 指示查询结果不存在.  保证返回集合,集合替代项,包装器和流的存储库方法永远不会返回 <code>null</code>,而是会返回相应的空表示形式.
有关详细信息,请参见 &#8220;<a href="#repository-query-return-types">存储库查询返回类型</a>&#8221; .</p>
</div>
<div class="sect4">
<h5 id="repositories.nullability.annotations"><a class="anchor" href="#repositories.nullability.annotations"></a>可空性注解</h5>
<div class="paragraph">
<p>您可以使用 <a href="http://docs.jcohy.com/zh-cn/spring-framework/5.2.12.RELEASE/spring-framework-reference/index.html/core.html#null-safety">Spring Framework 的可空性注解</a> 来表达存储库方法的可空性约束.  它们提供了一种工具友好的方法,并在运行时提供了选择加入的 <code>null</code> 检查,如下所示:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.2.12.RELEASE/javadoc-api/org/springframework/lang/NonNullApi.html"><code>@NonNullApi</code></a>: 在包级别用于声明参数和返回值的默认行为是不为空值.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.2.12.RELEASE/javadoc-api/org/springframework/lang/NonNull.html"><code>@NonNull</code></a>:用于不为空的参数或返回值 (<code>@NonNullApi</code> 适用的参数和返回值不需要) .</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.2.12.RELEASE/javadoc-api/org/springframework/lang/Nullable.html"><code>@Nullable</code></a>: 用于可以为空的参数或返回值.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring 注解使用 <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a> 注解进行元注解.  JSR 305 元注解使工具供应商 (如  <a href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html">IDEA</a>,
<a href="https://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm">Eclipse</a> 和 <a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">Kotlin</a> ) 以通用方式提供了空安全支持,而不必对 Spring 注解进行硬编码支持.
要对查询方法的可空性约束进行运行时检查,您需要使用 <code>package-info.java</code> 中的 Spring 的 <code>@NonNullApi</code> 在包级别激活非可空性,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. 在 <code>package-info.java</code> 中声明不可为空</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@org.springframework.lang.NonNullApi
package com.acme;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦设置了非 null 默认值,就可以在运行时验证存储库查询方法的调用是否具有可空性约束.  如果查询执行结果违反了定义的约束,则会引发异常.  当方法将返回 <code>null</code> 但被声明为不可为 <code>null</code> 时 (在存储库所在的包中定义了注解的默认值) ,就会发生这种情况.  如果要再次选择接受可为空的结果,请在各个方法上有选择地使用 <code>@Nullable</code>.
使用本节开头提到的结果包装器类型可以按预期继续工作: 将空结果转换为表示缺少的值.</p>
</div>
<div class="paragraph">
<p>下面的示例显示了刚才描述的许多技术:</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. 使用不同的可空性约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.acme;                                                       <i class="conum" data-value="1"></i><b>(1)</b>

import org.springframework.lang.Nullable;

interface UserRepository extends Repository&lt;User, Long&gt; {

  User getByEmailAddress(EmailAddress emailAddress);                    <i class="conum" data-value="2"></i><b>(2)</b>

  @Nullable
  User findByEmailAddress(@Nullable EmailAddress emailAdress);          <i class="conum" data-value="3"></i><b>(3)</b>

  Optional&lt;User&gt; findOptionalByEmailAddress(EmailAddress emailAddress); <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>存储库位于我们上面定义的非空的包 (或子包) 中.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>当执行的查询未产生结果时,抛出 <code>EmptyResultDataAccessException</code>.  当传递给该方法的 <code>emailAddress</code> 为 <code>null</code> 时,抛出 <code>IllegalArgumentException</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>当执行的查询不产生结果时,返回 <code>null</code>.  还接受 <code>null</code> 作为 <code>emailAddress</code> 的值.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>当执行的查询不产生结果时,返回 <code>Optional.empty()</code>.  当传递给该方法的 <code>emailAddress</code> 为 <code>null</code> 时,抛出 <code>IllegalArgumentException</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="repositories.nullability.kotlin"><a class="anchor" href="#repositories.nullability.kotlin"></a>基于 Kotlin 的存储库中的可空性</h5>
<div class="paragraph">
<p>Kotlin 定义了语言中包含的 <a href="https://kotlinlang.org/docs/reference/null-safety.html">可空性约束</a> .  Kotlin 代码编译为字节码,字节码不通过方法签名来表达可空性约束,而是通过内置的元数据来表达.  请确保在您的项目中包含 <code>kotlin-reflect</code> 的JAR,以对 Kotlin 的可空性约束进行自省.  Spring Data 存储库使用语言机制来定义这些约束以应用相同的运行时检查,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. 在 Kotlin repository 上使用可空性约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">interface UserRepository : Repository&lt;User, String&gt; {

  fun findByUsername(username: String): User     <i class="conum" data-value="1"></i><b>(1)</b>

  fun findByFirstname(firstname: String?): User? <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>该方法将参数和结果都定义为不可为空 (Kotlin 默认值) .  Kotlin 编译器拒绝将 <code>null</code> 传递给方法的方法调用.  如果查询执行产生空结果,则抛出 <code>EmptyResultDataAccessException</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>此方法的 <code>firstname</code> 参数接受 <code>null</code>,如果查询执行未产生结果,则返回 <code>null</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-streaming"><a class="anchor" href="#repositories.query-streaming"></a>4.4.8. 流查询结果</h4>
<div class="paragraph">
<p>可以使用 Java 8 <code>Stream&lt;T&gt;</code> 作为返回类型来递增地处理查询方法的结果.  并非将查询结果包装在 <code>Stream</code> 中,而是使用特定于数据存储的方法来执行流传输,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. 用Java 8  <code>Stream&lt;T&gt;</code> 流查询的结果</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Query("select u from User u")
Stream&lt;User&gt; findAllByCustomQueryAndStream();

Stream&lt;User&gt; readAllByFirstnameNotNull();

@Query("select u from User u")
Stream&lt;User&gt; streamAllPaged(Pageable pageable);</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Stream</code> 可能包装了特定于底层数据存储的资源,因此必须在使用后关闭.  您可以使用 <code>close()</code> 方法或使用 Java 7 <code>try-with-resources</code> 块来手动关闭 <code>Stream</code>,如以下示例所示:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 24. 使用 <code>Stream&lt;T&gt;</code> 会导致 try-with-resources 块</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) {
  stream.forEach(…);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当前,并非所有的 Spring Data 模块都支持 <code>Stream&lt;T&gt;</code> 作为返回类型.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-async"><a class="anchor" href="#repositories.query-async"></a>4.4.9. 异步查询结果</h4>
<div class="paragraph">
<p>使用  <a href="http://docs.jcohy.com/zh-cn/spring-framework/5.2.12.RELEASE/spring-framework-reference/index.html/integration.html#scheduling">Spring 的异步方法执行功能</a>,可以异步运行存储库查询.  这意味着该方法在调用时立即返回,而实际查询执行发生在已提交给 Spring <code>TaskExecutor</code> 的任务中.  异步查询执行与响应式查询执行不同,因此不应混为一谈.  有关响应式支持的更多详细信息,请参阅存储特定的文档.  以下示例显示了许多异步查询:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Async
Future&lt;User&gt; findByFirstname(String firstname);               <i class="conum" data-value="1"></i><b>(1)</b>

@Async
CompletableFuture&lt;User&gt; findOneByFirstname(String firstname); <i class="conum" data-value="2"></i><b>(2)</b>

@Async
ListenableFuture&lt;User&gt; findOneByLastname(String lastname);    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>java.util.concurrent.Future</code> 作为返回类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 Java 8 <code>java.util.concurrent.CompletableFuture</code> 作为返回类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用 <code>org.springframework.util.concurrent.ListenableFuture</code> 作为返回类型.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.create-instances"><a class="anchor" href="#repositories.create-instances"></a>4.5. 创建存储库实例</h3>
<div class="paragraph">
<p>在本部分中,将为已定义的存储库接口创建实例和 Bean 定义.  一种方法是使用支持存储库机制的每个 Spring Data 模块随附的 Spring 命名空间,尽管我们通常建议使用 Java 配置.</p>
</div>
<div class="sect3">
<h4 id="repositories.create-instances.spring"><a class="anchor" href="#repositories.create-instances.spring"></a>4.5.1. XML 配置</h4>
<div class="paragraph">
<p>每个 Spring Data 模块都包含一个 <code>repositories</code> 元素,可用于定义 Spring 为其扫描的基本包,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. 通过 XML 启用 Spring Data repository</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://www.springframework.org/schema/data/jpa"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    https://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

  &lt;repositories base-package="com.acme.repositories" /&gt;

&lt;/beans:beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中,指示 Spring 扫描 <code>com.acme.repositories</code> 及其所有子包,以查找扩展 <code>Repository</code> 的接口或其子接口之一.  对于找到的每个接口,基础结构都会注册持久性技术特定的 <code>FactoryBean</code>,以创建处理查询方法调用的适当代理.
每个 bean 都使用从接口名称扩展的 bean 名称进行注册,因此 <code>UserRepository</code> 的接口将注册在 <code>userRepository</code> 下.  <code>base-package</code> 属性允许使用通配符,以便您可以定义扫描程序包的模式.</p>
</div>
<div class="sect4">
<h5 id="repositories.using-filters"><a class="anchor" href="#repositories.using-filters"></a>使用过滤器</h5>
<div class="paragraph">
<p>默认情况下,Spring Data 会自动扫描配置路径下的 <code>Repository</code> 子接口的每个接口,并为其创建一个 bean 实例.  但是,您可能希望更精细地控制哪些接口具有为其创建的 Bean 实例.
为此,请在 <code>&lt;repositories /&gt;</code> 元素内使用 <code>&lt;include-filter /&gt;</code> 和 <code>&lt;exclude-filter /&gt;</code> 元素.  语义完全等同于 Spring 的上下文命名空间中的元素.  有关详细信息,请参见这些元素的 <a href="http://docs.jcohy.com/zh-cn/spring-framework/5.2.12.RELEASE/spring-framework-reference/index.html/core.html#beans-scanning-filters">Spring 参考文档</a> .</p>
</div>
<div class="paragraph">
<p>例如,要将某些接口从实例中排除为存储库 Bean,可以使用以下配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. 使用 exclude-filter 元素</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repositories"&gt;
  &lt;context:exclude-filter type="regex" expression=".*SomeRepository" /&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例将所有以 <code>SomeRepository</code> 结尾的接口都排除在实例化之外.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.create-instances.java-config"><a class="anchor" href="#repositories.create-instances.java-config"></a>4.5.2. Java 配置</h4>
<div class="paragraph">
<p>还可以在 JavaConfig 类上使用特定于存储的 <code>@Enable${store}Repositories</code>  注解来触发存储库基础架构.  有关 Spring 容器的基于 Java 的配置的介绍,请参见 <a href="http://docs.jcohy.com/zh-cn/spring-framework/5.2.12.RELEASE/spring-framework-reference/index.html/core.html#beans-java">Spring 参考文档中的 JavaConfig</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. 基于注解的存储卡示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJpaRepositories("com.acme.repositories")
class ApplicationConfiguration {

  @Bean
  EntityManagerFactory entityManagerFactory() {
    // …
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
前面的示例使用特定于 JPA 的注解,您将根据实际使用的存储模块对其进行更改.  这同样适用于 <code>EntityManagerFactory</code> bean 的定义.  请参阅涵盖存储特定配置的部分.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.create-instances.standalone"><a class="anchor" href="#repositories.create-instances.standalone"></a>4.5.3. 独立使用</h4>
<div class="paragraph">
<p>您还可以在 Spring 容器之外使用存储库基础结构,例如在 CDI 环境中.  您的类路径中仍然需要一些 Spring 库,但是,通常,您也可以通过编程方式来设置存储库.  提供存储库支持的 Spring Data 模块附带了特定于持久性技术的 <code>RepositoryFactory</code>,您可以按以下方式使用它:</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. repository 工厂的独立使用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RepositoryFactorySupport factory = … // Instantiate factory here
UserRepository repository = factory.getRepository(UserRepository.class);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.custom-implementations"><a class="anchor" href="#repositories.custom-implementations"></a>4.6. Spring Data 存储库的自定义实现</h3>
<div class="paragraph">
<p>本节介绍存储库定制以及片段如何形成复合存储库.</p>
</div>
<div class="paragraph">
<p>当查询方法需要不同的行为或无法通过查询扩展实现时,则有必要提供自定义实现.  Spring Data 存储库使您可以提供自定义存储库代码,并将其与通用 CRUD 抽象和查询方法功能集成.</p>
</div>
<div class="sect3">
<h4 id="repositories.single-repository-behavior"><a class="anchor" href="#repositories.single-repository-behavior"></a>4.6.1. 自定义单个存储库</h4>
<div class="paragraph">
<p>要使用自定义功能丰富存储库,必须首先定义一个接口和自定义功能的实现,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. 定制 repository 功能的接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface CustomizedUserRepository {
  void someCustomMethod(User user);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 30. 自定义存储库功能的实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class CustomizedUserRepositoryImpl implements CustomizedUserRepository {

  public void someCustomMethod(User user) {
    // Your custom implementation
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
与这个接口相对应的类名称中最重要的部分是 <code>Impl</code> 后缀.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>实现本身不依赖于 Spring Data,可以是常规的 Spring bean.  因此,您可以使用标准的依赖注入行为来注入对其他 bean (例如 <code>JdbcTemplate</code>) 的引用,参与各个方面,等等.</p>
</div>
<div class="paragraph">
<p>然后,可以让您的存储库接口扩展此接口,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. 更改您的存储库接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt;, CustomizedUserRepository {

  // Declare query methods here
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>用存储库接口扩展此接口,将 CRUD 和自定义功能结合在一起,并使它可用于客户端.</p>
</div>
<div class="paragraph">
<p>Spring Data 存储库是通过使用构成存储库组成的片段来实现的.  片段是基础存储库,功能方面 (例如 <a href="#core.extensions.querydsl">QueryDsl</a>) 以及自定义接口及其实现.  每次向存储库接口添加接口时,都通过添加片段来增强组合.  每个 Spring Data 模块都提供了基础存储库和存储库方面的实现.</p>
</div>
<div class="paragraph">
<p>以下示例显示了自定义接口及其实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. 片段及其实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface HumanRepository {
  void someHumanMethod(User user);
}

class HumanRepositoryImpl implements HumanRepository {

  public void someHumanMethod(User user) {
    // Your custom implementation
  }
}

interface ContactRepository {

  void someContactMethod(User user);

  User anotherContactMethod(User user);
}

class ContactRepositoryImpl implements ContactRepository {

  public void someContactMethod(User user) {
    // Your custom implementation
  }

  public User anotherContactMethod(User user) {
    // Your custom implementation
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了扩展 <code>CrudRepository</code> 的自定义存储库的接口:</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. 更改您的存储库接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt;, HumanRepository, ContactRepository {

  // Declare query methods here
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>存储库可能由多个自定义实现组成,这些自定义实现按其声明顺序导入.  自定义实现比基础实现和存储库方面的优先级更高.  通过此顺序,您可以覆盖基础存储库和方面方法,并在两个片段贡献相同方法签名的情况下解决歧义.
存储库片段不限于在单个存储库界面中使用.  多个存储库可以使用片段接口,使您可以跨不同的存储库重用自定义项.</p>
</div>
<div class="paragraph">
<p>以下示例显示了存储库片段及其实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. 覆盖 Fragments <code>save(…)</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface CustomizedSave&lt;T&gt; {
  &lt;S extends T&gt; S save(S entity);
}

class CustomizedSaveImpl&lt;T&gt; implements CustomizedSave&lt;T&gt; {

  public &lt;S extends T&gt; S save(S entity) {
    // Your custom implementation
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了使用上述存储库片段的存储库:</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. 定制的存储库接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt;, CustomizedSave&lt;User&gt; {
}

interface PersonRepository extends CrudRepository&lt;Person, Long&gt;, CustomizedSave&lt;Person&gt; {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="repositories.configuration"><a class="anchor" href="#repositories.configuration"></a>配置</h5>
<div class="paragraph">
<p>如果使用命名空间配置,则存储库基础结构会尝试通过扫描发现存储库的包下方的类来自动检测自定义实现片段.  这些类需要遵循将命名空间元素的 <code>repository-impl-postfix</code> 属性附加到片段接口名称的命名约定.  此后缀默认为 <code>Impl</code>.  以下示例显示了使用默认后缀的存储库和为后缀设置自定义值的存储库:</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. 配置示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repository" /&gt;

&lt;repositories base-package="com.acme.repository" repository-impl-postfix="MyPostfix" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上一示例中的第一个配置尝试查找一个名为 <code>com.acme.repository.CustomizedUserRepositoryImpl</code> 的类,以用作自定义存储库实现.  第二个示例尝试查找 <code>com.acme.repository.CustomizedUserRepositoryMyPostfix</code>.</p>
</div>
<div class="sect5">
<h6 id="repositories.single-repository-behaviour.ambiguity"><a class="anchor" href="#repositories.single-repository-behaviour.ambiguity"></a>解决歧义</h6>
<div class="paragraph">
<p>如果在不同的包中找到具有匹配类名的多个实现,Spring Data 将使用 Bean 名称来标识要使用的那个.</p>
</div>
<div class="paragraph">
<p>给定前面显示的 <code>CustomizedUserRepository</code> 的以下两个自定义实现,将使用第一个实现.  它的 bean 名称是 <code>customizedUserRepositoryImpl</code>,它与片段接口 (<code>CustomizedUserRepository</code>) 加上后缀 <code>Impl</code> 的名称匹配.</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. 解决歧义的实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.acme.impl.one;

class CustomizedUserRepositoryImpl implements CustomizedUserRepository {

  // Your custom implementation
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.acme.impl.two;

@Component("specialCustomImpl")
class CustomizedUserRepositoryImpl implements CustomizedUserRepository {

  // Your custom implementation
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用 <code>@Component("specialCustom")</code> 注解 <code>UserRepository</code> 接口,则 Bean 名称加 <code>Impl</code> 会与 <code>com.acme.impl.two</code> 中为存储库实现匹配定义一个,并使用它代替第一个.</p>
</div>
</div>
<div class="sect5">
<h6 id="repositories.manual-wiring"><a class="anchor" href="#repositories.manual-wiring"></a>手动织入</h6>
<div class="paragraph">
<p>如果您的自定义实现仅使用基于注解的配置和自动装配,则 <a href="#repositories.single-repository-behaviour.ambiguity">上述</a>显示的方法会很好地起作用,因为它被视为其他任何 Spring Bean.
如果实现片段 bean 需要特殊的拼接,则可以声明 bean 并根据上一节中描述的约定对其进行命名.  然后,基础结构通过名称引用手动定义的 bean 定义,而不是自己创建一个.  以下示例显示如何手动连接自定义实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 38. 手动织入自定义实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repository" /&gt;

&lt;beans:bean id="userRepositoryImpl" class="…"&gt;
  &lt;!-- further configuration --&gt;
&lt;/beans:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.customize-base-repository"><a class="anchor" href="#repositories.customize-base-repository"></a>4.6.2. 自定义基础存储库</h4>
<div class="paragraph">
<p>当您要自定义基本存储库行为时,<a href="#repositories.manual-wiring">上一节</a>  中描述的方法需要自定义每个存储库接口,以使所有存储库均受到影响.  要改为更改所有存储库的行为,您可以创建一个实现,以扩展特定于持久性技术的存储库基类.
然后,该类充当存储库代理的自定义基类,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 39. 定制存储库基类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class MyRepositoryImpl&lt;T, ID&gt;
  extends SimpleJpaRepository&lt;T, ID&gt; {

  private final EntityManager entityManager;

  MyRepositoryImpl(JpaEntityInformation entityInformation,
                          EntityManager entityManager) {
    super(entityInformation, entityManager);

    // Keep the EntityManager around to used from the newly introduced methods.
    this.entityManager = entityManager;
  }

  @Transactional
  public &lt;S extends T&gt; S save(S entity) {
    // implementation goes here
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
该类需要具有特定于存储库的存储库工厂实现使用的父类的构造函数.  如果存储库父类具有多个构造函数,则覆盖一个采用 <code>EntityInformation</code> 加上存储特定基础结构对象 (例如 <code>EntityManager</code> 或模板类) 的构造函数.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后一步是使 Spring Data 基础结构了解定制的存储库基类.  在 Java 配置中,可以通过使用 <code>@Enable${store}Repositories</code> 注解的 <code>repositoryBaseClass</code> 属性来实现,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. 使用JavaConfig配置自定义存储库基类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)
class ApplicationConfiguration { … }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>XML 命名空间中有相应的属性,如下例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. 使用XML配置自定义存储库基类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repository"
     base-class="….MyRepositoryImpl" /&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core.domain-events"><a class="anchor" href="#core.domain-events"></a>4.7. 从聚合根发布事件</h3>
<div class="paragraph">
<p>由存储库管理的实体是聚合根.  在领域驱动设计应用程序中,这些聚合根通常发布领域事件.  Spring Data 提供了一个称为 <code>@DomainEvents</code> 的注解,您可以在聚合根的方法上使用该注解,可以使发布事件变得简单,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. 从聚合根暴露领域事件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class AnAggregateRoot {

    @DomainEvents <i class="conum" data-value="1"></i><b>(1)</b>
    Collection&lt;Object&gt; domainEvents() {
        // … return events you want to get published here
    }

    @AfterDomainEventPublication <i class="conum" data-value="2"></i><b>(2)</b>
    void callbackMethod() {
       // … potentially clean up domain events list
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>@DomainEvents</code> 的方法可以返回单个事件实例或事件的集合.  它不能接受任何参数.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在发布所有事件之后,我们有一个用 <code>@AfterDomainEventPublication</code> 注解的方法.  它可以用来潜在地清除要发布的事件列表 (以及其他用途) .</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>每次调用 Spring Data Repository <code>save(&#8230;&#8203;)</code> 方法之一时,将调用这些方法.</p>
</div>
</div>
<div class="sect2">
<h3 id="core.extensions"><a class="anchor" href="#core.extensions"></a>4.8. Spring Data 扩展</h3>
<div class="paragraph">
<p>本节记录了一组 Spring Data 扩展,这些扩展可在各种上下文中启用 Spring Data 使用.  当前,大多数集成都针对 Spring MVC.</p>
</div>
<div class="sect3">
<h4 id="core.extensions.querydsl"><a class="anchor" href="#core.extensions.querydsl"></a>4.8.1. Querydsl 扩展</h4>
<div class="paragraph">
<p><a href="http://www.querydsl.com/">Querydsl</a> 是一个框架,可通过其流式的 API 来构造静态类型的类似 SQL 的查询.</p>
</div>
<div class="paragraph">
<p>几个 Spring Data 模块通过 <code>QuerydslPredicateExecutor</code> 与 <code>Querydsl</code> 集成,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. QuerydslPredicateExecutor 接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface QuerydslPredicateExecutor&lt;T&gt; {

  Optional&lt;T&gt; findById(Predicate predicate);  <i class="conum" data-value="1"></i><b>(1)</b>

  Iterable&lt;T&gt; findAll(Predicate predicate);   <i class="conum" data-value="2"></i><b>(2)</b>

  long count(Predicate predicate);            <i class="conum" data-value="3"></i><b>(3)</b>

  boolean exists(Predicate predicate);        <i class="conum" data-value="4"></i><b>(4)</b>

  // … more functionality omitted.
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>查找并返回与 <code>Predicate</code> 匹配的单个实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>查找并返回与 <code>Predicate</code> 匹配的所有实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>返回与 <code>Predicate</code> 匹配的实体数.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>返回与 <code>Predicate</code> 匹配的实体是否存在.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>要使用 Querydsl 支持,请在存储库界面上扩展 <code>QuerydslPredicateExecutor</code>,如以下示例所示</p>
</div>
<div class="exampleblock">
<div class="title">Example 44. repository 上的 Querydsl 集成</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt;, QuerydslPredicateExecutor&lt;User&gt; {
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例使您可以使用 Querydsl  <code>Predicate</code>  实例编写类型安全查询,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Predicate predicate = user.firstname.equalsIgnoreCase("dave")
    .and(user.lastname.startsWithIgnoreCase("mathews"));

userRepository.findAll(predicate);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core.web"><a class="anchor" href="#core.web"></a>4.8.2. Web 支持</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
本部分包含 Spring Data Web 支持的文档,该文档在 Spring Data Commons 的当前 (和更高版本) 中实现.  随着新引入的支持发生了许多变化,我们将以前行为的文档保存在<a href="#web.legacy">[web.legacy]</a>中.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>支持存储库编程模型的 Spring Data 模块附带了各种 Web 支持.  与 Web 相关的组件要求 Spring MVC JAR 位于类路径上.  其中一些甚至提供与 <a href="https://github.com/SpringSource/spring-hateoas">Spring HATEOAS</a>的集成.
通常,通过在 JavaConfig 配置类中使用 <code>@EnableSpringDataWebSupport</code> 注解来启用集成支持,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 45. 启用 Spring Data web 支持</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
@EnableSpringDataWebSupport
class WebConfiguration {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@EnableSpringDataWebSupport</code> 注解注册了一些我们稍后将讨论的组件.  它还将在类路径上检测 Spring HATEOAS,并为其注册集成组件 (如果存在) .</p>
</div>
<div class="paragraph">
<p>另外,如果您使用 XML 配置,则将 <code>SpringDataWebConfiguration</code> 或 <code>HateoasAwareSpringDataWebConfiguration</code> 注册为 Spring Bean,如以下示例所示 (对于 <code>SpringDataWebConfiguration</code>) :</p>
</div>
<div class="exampleblock">
<div class="title">Example 46. 在XML中启用 Spring Data web 支持</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.data.web.config.SpringDataWebConfiguration" /&gt;

&lt;!-- If you use Spring HATEOAS, register this one *instead* of the former --&gt;
&lt;bean class="org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="core.web.basic"><a class="anchor" href="#core.web.basic"></a>Basic Web 支持</h5>
<div class="paragraph">
<p><a href="#core.web">上一节</a> 中显示的配置注册了一些基本组件:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#core.web.basic.domain-class-converter">DomainClassConverter</a> 可让 Spring MVC 从请求参数或路径变量解析存储库管理的 domain 类的实例.</p>
</li>
<li>
<p><a href="#core.web.basic.paging-and-sorting"><code>HandlerMethodArgumentResolver</code></a> 实现,可让 Spring MVC 从请求参数中解析 <code>Pageable</code> 和 <code>Sort</code> 实例.</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="core.web.basic.domain-class-converter"><a class="anchor" href="#core.web.basic.domain-class-converter"></a>使用 <code>DomainClassConverter</code> 类</h6>
<div class="paragraph">
<p><code>DomainClassConverter</code> 允许您直接在 Spring MVC 控制器方法签名中使用 domain 类型,因此您无需通过存储库手动查找实例,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 47. 一个在方法签名中使用 domain 类型的 Spring MVC 控制器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/users")
class UserController {

  @RequestMapping("/{id}")
  String showUserForm(@PathVariable("id") User user, Model model) {

    model.addAttribute("user", user);
    return "userForm";
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见,该方法直接接收 <code>User</code> 实例,不需要进一步的查找.  可以通过让 Spring MVC 首先将路径变量转换为 domain 类的 <code>id</code> 类型并最终通过在为该类型注册的存储库实例上调用 <code>findById(…)</code> 来访问该实例来解析该实例.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当前,该存储库必须实现 <code>CrudRepository</code> 才有资格被发现以进行转换.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="core.web.basic.paging-and-sorting"><a class="anchor" href="#core.web.basic.paging-and-sorting"></a>用于分页和排序的 <code>HandlerMethodArgumentResolvers</code></h6>
<div class="paragraph">
<p><a href="#core.web.basic.domain-class-converter">上一节</a>中显示的配置代码段还注册了 <code>PageableHandlerMethodArgumentResolver</code> 以及 <code>SortHandlerMethodArgumentResolver</code> 的实例.  该注册启用了 <code>Pageable</code> 和 <code>Sort</code> 作为控制器方法参数,如以下示例所示</p>
</div>
<div class="exampleblock">
<div class="title">Example 48. 使用 Pageable 作为控制器方法参数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/users")
class UserController {

  private final UserRepository repository;

  UserController(UserRepository repository) {
    this.repository = repository;
  }

  @RequestMapping
  String showUsers(Model model, Pageable pageable) {

    model.addAttribute("users", repository.findAll(pageable));
    return "users";
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的方法签名使 Spring MVC 尝试使用以下默认配置从请求参数扩展 <code>Pageable</code> 实例:</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 1. 请求为 <code>Pageable</code> 实例评估后的参数</caption>
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>page</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您要检索的页面.  0索引,默认为0.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您要检索的页面大小.  默认为20</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sort</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该以格式属性 <code>property,property(,ASC|DESC)</code> 进行排序的属性.  默认排序方向为升序.  如果要切换排序,请使用多个排序参数. 例如, <code>?sort=firstname&amp;sort=lastname,asc</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要自定义此行为,请注册分别实现 <code>PageableHandlerMethodArgumentResolverCustomizer</code> 接口或 <code>SortHandlerMethodArgumentResolverCustomizer</code> 接口的 bean.  它的 <code>customize()</code> 方法被调用,让您更改设置,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean SortHandlerMethodArgumentResolverCustomizer sortCustomizer() {
    return s -&gt; s.setPropertyDelimiter("&lt;--&gt;");
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果设置现有 <code>MethodArgumentResolver</code> 的属性不足以满足您的目的,请扩展 <code>SpringDataWebConfiguration</code> 或启用 HATEOAS ,重写 <code>pageableResolver()</code> 或 <code>sortResolver()</code> 方法,然后导入自定义的配置文件,而不使用 <code>@Enable</code> 注解.</p>
</div>
<div class="paragraph">
<p>如果您需要从请求中解析多个 <code>Pageable</code> 或 <code>Sort</code> 实例 (例如,对于多个表) ,则可以使用 Spring 的 <code>@Qualifier</code> 注解将一个实例与另一个实例区分开.  然后,请求参数必须以 <code>${qualifier}_</code> 为前缀.  以下示例显示了生成的方法签名:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String showUsers(Model model,
      @Qualifier("thing1") Pageable first,
      @Qualifier("thing2") Pageable second) { … }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您必须填充 <code>thing1_page</code> 和 <code>thing2_page</code>,依此类推.</p>
</div>
<div class="paragraph">
<p>传递给该方法的默认 <code>Pageable</code> 等效于 <code>PageRequest.of(0, 20)</code>,但可以使用 <code>Pageable</code> 参数上的 <code>@PageableDefault</code> 注解注解进行自定义.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="core.web.pageables"><a class="anchor" href="#core.web.pageables"></a>超媒体对页面的支持</h5>
<div class="paragraph">
<p>Spring HATEOAS 附带了一个表示模型类 (<code>PagedResources</code>) ,该类允许使用必要的页面元数据以及链接来丰富 <code>Page</code> 实例的内容,并使客户端可以轻松浏览页面.  <code>Page</code> 到 <code>PagedResources</code> 的转换是通过 Spring HATEOAS <code>ResourceAssembler</code> 接口 (称为 <code>PagedResourcesAssembler</code>) 的实现完成的.  下面的示例演示如何将 <code>PagedResourcesAssembler</code> 用作控制器方法参数:</p>
</div>
<div class="exampleblock">
<div class="title">Example 49. 使用 PagedResourcesAssembler 作为控制器方法参数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
class PersonController {

  @Autowired PersonRepository repository;

  @RequestMapping(value = "/persons", method = RequestMethod.GET)
  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,
    PagedResourcesAssembler assembler) {

    Page&lt;Person&gt; persons = repository.findAll(pageable);
    return new ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如上例中所示启用配置,可以将 <code>PagedResourcesAssembler</code> 用作控制器方法参数.  对其调用  <code>toResources(…)</code> 具有以下效果:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Page</code> 的内容成为 <code>PagedResources</code> 实例的内容.</p>
</li>
<li>
<p><code>PagedResources</code> 对象获取附加的 <code>PageMetadata</code> 实例,并使用 <code>Page</code> 和基础 <code>PageRequest</code> 的信息填充该实例.</p>
</li>
<li>
<p><code>PagedResources</code> 可能会附加上一个和下一个链接,具体取决于页面的状态.  链接指向方法映射到的 URI.  添加到该方法的分页参数与 <code>PageableHandlerMethodArgumentResolver</code> 的设置匹配,以确保以后可以解析链接.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>假设数据库中有 30 个 Person 实例.  现在,您可以触发请求 (<code>GET <a href="http://localhost:8080/persons" class="bare">localhost:8080/persons</a></code> ) ,并查看类似于以下内容的输出:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{ "links" : [ { "rel" : "next",
                "href" : "http://localhost:8080/persons?page=1&amp;size=20 }
  ],
  "content" : [
     … // 20 Person instances rendered here
  ],
  "pageMetadata" : {
    "size" : 20,
    "totalElements" : 30,
    "totalPages" : 2,
    "number" : 0
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您会看到编译器生成了正确的 URI,并且还选择了默认配置以将参数解析为即将到来的请求的 <code>Pageable</code>.  这意味着,如果您更改该配置,则链接将自动遵循更改.  默认情况下,编译器指向调用它的控制器方法,但是可以通过传递自定义链接 (用作构建分页链接的基础) 进行自定义,这会使 <code>PagedResourcesAssembler.toResource(&#8230;&#8203;)</code> 方法过载.</p>
</div>
</div>
<div class="sect4">
<h5 id="core.web.binding"><a class="anchor" href="#core.web.binding"></a>Web 数据绑定支持</h5>
<div class="paragraph">
<p>通过使用 <a href="https://goessner.net/articles/JsonPath/">JSONPath</a> 表达式 (需要 <a href="https://github.com/json-path/JsonPath">Jayway JsonPath</a> 或 <a href="https://www.w3.org/TR/xpath-31/">XPath</a>表达式 (需要 <a href="https://xmlbeam.org/">XmlBeam</a>) ) ,可以使用 Spring Data 投影 (在 <a href="#projections">Projections</a> 中描述) 来绑定传入的请求有效负载,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 50. 使用JSONPath或XPath表达式的HTTP有效负载绑定</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ProjectedPayload
public interface UserPayload {

  @XBRead("//firstname")
  @JsonPath("$..firstname")
  String getFirstname();

  @XBRead("/lastname")
  @JsonPath({ "$.lastname", "$.user.lastname" })
  String getLastname();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面示例中显示的类型可以用作 Spring MVC 处理程序方法参数,也可以通过在 <code>RestTemplate</code> 的方法之一上使用 <code>ParameterizedTypeReference</code> 来使用.  前面的方法声明将尝试在给定文档中的任何位置查找名字.   <code>lastname</code> XML查找是在传入文档的顶层执行的.
JSON 首先尝试使用顶层 <code>lastname</code> ,但是如果前者不返回值,则还尝试嵌套在用户子文档中的 <code>lastname</code> .  这样,无需客户端调用暴露的方法即可轻松缓解源文档结构的更改 (通常是基于类的有效负载绑定的缺点) .</p>
</div>
<div class="paragraph">
<p>如 <a href="#projections">投影</a>中所述,支持嵌套投影.  如果该方法返回复杂的非接口类型,则将使用Jackson <code>ObjectMapper</code> 映射最终值.</p>
</div>
<div class="paragraph">
<p>对于 Spring MVC,<code>@EnableSpringDataWebSupport</code> 处于活动状态并且所需的依赖在类路径上可用后,会自动自动注册必要的转换器.  要与 <code>RestTemplate</code> 一起使用,请手动注册 <code>ProjectingJackson2HttpMessageConverter</code> (JSON)  或 <code>XmlBeamHttpMessageConverter</code>.</p>
</div>
<div class="paragraph">
<p>有关更多信息,请参见规范的 <a href="https://github.com/spring-projects/spring-data-examples">Spring Data Examples repository</a>存储库中的 <a href="https://github.com/spring-projects/spring-data-examples/tree/master/web/projection">web projection example</a> .</p>
</div>
</div>
<div class="sect4">
<h5 id="core.web.type-safe"><a class="anchor" href="#core.web.type-safe"></a>Querydsl Web 支持</h5>
<div class="paragraph">
<p>对于那些具有 <a href="http://www.querydsl.com/">QueryDSL</a> 集成的存储,可以从 · 查询字符串中包含的属性扩展查询.</p>
</div>
<div class="paragraph">
<p>考虑以下查询字符串:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">?firstname=Dave&amp;lastname=Matthews</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>给定前面示例中的 <code>User</code> 对象,可以使用 <code>QuerydslPredicateArgumentResolver</code> 将查询字符串解析为以下值.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">QUser.user.firstname.eq("Dave").and(QUser.user.lastname.eq("Matthews"))</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在类路径上找到 Querydsl 时,将自动启用该功能以及 <code>@EnableSpringDataWebSupport</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>将 <code>@QuerydslPredicate</code> 添加到方法签名中可提供一个现成的 <code>Predicate</code>,可以使用 <code>QuerydslPredicateExecutor</code> 来运行它.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
类型信息通常从方法的返回类型中解析.  由于该信息不一定与 domain 类型匹配,因此使用 <code>QuerydslPredicate</code> 的 <code>root</code> 属性可能是一个好主意.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的示例演示如何在方法签名中使用 <code>@QuerydslPredicate</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
class UserController {

  @Autowired UserRepository repository;

  @RequestMapping(value = "/", method = RequestMethod.GET)
  String index(Model model, @QuerydslPredicate(root = User.class) Predicate predicate,    <i class="conum" data-value="1"></i><b>(1)</b>
          Pageable pageable, @RequestParam MultiValueMap&lt;String, String&gt; parameters) {

    model.addAttribute("users", repository.findAll(predicate, pageable));

    return "index";
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将查询字符串参数解析为与 <code>User</code> <code>Predicate</code> 匹配.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>默认绑定如下:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>简单属性上的对象如 <code>eq</code>.</p>
</li>
<li>
<p>集合上的对象,如 <code>contains</code> 的属性.</p>
</li>
<li>
<p>集合上的对象,如 <code>in</code> 的属性.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以通过 <code>@QuerydslPredicate</code> 的 <code>bindings</code> 属性或通过使用 Java 8 <code>default methods</code> 并将 <code>QuerydslBinderCustomizer</code> 方法添加到存储库接口来自定义那些绑定.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, String&gt;,
                                 QuerydslPredicateExecutor&lt;User&gt;,                <i class="conum" data-value="1"></i><b>(1)</b>
                                 QuerydslBinderCustomizer&lt;QUser&gt; {               <i class="conum" data-value="2"></i><b>(2)</b>

  @Override
  default void customize(QuerydslBindings bindings, QUser user) {

    bindings.bind(user.username).first((path, value) -&gt; path.contains(value))    <i class="conum" data-value="3"></i><b>(3)</b>
    bindings.bind(String.class)
      .first((StringPath path, String value) -&gt; path.containsIgnoreCase(value)); <i class="conum" data-value="4"></i><b>(4)</b>
    bindings.excluding(user.password);                                           <i class="conum" data-value="5"></i><b>(5)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>QuerydslPredicateExecutor</code> 提供对断言的特定查找器方法的访问</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在存储库界面上定义的 <code>QuerydslBinderCustomizer</code> 会被自动提取,并提供 <code>@QuerydslPredicate(bindings=&#8230;&#8203;)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>将 <code>username</code> 属性的绑定定义为简单的 <code>contains</code>  绑定.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>将 <code>String</code> 属性的默认绑定定义为不区分大小写的 <code>contains</code> 匹配项.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>从  <code>Predicate</code> 解析中排除 <code>password</code> 属性.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core.repository-populators"><a class="anchor" href="#core.repository-populators"></a>4.8.3. 存储库填充器</h4>
<div class="paragraph">
<p>如果您使用 Spring JDBC 模块,则可能熟悉使用 SQL 脚本填充 <code>DataSource</code> 的支持.  尽管它不使用 SQL 作为数据定义语言,因为它必须独立于存储,因此可以在存储库级别使用类似的抽象.  因此,填充器支持XML (通过 Spring 的 OXM 抽象) 和 JSON  (通过 Jackson) 来定义用于填充存储库的数据.</p>
</div>
<div class="paragraph">
<p>假设您有一个包含以下内容的 <code>data.json</code> 文件:</p>
</div>
<div class="exampleblock">
<div class="title">Example 51. JSON中定义的数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">[ { "_class" : "com.acme.Person",
 "firstname" : "Dave",
  "lastname" : "Matthews" },
  { "_class" : "com.acme.Person",
 "firstname" : "Carter",
  "lastname" : "Beauford" } ]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用 Spring Data Commons 中提供的存储库命名空间的 <code>populator</code> 元素来填充存储库.  要将前面的数据填充到 <code>PersonRepository</code> 中,请声明类似于以下内容的填充器:</p>
</div>
<div class="exampleblock">
<div class="title">Example 52. 声明一个Jackson存储库填充器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    https://www.springframework.org/schema/data/repository/spring-repository.xsd"&gt;

  &lt;repository:jackson2-populator locations="classpath:data.json" /&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的声明使 <code>Jackson.ObjectMapper</code> 读取并反序列化 <code>data.json</code> 文件.</p>
</div>
<div class="paragraph">
<p>通过检查JSON文档的 <code>_class</code> 属性来确定将 JSON 对象解组到的类型.  基础结构最终选择适当的存储库来处理反序列化的对象.</p>
</div>
<div class="paragraph">
<p>要改为使用 XML 定义应使用存储库填充的数据,可以使用 <code>unmarshaller-populator</code> 元素.  您可以将其配置为使用 Spring OXM 中可用的 XML marshaller 选项之一.  有关详细信息,请参见 <a href="http://docs.jcohy.com/zh-cn/spring-framework/5.2.12.RELEASE/spring-framework-reference/index.html/data-access.html#oxm">Spring 参考文档</a>.  以下示例显示如何使用JAXB解组存储库填充器:</p>
</div>
<div class="exampleblock">
<div class="title">Example 53. 声明一个解组存储库填充器 (使用JAXB)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xmlns:oxm="http://www.springframework.org/schema/oxm"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    https://www.springframework.org/schema/data/repository/spring-repository.xsd
    http://www.springframework.org/schema/oxm
    https://www.springframework.org/schema/oxm/spring-oxm.xsd"&gt;

  &lt;repository:unmarshaller-populator locations="classpath:data.json"
    unmarshaller-ref="unmarshaller" /&gt;

  &lt;oxm:jaxb2-marshaller contextPath="com.acme" /&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reference"><a class="anchor" href="#reference"></a>5. 参考文档</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="jpa.repositories"><a class="anchor" href="#jpa.repositories"></a>6. JPA 存储库</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章指出了 JPA 存储库支持的特性.  这建立在  &#8220;<a href="#repositories">使用 Spring 数据存储库</a>&#8221; 中解释的核心存储库支持的基础上.  确保您对此处介绍的基本概念有很好的了解.</p>
</div>
<div class="sect2">
<h3 id="jpa.introduction"><a class="anchor" href="#jpa.introduction"></a>6.1. 简介</h3>
<div class="paragraph">
<p>本节介绍通过以下两种方式配置 Spring Data JPA 的基础知识:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&#8220;<a href="#jpa.namespace">Spring 命名空间</a>&#8221; (XML 配置)</p>
</li>
<li>
<p>&#8220;<a href="#jpa.java-config">基于注解的配置</a>&#8221; (Java 配置)</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="jpa.namespace"><a class="anchor" href="#jpa.namespace"></a>6.1.1. Spring 命名空间</h4>
<div class="paragraph">
<p>Spring Data 的 JPA 模块包含一个自定义命名空间,允许定义存储库 bean.  它还包含 JPA 特有的某些功能和元素属性.  通常,可以通过使用 <code>repositories</code> 元素来设置 JPA 存储库,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 54. 使用命名空间建立 JPA 存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:jpa="http://www.springframework.org/schema/data/jpa"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    https://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

  &lt;jpa:repositories base-package="com.acme.repositories" /&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>repositories</code>  元素可按  &#8220;<a href="#repositories.create-instances">创建存储库实例</a>&#8221; 中所述查找 Spring Data 存储库.  除此之外,它还为所有使用 <code>@Repository</code> 注解的 bean 激活持久性异常转换,以将 JPA 持久性导致的异常转换为 Spring 的 <code>DataAccessException</code> 层次结构.</p>
</div>
<div class="sect4">
<h5 id="自定义命名空间属性"><a class="anchor" href="#自定义命名空间属性"></a>自定义命名空间属性</h5>
<div class="paragraph">
<p>除了 <code>repositories</code>  元素的默认属性之外,JPA 命名空间还提供了其他属性,使您可以更详细地控制存储库的设置:</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 2. 自定义 JPA 特定于 <code>repositories</code> 元素的属性</caption>
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entity-manager-factory-ref</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显式地将 <code>EntityManagerFactory</code> 与要使用的 <code>repositories</code> 元素所检测到的存储库连接.  通常在应用程序中使用多个 <code>EntityManagerFactory</code> bean 的情况下使用.  如果未配置,Spring Data 会在 <code>ApplicationContext</code> 中自动查找名称为 <code>EntityManagerFactory</code> 的 <code>EntityManagerFactory</code> bean.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transaction-manager-ref</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">明确地将 <code>PlatformTransactionManager</code> 与要由 <code>repositories</code> 元素检测到的存储库进行连线.  通常仅在配置了多个事务管理器或 <code>EntityManagerFactory</code> bean 时才需要.  默认为当前 <code>ApplicationContext</code> 中单个定义的 <code>PlatformTransactionManager</code>.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果显式未定义的 <code>transaction-manager-ref</code>,Spring Data JPA 要求提供一个名为 <code>transactionManager</code> 的 <code>PlatformTransactionManager</code> bean.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.java-config"><a class="anchor" href="#jpa.java-config"></a>6.1.2. 基于注解的配置</h4>
<div class="paragraph">
<p>Spring Data JPA 存储库支持不仅可以通过 XML 命名空间来激活,还可以通过 JavaConfig 使用注解来激活,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 55. 使用 JavaConfig 的 Spring Data JPA 存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJpaRepositories
@EnableTransactionManagement
class ApplicationConfig {

  @Bean
  public DataSource dataSource() {

    EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();
    return builder.setType(EmbeddedDatabaseType.HSQL).build();
  }

  @Bean
  public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

    HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
    vendorAdapter.setGenerateDdl(true);

    LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();
    factory.setJpaVendorAdapter(vendorAdapter);
    factory.setPackagesToScan("com.acme.domain");
    factory.setDataSource(dataSource());
    return factory;
  }

  @Bean
  public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {

    JpaTransactionManager txManager = new JpaTransactionManager();
    txManager.setEntityManagerFactory(entityManagerFactory);
    return txManager;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
您必须直接创建 <code>LocalContainerEntityManagerFactoryBean</code> 而不是 <code>EntityManagerFactory</code>,因为前者除了创建 <code>EntityManagerFactory</code> 之外,还参与异常转换机制.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jpa.bootstrap-mode"><a class="anchor" href="#jpa.bootstrap-mode"></a>6.1.3. 引导模式</h4>
<div class="paragraph">
<p>默认情况下,Spring Data JPA 存储库是默认的 Spring Bean.  它们是单例作用域,并且已被初始化.  在启动期间,它们已经与 JPA <code>EntityManager</code> 进行交互,以进行验证和元数据分析.
Spring 框架在后台线程中支持 JPA <code>EntityManagerFactory</code> 的初始化,因为该过程通常在 Spring 应用程序中占用大量启动时间.  为了有效地利用后台初始化,我们需要确保 JPA 存储库尽可能早地初始化.</p>
</div>
<div class="paragraph">
<p>从 Spring Data JPA 2.1 开始,您现在可以配置 <code>BootstrapMode</code> (通过 <code>@EnableJpaRepositories</code> 注解或 XML 命名空间) ,该 <code>BootstrapMode</code> 采用以下值:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DEFAULT</code> (默认值)&#8201;&#8212;&#8201;急切地实例化存储库,除非使用 <code>@Lazy</code> 显式注解.  仅当没有任何客户 Bean 需要存储库实例时,<code>lazification</code> 才有效,因为这将需要初始化存储库 bean.</p>
</li>
<li>
<p><code>LAZY</code>&#8201;&#8212;&#8201;隐式地声明所有存储库 bean 都是惰性的,并且还使创建的惰性初始化代理被注入到客户端 bean 中.  这意味着,如果客户端 bean 仅将实例存储在字段中并且在初始化期间不使用存储库,则不会实例化存储库.  首次与存储库交互时,将初始化并验证存储库实例.</p>
</li>
<li>
<p><code>DEFERRED</code>&#8201;&#8212;&#8201;基本与 <code>LAZY</code> 相同,但会响应 <code>ContextRefreshedEvent</code> 触发存储库初始化,以便在应用程序完全启动之前验证存储库.</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="推荐建议"><a class="anchor" href="#推荐建议"></a>推荐建议</h5>
<div class="paragraph">
<p>如果您不使用默认 Bootstrap 模式的异步 JPA 引导.</p>
</div>
<div class="paragraph">
<p>如果您以异步方式引导 JPA,则 <code>DEFERRED</code> 是一个合理的默认值,因为它可以确保 Spring Data JPA 引导仅在其花费比初始化所有其他应用程序组件更长的时间时才等待 <code>EntityManagerFactory</code> 安装.  尽管如此,它仍可以确保在应用程序发出信号之前,对存储库进行了正确的初始化和验证.</p>
</div>
<div class="paragraph">
<p><code>LAZY</code> 是测试方案和本地开发的不错选择.  一旦确定了存储库将正确引导后,或者在测试应用程序的其他部分时,对所有存储库执行验证可能只会不必要地增加启动时间.  这同样适用于本地开发,在本地开发中,您仅访问应用程序的某些部分,而这些部分可能只需要初始化一个存储库即可.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.entity-persistence"><a class="anchor" href="#jpa.entity-persistence"></a>6.2. 持久化实体</h3>
<div class="paragraph">
<p>本节描述如何使用 Spring Data JPA 持久化 (保存) 实体.</p>
</div>
<div class="sect3">
<h4 id="jpa.entity-persistence.saving-entites"><a class="anchor" href="#jpa.entity-persistence.saving-entites"></a>6.2.1. 保存实体</h4>
<div class="paragraph">
<p>可以使用 <code>CrudRepository.save(…)</code>  方法执行保存实体.  它通过使用基础 JPA <code>EntityManager</code> 持久化或合并给定实体.  如果实体还没有持久化,Spring Data JPA 会通过调用 <code>entityManager.persist(…)</code> 方法来保存实体.  否则,它将调用 <code>entityManager.merge(…)</code> 方法.</p>
</div>
<div class="sect4">
<h5 id="jpa.entity-persistence.saving-entites.strategies"><a class="anchor" href="#jpa.entity-persistence.saving-entites.strategies"></a>实体状态检测策略</h5>
<div class="paragraph">
<p>Spring Data JPA 提供以下策略来检测实体是否为新实体:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Version-Property 和 Id-Property 检查 (默认) : 默认情况下,Spring Data JPA 首先检查是否存在非基本类型的 Version-property.
如果存在,则将该实体视为新实体 (如果该值为 <code>null</code>) .  没有这样的版本属性,Spring Data JPA 会检查给定实体的标识符属性.  如果标识符属性为 <code>null</code>,则假定该实体为新实体.  否则,它不是新的.</p>
</li>
<li>
<p>实现 <code>Persistable</code>: 如果实体实现 <code>Persistable</code>,则 Spring Data JPA 将新检测委托给该实体的 <code>isNew(…)</code> 方法.  有关详细信息,请参见 <a href="https://docs.spring.io/spring-data/data-commons/docs/current/api/index.html?org/springframework/data/domain/Persistable.html">JavaDoc</a> .</p>
</li>
<li>
<p>实现 <code>EntityInformation</code>: 通过创建 <code>JpaRepositoryFactory</code> 的子类并相应地重写  <code>getEntityInformation(…)</code> 方法,可以自定义 <code>SimpleJpaRepository</code> 实现中使用的 <code>EntityInformation</code> 抽象.  然后,您必须将 JpaRepositoryFactory 的自定义实现注册为 Spring bean.  请注意,这几乎没有必要.  有关详细信息,请参见  <a href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/JpaRepositoryFactory.html">JavaDoc</a> .</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>对于使用手动分配的标识符的实体,选项 1 不是选项,因为标识符将始终为非 <code>null</code>.  在这种情况下,一种常见的模式是使用一个公共基类,该基类的过渡标志默认表示一个新实例,并使用 JPA 生命周期回调在持久化操作上反转该标志:</p>
</div>
<div class="exampleblock">
<div class="title">Example 56. 具有手动分配的标识符的实体的基类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@MappedSuperclass
public abstract class AbstractEntity&lt;ID&gt; implements Persistable&lt;ID&gt; {

  @Transient
  private boolean isNew = true; <i class="conum" data-value="1"></i><b>(1)</b>

  @Override
  public boolean isNew() {
    return isNew; <i class="conum" data-value="2"></i><b>(2)</b>
  }

  @PrePersist <i class="conum" data-value="3"></i><b>(3)</b>
  @PostLoad
  void markNotNew() {
    this.isNew = false;
  }

  // More code…
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>声明一个标志以保持新状态.  暂时的,因此它不会持久化到数据库中.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在 <code>Persistable.isNew()</code> 的实现中返回标志,以便 Spring Data 存储库知道是调用 <code>EntityManager.persist()</code> 还是  <code>….merge()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>声明一个使用 JPA 实体回调的方法,以便在存储库调用 <code>save(…)</code> 或持久性提供程序创建实例之后,将标志切换为指示现有实体.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.query-methods"><a class="anchor" href="#jpa.query-methods"></a>6.3. 查询方法</h3>
<div class="paragraph">
<p>本节描述了使用 Spring Data JPA 创建查询的各种方法.</p>
</div>
<div class="sect3">
<h4 id="jpa.sample-app.finders.strategies"><a class="anchor" href="#jpa.sample-app.finders.strategies"></a>6.3.1. 查询策略</h4>
<div class="paragraph">
<p>JPA 模块支持手动将查询定义为 String 或从方法名称扩展查询.</p>
</div>
<div class="paragraph">
<p>断言为 <code>IsStartingWith</code>,<code>StartingWith</code>,<code>StartsWith</code>,<code>IsEndingWith</code>,<code>EndingWith</code>,<code>EndsWith</code>,<code>IsNotContaining</code>,<code>NotContaining</code>,<code>NotContains</code>,<code>IsContaining</code>,<code>Containing</code> 的扩展查询将包含这些查询的各自参数.
这意味着,如果参数实际包含 <code>LIKE</code> 识别为通配符的字符,则这些字符将被转义,因此它们仅作为文字匹配.  可以通过设置 <code>@EnableJpaRepositories</code> 注解的 <code>escapeCharacter</code> 来配置使用的转义字符.  与使用 <a href="#jpa.query.spel-expressions">SpEL 表达式</a>进行比较.</p>
</div>
<div class="sect4">
<h5 id="声明查询"><a class="anchor" href="#声明查询"></a>声明查询</h5>
<div class="paragraph">
<p>尽管从方法名扩展一个查询很方便,但可能会遇到这样一种情况,即方法名解析器不支持一个人想使用的关键字,或者方法名变的丑陋.  因此,您可以通过命名约定使用 JPA 命名查询 (有关更多信息,请参见使用<a href="#jpa.query-methods.named-queries">JPA 命名查询</a>) , 或者通过 <code>@Query</code> 注解您的查询方法 (有关详细信息,请参见使用 <code>@Query</code>) .</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-methods.query-creation"><a class="anchor" href="#jpa.query-methods.query-creation"></a>6.3.2. 查询创建</h4>
<div class="paragraph">
<p>通常,JPA 的查询创建机制按 &#8220;<a href="#repositories.query-methods">查询方法</a>&#8221; 中所述运行.  以下示例显示了 JPA 查询方法转换为的内容:</p>
</div>
<div class="exampleblock">
<div class="title">Example 57. 通过方法名称创建查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>public interface UserRepository extends Repository&lt;User, Long&gt; {

  List&lt;User&gt; findByEmailAddressAndLastname(String emailAddress, String lastname);
}</pre>
</div>
</div>
<div class="paragraph">
<p>我们从中使用 JPA 标准 API 创建查询,但是从本质上讲,这将转换为以下查询: <code>select u from User u where u.emailAddress = ?1 and u.lastname = ?2</code>.  Spring Data JPA 进行属性检查并遍历嵌套的属性,如  &#8220;<a href="#repositories.query-methods.query-property-expressions">属性表达式</a>&#8221; 中所述.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>下表描述了 JPA 支持的关键字以及包含该关键字的方法所转换的含义:</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 3. 方法名称中受支持的关键字</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">关键字</th>
<th class="tableblock halign-left valign-top">Sample</th>
<th class="tableblock halign-left valign-top">JPQL snippet</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Distinct</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findDistinctByLastnameAndFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>select distinct &#8230;&#8203; where x.lastname = ?1 and x.firstname = ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>And</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameAndFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname = ?1 and x.firstname = ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Or</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameOrFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname = ?1 or x.firstname = ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Is</code>, <code>Equals</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname = ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Between</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateBetween</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate between ?1 and ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeLessThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &lt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeLessThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &lt;= ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeGreaterThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeGreaterThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &gt;= ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>After</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateAfter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate &gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Before</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateBefore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate &lt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNull</code>, <code>Null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAge(Is)Null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age is null</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNotNull</code>, <code>NotNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAge(Is)NotNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age not null</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Like</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameNotLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname not like ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StartingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameStartingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound with appended <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EndingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameEndingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound with prepended <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Containing</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameContaining</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound wrapped in <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OrderBy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeOrderByLastnameDesc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age = ?1 order by x.lastname desc</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Not</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameNot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname &lt;&gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>In</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age in ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotIn</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeNotIn(Collection&lt;Age&gt; ages)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age not in ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>True</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByActiveTrue()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.active = true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>False</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByActiveFalse()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.active = false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IgnoreCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameIgnoreCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where UPPER(x.firstname) = UPPER(?1)</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>In</code> 和 <code>NotIn</code> 也将 <code>Collection</code> 的任何子类作为参数以及 <code>varargs</code> 的数组.  对于同一逻辑运算符的其他语法版本,请选中 &#8220;<a href="#repository-query-keywords">存储库查询关键字</a>&#8221;.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-methods.named-queries"><a class="anchor" href="#jpa.query-methods.named-queries"></a>6.3.3. 使用 JPA 命名查询</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这些示例使用 <code>&lt;named-query /&gt;</code> 元素和 <code>@NamedQuery</code> 注解.  这些配置元素的查询必须使用 JPA 查询语言进行定义.  当然,您也可以使用 <code>&lt;named-native-query /&gt;</code> 或 <code>@NamedNativeQuery</code> .  这些元素使您可以通过在没有数据库平台独立性来在本地 SQL 中定义查询.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="xml-命名查询定义"><a class="anchor" href="#xml-命名查询定义"></a>XML 命名查询定义</h5>
<div class="paragraph">
<p>要使用 XML 配置,请将必要的 <code>&lt;named-query /&gt;</code> 元素添加到位于类路径的 <code>META-INF</code> 文件夹中的 <code>orm.xml</code> JPA 配置文件中.  通过使用一些定义的命名约定,可以自动调用命名查询.  有关更多详细信息,请参见下文.</p>
</div>
<div class="exampleblock">
<div class="title">Example 58. XML 命名查询配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;named-query name="User.findByLastname"&gt;
  &lt;query&gt;select u from User u where u.lastname = ?1&lt;/query&gt;
&lt;/named-query&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该查询具有一个特殊名称,该名称用于在运行时解析它.</p>
</div>
</div>
<div class="sect4">
<h5 id="基于注解的配置"><a class="anchor" href="#基于注解的配置"></a>基于注解的配置</h5>
<div class="paragraph">
<p>基于注解的配置的优点是不需要编辑另一个配置文件,从而减少了维护工作.  您需要为每个新的查询声明重新编译 domain 类,从而为此付出了代价.</p>
</div>
<div class="exampleblock">
<div class="title">Example 59. 基于注解的命名查询配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Entity
@NamedQuery(name = "User.findByEmailAddress",
  query = "select u from User u where u.emailAddress = ?1")
public class User {

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="声明接口"><a class="anchor" href="#声明接口"></a>声明接口</h5>
<div class="paragraph">
<p>要允许执行这些命名查询,请按以下方式指定 <code>UserRepository</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 60. UserRepository中的查询方法声明</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  List&lt;User&gt; findByLastname(String lastname);

  User findByEmailAddress(String emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Data 尝试将对这些方法的调用解析为对命名查询的调用,从已配置 domain 类的简单名称开始,然后是由 点分隔的方法名称.  因此,前面的示例将使用示例中定义的命名查询,而不是尝试从方法名称创建查询.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-methods.at-query"><a class="anchor" href="#jpa.query-methods.at-query"></a>6.3.4. 使用 <code>@Query</code></h4>
<div class="paragraph">
<p>使用命名查询声明对实体的查询是一种有效的方法,并且对于少量查询也可以正常工作.  由于查询本身与执行它们的 Java 方法相关联,因此您实际上可以通过使用 Spring Data JPA <code>@Query</code> 注解直接绑定它们,而不是将它们注解到 domain 类.
这样可以将 domain 类从持久性特定的信息中释放出来,并将查询放置在存储库接口中.</p>
</div>
<div class="paragraph">
<p>注解查询方法的查询优先于使用 <code>@NamedQuery</code> 定义的查询或在 <code>orm.xml</code> 中声明的命名查询.</p>
</div>
<div class="paragraph">
<p>以下示例显示使用 <code>@Query</code> 注解创建的查询:</p>
</div>
<div class="exampleblock">
<div class="title">Example 61. 使用 <code>@Query</code> 在查询方法中声明查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query("select u from User u where u.emailAddress = ?1")
  User findByEmailAddress(String emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="使用高级-like-表达式"><a class="anchor" href="#使用高级-like-表达式"></a>使用高级 <code>LIKE</code> 表达式</h5>
<div class="paragraph">
<p>使用 <code>@Query</code> 创建的手动定义查询的查询执行机制允许在查询定义中定义高级 <code>LIKE</code> 表达式,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 62. @Query中的高级 <code>like</code> 表达式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query("select u from User u where u.firstname like %?1")
  List&lt;User&gt; findByFirstnameEndsWith(String firstname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中,识别了 <code>LIKE</code> 分隔符 (<code>％</code>) ,并将查询转换为有效的 JPQL 查询 (删除了 <code>％</code>) .  查询执行后,传递给方法调用的参数将使用先前识别的 <code>LIKE</code> 模式进行扩充.</p>
</div>
</div>
<div class="sect4">
<h5 id="本地查询"><a class="anchor" href="#本地查询"></a>本地查询</h5>
<div class="paragraph">
<p><code>@Query</code> 注解允许通过将 <code>nativeQuery</code> 标志设置为 <code>true</code> 来运行本地查询,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 63. 使用 <code>@Query</code> 在查询方法中声明一个本地查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1", nativeQuery = true)
  User findByEmailAddress(String emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Data JPA 当前不支持对本地查询进行动态排序,因为它必须声明操作的实际查询,而这对于本地 SQL 无法可靠地进行.  但是,您可以自己指定 count 查询,从而将本地查询用于分页,如以下示例所示:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 64. 使用 <code>@Query</code> 在查询方法中声明本地 count 查询以进行分页</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query(value = "SELECT * FROM USERS WHERE LASTNAME = ?1",
    countQuery = "SELECT count(*) FROM USERS WHERE LASTNAME = ?1",
    nativeQuery = true)
  Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过将 <code>.count</code> 后缀添加到查询的副本中,类似的方法也可用于命名本地查询.  不过,您可能需要为计数查询注册结果集映射.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-methods.sorting"><a class="anchor" href="#jpa.query-methods.sorting"></a>6.3.5. 使用排序</h4>
<div class="paragraph">
<p>可以通过提供 <code>PageRequest</code> 或直接使用 <code>Sort</code> 来完成排序.  在 <code>Sort</code> 的 <code>Order</code> 实例中实际使用的属性需要与您的 domain 模型匹配,这意味着它们需要解析为查询中使用的属性或别名.  JPQL 将此定义为状态字段路径表达式.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
使用任何不可引用的路径表达式都会导致异常.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>但是,将 <code>Sort</code> 与 <a href="#jpa.query-methods.at-query"><code>@Query</code></a>  一起使用,可以让您潜入包含 <code>ORDER BY</code> 子句中的函数的未经路径检查的 <code>Order</code> 实例.  这是可能的,因为 <code>Order</code> 附加到给定的查询字符串.
默认情况下,Spring Data JPA 拒绝任何包含函数调用的 Order 实例,但是您可以使用 <code>JpaSort.unsafe</code> 添加可能不安全的排序.</p>
</div>
<div class="paragraph">
<p>以下示例使用 <code>Sort</code> 和 <code>JpaSort</code>,在 <code>JpaSort</code> 上包括一个不安全的选项:</p>
</div>
<div class="exampleblock">
<div class="title">Example 65. 使用 <code>Sort</code> 和 <code>JpaSort</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query("select u from User u where u.lastname like ?1%")
  List&lt;User&gt; findByAndSort(String lastname, Sort sort);

  @Query("select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%")
  List&lt;Object[]&gt; findByAsArrayAndSort(String lastname, Sort sort);
}

repo.findByAndSort("lannister", Sort.by("firstname"));                <i class="conum" data-value="1"></i><b>(1)</b>
repo.findByAndSort("stark", Sort.by("LENGTH(firstname)"));            <i class="conum" data-value="2"></i><b>(2)</b>
repo.findByAndSort("targaryen", JpaSort.unsafe("LENGTH(firstname)")); <i class="conum" data-value="3"></i><b>(3)</b>
repo.findByAsArrayAndSort("bolton", Sort.by("fn_len"));               <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>指向 domain 模型中属性的有效 <code>Sort</code> 表达式.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>包含函数调用的无效 <code>Sort</code>  Throws 异常.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>有效  <code>Sort</code> 包含明显不安全的  <code>Order</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>指向别名函数的有效 <code>Sort</code> 表达式.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.named-parameters"><a class="anchor" href="#jpa.named-parameters"></a>6.3.6. 使用命名参数</h4>
<div class="paragraph">
<p>默认情况下,Spring Data JPA 使用基于位置的参数绑定,如前面所有示例中所述.  当重构关于参数位置的查询方法时,这会使查询方法容易出错.  要解决此问题,可以使用 <code>@Param</code> 注解为方法参数指定一个具体名称,并在查询中绑定该名称,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 66. 使用命名参数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query("select u from User u where u.firstname = :firstname or u.lastname = :lastname")
  User findByLastnameOrFirstname(@Param("lastname") String lastname,
                                 @Param("firstname") String firstname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
方法参数根据其在定义的查询中的顺序进行切换.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从版本 4 开始,Spring 完全基于 <code>-parameters</code> 编译器标志支持 Java 8 的参数名称发现.  通过在构建中使用此注解作为调试信息的替代方法,可以省略 <code>@Param</code> 注解中的命名参数.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query.spel-expressions"><a class="anchor" href="#jpa.query.spel-expressions"></a>6.3.7. 使用 SpEL 表达式</h4>
<div class="paragraph">
<p>从 Spring Data JPA 1.4 版开始,我们支持在使用 <code>@Query</code> 定义的手动定义的查询中使用受限的 SpEL 模板表达式.  查询执行后,将根据一组预定义的变量对这些表达式进行求值.
Spring Data JPA 支持一个名为 <code>entityName</code> 的变量.  它的用法是  <code>select x from #{#entityName} x</code>.  它插入与给定存储库关联的 domain 类型的 <code>entityName</code>.  实体名称的解析如下: 如果 domain 类型已在 <code>@Entity</code> 注解上设置了名称属性,则将其使用.
否则,将使用 domain 类型的简单类名.</p>
</div>
<div class="paragraph">
<p>以下示例演示了查询字符串中  <code>#{#entityName}</code> 表达式的一种用例,您想在其中使用查询方法和手动定义的查询来定义存储库接口:</p>
</div>
<div class="exampleblock">
<div class="title">Example 67. 在存储库查询方法中使用SpEL表达式-entityName</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Entity
public class User {

  @Id
  @GeneratedValue
  Long id;

  String lastname;
}

public interface UserRepository extends JpaRepository&lt;User,Long&gt; {

  @Query("select u from #{#entityName} u where u.lastname = ?1")
  List&lt;User&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为避免在 <code>@Query</code> 注解的查询字符串中声明实际的实体名称,可以使用 <code>#{#entityName}</code> 变量.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
可以使用 <code>@Entity</code> 注解来自定义 <code>entityName</code>.  SpEL 表达式不支持 <code>orm.xml</code> 中的自定义.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当然,您可能只在查询声明中直接使用了 <code>User</code>,但这也需要您更改查询.  对 <code>#entityName</code> 的引用将 <code>User</code> 类将来可能的重新映射选择为另一个实体名称 (例如,通过使用 <code>@Entity(name = "MyUser")</code>.</p>
</div>
<div class="paragraph">
<p>查询字符串中 <code>#{#entityName}</code> 表达式的另一个用例是,如果您想为特定的 domain 类型定义一个带有专用存储库接口的通用存储库接口.  要不在具体接口上重复定义自定义查询方法,可以在通用存储库接口的 <code>@Query</code> 注解的查询字符串中使用实体名称表达式,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 68. 在 repository  查询方法中使用 SpEL 表达式-具有继承的 <code>entityName</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@MappedSuperclass
public abstract class AbstractMappedType {
  …
  String attribute
}

@Entity
public class ConcreteType extends AbstractMappedType { … }

@NoRepositoryBean
public interface MappedTypeRepository&lt;T extends AbstractMappedType&gt;
  extends Repository&lt;T, Long&gt; {

  @Query("select t from #{#entityName} t where t.attribute = ?1")
  List&lt;T&gt; findAllByAttribute(String attribute);
}

public interface ConcreteRepository
  extends MappedTypeRepository&lt;ConcreteType&gt; { … }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中,<code>MappedTypeRepository</code> 接口是扩展 <code>AbstractMappedType</code> 的一些 domain 类型的公共父接口.  它还定义了通用的  <code>findAllByAttribute(…)</code> 方法,该方法可用于专用存储库接口的实例.  如果现在在 <code>ConcreteRepository</code> 上调用  <code>findByAllAttribute(…)</code> ,则查询  <code>select t from ConcreteType t where t.attribute = ?1</code> .</p>
</div>
<div class="paragraph">
<p>SpEL 表达式可用于操作参数,也可用于操作方法参数.  在这些 SpEL 表达式中,实体名称不可用,但自变量可用.  可以通过名称或索引访问它们,如以下示例所示.</p>
</div>
<div class="exampleblock">
<div class="title">Example 69. 在存储库查询方法中使用 SpEL 表达式-访问参数.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Query("select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}")
List&lt;User&gt; findByFirstnameAndCurrentUserWithCustomQuery(String firstname);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于 <code>like</code>,通常需要将 <code>％</code> 附加到 <code>String</code> 值参数的开头或结尾.  这可以通过在绑定参数标记或 SpEL 表达式上附加或前缀 <code>％</code> 来完成.  以下示例再次说明了这一点.</p>
</div>
<div class="exampleblock">
<div class="title">Example 70. 在 repository 查询方法中使用 SpEL 表达式-通配符快捷方式.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Query("select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%")
List&lt;User&gt; findByLastnameWithSpelExpression(@Param("lastname") String lastname);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用 <code>like</code> 条件的值来自不安全来源,则应清除这些值,以使它们不能包含任何通配符,从而使攻击者可以选择比其应有的能力更多的数据.  为此,在 SpEL 上下文中可以使用  <code>escape(String)</code> 方法.  它在第一个参数中的 <code>_</code> 和 <code>％</code> 的所有实例之前加上第二个参数中的单个字符.  与 JPQL 中提供的 <code>like</code> 表达式的转义子句和标准 SQL 结合使用,可以轻松清除绑定参数.</p>
</div>
<div class="exampleblock">
<div class="title">Example 71. 在存储库查询方法中使用 SpEL 表达式-清理输入值.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Query("select u from User u where u.firstname like %?#{escape([0])}% escape ?#{escapeCharacter()}")
List&lt;User&gt; findContainingEscaped(String namePart);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在存储库接口中给出此方法声明后, <code>findContainingEscaped("Peter_")</code> 将找到 <code>Peter_Parker</code> 而不是 <code>Peter Parker</code>. 可以通过设置 <code>@EnableJpaRepositories</code> 注解的 <code>escapeCharacter</code> 来配置所使用的转义字符. 请注意,该方法 <code>escape(String)</code> 可用 在SpEL上下文中,仅将转义 SQL 和 JPQL 标准通配符 <code>_</code> 和 <code>％</code>,如果基础数据库或 JPA 实现支持其他通配符,则将不会转义这些通配符.</p>
</div>
</div>
<div class="sect3">
<h4 id="jpa.modifying-queries"><a class="anchor" href="#jpa.modifying-queries"></a>6.3.8. 修改查询</h4>
<div class="paragraph">
<p>前面所有部分均描述了如何声明查询以访问给定实体或实体集合.  您可以使用 &#8220;<a href="#repositories.custom-implementations">Spring数据存储库的自定义实现</a>&#8221; 中介绍的功能来添加自定义修改行为.  由于此方法对于全面的定制功能是可行的,因此可以通过使用 <code>@Modifying</code> 注解查询方法来修改仅需要参数绑定的查询,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 72. 声明操作查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Modifying
@Query("update User u set u.firstname = ?1 where u.lastname = ?2")
int setFixedFirstnameFor(String firstname, String lastname);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样做会触发注解该方法的查询作为更新查询,而不是选择查询.  由于 <code>EntityManager</code> 在执行修改查询后可能包含之前的实体,因此我们不会自动清除它 (有关详细信息,请参阅 <code>EntityManager.clear()</code> 的  <a href="https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html">JavaDoc</a> ) ,因为这会有效地将所有尚未刷新的更新丢弃在 <code>EntityManager</code> 中.  如果您希望自动清除 <code>EntityManager</code>,则可以将 <code>@Modifying</code> 注解的 <code>clearAutomatically</code> 属性设置为 <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>@Modifying</code> 注解仅与 <code>@Query</code> 注解结合使用. 扩展的查询方法或自定义方法不需要此注解.</p>
</div>
<div class="sect4">
<h5 id="jpa.modifying-queries.derived-delete"><a class="anchor" href="#jpa.modifying-queries.derived-delete"></a>扩展删除查询</h5>
<div class="paragraph">
<p>Spring Data JPA 还支持扩展的删除查询,使您避免显式声明 JPQL 查询,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 73. 使用扩展的删除查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends Repository&lt;User, Long&gt; {

  void deleteByRoleId(long roleId);

  @Modifying
  @Query("delete from User u where u.role.id = ?1")
  void deleteInBulkByRoleId(long roleId);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>尽管 <code>deleteByRoleId(…)</code> 方法看起来基本上与 <code>deleteInBulkByRoleId(…)</code> 产生相同的结果,但是在执行方法方面,这两个方法声明之间存在重要区别.  顾名思义,后一种方法针对数据库发出单个 JPQL 查询 (在注解中定义的查询) .  这意味着,即使当前加载的 <code>User</code> 实例也看不到生命周期回调.</p>
</div>
<div class="paragraph">
<p>为了确保生命周期查询被实际调用,调用  <code>deleteByRoleId(…)</code>  会执行一个查询,然后逐个删除返回的实例,以便持久性提供程序实际上可以在这些实体上调用 <code>@PreRemove</code> 回调.</p>
</div>
<div class="paragraph">
<p>实际上,扩展的删除查询是执行查询,然后对结果调用  <code>CrudRepository.delete(Iterable&lt;User&gt; users)</code>  并使行为与 <code>CrudRepository</code> 中其他  <code>delete(…)</code>  方法的实现保持同步的快捷方式.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.query-hints"><a class="anchor" href="#jpa.query-hints"></a>6.3.9. 应用查询提示</h4>
<div class="paragraph">
<p>要将 JPA 查询提示应用于在存储库接口中声明的查询,可以使用 <code>@QueryHints</code> 注解.  它需要一个JPA <code>@QueryHint</code> 注解加上一个布尔标志,以潜在地禁用应用于应用分页时触发的附加计数查询的提示,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 74. 将 <code>QueryHints</code> 与存储库方法一起使用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends Repository&lt;User, Long&gt; {

  @QueryHints(value = { @QueryHint(name = "name", value = "value")},
              forCounting = false)
  Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的声明将为该实际查询应用已配置的 <code>@QueryHint</code>,但是省略了将其应用于为计算总页数而触发的计数查询.</p>
</div>
</div>
<div class="sect3">
<h4 id="jpa.entity-graph"><a class="anchor" href="#jpa.entity-graph"></a>6.3.10. 配置 Fetch- 和 LoadGraphs</h4>
<div class="paragraph">
<p>JPA 2.1 规范引入了对指定 Fetch- 和 LoadGraphs 的支持,我们也支持 <code>@EntityGraph</code> 注解,该注解使您可以引用 <code>@NamedEntityGraph</code> 定义.  您可以在实体上使用该注解来配置结果查询的获取计划.  可以通过使用 <code>@EntityGraph</code> 注解上的 <code>type</code> 属性来配置获取的类型 (<code>Fetch</code> 或 <code>Load</code>) .  有关更多参考,请参见 JPA 2.1 Spec 3.7.4.</p>
</div>
<div class="exampleblock">
<div class="title">Example 75. 在一个实体上定义一个命名实体图.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在存储库查询方法上引用命名实体图:</p>
</div>
<div class="exampleblock">
<div class="title">Example 76. 在存储库查询方法上引用命名实体图定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以使用 <code>@EntityGraph</code> 定义临时实体图.  提供的 <code>attributePaths</code> 转换为相应的 <code>EntityGraph</code>,而无需将 <code>@NamedEntityGraph</code> 显式添加到您的 domain 类型,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 77. 在存储库查询方法上使用 AD-HOC 实体图定义.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(attributePaths = { "members" })
  GroupInfo getByGroupName(String name);

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="projections"><a class="anchor" href="#projections"></a>6.3.11. 投影</h4>
<div class="paragraph">
<p>Spring Data 查询方法通常返回存储库管理的聚合根的一个或多个实例.  但是,有时可能需要根据这些类型的某些属性创建投影.  Spring Data 允许对专用的返回类型进行建模,以更选择性地检索托管聚合的部分视图.</p>
</div>
<div class="paragraph">
<p>想象一下一个存储库和聚合根类型,例如以下示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 78. 一个示例集合和存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {

  @Id UUID id;
  String firstname, lastname;
  Address address;

  static class Address {
    String zipCode, city, street;
  }
}

interface PersonRepository extends Repository&lt;Person, UUID&gt; {

  Collection&lt;Person&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在,假设我们只想检索此人的姓名属性.  Spring Data 提供什么手段来实现这一目标?  本章的其余部分将回答该问题.</p>
</div>
<div class="sect4">
<h5 id="projections.interfaces"><a class="anchor" href="#projections.interfaces"></a>基于接口的投影</h5>
<div class="paragraph">
<p>将查询结果限制为仅 <code>name</code> 属性的最简单方法是声明一个接口,该接口暴露要读取的属性的 get 方法,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 79. 一个投影接口来检索属性的子集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  String getFirstname();
  String getLastname();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此处重要的一点是,此处定义的属性与聚合根中的属性完全匹配.  这样做可以使查询方法添加如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 80. 使用基于接口的投影和查询方法的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, UUID&gt; {

  Collection&lt;NamesOnly&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>查询执行引擎在运行时为返回的每个元素创建该接口的代理实例,并将对暴露方法的调用转发给目标对象.</p>
</div>
<div id="projections.interfaces.nested" class="paragraph">
<p>投影可以递归使用.  如果还希望包括一些 <code>Address</code> 信息,则为此创建一个投影接口,并从 <code>getAddress()</code> 的声明返回该接口,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 81. 一个投影接口来检索属性的子集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonSummary {

  String getFirstname();
  String getLastname();
  AddressSummary getAddress();

  interface AddressSummary {
    String getCity();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在方法调用时,将获得目标实例的 <code>address</code> 属性,并将其包装到投影代理中.</p>
</div>
<div class="sect5">
<h6 id="projections.interfaces.closed"><a class="anchor" href="#projections.interfaces.closed"></a>封闭投影</h6>
<div class="paragraph">
<p>其 get 方法均与目标集合的属性完全匹配的投影接口被视为封闭投影.  下面的示例 (也在本章前面使用过) 是一个封闭的投影:</p>
</div>
<div class="exampleblock">
<div class="title">Example 82. 一个封闭的投影</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  String getFirstname();
  String getLastname();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用封闭式投影,Spring Data 可以优化查询执行,因为我们知道支持投影代理所需的所有属性.  有关更多信息,请参见参考文档中特定于模块的部分.</p>
</div>
</div>
<div class="sect5">
<h6 id="projections.interfaces.open"><a class="anchor" href="#projections.interfaces.open"></a>打开投影</h6>
<div class="paragraph">
<p>投影接口中的 get 方法也可以通过使用 <code>@Value</code> 注解来计算新值,如以下示例所示:</p>
</div>
<div id="projections.interfaces.open.simple" class="exampleblock">
<div class="title">Example 83. 一个 打开投影</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  @Value("#{target.firstname + ' ' + target.lastname}")
  String getFullName();
  …
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在  <code>target</code>  变量中提供了支持投影的合计根.  使用 <code>@Value</code> 的投影接口是开放式投影.  在这种情况下,Spring Data 无法应用查询执行优化,因为SpEL表达式可以使用聚合根的任何属性.</p>
</div>
<div class="paragraph">
<p><code>@Value</code> 中使用的表达式应该不太复杂-您要避免在 <code>String</code> 变量中进行编程.  对于非常简单的表达式,一种选择可能是求助于默认方法 (在Java 8中引入) ,如以下示例所示:</p>
</div>
<div id="projections.interfaces.open.default" class="exampleblock">
<div class="title">Example 84. 使用默认方法自定义逻辑的投影接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  String getFirstname();
  String getLastname();

  default String getFullName() {
    return getFirstname().concat(" ").concat(getLastname());
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种方法要求您能够完全基于投影接口上暴露的其他 get 方法来实现逻辑.  第二个更灵活的选择是在 Spring bean 中实现自定义逻辑,然后从 SpEL 表达式中调用该自定义逻辑,如以下示例所示:</p>
</div>
<div id="projections.interfaces.open.bean-reference" class="exampleblock">
<div class="title">Example 85. Sample Person 对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
class MyBean {

  String getFullName(Person person) {
    …
  }
}

interface NamesOnly {

  @Value("#{@myBean.getFullName(target)}")
  String getFullName();
  …
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意 SpEL 表达式如何引用 <code>myBean</code> 并调用  <code>getFullName(…)</code> 方法,并将投影目标作为方法参数转发.  SpEL 表达式评估支持的方法也可以使用方法参数,然后可以从表达式中引用这些参数.  方法参数可通过名为 <code>args</code> 的对象数组获得.
下面的示例演示如何从 <code>args</code> 数组获取方法参数:</p>
</div>
<div class="exampleblock">
<div class="title">Example 86. Sample Person 对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  @Value("#{args[0] + ' ' + target.firstname + '!'}")
  String getSalutation(String prefix);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样,对于更复杂的表达式,您应该使用Spring bean并让该表达式调用方法,<a href="#projections.interfaces.open.bean-reference">如前所述</a>.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="projections.dtos"><a class="anchor" href="#projections.dtos"></a>基于类的投影 (DTO)</h5>
<div class="paragraph">
<p>定义投影的另一种方法是使用值类型DTO (数据传输对象) ,该类型DTO保留应该被检索的字段的属性.  这些DTO类型可以以与使用投影接口完全相同的方式使用,除了没有代理发生和不能应用嵌套投影之外.</p>
</div>
<div class="paragraph">
<p>如果存储通过限制要加载的字段来优化查询执行,则要加载的字段由暴露的构造函数的参数名称确定.</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个预计的DTO:</p>
</div>
<div class="exampleblock">
<div class="title">Example 87. 一个投影的DTO</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class NamesOnly {

  private final String firstname, lastname;

  NamesOnly(String firstname, String lastname) {

    this.firstname = firstname;
    this.lastname = lastname;
  }

  String getFirstname() {
    return this.firstname;
  }

  String getLastname() {
    return this.lastname;
  }

  // equals(…) and hashCode() implementations
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">避免投影DTO的样板代码</div>
<div class="paragraph">
<p>您可以使用 <a href="https://projectlombok.org">Project Lombok</a> 大大简化DTO的代码,该项目提供了 <code>@Value</code> 注解 (不要与前面的界面示例中显示的Spring的 <code>@Value</code> 注解混淆) .  如果您使用 Project Lombok 的 <code>@Value</code> 注解,则前面显示的示例DTO将变为以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Value
class NamesOnly {
    String firstname, lastname;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下,字段是  <code>private final</code> 的,并且该类暴露了一个构造函数,该构造函数接受所有字段并自动获取实现的 <code>equals(…)</code> 和 <code>hashCode()</code> 方法.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="projection.dynamic"><a class="anchor" href="#projection.dynamic"></a>动态投影</h5>
<div class="paragraph">
<p>到目前为止,我们已经将投影类型用作集合的返回类型或元素类型.  但是,您可能想要选择在调用时要使用的类型 (这使它成为动态的) .  要应用动态投影,请使用查询方法,如以下示例中所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 88. 使用动态投影参数的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, UUID&gt; {

  &lt;T&gt; Collection&lt;T&gt; findByLastname(String lastname, Class&lt;T&gt; type);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过这种方式,该方法可以按原样或应用投影来获得聚合,如下例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 89. 使用带有动态投影的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void someMethod(PersonRepository people) {

  Collection&lt;Person&gt; aggregates =
    people.findByLastname("Matthews", Person.class);

  Collection&lt;NamesOnly&gt; aggregates =
    people.findByLastname("Matthews", NamesOnly.class);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.stored-procedures"><a class="anchor" href="#jpa.stored-procedures"></a>6.4. 存储过程</h3>
<div class="paragraph">
<p>JPA 2.1 规范引入了对使用 JPA 标准查询 API 调用存储过程的支持.  我们引入了 <code>@Procedure</code> 注解,用于在存储库方法上声明存储过程元数据.</p>
</div>
<div class="paragraph">
<p>下面的示例使用以下存储过程:</p>
</div>
<div class="exampleblock">
<div class="title">Example 90. HSQL DB中 <code>plus1inout</code>  过程的定义.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">/;
DROP procedure IF EXISTS plus1inout
/;
CREATE procedure plus1inout (IN arg int, OUT res int)
BEGIN ATOMIC
 set res = arg + 1;
END
/;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以通过在实体类型上使用 <code>NamedStoredProcedureQuery</code> 注解来配置存储过程的元数据.</p>
</div>
<div id="jpa.stored-procedure-entity-metadata" class="exampleblock">
<div class="title">Example 91. 实体上的 <code>StoredProcedure</code> 元数据定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Entity
@NamedStoredProcedureQuery(name = "User.plus1", procedureName = "plus1inout", parameters = {
  @StoredProcedureParameter(mode = ParameterMode.IN, name = "arg", type = Integer.class),
  @StoredProcedureParameter(mode = ParameterMode.OUT, name = "res", type = Integer.class) })
public class User {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意,<code>@NamedStoredProcedureQuery</code> 具有两个不同的存储过程名称.  名称是 JPA 使用的名称.  <code>procedureName</code> 是存储过程在数据库中具有的名称.</p>
</div>
<div class="paragraph">
<p>您可以通过多种方式从存储库方法引用存储过程.  可以使用 <code>@Procedure</code> 注解的 <code>value</code> 或 <code>procedureName</code> 属性直接定义要调用的存储过程.  这直接引用数据库中的存储过程,并忽略通过 <code>@NamedStoredProcedureQuery</code> 进行的任何配置.</p>
</div>
<div class="paragraph">
<p>或者,您可以将 <code>@NamedStoredProcedureQuery.name</code> 属性指定为 <code>@Procedure.name</code> 属性.  如果未配置 <code>value</code>,<code>procedureName</code> 或 <code>name</code>,则将存储库方法的名称用作 <code>name</code> 属性.</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何引用显式映射的过程:</p>
</div>
<div id="jpa.stored-procedure-reference" class="exampleblock">
<div class="title">Example 92. 在数据库中引用名称为 "plus1inout" 的显式映射过程.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Procedure("plus1inout")
Integer explicitlyNamedPlus1inout(Integer arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例与上一个示例等效,但是使用了 <code>procedureName</code> 别名:</p>
</div>
<div class="exampleblock">
<div class="title">Example 93. 通过 <code>procedureName</code> 别名在数据库中引用名称为 "plus1inout" 的隐式映射过程</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Procedure(procedureName = "plus1inout")
Integer callPlus1InOut(Integer arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面再次与前两个等效,但是使用方法名称而不是显式注解属性.</p>
</div>
<div class="exampleblock">
<div class="title">Example 94. 使用方法名称在 <code>EntityManager</code> 中引用隐式映射的命名存储过程 "User.plus1" .</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Procedure
Integer plus1inout(@Param("arg") Integer arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的示例演示如何通过引用 <code>@NamedStoredProcedureQuery.name</code> 属性来引用存储过程.</p>
</div>
<div class="exampleblock">
<div class="title">Example 95. 在 EntityManager 中引用显式映射的命名存储过程 "User.plus1IO".</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Procedure(name = "User.plus1IO")
Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param("arg") Integer arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果被调用的存储过程只有一个 <code>out</code> 参数,则该参数可以作为方法的返回值返回.  如果在 <code>@NamedStoredProcedureQuery</code> 注解中指定了多个 <code>out</code> 参数,则这些参数可以作为 <code>Map</code> 返回,其键为 <code>@NamedStoredProcedureQuery</code> 注解中给出的参数名称.</p>
</div>
</div>
<div class="sect2">
<h3 id="specifications"><a class="anchor" href="#specifications"></a>6.5. Specification</h3>
<div class="paragraph">
<p>JPA 2 引入了一个标准 API,您可以使用它来以编程方式构建查询.  通过编写条件,可以定义域类查询的 <code>where</code> 子句.  再往前一步,这些标准可以视为 JPA 标准 API 约束所描述的实体的断言.</p>
</div>
<div class="paragraph">
<p>Spring Data JPA 遵循 Eric Evans 的书 &#8220;领域驱动设计&#8221; 中的规范概念,遵循相同的语义,并提供了使用 JPA 标准 API 定义此类规范的 API.  为了支持规范,可以使用 <code>JpaSpecificationExecutor</code> 接口扩展存储库接口,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt;, JpaSpecificationExecutor {
 …
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>附加接口具有使您能够以各种方式执行规范的方法.  例如,<code>findAll</code> 方法返回与规范匹配的所有实体,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;T&gt; findAll(Specification&lt;T&gt; spec);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Specification</code> 接口定义如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Specification&lt;T&gt; {
  Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query,
            CriteriaBuilder builder);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specifications 可以轻松地用于在实体之上构建可扩展的断言集合,然后可以将其组合并与 <code>JpaRepository</code> 一起使用,而无需为每个所需的组合声明查询 (方法) ,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 96. 自定义 Specifications</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class CustomerSpecs {


  public static Specification&lt;Customer&gt; isLongTermCustomer() {
    return (root, query, builder) -&gt; {
      LocalDate date = LocalDate.now().minusYears(2);
      return builder.lessThan(root.get(Customer_.createdAt), date);
    };
  }

  public static Specification&lt;Customer&gt; hasSalesOfMoreThan(MonetaryAmount value) {
    return (root, query, builder) -&gt; {
      // build query here
    };
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>诚然,样板文件的数量尚待改进 (最终可能会因 Java 8 闭包而减少) ,但是客户端会变得更好,正如您将在本节后面看到的那样.  <code>Customer_</code> 类型是使用 JPA 元模型生成器生成的元模型类型 (有关示例,<a href="https://docs.jboss.org/hibernate/jpamodelgen/1.0/reference/en-US/html_single/#whatisit">参见Hibernate实现的文档</a>) .  因此,表达式 <code>Customer_.createdAt</code> 假定客户具有类型为 <code>Date</code> 的 <code>createdAt</code> 属性.  除此之外,我们在业务需求抽象级别上表达了一些标准,并创建了可执行的 <code>Specifications</code>.  因此,客户端可以使用以下 <code>Specifications</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 97. 使用一个简单的 Specification</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;Customer&gt; customers = customerRepository.findAll(isLongTermCustomer());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为什么不为这种数据访问创建查询?  与纯查询声明相比,使用单个 <code>Specification</code> 不会带来很多好处.  将 <code>specifications</code> 组合在一起以创建新的 <code>specifications</code> 对象时,<code>specifications</code> 的力量真正发挥了作用.
您可以通过我们提供的用于构建类似于以下内容的表达式的默认 <code>Specification</code> 方法来实现此目的:</p>
</div>
<div class="exampleblock">
<div class="title">Example 98. 组合 Specifications</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MonetaryAmount amount = new MonetaryAmount(200.0, Currencies.DOLLAR);
List&lt;Customer&gt; customers = customerRepository.findAll(
  isLongTermCustomer().or(hasSalesOfMoreThan(amount)));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Specification</code> 提供了一些 &#8220;glue-code&#8221; 默认方法来链接和组合  <code>Specification</code> 实例,这些方法使您可以通过创建新的  <code>Specification</code>  实现并将它们与现有的实现组合来扩展数据访问层.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-by-example"><a class="anchor" href="#query-by-example"></a>6.6. 查询例子</h3>
<div class="sect3">
<h4 id="query-by-example.introduction"><a class="anchor" href="#query-by-example.introduction"></a>6.6.1. 简介</h4>
<div class="paragraph">
<p>本章对 "按示例查询" 进行了介绍,并说明了如何使用它.</p>
</div>
<div class="paragraph">
<p>示例查询 (QBE) 是一种具有简单界面的用户友好查询技术.  它允许动态查询创建,并且不需要您编写包含字段名称的查询.  实际上,"示例查询" 根本不需要您使用存储库特定的查询语言编写查询.</p>
</div>
</div>
<div class="sect3">
<h4 id="query-by-example.usage"><a class="anchor" href="#query-by-example.usage"></a>6.6.2. 使用</h4>
<div class="paragraph">
<p>示例查询由三部分组成:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Probe: 带有填充字段的 domain 对象的实际示例.</p>
</li>
<li>
<p><code>ExampleMatcher</code>: <code>ExampleMatcher</code> 包含有关如何匹配特定字段的详细信息.  可以在多个示例中重复使用它.</p>
</li>
<li>
<p><code>Example</code>: 示例包括探针和 <code>ExampleMatcher</code>.  它用于创建查询.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>示例查询非常适合几种用例:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用一组静态或动态约束来查询数据存储.</p>
</li>
<li>
<p>频繁重构 domain 对象,而不必担心破坏现有查询.</p>
</li>
<li>
<p>独立于基础数据存储 API 进行工作.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>示例查询也有一些限制:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不支持嵌套或分组属性约束,例如 <code>firstname = ?0 or (firstname = ?1 and lastname = ?2)</code>.</p>
</li>
<li>
<p>仅支持字符串的开始/包含/结束/正则表达式匹配,以及其他属性类型的完全匹配.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在开始使用示例查询之前,您需要具有一个 domain 对象.  首先,为您的存储库创建一个接口,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 99. Sample Person 对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Person {

  @Id
  private String id;
  private String firstname;
  private String lastname;
  private Address address;

  // … getters and setters omitted
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例显示了一个简单的域对象.  您可以使用它来创建一个 <code>Example</code>.  默认情况下,具有 <code>null</code> 的字段将被忽略,并且使用存储特定的默认值来匹配字符串.  可以使用工厂方法或使用 <code>ExampleMatcher</code> 构建示例.  例子是一成不变的.  以下清单显示了一个简单的示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 100. Simple Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Person person = new Person();                         <i class="conum" data-value="1"></i><b>(1)</b>
person.setFirstname("Dave");                          <i class="conum" data-value="2"></i><b>(2)</b>

Example&lt;Person&gt; example = Example.of(person);         <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建  domain 对象的新实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置要查询的属性.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>创建 <code>Example</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>最好在存储库中执行示例.  为此,让您的存储库接口扩展 <code>QueryByExampleExecutor&lt;T&gt;</code>.  以下清单显示了 <code>QueryByExampleExecutor</code> 接口:</p>
</div>
<div class="exampleblock">
<div class="title">Example 101. <code>QueryByExampleExecutor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface QueryByExampleExecutor&lt;T&gt; {

  &lt;S extends T&gt; S findOne(Example&lt;S&gt; example);

  &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; example);

  // … more functionality omitted.
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="query-by-example.matchers"><a class="anchor" href="#query-by-example.matchers"></a>6.6.3. Example 匹配</h4>
<div class="paragraph">
<p>示例不限于默认设置.  您可以使用 <code>ExampleMatcher</code> 为字符串匹配,空值处理和特定于属性的设置指定自己的默认值,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 102. 具有定制匹配的例子匹配器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Person person = new Person();                          <i class="conum" data-value="1"></i><b>(1)</b>
person.setFirstname("Dave");                           <i class="conum" data-value="2"></i><b>(2)</b>

ExampleMatcher matcher = ExampleMatcher.matching()     <i class="conum" data-value="3"></i><b>(3)</b>
  .withIgnorePaths("lastname")                         <i class="conum" data-value="4"></i><b>(4)</b>
  .withIncludeNullValues()                             <i class="conum" data-value="5"></i><b>(5)</b>
  .withStringMatcherEnding();                          <i class="conum" data-value="6"></i><b>(6)</b>

Example&lt;Person&gt; example = Example.of(person, matcher); <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建域对象的新实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置属性.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>创建一个 <code>ExampleMatcher</code> 以期望所有值都匹配.  即使没有进一步的配置,它也可以在此阶段使用.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径并包含空值.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径,包括空值,并执行后缀字符串匹配.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>基于域对象和配置的 <code>ExampleMatcher</code> 创建一个新的 <code>Example</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下,<code>ExampleMatcher</code> 期望设置的所有值都匹配.  如果要获取与隐式定义的任何断言匹配的结果,请使用  <code>ExampleMatcher.matchingAny()</code>.</p>
</div>
<div class="paragraph">
<p>您可以为单个属性 (例如  "firstname" 和 "lastname",或者对于嵌套属性,"address.city") 指定行为.  您可以使用匹配选项和区分大小写对其进行调整,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 103. 配置匹配器选项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ExampleMatcher matcher = ExampleMatcher.matching()
  .withMatcher("firstname", endsWith())
  .withMatcher("lastname", startsWith().ignoreCase());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>配置匹配器选项的另一种方法是使用 lambda (在Java 8中引入) .  此方法创建一个回调,要求实现者修改匹配器.  您无需返回匹配器,因为配置选项保存在匹配器实例中.  以下示例显示了使用lambda的匹配器:</p>
</div>
<div class="exampleblock">
<div class="title">Example 104. 用lambdas配置匹配器选项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ExampleMatcher matcher = ExampleMatcher.matching()
  .withMatcher("firstname", match -&gt; match.endsWith())
  .withMatcher("firstname", match -&gt; match.startsWith());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由 <code>Example</code> 创建的查询使用配置的合并视图.  可以在 <code>ExampleMatcher</code> 级别上设置默认的匹配设置,而可以将单个设置应用于特定的属性路径.  除非明确定义,否则 <code>ExampleMatcher</code> 上设置的设置将由属性路径设置继承.
属性修补程序上的设置优先于默认设置.  下表描述了各种 <code>ExampleMatcher</code> 设置的范围:</p>
</div>
<div class="paragraph">
<p>表4. <code>ExampleMatcher</code> 设置的范围</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Scope of <code>ExampleMatcher</code> settings</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Setting</th>
<th class="tableblock halign-left valign-top">Scope</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Null-handling</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExampleMatcher</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String matching</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExampleMatcher</code> and property path</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ignoring properties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property path</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Case sensitivity</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExampleMatcher</code> and property path</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value transformation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property path</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="query-by-example.running"><a class="anchor" href="#query-by-example.running"></a>6.6.4. 执行一个例子</h4>
<div class="paragraph">
<p>在 Spring Data JPA 中,您可以对存储库使用按示例查询,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 105. 使用存储库按示例查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface PersonRepository extends JpaRepository&lt;Person, String&gt; { … }

public class PersonService {

  @Autowired PersonRepository personRepository;

  public List&lt;Person&gt; findPeople(Person probe) {
    return personRepository.findAll(Example.of(probe));
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当前,仅 <code>SingularAttribute</code> 属性可用于属性匹配.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>属性说明符接受属性名称(例如 <code>firstname</code> and <code>lastname</code>) .  您可以通过将属性与点(<code>address.city</code>) 链接在一起进行导航.  您还可以使用匹配选项和区分大小写对其进行调整.</p>
</div>
<div class="paragraph">
<p>下表显示了可以使用的各种 <code>StringMatcher</code> 选项,以及在名为 <code>firstname</code> 的字段上使用它们的结果:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. <code>StringMatcher</code> options</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Matching</th>
<th class="tableblock halign-left valign-top">Logical result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEFAULT</code> (case-sensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname = ?0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEFAULT</code> (case-insensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) = LOWER(?0)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXACT</code>  (case-sensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname = ?0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXACT</code> (case-insensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) = LOWER(?0)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STARTING</code>  (case-sensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname like ?0 + '%'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STARTING</code> (case-insensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) like LOWER(?0) + '%'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENDING</code>  (case-sensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname like '%' + ?0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENDING</code> (case-insensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) like '%' + LOWER(?0)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONTAINING</code>  (case-sensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname like '%' + ?0 + '%'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONTAINING</code> (case-insensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) like '%' + LOWER(?0) + '%'</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="transactions"><a class="anchor" href="#transactions"></a>6.7. 事务性</h3>
<div class="paragraph">
<p>默认情况下,存储库实例上的 CRUD 方法是事务性的.  对于读取操作,事务配置 <code>readOnly</code> 标志设置为 <code>true</code>.  所有其他文件都配置有简单的 <code>@Transactional</code>,以便应用默认事务配置.
有关详细信息,请参见 <a href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/SimpleJpaRepository.html"><code>SimpleJpaRepository</code></a> 的JavaDoc.  如果需要调整存储库中声明的方法之一的事务配置,请在存储库接口中重新声明该方法,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 106. CRUD 的自定义事务配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends CrudRepository&lt;User, Long&gt; {

  @Override
  @Transactional(timeout = 10)
  public List&lt;User&gt; findAll();

  // Further query method declarations
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做会使 <code>findAll()</code> 方法以 10 秒的超时运行,并且没有 <code>readOnly</code> 标志.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>更改事务行为的另一种方法是使用 facade 或 service 实现 (通常) 覆盖多个存储库.  其目的是为非 CRUD 操作定义事务边界.  以下示例使用了 facade 用于多个存储库:</p>
</div>
<div class="exampleblock">
<div class="title">Example 107. 使用外观定义多个存储库调用的事务</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Service
class UserManagementImpl implements UserManagement {

  private final UserRepository userRepository;
  private final RoleRepository roleRepository;

  @Autowired
  public UserManagementImpl(UserRepository userRepository,
    RoleRepository roleRepository) {
    this.userRepository = userRepository;
    this.roleRepository = roleRepository;
  }

  @Transactional
  public void addRoleToAllUsers(String roleName) {

    Role role = roleRepository.findByName(roleName);

    for (User user : userRepository.findAll()) {
      user.addRole(role);
      userRepository.save(user);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例使对 <code>addRoleToAllUsers(…)</code>  的调用在事务内运行 (参与现有事务或在没有事务的情况下创建新事务) .  然后忽略存储库中的事务配置,因为外部事务配置确定了实际使用的事务配置.  请注意,必须激活 <code>&lt;tx:annotation-driven /&gt;</code> 或显式使用 <code>@EnableTransactionManagement</code> 才能使立面的基于注解的配置生效.  本示例假定您使用组件扫描.</p>
</div>
<div class="paragraph">
<p>请注意, 从 JPA 的角度来看, 对 <code>save</code> 的调用不是绝对必要的, 但为了与 Spring Data 提供的存储库抽象保持一致, 仍然应该存在.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="transactional-query-methods"><a class="anchor" href="#transactional-query-methods"></a>6.7.1. 事务查询方法</h4>
<div class="paragraph">
<p>要使查询方法具有事务性,请在您定义的存储库接口上使用 <code>@Transactional</code>,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 108. 在查询方法上使用 <code>@Transactional</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Transactional(readOnly = true)
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  List&lt;User&gt; findByLastname(String lastname);

  @Modifying
  @Transactional
  @Query("delete from User u where u.active = false")
  void deleteInactiveUsers();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常,您希望将 <code>readOnly</code> 标志设置为 <code>true</code>,因为大多数查询方法仅读取数据.  与此相反, <code>deleteInactiveUsers()</code> 使用 <code>@Modifying</code> 注解并覆盖事务配置.  因此,该方法在 <code>readOnly</code> 标志设置为 <code>false</code> 的情况下运行.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以将事务用于只读查询,并通过设置 <code>readOnly</code> 标志将其标记为事务.  但是,这样做并不表示您不会触发操作查询 (尽管某些数据库拒绝只读事务中的 <code>INSERT</code> 和 <code>UPDATE</code> 语句) .  相反,将 <code>readOnly</code> 标志作为提示传播到底层 JDBC 驱动程序,以进行性能优化.  此外,Spring 在基础 JPA 提供程序上执行了一些优化.  例如,当与 Hibernate 一起使用时,将事务配置为 <code>readOnly</code> 时,刷新模式将设置为 <code>NEVER</code>,这将导致 Hibernate 跳过脏检查 (对大型对象树的显着改进) .</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="locking"><a class="anchor" href="#locking"></a>6.8. 锁</h3>
<div class="paragraph">
<p>要指定要使用的锁定模式,可以在查询方法上使用 <code>@Lock</code> 注解,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 109. 在查询方法上定义锁元数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends Repository&lt;User, Long&gt; {

  // Plain query method
  @Lock(LockModeType.READ)
  List&lt;User&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此方法声明使触发的查询配备有 <code>READ</code> 的 <code>LockModeType</code>.  您还可以通过在存储库界面中重新声明 CRUD 方法并为它们添加 <code>@Lock</code> 注解来定义 CRUD 方法的锁定,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 110. 在 CRUD 方法上定义锁元数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends Repository&lt;User, Long&gt; {

  // Redeclaration of a CRUD method
  @Lock(LockModeType.READ)
  List&lt;User&gt; findAll();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="auditing"><a class="anchor" href="#auditing"></a>6.9. 审计</h3>
<div class="sect3">
<h4 id="auditing.basics"><a class="anchor" href="#auditing.basics"></a>6.9.1. 基础</h4>
<div class="paragraph">
<p>Spring Data 提供了完善的支持,可以透明地跟踪创建或更改实体的人员以及更改发生的时间.  要利用该功能,您必须为实体类配备审核元数据,该审核元数据可以使用注解或通过实现接口来定义.</p>
</div>
<div class="sect4">
<h5 id="auditing.annotations"><a class="anchor" href="#auditing.annotations"></a>基于注解的审核元数据</h5>
<div class="paragraph">
<p>我们提供 <code>@CreatedBy</code> 和 <code>@LastModifiedBy</code> 来捕获创建或修改实体的用户,并提供 <code>@CreatedDate</code> 和 <code>@LastModifiedDate</code> 来捕获更改发生的时间.</p>
</div>
<div class="exampleblock">
<div class="title">Example 111. 被审计实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Customer {

  @CreatedBy
  private User user;

  @CreatedDate
  private DateTime createdDate;

  // … further properties omitted
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见,可以根据要捕获的信息有选择地应用注解.  捕获更改时捕获的注解可用于类型 <code>Joda-Time</code>,<code>DateTime</code>,旧版Java <code>Date</code> 和 <code>Calendar</code>,JDK8日期和时间类型以及 <code>long</code> 或 <code>Long</code> 的属性.</p>
</div>
</div>
<div class="sect4">
<h5 id="auditing.interfaces"><a class="anchor" href="#auditing.interfaces"></a>基于接口的审核元数据</h5>
<div class="paragraph">
<p>如果您不想使用注解来定义审核元数据,则可以让您的 domain 类实现 <code>Auditable</code> 接口.  它为所有审核属性暴露了setter方法.</p>
</div>
<div class="paragraph">
<p>还有一个便捷的基类 <code>AbstractAuditable</code>,可以对其进行扩展,以避免需要手动实现接口方法.  这样做会增加您的 domain 类与 Spring Data 的耦合,这可能是您要避免的事情.  通常,首选基于注解的方式来定义审核元数据,因为它侵入性较小且更灵活.</p>
</div>
</div>
<div class="sect4">
<h5 id="auditing.auditor-aware"><a class="anchor" href="#auditing.auditor-aware"></a><code>AuditorAware</code></h5>
<div class="paragraph">
<p>如果使用 <code>@CreatedBy</code> 或 <code>@LastModifiedBy</code>,则审计基础结构需要以某种方式了解当前的主体.  为此,我们提供了 <code>AuditorAware&lt;T&gt;</code> SPI接口,您必须实现该接口以告知基础结构与应用程序交互的当前用户或系统是谁.
通用类型T定义必须使用 <code>@CreatedBy</code> 或 <code>@LastModifiedBy</code> 注解的属性的类型.</p>
</div>
<div class="paragraph">
<p>以下示例显示了使用Spring Security的 <code>Authentication</code> 对象的接口的实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 112. 基于Spring Security的AuditorAware的实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class SpringSecurityAuditorAware implements AuditorAware&lt;User&gt; {

  public Optional&lt;User&gt; getCurrentAuditor() {

    return Optional.ofNullable(SecurityContextHolder.getContext())
              .map(SecurityContext::getAuthentication)
              .filter(Authentication::isAuthenticated)
              .map(Authentication::getPrincipal)
              .map(User.class::cast);
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该实现访问Spring Security提供的 <code>Authentication</code> 对象,并查找您在 <code>UserDetailsService</code> 实现中创建的自定义 <code>UserDetails</code> 实例.  我们在这里假设您通过 <code>UserDetails</code> 实现暴露域用户,但是根据找到的身份验证,您还可以从任何地方查找它.
:leveloffset: -1</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.auditing"><a class="anchor" href="#jpa.auditing"></a>6.9.2. JPA 审计</h4>
<div class="sect4">
<h5 id="jpa.auditing.configuration"><a class="anchor" href="#jpa.auditing.configuration"></a>通用审核配置</h5>
<div class="paragraph">
<p>Spring Data JPA 附带了一个实体监听器,该监听器可用于触发捕获审计信息.  首先,必须在 <code>orm.xml</code> 文件内的持久性上下文中注册要用于所有实体的 <code>AuditingEntityListener</code>,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 113. Auditing configuration orm.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;persistence-unit-metadata&gt;
  &lt;persistence-unit-defaults&gt;
    &lt;entity-listeners&gt;
      &lt;entity-listener class="….data.jpa.domain.support.AuditingEntityListener" /&gt;
    &lt;/entity-listeners&gt;
  &lt;/persistence-unit-defaults&gt;
&lt;/persistence-unit-metadata&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用 <code>@EntityListeners</code> 注解按每个实体启用 <code>AuditingEntityListener</code>,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Entity
@EntityListeners(AuditingEntityListener.class)
public class MyEntity {

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
审计功能要求 <code>spring-aspects.jar</code> 位于类路径中.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通过适当地修改 <code>orm.xml</code> 并在类路径上使用 <code>spring-aspects.jar</code>,激活审核功能只需将 Spring Data JPA <code>auditing</code> 命名空间元素添加到您的配置中,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 114. 使用 XML 配置激活审计</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;jpa:auditing auditor-aware-ref="yourAuditorAwareBean" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从 Spring Data JPA 1.5 开始,您可以通过使用 <code>@EnableJpaAuditing</code> 注解对配置类进行注解来启用审核.  您仍然必须修改 <code>orm.xml</code> 文件,并在类路径上具有 <code>spring-aspects.jar</code>.  以下示例显示了如何使用 <code>@EnableJpaAuditing</code> 注解:</p>
</div>
<div class="exampleblock">
<div class="title">Example 115. 用 Java 配置激活审计</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJpaAuditing
class Config {

  @Bean
  public AuditorAware&lt;AuditableUser&gt; auditorProvider() {
    return new AuditorAwareImpl();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果将类型 <code>AuditorAware</code> 的 bean 暴露给 <code>ApplicationContext</code>,则审计基础结构会自动选择它并使用它来确定要在 domain 类型上设置的当前用户.  如果您在 <code>ApplicationContext</code> 中注册了多个实现,则可以通过显式设置 <code>@EnableJpaAuditing</code> 的 <code>auditAwareRef</code> 属性来选择要使用的实现.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.misc"><a class="anchor" href="#jpa.misc"></a>6.10. 其他注意事项</h3>
<div class="sect3">
<h4 id="jpa.misc.jpa-context"><a class="anchor" href="#jpa.misc.jpa-context"></a>6.10.1. 在自定义实现中使用 <code>JpaContext</code></h4>
<div class="paragraph">
<p>当使用多个 <code>EntityManager</code> 实例和<a href="#repositories.custom-implementations">自定义存储库实现</a>实现时,您需要将正确的 <code>EntityManager</code> 连接到存储库实现类中.  您可以通过在 <code>@PersistenceContext</code> 注解中显式命名 <code>EntityManager</code> 来实现,
或者,如果 <code>EntityManager</code> 是 <code>@Autowired</code>,则可以使用 <code>@Qualifier</code> 来实现.</p>
</div>
<div class="paragraph">
<p>从 Spring Data JPA 1.9 开始,Spring Data JPA 包含一个名为 <code>JpaContext</code> 的类,假定您只由应用程序中的 <code>EntityManager</code> 实例之一进行管理,该类使您可以通过被管理 domain 类获取 <code>EntityManager</code>.  以下示例显示如何在自定义存储库中使用 <code>JpaContext</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 116. 在自定义存储库实现中使用 <code>JpaContext</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class UserRepositoryImpl implements UserRepositoryCustom {

  private final EntityManager em;

  @Autowired
  public UserRepositoryImpl(JpaContext context) {
    this.em = context.getEntityManagerByManagedType(User.class);
  }

  …
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种方法的优点是,如果将 domain 类型分配给其他持久性单元,则无需触摸存储库即可更改对持久性单元的引用.</p>
</div>
</div>
<div class="sect3">
<h4 id="jpa.misc.merging-persistence-units"><a class="anchor" href="#jpa.misc.merging-persistence-units"></a>6.10.2. 合并持久性单元</h4>
<div class="paragraph">
<p>Spring 支持具有多个持久性单元.  但是,有时您可能希望对应用程序进行模块化,但仍要确保所有这些模块都在单个持久性单元中运行.  为了实现这种行为,Spring Data JPA 提供了一个 <code>PersistenceUnitManager</code> 实现,该实现会根据其名称自动合并持久性单元,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 117. 使用 MergingPersistenceUnitmanager</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean class="….LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="persistenceUnitManager"&gt;
    &lt;bean class="….MergingPersistenceUnitManager" /&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="jpa.misc.entity-scanning"><a class="anchor" href="#jpa.misc.entity-scanning"></a>@Entity 类和 JPA 映射文件的类路径扫描</h5>
<div class="paragraph">
<p>普通的JPA设置要求所有注解映射的实体类在 <code>orm.xml</code> 中列出.  XML映射文件也是如此.  Spring Data JPA 提供了一个 <code>ClasspathScanningPersistenceUnitPostProcessor</code>,它配置了一个基本包,并可以选择采用映射文件名模式.  然后,它在给定的软件包中扫描以 <code>@Entity</code> 或 <code>@MappedSuperclass</code> 注解的类,加载与文件名模式匹配的配置文件,并将其交给JPA配置.  后处理器必须配置如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 118. 使用 ClasspathScanningPersistenceUnitPostProcessor</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean class="….LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="persistenceUnitPostProcessors"&gt;
    &lt;list&gt;
      &lt;bean class="org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor"&gt;
        &lt;constructor-arg value="com.acme.domain" /&gt;
        &lt;property name="mappingFileNamePattern" value="**/*Mapping.xml" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从 Spring 3.1 开始,可以直接在 <code>LocalContainerEntityManagerFactoryBean</code> 上配置要扫描的程序包,以对实体类启用类路径扫描.  有关详细信息,请参见 <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html#setPackagesToScan(java.lang.String...)">JavaDoc</a>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpd.misc.cdi-integration"><a class="anchor" href="#jpd.misc.cdi-integration"></a>6.10.3. CDI 集成</h4>
<div class="paragraph">
<p>存储库接口的实例通常由容器创建,在使用 Spring Data 时,Spring 是最自然的选择.  如<a href="#repositories.create-instances">创建存储库实例</a>中所述,Spring 为创建 bean 实例提供了复杂的支持.  从 1.1.0 版本开始,Spring Data JPA 附带了一个自定义 CDI 扩展名,该扩展名允许在 CDI 环境中使用存储库抽象.  该扩展是 JAR 的一部分.  要激活它,请将 Spring Data JPA JAR 包含在类路径中.</p>
</div>
<div class="paragraph">
<p>现在,您可以通过为 <code>EntityManagerFactory</code> 和 <code>EntityManager</code> 实现 CDI 生产者来设置基础结构,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class EntityManagerFactoryProducer {

  @Produces
  @ApplicationScoped
  public EntityManagerFactory createEntityManagerFactory() {
    return Persistence.createEntityManagerFactory("my-persistence-unit");
  }

  public void close(@Disposes EntityManagerFactory entityManagerFactory) {
    entityManagerFactory.close();
  }

  @Produces
  @RequestScoped
  public EntityManager createEntityManager(EntityManagerFactory entityManagerFactory) {
    return entityManagerFactory.createEntityManager();
  }

  public void close(@Disposes EntityManager entityManager) {
    entityManager.close();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>必要的设置可能会因 JavaEE 环境而异.  您可能需要做的只是将 <code>EntityManager</code> 重新声明为 CDI bean,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class CdiConfig {

  @Produces
  @RequestScoped
  @PersistenceContext
  public EntityManager entityManager;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中,容器必须能够创建 JPA <code>EntityManagers</code> 本身.  所有配置所做的就是将 JPA <code>EntityManager</code> 重新导出为 CDI bean.</p>
</div>
<div class="paragraph">
<p>每当容器请求存储库类型的 bean 时,Spring Data JPA CDI 扩展都将所有可用的 <code>EntityManager</code> 实例作为 CDI bean 进行选择,并为 Spring Data 存储库创建代理.  因此,获取 Spring Data 存储库的实例只需声明一个 <code>@Injected</code> 属性即可,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class RepositoryClient {

  @Inject
  PersonRepository repository;

  public void businessMethod() {
    List&lt;Person&gt; people = repository.findAll();
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix"><a class="anchor" href="#appendix"></a>7. 附录</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="repositories.namespace-reference"><a class="anchor" href="#repositories.namespace-reference"></a>Appendix A: 命名空间参考</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="populator.namespace-dao-config"><a class="anchor" href="#populator.namespace-dao-config"></a><code>&lt;repositories /&gt;</code> 元素</h3>
<div class="paragraph">
<p><code>&lt;repositories /&gt;</code> 元素触发Spring Data存储库基础结构的设置.  最重要的属性是 <code>base-package</code>,它定义了要扫描Spring Data 存储库接口的软件包.
请参阅 &#8220;<a href="#repositories.create-instances.spring">XML配置</a>&#8221;.  下表描述了 <code>&lt;repositories /&gt;</code> 元素的属性:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. 属性</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>base-package</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义要扫描的软件包,以查找在自动检测模式下扩展 <code>*Repository</code>(实际接口由特定的Spring Data模块确定) 的存储库接口.  配置包下面的所有包也将被扫描.  允许使用通配符.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>repository-impl-postfix</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义后缀以自动检测自定义存储库实现.  名称以配置的后缀结尾的类被视为候选.  默认为 <code>Impl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>query-lookup-strategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">确定用于创建查找器查询的策略.  有关详细信息,请参见 &#8220;<a href="#repositories.query-methods.query-lookup-strategies">查询查找策略</a>&#8221;.  默认为 <code>create-if-not-found</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>named-queries-location</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义搜索包含外部定义查询的属性文件的位置.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>consider-nested-repositories</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否应考虑嵌套的存储库接口定义.  默认为 <code>false</code>.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="populator.namespace-reference"><a class="anchor" href="#populator.namespace-reference"></a>Appendix B: Populators  命名空间参考</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="namespace-dao-config"><a class="anchor" href="#namespace-dao-config"></a>&lt;populator /&gt; element</h3>
<div class="paragraph">
<p><code>&lt;populator /&gt;</code> 元素允许通过Spring数据存储库基础结构填充数据存储. <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. 属性</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>locations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从哪里可以找到要从存储库读取对象的文件,应在其中填充.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repository-query-keywords"><a class="anchor" href="#repository-query-keywords"></a>Appendix C: 存储库查询关键字</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="appendix.query.method.subject"><a class="anchor" href="#appendix.query.method.subject"></a>支持的查询方法主题关键字</h3>
<div class="paragraph">
<p>下表列出了 Spring Data 存储库查询扩展机制通常支持的表示断言的主题关键字.但是,请参阅 store-specific 的文档以获取受支持关键字的确切列表,因为 store-specific 可能不支持此处列出的某些关键字.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. Query 主题关键字</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">关键字</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>find…By</code>, <code>read…By</code>, <code>get…By</code>, <code>query…By</code>, <code>search…By</code>, <code>stream…By</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一般查询方法通常返回存储库类型,  <code>Collection</code> 或 <code>Streamable</code> 的子类型或包装类型 <code>Page</code>, <code>GeoResults</code> 或任何其他 store-specific 的结果包装器. 可以用作 <code>findBy…</code>, <code>findMyDomainTypeBy…</code> 或其他关键字结合使用.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exists…By</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否存在, 通常返回 <code>boolean</code> 类型.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>count…By</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计算返回的结果数字</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>delete…By</code>, <code>remove…By</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除查询方法,不返回结果 (<code>void</code>) 或 delete count.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>…First&lt;number&gt;…</code>, <code>…Top&lt;number&gt;…</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回查询结果的第一个 <code>&lt;number&gt;</code> . 此关键字可以出现在主题 <code>find</code> (或其他关键字) 和 <code>by</code> 之间.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>…Distinct…</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 distinct 查询返回唯一的结果. 请查阅特定的文档以了解是否支持该功能. 此关键字可以出现在主题 <code>find</code> (或其他关键字) 和 <code>by</code> 之间.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="appendix.query.method.predicate"><a class="anchor" href="#appendix.query.method.predicate"></a>支持的查询方法断言关键字和修饰符</h3>
<div class="paragraph">
<p>下表列出了 Spring Data 存储库查询扩展机制通常支持的断言关键字.  但是,请参阅 store-specific 的文档以获取受支持关键字的确切列表,因为 store-specific 可能不支持此处列出的某些关键字.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. 查询断言关键字</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">逻辑关键字</th>
<th class="tableblock halign-left valign-top">关键字表达</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AND</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>And</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Or</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AFTER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>After</code>, <code>IsAfter</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BEFORE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Before</code>, <code>IsBefore</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONTAINING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Containing</code>, <code>IsContaining</code>, <code>Contains</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BETWEEN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Between</code>, <code>IsBetween</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENDING_WITH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EndingWith</code>, <code>IsEndingWith</code>, <code>EndsWith</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXISTS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Exists</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>False</code>, <code>IsFalse</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GREATER_THAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThan</code>, <code>IsGreaterThan</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GREATER_THAN_EQUALS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThanEqual</code>, <code>IsGreaterThanEqual</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>In</code>, <code>IsIn</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Is</code>, <code>Equals</code>, (or no keyword)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_EMPTY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsEmpty</code>, <code>Empty</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_NOT_EMPTY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNotEmpty</code>, <code>NotEmpty</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_NOT_NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotNull</code>, <code>IsNotNull</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Null</code>, <code>IsNull</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LESS_THAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThan</code>, <code>IsLessThan</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LESS_THAN_EQUAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThanEqual</code>, <code>IsLessThanEqual</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LIKE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Like</code>, <code>IsLike</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NEAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Near</code>, <code>IsNear</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Not</code>, <code>IsNot</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT_IN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotIn</code>, <code>IsNotIn</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT_LIKE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotLike</code>, <code>IsNotLike</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REGEX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Regex</code>, <code>MatchesRegex</code>, <code>Matches</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STARTING_WITH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StartingWith</code>, <code>IsStartingWith</code>, <code>StartsWith</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>True</code>, <code>IsTrue</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WITHIN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Within</code>, <code>IsWithin</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除过滤断言外,还支持以下修饰符列表:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. 查询断言修饰符关键字</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">关键字</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IgnoreCase</code>, <code>IgnoringCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与福安艳关键字一起使用,不区分大小写的比较.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AllIgnoreCase</code>, <code>AllIgnoringCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">忽略所有属性的大小写. 在查询方法断言中的某处使用.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OrderBy…</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定一个静态的排序顺序,后面跟属性的 path 和 方向 (例如. <code>OrderByFirstnameAscLastnameDesc</code>).</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repository-query-return-types"><a class="anchor" href="#repository-query-return-types"></a>Appendix D: 储存库查询返回类型</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="appendix.query.return.types"><a class="anchor" href="#appendix.query.return.types"></a>支持的查询返回类型</h3>
<div class="paragraph">
<p>下表列出了 Spring Data 存储库通常支持的返回类型.  但是,请参阅 store-specific 的文档以获取受支持的退货类型的确切列表,因为特定 存储 可能不支持此处列出的某些类型.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
地理空间类型 (例如 <code>GeoResult</code>,<code>GeoResults</code> 和 <code>GeoPage</code>) 仅适用于支持地理空间查询的数据存储.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>某些存储模块可能会定义自己的结果包装器类型.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. 查询返回类型</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示没有返回值.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primitives</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 原语.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wrapper types</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 包装器类型.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">唯一实体.  期望查询方法最多返回一个结果.  如果未找到结果,则返回 <code>null</code>.  一个以上的结果触发一个 <code>IncorrectResultSizeDataAccessException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterator&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterator</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Collection&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Collection</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Optional&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 8或 <code>Guava</code> 可选.  期望查询方法最多返回一个结果.  如果未找到结果,则返回 <code>Optional.empty()</code> 或 <code>Optional.absent()</code>.  一个以上的结果触发一个 <code>IncorrectResultSizeDataAccessException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Option&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scala或Vavr <code>Option</code> 类型.  语义上与前面描述的Java 8的 <code>Optional</code> 行为相同.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Stream&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 8 <code>Stream</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Streamable&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterable</code> 的便捷扩展,直接将方法暴露以流式处理,映射和过滤结果,将其串联等.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Types that implement <code>Streamable</code> and take a <code>Streamable</code> constructor or factory method argument</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">暴露构造函数或使用Streamable作为参数的  <code>….of(…)</code>/<code>….valueOf(…)</code> 工厂方法的类型.  有关详细信息,请参见返回<a href="#repositories.collections-and-iterables.streamable-wrapper">自定义流式包装器类型</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vavr <code>Seq</code>, <code>List</code>, <code>Map</code>, <code>Set</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vavr集合类型.  有关详细信息,请参见 <a href="#repositories.collections-and-iterables.vavr">支持Vavr集合</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Future&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Future</code>.  期望使用 <code>@Async</code> 注解方法,并且需要启用Spring的异步方法执行功能.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CompletableFuture&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 8 <code>CompletableFuture</code>.  期望使用 <code>@Async</code> 注解方法,并且需要启用Spring的异步方法执行功能.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ListenableFuture</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.util.concurrent.ListenableFuture</code>.  期望使用 <code>@Async</code> 注解方法,并且需要启用Spring的异步方法执行功能.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Slice&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一定大小的数据块,用于指示是否有更多可用数据.  需要 <code>Pageable</code> 方法参数.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Page&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有附加信息 (例如结果总数) 的 <code>Slice</code>.  需要 <code>Pageable</code> 方法参数.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoResult&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有附加信息 (例如到参考位置的距离) 的结果条目.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoResults&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含其他信息的 <code>GeoResult&lt;T&gt;</code> 列表,例如到参考位置的平均距离.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoPage&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有 <code>GeoResult&lt;T&gt;</code> 的页面,例如到参考位置的平均距离.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 Reactor 储存库发射零或一个元素的Project Reactor Mono.  期望查询方法最多返回一个结果.  如果未找到结果,则返回 <code>Mono.empty()</code>.  一个以上的结果触发一个 <code>IncorrectResultSizeDataAccessException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 Reactor 存储库发射零,一个或多个元素的Project Reactor通量.  返回 <code>Flux</code> 的查询也可以发出无限数量的元素.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Single&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 Reactor 存储库发出 <code>Single</code>  元素的RxJava Single.  期望查询方法最多返回一个结果.  如果未找到结果,则返回 <code>Mono.empty()</code>.  一个以上的结果触发一个 <code>IncorrectResultSizeDataAccessException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Maybe&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RxJava可能使用 Reactor 存储库发出零个或一个元素.  期望查询方法最多返回一个结果.  如果未找到结果,则返回 <code>Mono.empty()</code> .  一个以上的结果触发一个 <code>IncorrectResultSizeDataAccessException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flowable&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RxJava <code>Flowable</code> 使用响应式存储库发出零个,一个或多个元素.  返回 <code>Flowable</code> 的查询也可以发出无限数量的元素.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="faq"><a class="anchor" href="#faq"></a>Appendix E: 常见问题</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="通用"><a class="anchor" href="#通用"></a>通用</h3>
<div class="qlist qanda">
<ol>
<li>
<p><em>我想获得更详细的日志记录信息,例如有关在 <code>JpaRepository</code> 内部调用哪些方法的信息.  我如何获得他们? </em></p>
<p>您可以使用 Spring 提供的 <code>CustomizableTraceInterceptor</code>,如以下示例所示:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="customizableTraceInterceptor" class="
  org.springframework.aop.interceptor.CustomizableTraceInterceptor"&gt;
  &lt;property name="enterMessage" value="Entering $[methodName]($[arguments])"/&gt;
  &lt;property name="exitMessage" value="Leaving $[methodName](): $[returnValue]"/&gt;
&lt;/bean&gt;

&lt;aop:config&gt;
  &lt;aop:advisor advice-ref="customizableTraceInterceptor"
    pointcut="execution(public * org.springframework.data.jpa.repository.JpaRepository+.*(..))"/&gt;
&lt;/aop:config&gt;</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="基础"><a class="anchor" href="#基础"></a>基础</h3>
<div class="qlist qanda">
<ol>
<li>
<p><em>目前,我已经基于 HibernateDaoSupport 实现了一个存储库层.  我使用 <code>Spring 的AnnotationSessionFactoryBean</code> 创建一个 <code>SessionFactory</code>.  如何在这种环境中使用 Spring Data 存储库? </em></p>
<p>您必须使用 <code>HibernateJpaSessionFactoryBean</code> 替换 <code>AnnotationSessionFactoryBean</code>,如下所示:</p>
<div class="exampleblock">
<div class="title">Example 119. 从一个 <code>HibernateEntityManagerFactory</code> 查找一个 <code>SessionFactory</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="sessionFactory" class="org.springframework.orm.jpa.vendor.HibernateJpaSessionFactoryBean"&gt;
  &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="审计"><a class="anchor" href="#审计"></a>审计</h3>
<div class="qlist qanda">
<ol>
<li>
<p><em>我想使用 Spring Data JPA 审计功能,但是已经将我的数据库配置为在实体上设置修改和创建日期.  如何防止 Spring Data 以编程方式设置日期. </em></p>
<p>将 <code>auditing</code> 命名空间元素的 <code>set-dates</code> 属性设置为 <code>false</code>.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="glossary"><a class="anchor" href="#glossary"></a>Appendix F: 词汇表</h2>
<div class="sectionbody">
<div class="dlist">
<dl>
<dt class="hdlist1">AOP </dt>
<dd>
<p>面向切面的编程</p>
</dd>
<dt class="hdlist1">Commons DBCP </dt>
<dd>
<p>Commons DataBase Connection Pools-来自 Apache 基础的库,提供 DataSource 接口的池实现.</p>
</dd>
<dt class="hdlist1">CRUD </dt>
<dd>
<p>创建,读取,更新,删除-基本持久性操作.</p>
</dd>
<dt class="hdlist1">DAO </dt>
<dd>
<p>数据访问对象-用于将持久逻辑与要持久的对象分离的模式</p>
</dd>
<dt class="hdlist1">Dependency Injection </dt>
<dd>
<p>从外部将组件的依赖传递给组件的模式,以释放组件以查找依赖本身.  有关更多信息,请参见  <a href="https://en.wikipedia.org/wiki/Dependency_Injection"><a href="https://en.wikipedia.org/wiki/Dependency_Injection" class="bare">en.wikipedia.org/wiki/Dependency_Injection</a></a>.</p>
</dd>
<dt class="hdlist1">EclipseLink </dt>
<dd>
<p>实现 JPA 的对象关系映射器- <a href="https://www.eclipse.org/eclipselink/"><a href="https://www.eclipse.org/eclipselink/" class="bare">www.eclipse.org/eclipselink/</a></a></p>
</dd>
<dt class="hdlist1">Hibernate </dt>
<dd>
<p>实现 JPA 的对象关系映射器 - <a href="https://hibernate.org/"><a href="https://hibernate.org/" class="bare">hibernate.org/</a></a></p>
</dd>
<dt class="hdlist1">JPA </dt>
<dd>
<p>Java 持久性 API</p>
</dd>
<dt class="hdlist1">Spring </dt>
<dd>
<p>Java 应用程序框架 - <a href="https://projects.spring.io/spring-framework"><a href="https://projects.spring.io/spring-framework" class="bare">projects.spring.io/spring-framework</a></a></p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. 参阅 <a href="#repositories.create-instances.spring">XML 配置</a>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2.3.6.RELEASE<br>
Last updated 2021-02-06 12:43:48 +0800
</div>
</div>
<script type="text/javascript" src="http://resources.jcohy.com/js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="http://resources.jcohy.com/js/toc.js"></script>
<script type="text/javascript" src="http://resources.jcohy.com/js/switch-language.js"></script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<title>JPA 存储库</title>
<style>
@import 'http://resources.jcohy.com/css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			selectedIndex = $(this).index()
			$(".switch--item").filter(function() { return ($(this).text() === selectedText) }).each(function() {
				$(this).addClass('selected');
				$(this).siblings().removeClass('selected');
				selectedContent = $(this).parent().siblings(".content").eq(selectedIndex)
				selectedContent.removeClass('hidden');
				selectedContent.siblings().addClass('hidden');
			});
		});
	});
}

$(addBlockSwitches);
$(globalSwitch);

</script>

</head>
<body id="jpa.repositories" class="book toc2 toc-left">
<div id="header">
<h1>JPA 存储库</h1>
<div class="details">
<span id="revnumber">version 2.3.6.RELEASE,</span>
<span id="revdate">2021-05-14</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#jpa.introduction">1. 简介</a>
<ul class="sectlevel2">
<li><a href="#jpa.namespace">1.1. Spring 命名空间</a>
<ul class="sectlevel3">
<li><a href="#自定义命名空间属性">1.1.1. 自定义命名空间属性</a></li>
</ul>
</li>
<li><a href="#jpa.java-config">1.2. 基于注解的配置</a></li>
<li><a href="#jpa.bootstrap-mode">1.3. 引导模式</a>
<ul class="sectlevel3">
<li><a href="#推荐建议">1.3.1. 推荐建议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jpa.entity-persistence">2. 持久化实体</a>
<ul class="sectlevel2">
<li><a href="#jpa.entity-persistence.saving-entites">2.1. 保存实体</a>
<ul class="sectlevel3">
<li><a href="#jpa.entity-persistence.saving-entites.strategies">2.1.1. 实体状态检测策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jpa.query-methods">3. 查询方法</a>
<ul class="sectlevel2">
<li><a href="#jpa.sample-app.finders.strategies">3.1. 查询策略</a>
<ul class="sectlevel3">
<li><a href="#声明查询">3.1.1. 声明查询</a></li>
</ul>
</li>
<li><a href="#jpa.query-methods.query-creation">3.2. 查询创建</a></li>
<li><a href="#jpa.query-methods.named-queries">3.3. 使用 JPA 命名查询</a>
<ul class="sectlevel3">
<li><a href="#xml-命名查询定义">3.3.1. XML 命名查询定义</a></li>
<li><a href="#基于注解的配置">3.3.2. 基于注解的配置</a></li>
<li><a href="#声明接口">3.3.3. 声明接口</a></li>
</ul>
</li>
<li><a href="#jpa.query-methods.at-query">3.4. 使用 <code>@Query</code></a>
<ul class="sectlevel3">
<li><a href="#使用高级-like-表达式">3.4.1. 使用高级 <code>LIKE</code> 表达式</a></li>
<li><a href="#本地查询">3.4.2. 本地查询</a></li>
</ul>
</li>
<li><a href="#jpa.query-methods.sorting">3.5. 使用排序</a></li>
<li><a href="#jpa.named-parameters">3.6. 使用命名参数</a></li>
<li><a href="#jpa.query.spel-expressions">3.7. 使用 SpEL 表达式</a></li>
<li><a href="#jpa.modifying-queries">3.8. 修改查询</a>
<ul class="sectlevel3">
<li><a href="#jpa.modifying-queries.derived-delete">3.8.1. 扩展删除查询</a></li>
</ul>
</li>
<li><a href="#jpa.query-hints">3.9. 应用查询提示</a></li>
<li><a href="#jpa.entity-graph">3.10. 配置 Fetch- 和 LoadGraphs</a></li>
<li><a href="#projections">3.11. 投影</a>
<ul class="sectlevel3">
<li><a href="#projections.interfaces">3.11.1. 基于接口的投影</a>
<ul class="sectlevel4">
<li><a href="#projections.interfaces.closed">封闭投影</a></li>
<li><a href="#projections.interfaces.open">打开投影</a></li>
</ul>
</li>
<li><a href="#projections.dtos">3.11.2. 基于类的投影 (DTO)</a></li>
<li><a href="#projection.dynamic">3.11.3. 动态投影</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jpa.stored-procedures">4. 存储过程</a></li>
<li><a href="#specifications">5. Specification</a></li>
<li><a href="#query-by-example">6. 查询例子</a>
<ul class="sectlevel2">
<li><a href="#query-by-example.introduction">6.1. 简介</a></li>
<li><a href="#query-by-example.usage">6.2. 使用</a></li>
<li><a href="#query-by-example.matchers">6.3. Example 匹配</a></li>
<li><a href="#query-by-example.running">6.4. 执行一个例子</a></li>
</ul>
</li>
<li><a href="#transactions">7. 事务性</a>
<ul class="sectlevel2">
<li><a href="#transactional-query-methods">7.1. 事务查询方法</a></li>
</ul>
</li>
<li><a href="#locking">8. 锁</a></li>
<li><a href="#auditing">9. 审计</a>
<ul class="sectlevel2">
<li><a href="#auditing.basics">9.1. 基础</a>
<ul class="sectlevel3">
<li><a href="#auditing.annotations">9.1.1. 基于注解的审核元数据</a></li>
<li><a href="#auditing.interfaces">9.1.2. 基于接口的审核元数据</a></li>
<li><a href="#auditing.auditor-aware">9.1.3. <code>AuditorAware</code></a></li>
</ul>
</li>
<li><a href="#jpa.auditing">9.2. JPA 审计</a>
<ul class="sectlevel3">
<li><a href="#jpa.auditing.configuration">9.2.1. 通用审核配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jpa.misc">10. 其他注意事项</a>
<ul class="sectlevel2">
<li><a href="#jpa.misc.jpa-context">10.1. 在自定义实现中使用 <code>JpaContext</code></a></li>
<li><a href="#jpa.misc.merging-persistence-units">10.2. 合并持久性单元</a>
<ul class="sectlevel3">
<li><a href="#jpa.misc.entity-scanning">10.2.1. @Entity 类和 JPA 映射文件的类路径扫描</a></li>
</ul>
</li>
<li><a href="#jpd.misc.cdi-integration">10.3. CDI 集成</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>本章指出了 JPA 存储库支持的特性.  这建立在  &#8220;<a href="#repositories">使用 Spring 数据存储库</a>&#8221; 中解释的核心存储库支持的基础上.  确保您对此处介绍的基本概念有很好的了解.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jpa.introduction"><a class="anchor" href="#jpa.introduction"></a>1. 简介</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节介绍通过以下两种方式配置 Spring Data JPA 的基础知识:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&#8220;<a href="#jpa.namespace">Spring 命名空间</a>&#8221; (XML 配置)</p>
</li>
<li>
<p>&#8220;<a href="#jpa.java-config">基于注解的配置</a>&#8221; (Java 配置)</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="jpa.namespace"><a class="anchor" href="#jpa.namespace"></a>1.1. Spring 命名空间</h3>
<div class="paragraph">
<p>Spring Data 的 JPA 模块包含一个自定义命名空间,允许定义存储库 bean.  它还包含 JPA 特有的某些功能和元素属性.  通常,可以通过使用 <code>repositories</code> 元素来设置 JPA 存储库,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. 使用命名空间建立 JPA 存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:jpa="http://www.springframework.org/schema/data/jpa"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    https://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

  &lt;jpa:repositories base-package="com.acme.repositories" /&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>repositories</code>  元素可按  &#8220;<a href="#repositories.create-instances">创建存储库实例</a>&#8221; 中所述查找 Spring Data 存储库.  除此之外,它还为所有使用 <code>@Repository</code> 注解的 bean 激活持久性异常转换,以将 JPA 持久性导致的异常转换为 Spring 的 <code>DataAccessException</code> 层次结构.</p>
</div>
<div class="sect3">
<h4 id="自定义命名空间属性"><a class="anchor" href="#自定义命名空间属性"></a>1.1.1. 自定义命名空间属性</h4>
<div class="paragraph">
<p>除了 <code>repositories</code>  元素的默认属性之外,JPA 命名空间还提供了其他属性,使您可以更详细地控制存储库的设置:</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 1. 自定义 JPA 特定于 <code>repositories</code> 元素的属性</caption>
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>entity-manager-factory-ref</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显式地将 <code>EntityManagerFactory</code> 与要使用的 <code>repositories</code> 元素所检测到的存储库连接.  通常在应用程序中使用多个 <code>EntityManagerFactory</code> bean 的情况下使用.  如果未配置,Spring Data 会在 <code>ApplicationContext</code> 中自动查找名称为 <code>EntityManagerFactory</code> 的 <code>EntityManagerFactory</code> bean.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>transaction-manager-ref</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">明确地将 <code>PlatformTransactionManager</code> 与要由 <code>repositories</code> 元素检测到的存储库进行连线.  通常仅在配置了多个事务管理器或 <code>EntityManagerFactory</code> bean 时才需要.  默认为当前 <code>ApplicationContext</code> 中单个定义的 <code>PlatformTransactionManager</code>.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果显式未定义的 <code>transaction-manager-ref</code>,Spring Data JPA 要求提供一个名为 <code>transactionManager</code> 的 <code>PlatformTransactionManager</code> bean.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.java-config"><a class="anchor" href="#jpa.java-config"></a>1.2. 基于注解的配置</h3>
<div class="paragraph">
<p>Spring Data JPA 存储库支持不仅可以通过 XML 命名空间来激活,还可以通过 JavaConfig 使用注解来激活,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. 使用 JavaConfig 的 Spring Data JPA 存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJpaRepositories
@EnableTransactionManagement
class ApplicationConfig {

  @Bean
  public DataSource dataSource() {

    EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder();
    return builder.setType(EmbeddedDatabaseType.HSQL).build();
  }

  @Bean
  public LocalContainerEntityManagerFactoryBean entityManagerFactory() {

    HibernateJpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter();
    vendorAdapter.setGenerateDdl(true);

    LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();
    factory.setJpaVendorAdapter(vendorAdapter);
    factory.setPackagesToScan("com.acme.domain");
    factory.setDataSource(dataSource());
    return factory;
  }

  @Bean
  public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {

    JpaTransactionManager txManager = new JpaTransactionManager();
    txManager.setEntityManagerFactory(entityManagerFactory);
    return txManager;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
您必须直接创建 <code>LocalContainerEntityManagerFactoryBean</code> 而不是 <code>EntityManagerFactory</code>,因为前者除了创建 <code>EntityManagerFactory</code> 之外,还参与异常转换机制.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jpa.bootstrap-mode"><a class="anchor" href="#jpa.bootstrap-mode"></a>1.3. 引导模式</h3>
<div class="paragraph">
<p>默认情况下,Spring Data JPA 存储库是默认的 Spring Bean.  它们是单例作用域,并且已被初始化.  在启动期间,它们已经与 JPA <code>EntityManager</code> 进行交互,以进行验证和元数据分析.
Spring 框架在后台线程中支持 JPA <code>EntityManagerFactory</code> 的初始化,因为该过程通常在 Spring 应用程序中占用大量启动时间.  为了有效地利用后台初始化,我们需要确保 JPA 存储库尽可能早地初始化.</p>
</div>
<div class="paragraph">
<p>从 Spring Data JPA 2.1 开始,您现在可以配置 <code>BootstrapMode</code> (通过 <code>@EnableJpaRepositories</code> 注解或 XML 命名空间) ,该 <code>BootstrapMode</code> 采用以下值:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DEFAULT</code> (默认值)&#8201;&#8212;&#8201;急切地实例化存储库,除非使用 <code>@Lazy</code> 显式注解.  仅当没有任何客户 Bean 需要存储库实例时,<code>lazification</code> 才有效,因为这将需要初始化存储库 bean.</p>
</li>
<li>
<p><code>LAZY</code>&#8201;&#8212;&#8201;隐式地声明所有存储库 bean 都是惰性的,并且还使创建的惰性初始化代理被注入到客户端 bean 中.  这意味着,如果客户端 bean 仅将实例存储在字段中并且在初始化期间不使用存储库,则不会实例化存储库.  首次与存储库交互时,将初始化并验证存储库实例.</p>
</li>
<li>
<p><code>DEFERRED</code>&#8201;&#8212;&#8201;基本与 <code>LAZY</code> 相同,但会响应 <code>ContextRefreshedEvent</code> 触发存储库初始化,以便在应用程序完全启动之前验证存储库.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="推荐建议"><a class="anchor" href="#推荐建议"></a>1.3.1. 推荐建议</h4>
<div class="paragraph">
<p>如果您不使用默认 Bootstrap 模式的异步 JPA 引导.</p>
</div>
<div class="paragraph">
<p>如果您以异步方式引导 JPA,则 <code>DEFERRED</code> 是一个合理的默认值,因为它可以确保 Spring Data JPA 引导仅在其花费比初始化所有其他应用程序组件更长的时间时才等待 <code>EntityManagerFactory</code> 安装.  尽管如此,它仍可以确保在应用程序发出信号之前,对存储库进行了正确的初始化和验证.</p>
</div>
<div class="paragraph">
<p><code>LAZY</code> 是测试方案和本地开发的不错选择.  一旦确定了存储库将正确引导后,或者在测试应用程序的其他部分时,对所有存储库执行验证可能只会不必要地增加启动时间.  这同样适用于本地开发,在本地开发中,您仅访问应用程序的某些部分,而这些部分可能只需要初始化一个存储库即可.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jpa.entity-persistence"><a class="anchor" href="#jpa.entity-persistence"></a>2. 持久化实体</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节描述如何使用 Spring Data JPA 持久化 (保存) 实体.</p>
</div>
<div class="sect2">
<h3 id="jpa.entity-persistence.saving-entites"><a class="anchor" href="#jpa.entity-persistence.saving-entites"></a>2.1. 保存实体</h3>
<div class="paragraph">
<p>可以使用 <code>CrudRepository.save(…)</code>  方法执行保存实体.  它通过使用基础 JPA <code>EntityManager</code> 持久化或合并给定实体.  如果实体还没有持久化,Spring Data JPA 会通过调用 <code>entityManager.persist(…)</code> 方法来保存实体.  否则,它将调用 <code>entityManager.merge(…)</code> 方法.</p>
</div>
<div class="sect3">
<h4 id="jpa.entity-persistence.saving-entites.strategies"><a class="anchor" href="#jpa.entity-persistence.saving-entites.strategies"></a>2.1.1. 实体状态检测策略</h4>
<div class="paragraph">
<p>Spring Data JPA 提供以下策略来检测实体是否为新实体:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Version-Property 和 Id-Property 检查 (默认) : 默认情况下,Spring Data JPA 首先检查是否存在非基本类型的 Version-property.
如果存在,则将该实体视为新实体 (如果该值为 <code>null</code>) .  没有这样的版本属性,Spring Data JPA 会检查给定实体的标识符属性.  如果标识符属性为 <code>null</code>,则假定该实体为新实体.  否则,它不是新的.</p>
</li>
<li>
<p>实现 <code>Persistable</code>: 如果实体实现 <code>Persistable</code>,则 Spring Data JPA 将新检测委托给该实体的 <code>isNew(…)</code> 方法.  有关详细信息,请参见 <a href="https://docs.spring.io/spring-data/data-commons/docs/current/api/index.html?org/springframework/data/domain/Persistable.html">JavaDoc</a> .</p>
</li>
<li>
<p>实现 <code>EntityInformation</code>: 通过创建 <code>JpaRepositoryFactory</code> 的子类并相应地重写  <code>getEntityInformation(…)</code> 方法,可以自定义 <code>SimpleJpaRepository</code> 实现中使用的 <code>EntityInformation</code> 抽象.  然后,您必须将 JpaRepositoryFactory 的自定义实现注册为 Spring bean.  请注意,这几乎没有必要.  有关详细信息,请参见  <a href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/JpaRepositoryFactory.html">JavaDoc</a> .</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>对于使用手动分配的标识符的实体,选项 1 不是选项,因为标识符将始终为非 <code>null</code>.  在这种情况下,一种常见的模式是使用一个公共基类,该基类的过渡标志默认表示一个新实例,并使用 JPA 生命周期回调在持久化操作上反转该标志:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. 具有手动分配的标识符的实体的基类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@MappedSuperclass
public abstract class AbstractEntity&lt;ID&gt; implements Persistable&lt;ID&gt; {

  @Transient
  private boolean isNew = true; <i class="conum" data-value="1"></i><b>(1)</b>

  @Override
  public boolean isNew() {
    return isNew; <i class="conum" data-value="2"></i><b>(2)</b>
  }

  @PrePersist <i class="conum" data-value="3"></i><b>(3)</b>
  @PostLoad
  void markNotNew() {
    this.isNew = false;
  }

  // More code…
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>声明一个标志以保持新状态.  暂时的,因此它不会持久化到数据库中.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在 <code>Persistable.isNew()</code> 的实现中返回标志,以便 Spring Data 存储库知道是调用 <code>EntityManager.persist()</code> 还是  <code>….merge()</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>声明一个使用 JPA 实体回调的方法,以便在存储库调用 <code>save(…)</code> 或持久性提供程序创建实例之后,将标志切换为指示现有实体.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jpa.query-methods"><a class="anchor" href="#jpa.query-methods"></a>3. 查询方法</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节描述了使用 Spring Data JPA 创建查询的各种方法.</p>
</div>
<div class="sect2">
<h3 id="jpa.sample-app.finders.strategies"><a class="anchor" href="#jpa.sample-app.finders.strategies"></a>3.1. 查询策略</h3>
<div class="paragraph">
<p>JPA 模块支持手动将查询定义为 String 或从方法名称扩展查询.</p>
</div>
<div class="paragraph">
<p>断言为 <code>IsStartingWith</code>,<code>StartingWith</code>,<code>StartsWith</code>,<code>IsEndingWith</code>,<code>EndingWith</code>,<code>EndsWith</code>,<code>IsNotContaining</code>,<code>NotContaining</code>,<code>NotContains</code>,<code>IsContaining</code>,<code>Containing</code> 的扩展查询将包含这些查询的各自参数.
这意味着,如果参数实际包含 <code>LIKE</code> 识别为通配符的字符,则这些字符将被转义,因此它们仅作为文字匹配.  可以通过设置 <code>@EnableJpaRepositories</code> 注解的 <code>escapeCharacter</code> 来配置使用的转义字符.  与使用 <a href="#jpa.query.spel-expressions">SpEL 表达式</a>进行比较.</p>
</div>
<div class="sect3">
<h4 id="声明查询"><a class="anchor" href="#声明查询"></a>3.1.1. 声明查询</h4>
<div class="paragraph">
<p>尽管从方法名扩展一个查询很方便,但可能会遇到这样一种情况,即方法名解析器不支持一个人想使用的关键字,或者方法名变的丑陋.  因此,您可以通过命名约定使用 JPA 命名查询 (有关更多信息,请参见使用<a href="#jpa.query-methods.named-queries">JPA 命名查询</a>) , 或者通过 <code>@Query</code> 注解您的查询方法 (有关详细信息,请参见使用 <code>@Query</code>) .</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.query-methods.query-creation"><a class="anchor" href="#jpa.query-methods.query-creation"></a>3.2. 查询创建</h3>
<div class="paragraph">
<p>通常,JPA 的查询创建机制按 &#8220;<a href="#repositories.query-methods">查询方法</a>&#8221; 中所述运行.  以下示例显示了 JPA 查询方法转换为的内容:</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. 通过方法名称创建查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>public interface UserRepository extends Repository&lt;User, Long&gt; {

  List&lt;User&gt; findByEmailAddressAndLastname(String emailAddress, String lastname);
}</pre>
</div>
</div>
<div class="paragraph">
<p>我们从中使用 JPA 标准 API 创建查询,但是从本质上讲,这将转换为以下查询: <code>select u from User u where u.emailAddress = ?1 and u.lastname = ?2</code>.  Spring Data JPA 进行属性检查并遍历嵌套的属性,如  &#8220;<a href="#repositories.query-methods.query-property-expressions">属性表达式</a>&#8221; 中所述.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>下表描述了 JPA 支持的关键字以及包含该关键字的方法所转换的含义:</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 2. 方法名称中受支持的关键字</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">关键字</th>
<th class="tableblock halign-left valign-top">Sample</th>
<th class="tableblock halign-left valign-top">JPQL snippet</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Distinct</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findDistinctByLastnameAndFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>select distinct &#8230;&#8203; where x.lastname = ?1 and x.firstname = ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>And</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameAndFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname = ?1 and x.firstname = ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Or</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameOrFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname = ?1 or x.firstname = ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Is</code>, <code>Equals</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname = ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Between</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateBetween</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate between ?1 and ?2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeLessThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &lt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeLessThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &lt;= ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeGreaterThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeGreaterThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age &gt;= ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>After</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateAfter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate &gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Before</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStartDateBefore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.startDate &lt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNull</code>, <code>Null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAge(Is)Null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age is null</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNotNull</code>, <code>NotNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAge(Is)NotNull</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age not null</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Like</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameNotLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname not like ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StartingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameStartingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound with appended <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EndingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameEndingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound with prepended <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Containing</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameContaining</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.firstname like ?1</code> (parameter bound wrapped in <code>%</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OrderBy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeOrderByLastnameDesc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age = ?1 order by x.lastname desc</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Not</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameNot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.lastname &lt;&gt; ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>In</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age in ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotIn</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAgeNotIn(Collection&lt;Age&gt; ages)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.age not in ?1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>True</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByActiveTrue()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.active = true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>False</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByActiveFalse()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where x.active = false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IgnoreCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstnameIgnoreCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>… where UPPER(x.firstname) = UPPER(?1)</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>In</code> 和 <code>NotIn</code> 也将 <code>Collection</code> 的任何子类作为参数以及 <code>varargs</code> 的数组.  对于同一逻辑运算符的其他语法版本,请选中 &#8220;<a href="#repository-query-keywords">存储库查询关键字</a>&#8221;.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jpa.query-methods.named-queries"><a class="anchor" href="#jpa.query-methods.named-queries"></a>3.3. 使用 JPA 命名查询</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这些示例使用 <code>&lt;named-query /&gt;</code> 元素和 <code>@NamedQuery</code> 注解.  这些配置元素的查询必须使用 JPA 查询语言进行定义.  当然,您也可以使用 <code>&lt;named-native-query /&gt;</code> 或 <code>@NamedNativeQuery</code> .  这些元素使您可以通过在没有数据库平台独立性来在本地 SQL 中定义查询.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="xml-命名查询定义"><a class="anchor" href="#xml-命名查询定义"></a>3.3.1. XML 命名查询定义</h4>
<div class="paragraph">
<p>要使用 XML 配置,请将必要的 <code>&lt;named-query /&gt;</code> 元素添加到位于类路径的 <code>META-INF</code> 文件夹中的 <code>orm.xml</code> JPA 配置文件中.  通过使用一些定义的命名约定,可以自动调用命名查询.  有关更多详细信息,请参见下文.</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. XML 命名查询配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;named-query name="User.findByLastname"&gt;
  &lt;query&gt;select u from User u where u.lastname = ?1&lt;/query&gt;
&lt;/named-query&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该查询具有一个特殊名称,该名称用于在运行时解析它.</p>
</div>
</div>
<div class="sect3">
<h4 id="基于注解的配置"><a class="anchor" href="#基于注解的配置"></a>3.3.2. 基于注解的配置</h4>
<div class="paragraph">
<p>基于注解的配置的优点是不需要编辑另一个配置文件,从而减少了维护工作.  您需要为每个新的查询声明重新编译 domain 类,从而为此付出了代价.</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. 基于注解的命名查询配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Entity
@NamedQuery(name = "User.findByEmailAddress",
  query = "select u from User u where u.emailAddress = ?1")
public class User {

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="声明接口"><a class="anchor" href="#声明接口"></a>3.3.3. 声明接口</h4>
<div class="paragraph">
<p>要允许执行这些命名查询,请按以下方式指定 <code>UserRepository</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. UserRepository中的查询方法声明</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  List&lt;User&gt; findByLastname(String lastname);

  User findByEmailAddress(String emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Data 尝试将对这些方法的调用解析为对命名查询的调用,从已配置 domain 类的简单名称开始,然后是由 点分隔的方法名称.  因此,前面的示例将使用示例中定义的命名查询,而不是尝试从方法名称创建查询.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.query-methods.at-query"><a class="anchor" href="#jpa.query-methods.at-query"></a>3.4. 使用 <code>@Query</code></h3>
<div class="paragraph">
<p>使用命名查询声明对实体的查询是一种有效的方法,并且对于少量查询也可以正常工作.  由于查询本身与执行它们的 Java 方法相关联,因此您实际上可以通过使用 Spring Data JPA <code>@Query</code> 注解直接绑定它们,而不是将它们注解到 domain 类.
这样可以将 domain 类从持久性特定的信息中释放出来,并将查询放置在存储库接口中.</p>
</div>
<div class="paragraph">
<p>注解查询方法的查询优先于使用 <code>@NamedQuery</code> 定义的查询或在 <code>orm.xml</code> 中声明的命名查询.</p>
</div>
<div class="paragraph">
<p>以下示例显示使用 <code>@Query</code> 注解创建的查询:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. 使用 <code>@Query</code> 在查询方法中声明查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query("select u from User u where u.emailAddress = ?1")
  User findByEmailAddress(String emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="使用高级-like-表达式"><a class="anchor" href="#使用高级-like-表达式"></a>3.4.1. 使用高级 <code>LIKE</code> 表达式</h4>
<div class="paragraph">
<p>使用 <code>@Query</code> 创建的手动定义查询的查询执行机制允许在查询定义中定义高级 <code>LIKE</code> 表达式,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. @Query中的高级 <code>like</code> 表达式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query("select u from User u where u.firstname like %?1")
  List&lt;User&gt; findByFirstnameEndsWith(String firstname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中,识别了 <code>LIKE</code> 分隔符 (<code>％</code>) ,并将查询转换为有效的 JPQL 查询 (删除了 <code>％</code>) .  查询执行后,传递给方法调用的参数将使用先前识别的 <code>LIKE</code> 模式进行扩充.</p>
</div>
</div>
<div class="sect3">
<h4 id="本地查询"><a class="anchor" href="#本地查询"></a>3.4.2. 本地查询</h4>
<div class="paragraph">
<p><code>@Query</code> 注解允许通过将 <code>nativeQuery</code> 标志设置为 <code>true</code> 来运行本地查询,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. 使用 <code>@Query</code> 在查询方法中声明一个本地查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query(value = "SELECT * FROM USERS WHERE EMAIL_ADDRESS = ?1", nativeQuery = true)
  User findByEmailAddress(String emailAddress);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Data JPA 当前不支持对本地查询进行动态排序,因为它必须声明操作的实际查询,而这对于本地 SQL 无法可靠地进行.  但是,您可以自己指定 count 查询,从而将本地查询用于分页,如以下示例所示:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 11. 使用 <code>@Query</code> 在查询方法中声明本地 count 查询以进行分页</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query(value = "SELECT * FROM USERS WHERE LASTNAME = ?1",
    countQuery = "SELECT count(*) FROM USERS WHERE LASTNAME = ?1",
    nativeQuery = true)
  Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过将 <code>.count</code> 后缀添加到查询的副本中,类似的方法也可用于命名本地查询.  不过,您可能需要为计数查询注册结果集映射.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.query-methods.sorting"><a class="anchor" href="#jpa.query-methods.sorting"></a>3.5. 使用排序</h3>
<div class="paragraph">
<p>可以通过提供 <code>PageRequest</code> 或直接使用 <code>Sort</code> 来完成排序.  在 <code>Sort</code> 的 <code>Order</code> 实例中实际使用的属性需要与您的 domain 模型匹配,这意味着它们需要解析为查询中使用的属性或别名.  JPQL 将此定义为状态字段路径表达式.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
使用任何不可引用的路径表达式都会导致异常.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>但是,将 <code>Sort</code> 与 <a href="#jpa.query-methods.at-query"><code>@Query</code></a>  一起使用,可以让您潜入包含 <code>ORDER BY</code> 子句中的函数的未经路径检查的 <code>Order</code> 实例.  这是可能的,因为 <code>Order</code> 附加到给定的查询字符串.
默认情况下,Spring Data JPA 拒绝任何包含函数调用的 Order 实例,但是您可以使用 <code>JpaSort.unsafe</code> 添加可能不安全的排序.</p>
</div>
<div class="paragraph">
<p>以下示例使用 <code>Sort</code> 和 <code>JpaSort</code>,在 <code>JpaSort</code> 上包括一个不安全的选项:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. 使用 <code>Sort</code> 和 <code>JpaSort</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query("select u from User u where u.lastname like ?1%")
  List&lt;User&gt; findByAndSort(String lastname, Sort sort);

  @Query("select u.id, LENGTH(u.firstname) as fn_len from User u where u.lastname like ?1%")
  List&lt;Object[]&gt; findByAsArrayAndSort(String lastname, Sort sort);
}

repo.findByAndSort("lannister", Sort.by("firstname"));                <i class="conum" data-value="1"></i><b>(1)</b>
repo.findByAndSort("stark", Sort.by("LENGTH(firstname)"));            <i class="conum" data-value="2"></i><b>(2)</b>
repo.findByAndSort("targaryen", JpaSort.unsafe("LENGTH(firstname)")); <i class="conum" data-value="3"></i><b>(3)</b>
repo.findByAsArrayAndSort("bolton", Sort.by("fn_len"));               <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>指向 domain 模型中属性的有效 <code>Sort</code> 表达式.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>包含函数调用的无效 <code>Sort</code>  Throws 异常.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>有效  <code>Sort</code> 包含明显不安全的  <code>Order</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>指向别名函数的有效 <code>Sort</code> 表达式.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.named-parameters"><a class="anchor" href="#jpa.named-parameters"></a>3.6. 使用命名参数</h3>
<div class="paragraph">
<p>默认情况下,Spring Data JPA 使用基于位置的参数绑定,如前面所有示例中所述.  当重构关于参数位置的查询方法时,这会使查询方法容易出错.  要解决此问题,可以使用 <code>@Param</code> 注解为方法参数指定一个具体名称,并在查询中绑定该名称,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. 使用命名参数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  @Query("select u from User u where u.firstname = :firstname or u.lastname = :lastname")
  User findByLastnameOrFirstname(@Param("lastname") String lastname,
                                 @Param("firstname") String firstname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
方法参数根据其在定义的查询中的顺序进行切换.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从版本 4 开始,Spring 完全基于 <code>-parameters</code> 编译器标志支持 Java 8 的参数名称发现.  通过在构建中使用此注解作为调试信息的替代方法,可以省略 <code>@Param</code> 注解中的命名参数.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jpa.query.spel-expressions"><a class="anchor" href="#jpa.query.spel-expressions"></a>3.7. 使用 SpEL 表达式</h3>
<div class="paragraph">
<p>从 Spring Data JPA 1.4 版开始,我们支持在使用 <code>@Query</code> 定义的手动定义的查询中使用受限的 SpEL 模板表达式.  查询执行后,将根据一组预定义的变量对这些表达式进行求值.
Spring Data JPA 支持一个名为 <code>entityName</code> 的变量.  它的用法是  <code>select x from #{#entityName} x</code>.  它插入与给定存储库关联的 domain 类型的 <code>entityName</code>.  实体名称的解析如下: 如果 domain 类型已在 <code>@Entity</code> 注解上设置了名称属性,则将其使用.
否则,将使用 domain 类型的简单类名.</p>
</div>
<div class="paragraph">
<p>以下示例演示了查询字符串中  <code>#{#entityName}</code> 表达式的一种用例,您想在其中使用查询方法和手动定义的查询来定义存储库接口:</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. 在存储库查询方法中使用SpEL表达式-entityName</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Entity
public class User {

  @Id
  @GeneratedValue
  Long id;

  String lastname;
}

public interface UserRepository extends JpaRepository&lt;User,Long&gt; {

  @Query("select u from #{#entityName} u where u.lastname = ?1")
  List&lt;User&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为避免在 <code>@Query</code> 注解的查询字符串中声明实际的实体名称,可以使用 <code>#{#entityName}</code> 变量.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
可以使用 <code>@Entity</code> 注解来自定义 <code>entityName</code>.  SpEL 表达式不支持 <code>orm.xml</code> 中的自定义.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当然,您可能只在查询声明中直接使用了 <code>User</code>,但这也需要您更改查询.  对 <code>#entityName</code> 的引用将 <code>User</code> 类将来可能的重新映射选择为另一个实体名称 (例如,通过使用 <code>@Entity(name = "MyUser")</code>.</p>
</div>
<div class="paragraph">
<p>查询字符串中 <code>#{#entityName}</code> 表达式的另一个用例是,如果您想为特定的 domain 类型定义一个带有专用存储库接口的通用存储库接口.  要不在具体接口上重复定义自定义查询方法,可以在通用存储库接口的 <code>@Query</code> 注解的查询字符串中使用实体名称表达式,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. 在 repository  查询方法中使用 SpEL 表达式-具有继承的 <code>entityName</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@MappedSuperclass
public abstract class AbstractMappedType {
  …
  String attribute
}

@Entity
public class ConcreteType extends AbstractMappedType { … }

@NoRepositoryBean
public interface MappedTypeRepository&lt;T extends AbstractMappedType&gt;
  extends Repository&lt;T, Long&gt; {

  @Query("select t from #{#entityName} t where t.attribute = ?1")
  List&lt;T&gt; findAllByAttribute(String attribute);
}

public interface ConcreteRepository
  extends MappedTypeRepository&lt;ConcreteType&gt; { … }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中,<code>MappedTypeRepository</code> 接口是扩展 <code>AbstractMappedType</code> 的一些 domain 类型的公共父接口.  它还定义了通用的  <code>findAllByAttribute(…)</code> 方法,该方法可用于专用存储库接口的实例.  如果现在在 <code>ConcreteRepository</code> 上调用  <code>findByAllAttribute(…)</code> ,则查询  <code>select t from ConcreteType t where t.attribute = ?1</code> .</p>
</div>
<div class="paragraph">
<p>SpEL 表达式可用于操作参数,也可用于操作方法参数.  在这些 SpEL 表达式中,实体名称不可用,但自变量可用.  可以通过名称或索引访问它们,如以下示例所示.</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. 在存储库查询方法中使用 SpEL 表达式-访问参数.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Query("select u from User u where u.firstname = ?1 and u.firstname=?#{[0]} and u.emailAddress = ?#{principal.emailAddress}")
List&lt;User&gt; findByFirstnameAndCurrentUserWithCustomQuery(String firstname);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于 <code>like</code>,通常需要将 <code>％</code> 附加到 <code>String</code> 值参数的开头或结尾.  这可以通过在绑定参数标记或 SpEL 表达式上附加或前缀 <code>％</code> 来完成.  以下示例再次说明了这一点.</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. 在 repository 查询方法中使用 SpEL 表达式-通配符快捷方式.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Query("select u from User u where u.lastname like %:#{[0]}% and u.lastname like %:lastname%")
List&lt;User&gt; findByLastnameWithSpelExpression(@Param("lastname") String lastname);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用 <code>like</code> 条件的值来自不安全来源,则应清除这些值,以使它们不能包含任何通配符,从而使攻击者可以选择比其应有的能力更多的数据.  为此,在 SpEL 上下文中可以使用  <code>escape(String)</code> 方法.  它在第一个参数中的 <code>_</code> 和 <code>％</code> 的所有实例之前加上第二个参数中的单个字符.  与 JPQL 中提供的 <code>like</code> 表达式的转义子句和标准 SQL 结合使用,可以轻松清除绑定参数.</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. 在存储库查询方法中使用 SpEL 表达式-清理输入值.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Query("select u from User u where u.firstname like %?#{escape([0])}% escape ?#{escapeCharacter()}")
List&lt;User&gt; findContainingEscaped(String namePart);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在存储库接口中给出此方法声明后, <code>findContainingEscaped("Peter_")</code> 将找到 <code>Peter_Parker</code> 而不是 <code>Peter Parker</code>. 可以通过设置 <code>@EnableJpaRepositories</code> 注解的 <code>escapeCharacter</code> 来配置所使用的转义字符. 请注意,该方法 <code>escape(String)</code> 可用 在SpEL上下文中,仅将转义 SQL 和 JPQL 标准通配符 <code>_</code> 和 <code>％</code>,如果基础数据库或 JPA 实现支持其他通配符,则将不会转义这些通配符.</p>
</div>
</div>
<div class="sect2">
<h3 id="jpa.modifying-queries"><a class="anchor" href="#jpa.modifying-queries"></a>3.8. 修改查询</h3>
<div class="paragraph">
<p>前面所有部分均描述了如何声明查询以访问给定实体或实体集合.  您可以使用 &#8220;<a href="#repositories.custom-implementations">Spring数据存储库的自定义实现</a>&#8221; 中介绍的功能来添加自定义修改行为.  由于此方法对于全面的定制功能是可行的,因此可以通过使用 <code>@Modifying</code> 注解查询方法来修改仅需要参数绑定的查询,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. 声明操作查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Modifying
@Query("update User u set u.firstname = ?1 where u.lastname = ?2")
int setFixedFirstnameFor(String firstname, String lastname);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这样做会触发注解该方法的查询作为更新查询,而不是选择查询.  由于 <code>EntityManager</code> 在执行修改查询后可能包含之前的实体,因此我们不会自动清除它 (有关详细信息,请参阅 <code>EntityManager.clear()</code> 的  <a href="https://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html">JavaDoc</a> ) ,因为这会有效地将所有尚未刷新的更新丢弃在 <code>EntityManager</code> 中.  如果您希望自动清除 <code>EntityManager</code>,则可以将 <code>@Modifying</code> 注解的 <code>clearAutomatically</code> 属性设置为 <code>true</code>.</p>
</div>
<div class="paragraph">
<p><code>@Modifying</code> 注解仅与 <code>@Query</code> 注解结合使用. 扩展的查询方法或自定义方法不需要此注解.</p>
</div>
<div class="sect3">
<h4 id="jpa.modifying-queries.derived-delete"><a class="anchor" href="#jpa.modifying-queries.derived-delete"></a>3.8.1. 扩展删除查询</h4>
<div class="paragraph">
<p>Spring Data JPA 还支持扩展的删除查询,使您避免显式声明 JPQL 查询,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. 使用扩展的删除查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends Repository&lt;User, Long&gt; {

  void deleteByRoleId(long roleId);

  @Modifying
  @Query("delete from User u where u.role.id = ?1")
  void deleteInBulkByRoleId(long roleId);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>尽管 <code>deleteByRoleId(…)</code> 方法看起来基本上与 <code>deleteInBulkByRoleId(…)</code> 产生相同的结果,但是在执行方法方面,这两个方法声明之间存在重要区别.  顾名思义,后一种方法针对数据库发出单个 JPQL 查询 (在注解中定义的查询) .  这意味着,即使当前加载的 <code>User</code> 实例也看不到生命周期回调.</p>
</div>
<div class="paragraph">
<p>为了确保生命周期查询被实际调用,调用  <code>deleteByRoleId(…)</code>  会执行一个查询,然后逐个删除返回的实例,以便持久性提供程序实际上可以在这些实体上调用 <code>@PreRemove</code> 回调.</p>
</div>
<div class="paragraph">
<p>实际上,扩展的删除查询是执行查询,然后对结果调用  <code>CrudRepository.delete(Iterable&lt;User&gt; users)</code>  并使行为与 <code>CrudRepository</code> 中其他  <code>delete(…)</code>  方法的实现保持同步的快捷方式.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.query-hints"><a class="anchor" href="#jpa.query-hints"></a>3.9. 应用查询提示</h3>
<div class="paragraph">
<p>要将 JPA 查询提示应用于在存储库接口中声明的查询,可以使用 <code>@QueryHints</code> 注解.  它需要一个JPA <code>@QueryHint</code> 注解加上一个布尔标志,以潜在地禁用应用于应用分页时触发的附加计数查询的提示,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. 将 <code>QueryHints</code> 与存储库方法一起使用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends Repository&lt;User, Long&gt; {

  @QueryHints(value = { @QueryHint(name = "name", value = "value")},
              forCounting = false)
  Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的声明将为该实际查询应用已配置的 <code>@QueryHint</code>,但是省略了将其应用于为计算总页数而触发的计数查询.</p>
</div>
</div>
<div class="sect2">
<h3 id="jpa.entity-graph"><a class="anchor" href="#jpa.entity-graph"></a>3.10. 配置 Fetch- 和 LoadGraphs</h3>
<div class="paragraph">
<p>JPA 2.1 规范引入了对指定 Fetch- 和 LoadGraphs 的支持,我们也支持 <code>@EntityGraph</code> 注解,该注解使您可以引用 <code>@NamedEntityGraph</code> 定义.  您可以在实体上使用该注解来配置结果查询的获取计划.  可以通过使用 <code>@EntityGraph</code> 注解上的 <code>type</code> 属性来配置获取的类型 (<code>Fetch</code> 或 <code>Load</code>) .  有关更多参考,请参见 JPA 2.1 Spec 3.7.4.</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. 在一个实体上定义一个命名实体图.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Entity
@NamedEntityGraph(name = "GroupInfo.detail",
  attributeNodes = @NamedAttributeNode("members"))
public class GroupInfo {

  // default fetch mode is lazy.
  @ManyToMany
  List&lt;GroupMember&gt; members = new ArrayList&lt;GroupMember&gt;();

  …
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示如何在存储库查询方法上引用命名实体图:</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. 在存储库查询方法上引用命名实体图定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(value = "GroupInfo.detail", type = EntityGraphType.LOAD)
  GroupInfo getByGroupName(String name);

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以使用 <code>@EntityGraph</code> 定义临时实体图.  提供的 <code>attributePaths</code> 转换为相应的 <code>EntityGraph</code>,而无需将 <code>@NamedEntityGraph</code> 显式添加到您的 domain 类型,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. 在存储库查询方法上使用 AD-HOC 实体图定义.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Repository
public interface GroupRepository extends CrudRepository&lt;GroupInfo, String&gt; {

  @EntityGraph(attributePaths = { "members" })
  GroupInfo getByGroupName(String name);

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="projections"><a class="anchor" href="#projections"></a>3.11. 投影</h3>
<div class="paragraph">
<p>Spring Data 查询方法通常返回存储库管理的聚合根的一个或多个实例.  但是,有时可能需要根据这些类型的某些属性创建投影.  Spring Data 允许对专用的返回类型进行建模,以更选择性地检索托管聚合的部分视图.</p>
</div>
<div class="paragraph">
<p>想象一下一个存储库和聚合根类型,例如以下示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. 一个示例集合和存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {

  @Id UUID id;
  String firstname, lastname;
  Address address;

  static class Address {
    String zipCode, city, street;
  }
}

interface PersonRepository extends Repository&lt;Person, UUID&gt; {

  Collection&lt;Person&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在,假设我们只想检索此人的姓名属性.  Spring Data 提供什么手段来实现这一目标?  本章的其余部分将回答该问题.</p>
</div>
<div class="sect3">
<h4 id="projections.interfaces"><a class="anchor" href="#projections.interfaces"></a>3.11.1. 基于接口的投影</h4>
<div class="paragraph">
<p>将查询结果限制为仅 <code>name</code> 属性的最简单方法是声明一个接口,该接口暴露要读取的属性的 get 方法,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. 一个投影接口来检索属性的子集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  String getFirstname();
  String getLastname();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此处重要的一点是,此处定义的属性与聚合根中的属性完全匹配.  这样做可以使查询方法添加如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. 使用基于接口的投影和查询方法的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, UUID&gt; {

  Collection&lt;NamesOnly&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>查询执行引擎在运行时为返回的每个元素创建该接口的代理实例,并将对暴露方法的调用转发给目标对象.</p>
</div>
<div id="projections.interfaces.nested" class="paragraph">
<p>投影可以递归使用.  如果还希望包括一些 <code>Address</code> 信息,则为此创建一个投影接口,并从 <code>getAddress()</code> 的声明返回该接口,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. 一个投影接口来检索属性的子集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonSummary {

  String getFirstname();
  String getLastname();
  AddressSummary getAddress();

  interface AddressSummary {
    String getCity();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在方法调用时,将获得目标实例的 <code>address</code> 属性,并将其包装到投影代理中.</p>
</div>
<div class="sect4">
<h5 id="projections.interfaces.closed"><a class="anchor" href="#projections.interfaces.closed"></a>封闭投影</h5>
<div class="paragraph">
<p>其 get 方法均与目标集合的属性完全匹配的投影接口被视为封闭投影.  下面的示例 (也在本章前面使用过) 是一个封闭的投影:</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. 一个封闭的投影</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  String getFirstname();
  String getLastname();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用封闭式投影,Spring Data 可以优化查询执行,因为我们知道支持投影代理所需的所有属性.  有关更多信息,请参见参考文档中特定于模块的部分.</p>
</div>
</div>
<div class="sect4">
<h5 id="projections.interfaces.open"><a class="anchor" href="#projections.interfaces.open"></a>打开投影</h5>
<div class="paragraph">
<p>投影接口中的 get 方法也可以通过使用 <code>@Value</code> 注解来计算新值,如以下示例所示:</p>
</div>
<div id="projections.interfaces.open.simple" class="exampleblock">
<div class="title">Example 30. 一个 打开投影</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  @Value("#{target.firstname + ' ' + target.lastname}")
  String getFullName();
  …
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在  <code>target</code>  变量中提供了支持投影的合计根.  使用 <code>@Value</code> 的投影接口是开放式投影.  在这种情况下,Spring Data 无法应用查询执行优化,因为SpEL表达式可以使用聚合根的任何属性.</p>
</div>
<div class="paragraph">
<p><code>@Value</code> 中使用的表达式应该不太复杂-您要避免在 <code>String</code> 变量中进行编程.  对于非常简单的表达式,一种选择可能是求助于默认方法 (在Java 8中引入) ,如以下示例所示:</p>
</div>
<div id="projections.interfaces.open.default" class="exampleblock">
<div class="title">Example 31. 使用默认方法自定义逻辑的投影接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  String getFirstname();
  String getLastname();

  default String getFullName() {
    return getFirstname().concat(" ").concat(getLastname());
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种方法要求您能够完全基于投影接口上暴露的其他 get 方法来实现逻辑.  第二个更灵活的选择是在 Spring bean 中实现自定义逻辑,然后从 SpEL 表达式中调用该自定义逻辑,如以下示例所示:</p>
</div>
<div id="projections.interfaces.open.bean-reference" class="exampleblock">
<div class="title">Example 32. Sample Person 对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
class MyBean {

  String getFullName(Person person) {
    …
  }
}

interface NamesOnly {

  @Value("#{@myBean.getFullName(target)}")
  String getFullName();
  …
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意 SpEL 表达式如何引用 <code>myBean</code> 并调用  <code>getFullName(…)</code> 方法,并将投影目标作为方法参数转发.  SpEL 表达式评估支持的方法也可以使用方法参数,然后可以从表达式中引用这些参数.  方法参数可通过名为 <code>args</code> 的对象数组获得.
下面的示例演示如何从 <code>args</code> 数组获取方法参数:</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. Sample Person 对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  @Value("#{args[0] + ' ' + target.firstname + '!'}")
  String getSalutation(String prefix);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样,对于更复杂的表达式,您应该使用Spring bean并让该表达式调用方法,<a href="#projections.interfaces.open.bean-reference">如前所述</a>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="projections.dtos"><a class="anchor" href="#projections.dtos"></a>3.11.2. 基于类的投影 (DTO)</h4>
<div class="paragraph">
<p>定义投影的另一种方法是使用值类型DTO (数据传输对象) ,该类型DTO保留应该被检索的字段的属性.  这些DTO类型可以以与使用投影接口完全相同的方式使用,除了没有代理发生和不能应用嵌套投影之外.</p>
</div>
<div class="paragraph">
<p>如果存储通过限制要加载的字段来优化查询执行,则要加载的字段由暴露的构造函数的参数名称确定.</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个预计的DTO:</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. 一个投影的DTO</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class NamesOnly {

  private final String firstname, lastname;

  NamesOnly(String firstname, String lastname) {

    this.firstname = firstname;
    this.lastname = lastname;
  }

  String getFirstname() {
    return this.firstname;
  }

  String getLastname() {
    return this.lastname;
  }

  // equals(…) and hashCode() implementations
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">避免投影DTO的样板代码</div>
<div class="paragraph">
<p>您可以使用 <a href="https://projectlombok.org">Project Lombok</a> 大大简化DTO的代码,该项目提供了 <code>@Value</code> 注解 (不要与前面的界面示例中显示的Spring的 <code>@Value</code> 注解混淆) .  如果您使用 Project Lombok 的 <code>@Value</code> 注解,则前面显示的示例DTO将变为以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Value
class NamesOnly {
    String firstname, lastname;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下,字段是  <code>private final</code> 的,并且该类暴露了一个构造函数,该构造函数接受所有字段并自动获取实现的 <code>equals(…)</code> 和 <code>hashCode()</code> 方法.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="projection.dynamic"><a class="anchor" href="#projection.dynamic"></a>3.11.3. 动态投影</h4>
<div class="paragraph">
<p>到目前为止,我们已经将投影类型用作集合的返回类型或元素类型.  但是,您可能想要选择在调用时要使用的类型 (这使它成为动态的) .  要应用动态投影,请使用查询方法,如以下示例中所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. 使用动态投影参数的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, UUID&gt; {

  &lt;T&gt; Collection&lt;T&gt; findByLastname(String lastname, Class&lt;T&gt; type);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过这种方式,该方法可以按原样或应用投影来获得聚合,如下例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. 使用带有动态投影的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void someMethod(PersonRepository people) {

  Collection&lt;Person&gt; aggregates =
    people.findByLastname("Matthews", Person.class);

  Collection&lt;NamesOnly&gt; aggregates =
    people.findByLastname("Matthews", NamesOnly.class);
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jpa.stored-procedures"><a class="anchor" href="#jpa.stored-procedures"></a>4. 存储过程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JPA 2.1 规范引入了对使用 JPA 标准查询 API 调用存储过程的支持.  我们引入了 <code>@Procedure</code> 注解,用于在存储库方法上声明存储过程元数据.</p>
</div>
<div class="paragraph">
<p>下面的示例使用以下存储过程:</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. HSQL DB中 <code>plus1inout</code>  过程的定义.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">/;
DROP procedure IF EXISTS plus1inout
/;
CREATE procedure plus1inout (IN arg int, OUT res int)
BEGIN ATOMIC
 set res = arg + 1;
END
/;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以通过在实体类型上使用 <code>NamedStoredProcedureQuery</code> 注解来配置存储过程的元数据.</p>
</div>
<div id="jpa.stored-procedure-entity-metadata" class="exampleblock">
<div class="title">Example 38. 实体上的 <code>StoredProcedure</code> 元数据定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Entity
@NamedStoredProcedureQuery(name = "User.plus1", procedureName = "plus1inout", parameters = {
  @StoredProcedureParameter(mode = ParameterMode.IN, name = "arg", type = Integer.class),
  @StoredProcedureParameter(mode = ParameterMode.OUT, name = "res", type = Integer.class) })
public class User {}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意,<code>@NamedStoredProcedureQuery</code> 具有两个不同的存储过程名称.  名称是 JPA 使用的名称.  <code>procedureName</code> 是存储过程在数据库中具有的名称.</p>
</div>
<div class="paragraph">
<p>您可以通过多种方式从存储库方法引用存储过程.  可以使用 <code>@Procedure</code> 注解的 <code>value</code> 或 <code>procedureName</code> 属性直接定义要调用的存储过程.  这直接引用数据库中的存储过程,并忽略通过 <code>@NamedStoredProcedureQuery</code> 进行的任何配置.</p>
</div>
<div class="paragraph">
<p>或者,您可以将 <code>@NamedStoredProcedureQuery.name</code> 属性指定为 <code>@Procedure.name</code> 属性.  如果未配置 <code>value</code>,<code>procedureName</code> 或 <code>name</code>,则将存储库方法的名称用作 <code>name</code> 属性.</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何引用显式映射的过程:</p>
</div>
<div id="jpa.stored-procedure-reference" class="exampleblock">
<div class="title">Example 39. 在数据库中引用名称为 "plus1inout" 的显式映射过程.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Procedure("plus1inout")
Integer explicitlyNamedPlus1inout(Integer arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例与上一个示例等效,但是使用了 <code>procedureName</code> 别名:</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. 通过 <code>procedureName</code> 别名在数据库中引用名称为 "plus1inout" 的隐式映射过程</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Procedure(procedureName = "plus1inout")
Integer callPlus1InOut(Integer arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面再次与前两个等效,但是使用方法名称而不是显式注解属性.</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. 使用方法名称在 <code>EntityManager</code> 中引用隐式映射的命名存储过程 "User.plus1" .</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Procedure
Integer plus1inout(@Param("arg") Integer arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的示例演示如何通过引用 <code>@NamedStoredProcedureQuery.name</code> 属性来引用存储过程.</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. 在 EntityManager 中引用显式映射的命名存储过程 "User.plus1IO".</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Procedure(name = "User.plus1IO")
Integer entityAnnotatedCustomNamedProcedurePlus1IO(@Param("arg") Integer arg);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果被调用的存储过程只有一个 <code>out</code> 参数,则该参数可以作为方法的返回值返回.  如果在 <code>@NamedStoredProcedureQuery</code> 注解中指定了多个 <code>out</code> 参数,则这些参数可以作为 <code>Map</code> 返回,其键为 <code>@NamedStoredProcedureQuery</code> 注解中给出的参数名称.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="specifications"><a class="anchor" href="#specifications"></a>5. Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>JPA 2 引入了一个标准 API,您可以使用它来以编程方式构建查询.  通过编写条件,可以定义域类查询的 <code>where</code> 子句.  再往前一步,这些标准可以视为 JPA 标准 API 约束所描述的实体的断言.</p>
</div>
<div class="paragraph">
<p>Spring Data JPA 遵循 Eric Evans 的书 &#8220;领域驱动设计&#8221; 中的规范概念,遵循相同的语义,并提供了使用 JPA 标准 API 定义此类规范的 API.  为了支持规范,可以使用 <code>JpaSpecificationExecutor</code> 接口扩展存储库接口,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt;, JpaSpecificationExecutor {
 …
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>附加接口具有使您能够以各种方式执行规范的方法.  例如,<code>findAll</code> 方法返回与规范匹配的所有实体,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;T&gt; findAll(Specification&lt;T&gt; spec);</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Specification</code> 接口定义如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface Specification&lt;T&gt; {
  Predicate toPredicate(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query,
            CriteriaBuilder builder);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Specifications 可以轻松地用于在实体之上构建可扩展的断言集合,然后可以将其组合并与 <code>JpaRepository</code> 一起使用,而无需为每个所需的组合声明查询 (方法) ,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. 自定义 Specifications</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class CustomerSpecs {


  public static Specification&lt;Customer&gt; isLongTermCustomer() {
    return (root, query, builder) -&gt; {
      LocalDate date = LocalDate.now().minusYears(2);
      return builder.lessThan(root.get(Customer_.createdAt), date);
    };
  }

  public static Specification&lt;Customer&gt; hasSalesOfMoreThan(MonetaryAmount value) {
    return (root, query, builder) -&gt; {
      // build query here
    };
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>诚然,样板文件的数量尚待改进 (最终可能会因 Java 8 闭包而减少) ,但是客户端会变得更好,正如您将在本节后面看到的那样.  <code>Customer_</code> 类型是使用 JPA 元模型生成器生成的元模型类型 (有关示例,<a href="https://docs.jboss.org/hibernate/jpamodelgen/1.0/reference/en-US/html_single/#whatisit">参见Hibernate实现的文档</a>) .  因此,表达式 <code>Customer_.createdAt</code> 假定客户具有类型为 <code>Date</code> 的 <code>createdAt</code> 属性.  除此之外,我们在业务需求抽象级别上表达了一些标准,并创建了可执行的 <code>Specifications</code>.  因此,客户端可以使用以下 <code>Specifications</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 44. 使用一个简单的 Specification</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;Customer&gt; customers = customerRepository.findAll(isLongTermCustomer());</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为什么不为这种数据访问创建查询?  与纯查询声明相比,使用单个 <code>Specification</code> 不会带来很多好处.  将 <code>specifications</code> 组合在一起以创建新的 <code>specifications</code> 对象时,<code>specifications</code> 的力量真正发挥了作用.
您可以通过我们提供的用于构建类似于以下内容的表达式的默认 <code>Specification</code> 方法来实现此目的:</p>
</div>
<div class="exampleblock">
<div class="title">Example 45. 组合 Specifications</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MonetaryAmount amount = new MonetaryAmount(200.0, Currencies.DOLLAR);
List&lt;Customer&gt; customers = customerRepository.findAll(
  isLongTermCustomer().or(hasSalesOfMoreThan(amount)));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Specification</code> 提供了一些 &#8220;glue-code&#8221; 默认方法来链接和组合  <code>Specification</code> 实例,这些方法使您可以通过创建新的  <code>Specification</code>  实现并将它们与现有的实现组合来扩展数据访问层.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="query-by-example"><a class="anchor" href="#query-by-example"></a>6. 查询例子</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="query-by-example.introduction"><a class="anchor" href="#query-by-example.introduction"></a>6.1. 简介</h3>
<div class="paragraph">
<p>本章对 "按示例查询" 进行了介绍,并说明了如何使用它.</p>
</div>
<div class="paragraph">
<p>示例查询 (QBE) 是一种具有简单界面的用户友好查询技术.  它允许动态查询创建,并且不需要您编写包含字段名称的查询.  实际上,"示例查询" 根本不需要您使用存储库特定的查询语言编写查询.</p>
</div>
</div>
<div class="sect2">
<h3 id="query-by-example.usage"><a class="anchor" href="#query-by-example.usage"></a>6.2. 使用</h3>
<div class="paragraph">
<p>示例查询由三部分组成:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Probe: 带有填充字段的 domain 对象的实际示例.</p>
</li>
<li>
<p><code>ExampleMatcher</code>: <code>ExampleMatcher</code> 包含有关如何匹配特定字段的详细信息.  可以在多个示例中重复使用它.</p>
</li>
<li>
<p><code>Example</code>: 示例包括探针和 <code>ExampleMatcher</code>.  它用于创建查询.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>示例查询非常适合几种用例:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用一组静态或动态约束来查询数据存储.</p>
</li>
<li>
<p>频繁重构 domain 对象,而不必担心破坏现有查询.</p>
</li>
<li>
<p>独立于基础数据存储 API 进行工作.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>示例查询也有一些限制:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不支持嵌套或分组属性约束,例如 <code>firstname = ?0 or (firstname = ?1 and lastname = ?2)</code>.</p>
</li>
<li>
<p>仅支持字符串的开始/包含/结束/正则表达式匹配,以及其他属性类型的完全匹配.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在开始使用示例查询之前,您需要具有一个 domain 对象.  首先,为您的存储库创建一个接口,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 46. Sample Person 对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Person {

  @Id
  private String id;
  private String firstname;
  private String lastname;
  private Address address;

  // … getters and setters omitted
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例显示了一个简单的域对象.  您可以使用它来创建一个 <code>Example</code>.  默认情况下,具有 <code>null</code> 的字段将被忽略,并且使用存储特定的默认值来匹配字符串.  可以使用工厂方法或使用 <code>ExampleMatcher</code> 构建示例.  例子是一成不变的.  以下清单显示了一个简单的示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 47. Simple Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Person person = new Person();                         <i class="conum" data-value="1"></i><b>(1)</b>
person.setFirstname("Dave");                          <i class="conum" data-value="2"></i><b>(2)</b>

Example&lt;Person&gt; example = Example.of(person);         <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建  domain 对象的新实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置要查询的属性.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>创建 <code>Example</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>最好在存储库中执行示例.  为此,让您的存储库接口扩展 <code>QueryByExampleExecutor&lt;T&gt;</code>.  以下清单显示了 <code>QueryByExampleExecutor</code> 接口:</p>
</div>
<div class="exampleblock">
<div class="title">Example 48. <code>QueryByExampleExecutor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface QueryByExampleExecutor&lt;T&gt; {

  &lt;S extends T&gt; S findOne(Example&lt;S&gt; example);

  &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; example);

  // … more functionality omitted.
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-by-example.matchers"><a class="anchor" href="#query-by-example.matchers"></a>6.3. Example 匹配</h3>
<div class="paragraph">
<p>示例不限于默认设置.  您可以使用 <code>ExampleMatcher</code> 为字符串匹配,空值处理和特定于属性的设置指定自己的默认值,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 49. 具有定制匹配的例子匹配器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Person person = new Person();                          <i class="conum" data-value="1"></i><b>(1)</b>
person.setFirstname("Dave");                           <i class="conum" data-value="2"></i><b>(2)</b>

ExampleMatcher matcher = ExampleMatcher.matching()     <i class="conum" data-value="3"></i><b>(3)</b>
  .withIgnorePaths("lastname")                         <i class="conum" data-value="4"></i><b>(4)</b>
  .withIncludeNullValues()                             <i class="conum" data-value="5"></i><b>(5)</b>
  .withStringMatcherEnding();                          <i class="conum" data-value="6"></i><b>(6)</b>

Example&lt;Person&gt; example = Example.of(person, matcher); <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建域对象的新实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置属性.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>创建一个 <code>ExampleMatcher</code> 以期望所有值都匹配.  即使没有进一步的配置,它也可以在此阶段使用.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径并包含空值.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径,包括空值,并执行后缀字符串匹配.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>基于域对象和配置的 <code>ExampleMatcher</code> 创建一个新的 <code>Example</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下,<code>ExampleMatcher</code> 期望设置的所有值都匹配.  如果要获取与隐式定义的任何断言匹配的结果,请使用  <code>ExampleMatcher.matchingAny()</code>.</p>
</div>
<div class="paragraph">
<p>您可以为单个属性 (例如  "firstname" 和 "lastname",或者对于嵌套属性,"address.city") 指定行为.  您可以使用匹配选项和区分大小写对其进行调整,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 50. 配置匹配器选项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ExampleMatcher matcher = ExampleMatcher.matching()
  .withMatcher("firstname", endsWith())
  .withMatcher("lastname", startsWith().ignoreCase());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>配置匹配器选项的另一种方法是使用 lambda (在Java 8中引入) .  此方法创建一个回调,要求实现者修改匹配器.  您无需返回匹配器,因为配置选项保存在匹配器实例中.  以下示例显示了使用lambda的匹配器:</p>
</div>
<div class="exampleblock">
<div class="title">Example 51. 用lambdas配置匹配器选项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ExampleMatcher matcher = ExampleMatcher.matching()
  .withMatcher("firstname", match -&gt; match.endsWith())
  .withMatcher("firstname", match -&gt; match.startsWith());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由 <code>Example</code> 创建的查询使用配置的合并视图.  可以在 <code>ExampleMatcher</code> 级别上设置默认的匹配设置,而可以将单个设置应用于特定的属性路径.  除非明确定义,否则 <code>ExampleMatcher</code> 上设置的设置将由属性路径设置继承.
属性修补程序上的设置优先于默认设置.  下表描述了各种 <code>ExampleMatcher</code> 设置的范围:</p>
</div>
<div class="paragraph">
<p>表4. <code>ExampleMatcher</code> 设置的范围</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Scope of <code>ExampleMatcher</code> settings</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Setting</th>
<th class="tableblock halign-left valign-top">Scope</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Null-handling</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExampleMatcher</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String matching</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExampleMatcher</code> and property path</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ignoring properties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property path</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Case sensitivity</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExampleMatcher</code> and property path</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value transformation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property path</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="query-by-example.running"><a class="anchor" href="#query-by-example.running"></a>6.4. 执行一个例子</h3>
<div class="paragraph">
<p>在 Spring Data JPA 中,您可以对存储库使用按示例查询,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 52. 使用存储库按示例查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface PersonRepository extends JpaRepository&lt;Person, String&gt; { … }

public class PersonService {

  @Autowired PersonRepository personRepository;

  public List&lt;Person&gt; findPeople(Person probe) {
    return personRepository.findAll(Example.of(probe));
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当前,仅 <code>SingularAttribute</code> 属性可用于属性匹配.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>属性说明符接受属性名称(例如 <code>firstname</code> and <code>lastname</code>) .  您可以通过将属性与点(<code>address.city</code>) 链接在一起进行导航.  您还可以使用匹配选项和区分大小写对其进行调整.</p>
</div>
<div class="paragraph">
<p>下表显示了可以使用的各种 <code>StringMatcher</code> 选项,以及在名为 <code>firstname</code> 的字段上使用它们的结果:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. <code>StringMatcher</code> options</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Matching</th>
<th class="tableblock halign-left valign-top">Logical result</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEFAULT</code> (case-sensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname = ?0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DEFAULT</code> (case-insensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) = LOWER(?0)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXACT</code>  (case-sensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname = ?0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXACT</code> (case-insensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) = LOWER(?0)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STARTING</code>  (case-sensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname like ?0 + '%'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STARTING</code> (case-insensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) like LOWER(?0) + '%'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENDING</code>  (case-sensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname like '%' + ?0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENDING</code> (case-insensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) like '%' + LOWER(?0)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONTAINING</code>  (case-sensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>firstname like '%' + ?0 + '%'</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONTAINING</code> (case-insensitive)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LOWER(firstname) like '%' + LOWER(?0) + '%'</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="transactions"><a class="anchor" href="#transactions"></a>7. 事务性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>默认情况下,存储库实例上的 CRUD 方法是事务性的.  对于读取操作,事务配置 <code>readOnly</code> 标志设置为 <code>true</code>.  所有其他文件都配置有简单的 <code>@Transactional</code>,以便应用默认事务配置.
有关详细信息,请参见 <a href="https://docs.spring.io/spring-data/data-jpa/docs/current/api/index.html?org/springframework/data/jpa/repository/support/SimpleJpaRepository.html"><code>SimpleJpaRepository</code></a> 的JavaDoc.  如果需要调整存储库中声明的方法之一的事务配置,请在存储库接口中重新声明该方法,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 53. CRUD 的自定义事务配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface UserRepository extends CrudRepository&lt;User, Long&gt; {

  @Override
  @Transactional(timeout = 10)
  public List&lt;User&gt; findAll();

  // Further query method declarations
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样做会使 <code>findAll()</code> 方法以 10 秒的超时运行,并且没有 <code>readOnly</code> 标志.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>更改事务行为的另一种方法是使用 facade 或 service 实现 (通常) 覆盖多个存储库.  其目的是为非 CRUD 操作定义事务边界.  以下示例使用了 facade 用于多个存储库:</p>
</div>
<div class="exampleblock">
<div class="title">Example 54. 使用外观定义多个存储库调用的事务</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Service
class UserManagementImpl implements UserManagement {

  private final UserRepository userRepository;
  private final RoleRepository roleRepository;

  @Autowired
  public UserManagementImpl(UserRepository userRepository,
    RoleRepository roleRepository) {
    this.userRepository = userRepository;
    this.roleRepository = roleRepository;
  }

  @Transactional
  public void addRoleToAllUsers(String roleName) {

    Role role = roleRepository.findByName(roleName);

    for (User user : userRepository.findAll()) {
      user.addRole(role);
      userRepository.save(user);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例使对 <code>addRoleToAllUsers(…)</code>  的调用在事务内运行 (参与现有事务或在没有事务的情况下创建新事务) .  然后忽略存储库中的事务配置,因为外部事务配置确定了实际使用的事务配置.  请注意,必须激活 <code>&lt;tx:annotation-driven /&gt;</code> 或显式使用 <code>@EnableTransactionManagement</code> 才能使立面的基于注解的配置生效.  本示例假定您使用组件扫描.</p>
</div>
<div class="paragraph">
<p>请注意, 从 JPA 的角度来看, 对 <code>save</code> 的调用不是绝对必要的, 但为了与 Spring Data 提供的存储库抽象保持一致, 仍然应该存在.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="transactional-query-methods"><a class="anchor" href="#transactional-query-methods"></a>7.1. 事务查询方法</h3>
<div class="paragraph">
<p>要使查询方法具有事务性,请在您定义的存储库接口上使用 <code>@Transactional</code>,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 55. 在查询方法上使用 <code>@Transactional</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Transactional(readOnly = true)
public interface UserRepository extends JpaRepository&lt;User, Long&gt; {

  List&lt;User&gt; findByLastname(String lastname);

  @Modifying
  @Transactional
  @Query("delete from User u where u.active = false")
  void deleteInactiveUsers();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常,您希望将 <code>readOnly</code> 标志设置为 <code>true</code>,因为大多数查询方法仅读取数据.  与此相反, <code>deleteInactiveUsers()</code> 使用 <code>@Modifying</code> 注解并覆盖事务配置.  因此,该方法在 <code>readOnly</code> 标志设置为 <code>false</code> 的情况下运行.</p>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以将事务用于只读查询,并通过设置 <code>readOnly</code> 标志将其标记为事务.  但是,这样做并不表示您不会触发操作查询 (尽管某些数据库拒绝只读事务中的 <code>INSERT</code> 和 <code>UPDATE</code> 语句) .  相反,将 <code>readOnly</code> 标志作为提示传播到底层 JDBC 驱动程序,以进行性能优化.  此外,Spring 在基础 JPA 提供程序上执行了一些优化.  例如,当与 Hibernate 一起使用时,将事务配置为 <code>readOnly</code> 时,刷新模式将设置为 <code>NEVER</code>,这将导致 Hibernate 跳过脏检查 (对大型对象树的显着改进) .</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="locking"><a class="anchor" href="#locking"></a>8. 锁</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要指定要使用的锁定模式,可以在查询方法上使用 <code>@Lock</code> 注解,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 56. 在查询方法上定义锁元数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends Repository&lt;User, Long&gt; {

  // Plain query method
  @Lock(LockModeType.READ)
  List&lt;User&gt; findByLastname(String lastname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此方法声明使触发的查询配备有 <code>READ</code> 的 <code>LockModeType</code>.  您还可以通过在存储库界面中重新声明 CRUD 方法并为它们添加 <code>@Lock</code> 注解来定义 CRUD 方法的锁定,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 57. 在 CRUD 方法上定义锁元数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends Repository&lt;User, Long&gt; {

  // Redeclaration of a CRUD method
  @Lock(LockModeType.READ)
  List&lt;User&gt; findAll();
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="auditing"><a class="anchor" href="#auditing"></a>9. 审计</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="auditing.basics"><a class="anchor" href="#auditing.basics"></a>9.1. 基础</h3>
<div class="paragraph">
<p>Spring Data 提供了完善的支持,可以透明地跟踪创建或更改实体的人员以及更改发生的时间.  要利用该功能,您必须为实体类配备审核元数据,该审核元数据可以使用注解或通过实现接口来定义.</p>
</div>
<div class="sect3">
<h4 id="auditing.annotations"><a class="anchor" href="#auditing.annotations"></a>9.1.1. 基于注解的审核元数据</h4>
<div class="paragraph">
<p>我们提供 <code>@CreatedBy</code> 和 <code>@LastModifiedBy</code> 来捕获创建或修改实体的用户,并提供 <code>@CreatedDate</code> 和 <code>@LastModifiedDate</code> 来捕获更改发生的时间.</p>
</div>
<div class="exampleblock">
<div class="title">Example 58. 被审计实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Customer {

  @CreatedBy
  private User user;

  @CreatedDate
  private DateTime createdDate;

  // … further properties omitted
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见,可以根据要捕获的信息有选择地应用注解.  捕获更改时捕获的注解可用于类型 <code>Joda-Time</code>,<code>DateTime</code>,旧版Java <code>Date</code> 和 <code>Calendar</code>,JDK8日期和时间类型以及 <code>long</code> 或 <code>Long</code> 的属性.</p>
</div>
</div>
<div class="sect3">
<h4 id="auditing.interfaces"><a class="anchor" href="#auditing.interfaces"></a>9.1.2. 基于接口的审核元数据</h4>
<div class="paragraph">
<p>如果您不想使用注解来定义审核元数据,则可以让您的 domain 类实现 <code>Auditable</code> 接口.  它为所有审核属性暴露了setter方法.</p>
</div>
<div class="paragraph">
<p>还有一个便捷的基类 <code>AbstractAuditable</code>,可以对其进行扩展,以避免需要手动实现接口方法.  这样做会增加您的 domain 类与 Spring Data 的耦合,这可能是您要避免的事情.  通常,首选基于注解的方式来定义审核元数据,因为它侵入性较小且更灵活.</p>
</div>
</div>
<div class="sect3">
<h4 id="auditing.auditor-aware"><a class="anchor" href="#auditing.auditor-aware"></a>9.1.3. <code>AuditorAware</code></h4>
<div class="paragraph">
<p>如果使用 <code>@CreatedBy</code> 或 <code>@LastModifiedBy</code>,则审计基础结构需要以某种方式了解当前的主体.  为此,我们提供了 <code>AuditorAware&lt;T&gt;</code> SPI接口,您必须实现该接口以告知基础结构与应用程序交互的当前用户或系统是谁.
通用类型T定义必须使用 <code>@CreatedBy</code> 或 <code>@LastModifiedBy</code> 注解的属性的类型.</p>
</div>
<div class="paragraph">
<p>以下示例显示了使用Spring Security的 <code>Authentication</code> 对象的接口的实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 59. 基于Spring Security的AuditorAware的实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class SpringSecurityAuditorAware implements AuditorAware&lt;User&gt; {

  public Optional&lt;User&gt; getCurrentAuditor() {

    return Optional.ofNullable(SecurityContextHolder.getContext())
              .map(SecurityContext::getAuthentication)
              .filter(Authentication::isAuthenticated)
              .map(Authentication::getPrincipal)
              .map(User.class::cast);
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该实现访问Spring Security提供的 <code>Authentication</code> 对象,并查找您在 <code>UserDetailsService</code> 实现中创建的自定义 <code>UserDetails</code> 实例.  我们在这里假设您通过 <code>UserDetails</code> 实现暴露域用户,但是根据找到的身份验证,您还可以从任何地方查找它.
:leveloffset: -1</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpa.auditing"><a class="anchor" href="#jpa.auditing"></a>9.2. JPA 审计</h3>
<div class="sect3">
<h4 id="jpa.auditing.configuration"><a class="anchor" href="#jpa.auditing.configuration"></a>9.2.1. 通用审核配置</h4>
<div class="paragraph">
<p>Spring Data JPA 附带了一个实体监听器,该监听器可用于触发捕获审计信息.  首先,必须在 <code>orm.xml</code> 文件内的持久性上下文中注册要用于所有实体的 <code>AuditingEntityListener</code>,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 60. Auditing configuration orm.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;persistence-unit-metadata&gt;
  &lt;persistence-unit-defaults&gt;
    &lt;entity-listeners&gt;
      &lt;entity-listener class="….data.jpa.domain.support.AuditingEntityListener" /&gt;
    &lt;/entity-listeners&gt;
  &lt;/persistence-unit-defaults&gt;
&lt;/persistence-unit-metadata&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用 <code>@EntityListeners</code> 注解按每个实体启用 <code>AuditingEntityListener</code>,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Entity
@EntityListeners(AuditingEntityListener.class)
public class MyEntity {

}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
审计功能要求 <code>spring-aspects.jar</code> 位于类路径中.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通过适当地修改 <code>orm.xml</code> 并在类路径上使用 <code>spring-aspects.jar</code>,激活审核功能只需将 Spring Data JPA <code>auditing</code> 命名空间元素添加到您的配置中,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 61. 使用 XML 配置激活审计</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;jpa:auditing auditor-aware-ref="yourAuditorAwareBean" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>从 Spring Data JPA 1.5 开始,您可以通过使用 <code>@EnableJpaAuditing</code> 注解对配置类进行注解来启用审核.  您仍然必须修改 <code>orm.xml</code> 文件,并在类路径上具有 <code>spring-aspects.jar</code>.  以下示例显示了如何使用 <code>@EnableJpaAuditing</code> 注解:</p>
</div>
<div class="exampleblock">
<div class="title">Example 62. 用 Java 配置激活审计</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJpaAuditing
class Config {

  @Bean
  public AuditorAware&lt;AuditableUser&gt; auditorProvider() {
    return new AuditorAwareImpl();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果将类型 <code>AuditorAware</code> 的 bean 暴露给 <code>ApplicationContext</code>,则审计基础结构会自动选择它并使用它来确定要在 domain 类型上设置的当前用户.  如果您在 <code>ApplicationContext</code> 中注册了多个实现,则可以通过显式设置 <code>@EnableJpaAuditing</code> 的 <code>auditAwareRef</code> 属性来选择要使用的实现.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jpa.misc"><a class="anchor" href="#jpa.misc"></a>10. 其他注意事项</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="jpa.misc.jpa-context"><a class="anchor" href="#jpa.misc.jpa-context"></a>10.1. 在自定义实现中使用 <code>JpaContext</code></h3>
<div class="paragraph">
<p>当使用多个 <code>EntityManager</code> 实例和<a href="#repositories.custom-implementations">自定义存储库实现</a>实现时,您需要将正确的 <code>EntityManager</code> 连接到存储库实现类中.  您可以通过在 <code>@PersistenceContext</code> 注解中显式命名 <code>EntityManager</code> 来实现,
或者,如果 <code>EntityManager</code> 是 <code>@Autowired</code>,则可以使用 <code>@Qualifier</code> 来实现.</p>
</div>
<div class="paragraph">
<p>从 Spring Data JPA 1.9 开始,Spring Data JPA 包含一个名为 <code>JpaContext</code> 的类,假定您只由应用程序中的 <code>EntityManager</code> 实例之一进行管理,该类使您可以通过被管理 domain 类获取 <code>EntityManager</code>.  以下示例显示如何在自定义存储库中使用 <code>JpaContext</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 63. 在自定义存储库实现中使用 <code>JpaContext</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class UserRepositoryImpl implements UserRepositoryCustom {

  private final EntityManager em;

  @Autowired
  public UserRepositoryImpl(JpaContext context) {
    this.em = context.getEntityManagerByManagedType(User.class);
  }

  …
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种方法的优点是,如果将 domain 类型分配给其他持久性单元,则无需触摸存储库即可更改对持久性单元的引用.</p>
</div>
</div>
<div class="sect2">
<h3 id="jpa.misc.merging-persistence-units"><a class="anchor" href="#jpa.misc.merging-persistence-units"></a>10.2. 合并持久性单元</h3>
<div class="paragraph">
<p>Spring 支持具有多个持久性单元.  但是,有时您可能希望对应用程序进行模块化,但仍要确保所有这些模块都在单个持久性单元中运行.  为了实现这种行为,Spring Data JPA 提供了一个 <code>PersistenceUnitManager</code> 实现,该实现会根据其名称自动合并持久性单元,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 64. 使用 MergingPersistenceUnitmanager</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean class="….LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="persistenceUnitManager"&gt;
    &lt;bean class="….MergingPersistenceUnitManager" /&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jpa.misc.entity-scanning"><a class="anchor" href="#jpa.misc.entity-scanning"></a>10.2.1. @Entity 类和 JPA 映射文件的类路径扫描</h4>
<div class="paragraph">
<p>普通的JPA设置要求所有注解映射的实体类在 <code>orm.xml</code> 中列出.  XML映射文件也是如此.  Spring Data JPA 提供了一个 <code>ClasspathScanningPersistenceUnitPostProcessor</code>,它配置了一个基本包,并可以选择采用映射文件名模式.  然后,它在给定的软件包中扫描以 <code>@Entity</code> 或 <code>@MappedSuperclass</code> 注解的类,加载与文件名模式匹配的配置文件,并将其交给JPA配置.  后处理器必须配置如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 65. 使用 ClasspathScanningPersistenceUnitPostProcessor</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean class="….LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="persistenceUnitPostProcessors"&gt;
    &lt;list&gt;
      &lt;bean class="org.springframework.data.jpa.support.ClasspathScanningPersistenceUnitPostProcessor"&gt;
        &lt;constructor-arg value="com.acme.domain" /&gt;
        &lt;property name="mappingFileNamePattern" value="**/*Mapping.xml" /&gt;
      &lt;/bean&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从 Spring 3.1 开始,可以直接在 <code>LocalContainerEntityManagerFactoryBean</code> 上配置要扫描的程序包,以对实体类启用类路径扫描.  有关详细信息,请参见 <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/orm/jpa/LocalContainerEntityManagerFactoryBean.html#setPackagesToScan(java.lang.String...)">JavaDoc</a>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jpd.misc.cdi-integration"><a class="anchor" href="#jpd.misc.cdi-integration"></a>10.3. CDI 集成</h3>
<div class="paragraph">
<p>存储库接口的实例通常由容器创建,在使用 Spring Data 时,Spring 是最自然的选择.  如<a href="#repositories.create-instances">创建存储库实例</a>中所述,Spring 为创建 bean 实例提供了复杂的支持.  从 1.1.0 版本开始,Spring Data JPA 附带了一个自定义 CDI 扩展名,该扩展名允许在 CDI 环境中使用存储库抽象.  该扩展是 JAR 的一部分.  要激活它,请将 Spring Data JPA JAR 包含在类路径中.</p>
</div>
<div class="paragraph">
<p>现在,您可以通过为 <code>EntityManagerFactory</code> 和 <code>EntityManager</code> 实现 CDI 生产者来设置基础结构,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class EntityManagerFactoryProducer {

  @Produces
  @ApplicationScoped
  public EntityManagerFactory createEntityManagerFactory() {
    return Persistence.createEntityManagerFactory("my-persistence-unit");
  }

  public void close(@Disposes EntityManagerFactory entityManagerFactory) {
    entityManagerFactory.close();
  }

  @Produces
  @RequestScoped
  public EntityManager createEntityManager(EntityManagerFactory entityManagerFactory) {
    return entityManagerFactory.createEntityManager();
  }

  public void close(@Disposes EntityManager entityManager) {
    entityManager.close();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>必要的设置可能会因 JavaEE 环境而异.  您可能需要做的只是将 <code>EntityManager</code> 重新声明为 CDI bean,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class CdiConfig {

  @Produces
  @RequestScoped
  @PersistenceContext
  public EntityManager entityManager;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中,容器必须能够创建 JPA <code>EntityManagers</code> 本身.  所有配置所做的就是将 JPA <code>EntityManager</code> 重新导出为 CDI bean.</p>
</div>
<div class="paragraph">
<p>每当容器请求存储库类型的 bean 时,Spring Data JPA CDI 扩展都将所有可用的 <code>EntityManager</code> 实例作为 CDI bean 进行选择,并为 Spring Data 存储库创建代理.  因此,获取 Spring Data 存储库的实例只需声明一个 <code>@Injected</code> 属性即可,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class RepositoryClient {

  @Inject
  PersonRepository repository;

  public void businessMethod() {
    List&lt;Person&gt; people = repository.findAll();
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2.3.6.RELEASE<br>
Last updated 2021-05-14 15:46:03 +0800
</div>
</div>
<script type="text/javascript" src="http://resources.jcohy.com/js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="http://resources.jcohy.com/js/toc.js"></script>
<script type="text/javascript" src="http://resources.jcohy.com/js/switch-language.js"></script>
</body>
</html>
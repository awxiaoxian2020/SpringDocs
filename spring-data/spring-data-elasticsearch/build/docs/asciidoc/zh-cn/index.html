<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="author" content="BioMed Central Development Team, Oliver Drotbohm, Greg Turnquist, Christoph Strobl, Peter-Josef Meisch">
<title>Spring Data Elasticsearch - 参考文档</title>
<link rel="stylesheet" href="css/site.css">
<script src="js/setup.js"></script><script defer src="js/site.js"></script>

</head>
<body class="book toc2 toc-left"><div id="banner-container" class="container" role="banner">
  <div id="banner" class="contained" role="banner">
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </div>
</div>
<div id="tocbar-container" class="container" role="navigation">
  <div id="tocbar" class="contained" role="navigation">
    <button id="toggle-toc"></button>
  </div>
</div>
<div id="main-container" class="container">
  <div id="main" class="contained">
    <div id="doc" class="doc">
<div id="header">
<h1>Spring Data Elasticsearch - 参考文档</h1>
<div class="details">
<span id="author" class="author">BioMed Central Development Team</span><br>
<span id="author2" class="author">Oliver Drotbohm</span><br>
<span id="author3" class="author">Greg Turnquist</span><br>
<span id="author4" class="author">Christoph Strobl</span><br>
<span id="author5" class="author">Peter-Josef Meisch</span><br>
<span id="revdate">2021-09-13</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#preface">前言</a>
<ul class="sectlevel1">
<li><a href="#new-features">1. 新增功能</a>
<ul class="sectlevel2">
<li><a href="#new-features.4-1-0">1.1. New in Spring Data Elasticsearch 4.1</a></li>
<li><a href="#new-features.4-0-0">1.2. Spring Data Elasticsearch 4.0 新增功能</a></li>
<li><a href="#new-features.3-2-0">1.3. Spring Data Elasticsearch 3.2 新增功能</a></li>
</ul>
</li>
<li><a href="#preface.metadata">2. 项目元数据</a></li>
<li><a href="#preface.requirements">3. 要求</a>
<ul class="sectlevel2">
<li><a href="#preface.versions">3.1. 版本</a></li>
</ul>
</li>
<li><a href="#repositories">4. 使用 Spring Data Repositories</a>
<ul class="sectlevel2">
<li><a href="#repositories.core-concepts">4.1. 核心概念</a></li>
<li><a href="#repositories.query-methods">4.2. 查询方法</a></li>
<li><a href="#repositories.definition">4.3. 定义 Repository  接口</a>
<ul class="sectlevel3">
<li><a href="#repositories.definition-tuning">4.3.1. 微调 Repository  定义</a></li>
<li><a href="#repositories.multiple-modules">4.3.2. 将 Repositories  与多个 Spring Data 模块一起使用</a></li>
</ul>
</li>
<li><a href="#repositories.query-methods.details">4.4. 定义查询方法</a>
<ul class="sectlevel3">
<li><a href="#repositories.query-methods.query-lookup-strategies">4.4.1. 查询策略</a></li>
<li><a href="#repositories.query-methods.query-creation">4.4.2. 查询创建</a></li>
<li><a href="#repositories.query-methods.query-property-expressions">4.4.3. 属性表达式</a></li>
<li><a href="#repositories.special-parameters">4.4.4. 特殊参数处理</a>
<ul class="sectlevel4">
<li><a href="#repositories.paging-and-sorting">Paging 和 Sorting</a></li>
</ul>
</li>
<li><a href="#repositories.limit-query-result">4.4.5. 限制查询结果</a></li>
<li><a href="#repositories.collections-and-iterables">4.4.6. 存储库方法返回集合或可迭代对象</a>
<ul class="sectlevel4">
<li><a href="#repositories.collections-and-iterables.streamable">使用 Streamable 作为查询方法返回类型</a></li>
<li><a href="#repositories.collections-and-iterables.streamable-wrapper">返回自定义 Streamable 包装器类型</a></li>
<li><a href="#repositories.collections-and-iterables.vavr">支持 Vavr 集合</a></li>
</ul>
</li>
<li><a href="#repositories.nullability">4.4.7. 存储库方法的空处理</a>
<ul class="sectlevel4">
<li><a href="#repositories.nullability.annotations">可空性注解</a></li>
<li><a href="#repositories.nullability.kotlin">基于 Kotlin 的存储库中的可空性</a></li>
</ul>
</li>
<li><a href="#repositories.query-streaming">4.4.8. 流查询结果</a></li>
<li><a href="#repositories.query-async">4.4.9. 异步查询结果</a></li>
</ul>
</li>
<li><a href="#repositories.create-instances">4.5. 创建存储库实例</a>
<ul class="sectlevel3">
<li><a href="#repositories.create-instances.spring">4.5.1. XML 配置</a>
<ul class="sectlevel4">
<li><a href="#repositories.using-filters">使用过滤器</a></li>
</ul>
</li>
<li><a href="#repositories.create-instances.java-config">4.5.2. Java 配置</a></li>
<li><a href="#repositories.create-instances.standalone">4.5.3. 独立使用</a></li>
</ul>
</li>
<li><a href="#repositories.custom-implementations">4.6. Spring Data 存储库的自定义实现</a>
<ul class="sectlevel3">
<li><a href="#repositories.single-repository-behavior">4.6.1. 自定义单个存储库</a>
<ul class="sectlevel4">
<li><a href="#repositories.configuration">配置</a></li>
</ul>
</li>
<li><a href="#repositories.customize-base-repository">4.6.2. 自定义基础存储库</a></li>
</ul>
</li>
<li><a href="#core.domain-events">4.7. 从聚合根发布事件</a></li>
<li><a href="#core.extensions">4.8. Spring Data 扩展</a>
<ul class="sectlevel3">
<li><a href="#core.extensions.querydsl">4.8.1. Querydsl 扩展</a></li>
<li><a href="#core.web">4.8.2. Web 支持</a>
<ul class="sectlevel4">
<li><a href="#core.web.basic">Basic Web 支持</a></li>
<li><a href="#core.web.pageables">超媒体对页面的支持</a></li>
<li><a href="#core.web.basic.jackson-mappers">Spring Data Jackson Modules</a></li>
<li><a href="#core.web.binding">Web 数据绑定支持</a></li>
<li><a href="#core.web.type-safe">Querydsl Web 支持</a></li>
</ul>
</li>
<li><a href="#core.repository-populators">4.8.3. 存储库填充器</a></li>
</ul>
</li>
<li><a href="#projections">4.9. 投影</a>
<ul class="sectlevel3">
<li><a href="#projections.interfaces">4.9.1. 基于接口的投影</a>
<ul class="sectlevel4">
<li><a href="#projections.interfaces.closed">封闭投影</a></li>
<li><a href="#projections.interfaces.open">打开投影</a></li>
<li><a href="#projections.interfaces.nullable-wrappers">Nullable Wrappers</a></li>
</ul>
</li>
<li><a href="#projections.dtos">4.9.2. 基于类的投影 (DTO)</a></li>
<li><a href="#projection.dynamic">4.9.3. 动态投影</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">参考文档</a>
<ul class="sectlevel1">
<li><a href="#elasticsearch.clients">5. Elasticsearch 客户端</a>
<ul class="sectlevel2">
<li><a href="#elasticsearch.clients.transport">5.1. Transport Client</a></li>
<li><a href="#elasticsearch.clients.rest">5.2. 更高级别的 REST Client</a></li>
<li><a href="#elasticsearch.clients.reactive">5.3. Reactive Client</a></li>
<li><a href="#elasticsearch.clients.configuration">5.4. Client 配置</a></li>
<li><a href="#elasticsearch.clients.logging">5.5. Client 日志</a></li>
</ul>
</li>
<li><a href="#elasticsearch.mapping">6. Elasticsearch 对象映射</a>
<ul class="sectlevel2">
<li><a href="#elasticsearch.mapping.meta-model">6.1. Meta Model Object Mapping</a>
<ul class="sectlevel3">
<li><a href="#elasticsearch.mapping.meta-model.annotations">6.1.1. 映射注解概述</a></li>
<li><a href="#elasticsearch.mapping.meta-model.rules">6.1.2. 映射规则</a>
<ul class="sectlevel4">
<li><a href="#type-hints类型提示">Type Hints(类型提示)</a></li>
<li><a href="#geospatial-类型">Geospatial 类型</a></li>
<li><a href="#collections集合">Collections(集合)</a></li>
<li><a href="#maps">Maps</a></li>
</ul>
</li>
<li><a href="#elasticsearch.mapping.meta-model.conversions">6.1.3. 自定义转换</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#elasticsearch.operations">7. Elasticsearch 操作</a>
<ul class="sectlevel2">
<li><a href="#elasticsearch.operations.template">7.1. ElasticsearchTemplate</a></li>
<li><a href="#elasticsearch.operations.resttemplate">7.2. ElasticsearchRestTemplate</a></li>
<li><a href="#elasticsearch.operations.usage">7.3. 使用案例</a></li>
<li><a href="#elasticsearch.reactive.operations">7.4. Reactive Elasticsearch 操作</a>
<ul class="sectlevel3">
<li><a href="#elasticsearch.reactive.template">7.4.1. Reactive Elasticsearch Template</a>
<ul class="sectlevel4">
<li><a href="#elasticsearch.reactive.template.configuration">Reactive Template 配置</a></li>
<li><a href="#elasticsearch.reactive.template.usage">Reactive Template 使用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#elasticsearch.operations.searchresulttypes">7.5. 搜索结果类型</a></li>
<li><a href="#queries">7.6. Queries</a>
<ul class="sectlevel3">
<li><a href="#criteriaquery">7.6.1. CriteriaQuery</a></li>
<li><a href="#stringquery">7.6.2. StringQuery</a></li>
<li><a href="#nativesearchquery">7.6.3. NativeSearchQuery</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#elasticsearch.repositories">8. Elasticsearch Repositories</a>
<ul class="sectlevel2">
<li><a href="#elasticsearch.repositories.autocreation">8.1. 自动创建具有相应映射的索引</a></li>
<li><a href="#elasticsearch.query-methods">8.2. 查询方法</a>
<ul class="sectlevel3">
<li><a href="#elasticsearch.query-methods.finders">8.2.1. 查询方法查找策略</a>
<ul class="sectlevel4">
<li><a href="#声明查询">声明查询</a></li>
</ul>
</li>
<li><a href="#elasticsearch.query-methods.criterions">8.2.2. 创建查询</a></li>
<li><a href="#方法返回类型">8.2.3. 方法返回类型</a></li>
<li><a href="#elasticsearch.query-methods.at-query">8.2.4. 使用 @Query 注解</a></li>
</ul>
</li>
<li><a href="#elasticsearch.reactive.repositories">8.3. Reactive Elasticsearch Repositories</a>
<ul class="sectlevel3">
<li><a href="#elasticsearch.reactive.repositories.usage">8.3.1. 使用</a></li>
<li><a href="#elasticsearch.reactive.repositories.configuration">8.3.2. 配置</a></li>
</ul>
</li>
<li><a href="#elasticsearch.repositories.annotations">8.4. repository 方法注解</a>
<ul class="sectlevel3">
<li><a href="#highlight">8.4.1. @Highlight</a></li>
</ul>
</li>
<li><a href="#elasticsearch.annotation">8.5. 基于注解的配置</a></li>
<li><a href="#elasticsearch.cdi">8.6. Elasticsearch Repositories 使用 CDI</a></li>
<li><a href="#elasticsearch.namespace">8.7. Spring 命名空间</a></li>
</ul>
</li>
<li><a href="#auditing">9. 审计</a>
<ul class="sectlevel2">
<li><a href="#auditing.basics">9.1. 基础</a>
<ul class="sectlevel3">
<li><a href="#auditing.annotations">9.1.1. 基于注解的审核元数据</a></li>
<li><a href="#auditing.interfaces">9.1.2. 基于接口的审核元数据</a></li>
<li><a href="#auditing.auditor-aware">9.1.3. <code>AuditorAware</code></a></li>
<li><a href="#auditing.reactive-auditor-aware">9.1.4. <code>ReactiveAuditorAware</code></a></li>
</ul>
</li>
<li><a href="#elasticsearch.auditing">9.2. Elasticsearch 审计</a>
<ul class="sectlevel3">
<li><a href="#准备实体">9.2.1. 准备实体</a></li>
<li><a href="#启用审计">9.2.2. 启用审计</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#entity-callbacks">10. Entity Callbacks (实体回调)</a>
<ul class="sectlevel2">
<li><a href="#entity-callbacks.implement">10.1. 实现 Entity Callbacks</a></li>
<li><a href="#entity-callbacks.register">10.2. 注册 Entity Callbacks</a></li>
<li><a href="#elasticsearch.entity-callbacks">10.3. Elasticsearch EntityCallbacks</a></li>
</ul>
</li>
<li><a href="#elasticsearch.misc">11. 其他 Elasticsearch 操作支持</a>
<ul class="sectlevel2">
<li><a href="#elasticsearch.misc.filter">11.1. Filter Builder</a></li>
<li><a href="#elasticsearch.scroll">11.2. 对的数据量大的结果集使用 Scroll</a></li>
<li><a href="#elasticsearch.misc.sorts">11.3. Sort 选项</a></li>
<li><a href="#elasticsearch.misc.jointype">11.4. Join-Type 实现</a>
<ul class="sectlevel3">
<li><a href="#设置数据">11.4.1. 设置数据</a></li>
<li><a href="#存储数据">11.4.2. 存储数据</a></li>
<li><a href="#检索数据">11.4.3. 检索数据</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix">Appendix</a>
<ul class="sectlevel1">
<li><a href="#repositories.namespace-reference">Appendix A: 命名空间参考</a>
<ul class="sectlevel2">
<li><a href="#populator.namespace-dao-config"><code>&lt;repositories /&gt;</code> 元素</a></li>
</ul>
</li>
<li><a href="#populator.namespace-reference">Appendix B: Populators  命名空间参考</a>
<ul class="sectlevel2">
<li><a href="#namespace-dao-config">&lt;populator /&gt; element</a></li>
</ul>
</li>
<li><a href="#repository-query-keywords">Appendix C: 存储库查询关键字</a>
<ul class="sectlevel2">
<li><a href="#appendix.query.method.subject">支持的查询方法主题关键字</a></li>
<li><a href="#appendix.query.method.predicate">支持的查询方法断言关键字和修饰符</a></li>
</ul>
</li>
<li><a href="#repository-query-return-types">Appendix D: 储存库查询返回类型</a>
<ul class="sectlevel2">
<li><a href="#appendix.query.return.types">支持的查询返回类型</a></li>
</ul>
</li>
<li><a href="#elasticsearch.migration">Appendix E: Migration Guides</a>
<ul class="sectlevel2">
<li><a href="#elasticsearch-migration-guide-3.2-4.0">Upgrading from 3.2.x to 4.0.x</a>
<ul class="sectlevel3">
<li><a href="#elasticsearch-migration-guide-3.2-4.0.jackson-removal">Removal of the used Jackson Mapper</a></li>
<li><a href="#elasticsearch-migration-guide-3.2-4.0.implicit-index-name">Removal of implicit index name from query objects</a></li>
<li><a href="#elasticsearch-migration-guide-3.2-4.0.new-operations">The new Operations interfaces</a></li>
<li><a href="#elasticsearch-migration-guide-3.2-4.0.deprecations">Deprecations</a>
<ul class="sectlevel4">
<li><a href="#methods-and-classes">Methods and classes</a></li>
<li><a href="#elasticsearch-deprecations">Elasticsearch deprecations</a></li>
</ul>
</li>
<li><a href="#elasticsearch-migration-guide-3.2-4.0.removal">Removals</a></li>
</ul>
</li>
<li><a href="#elasticsearch-migration-guide-4.0-4.1">从 4.0.x 升级到 4.1.x</a>
<ul class="sectlevel3">
<li><a href="#elasticsearch-migration-guide-4.0-4.1.deprecations">弃用</a></li>
<li><a href="#elasticsearch-migration-guide-4.0-4.1.removal">删除</a></li>
<li><a href="#elasticsearch-migration-guide-4.0-4.1.breaking-changes">重大变化</a>
<ul class="sectlevel4">
<li><a href="#reactiveelasticsearchclient-indices-方法的返回类型">ReactiveElasticsearchClient.Indices 方法的返回类型</a></li>
<li><a href="#documentoperartions-bulkindex-方法的返回类型">DocumentOperartions.bulkIndex 方法的返回类型</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>&#169; 2013-2020 The original author(s).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
本文档的副本可以供您自己使用,也可以分发给其他人,但前提是您不对此类副本收取任何费用,并且还应确保每份副本均包含本版权声明(无论是印刷版本还是电子版本) .
</td>
</tr>
</table>
</div>
<!-- toc disabled -->
</div>
</div>
<h1 id="preface" class="sect0"><a class="anchor" href="#preface"></a>前言</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Spring Data Elasticsearch 项目将 Spring 的核心概念应用于使用 Elasticsearch 搜索引擎的解决方案的开发中. 它提供:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个用于存储,搜索,排序以及构建聚合的高级抽象 <em>Templates</em></p>
</li>
<li>
<p>例如,<em>Repositories</em> 允许用户自定义接口方法来传达查询方法 (有关 repositories 的基础,请查看 <a href="#repositories">使用 Spring Data Repositories</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>你会注意到这与 Spring Framework 中的 Spring data solr 和 mongodb 非常相似</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="new-features"><a class="anchor" href="#new-features"></a>1. 新增功能</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="new-features.4-1-0"><a class="anchor" href="#new-features.4-1-0"></a>1.1. New in Spring Data Elasticsearch 4.1</h3>
<div class="ulist">
<ul>
<li>
<p>使用 Spring 5.3.</p>
</li>
<li>
<p>更新版本至 Elasticsearch 7.9.3.</p>
</li>
<li>
<p>改进 别名管理 API.</p>
</li>
<li>
<p>引入用于索引管理的 <code>ReactiveIndexOperations</code> .</p>
</li>
<li>
<p>Index templates support.</p>
</li>
<li>
<p>Support for Geo-shape data with GeoJson.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-features.4-0-0"><a class="anchor" href="#new-features.4-0-0"></a>1.2. Spring Data Elasticsearch 4.0 新增功能</h3>
<div class="ulist">
<ul>
<li>
<p>使用 Spring 5.2.</p>
</li>
<li>
<p>更新版本至 Elasticsearch 7.6.2.</p>
</li>
<li>
<p>弃用 <code>TransportClient</code>.</p>
</li>
<li>
<p>实现大多数可用于索引映射的映射类型.</p>
</li>
<li>
<p>删除 Jackson <code>ObjectMapper</code>, 现在使用 <a href="#elasticsearch.mapping.meta-model">MappingElasticsearchConverter</a></p>
</li>
<li>
<p>清理 <code>*Operations</code> interfaces API, 对方法进行分组和重命名,使他们与 Elasticsearch API 匹配, 弃用旧方法, 并与其他 Spring Data 模块版本对其.</p>
</li>
<li>
<p>引入 <code>SearchHit&lt;T&gt;</code> 类来表示找到的文档以及该文档的相关元数据(i.e. <em>sortValues</em>).</p>
</li>
<li>
<p>引入 <code>SearchHits&lt;T&gt;</code> 类来表示整个搜索结果以及完整搜索结果的元数据 (i.e. <em>max_score</em>).</p>
</li>
<li>
<p>引入 <code>SearchPage&lt;T&gt;</code> 类以表示包含 <code>SearchHits&lt;T&gt;</code> 实例的分页结果.</p>
</li>
<li>
<p>引入 <code>GeoDistanceOrder</code> 类以便能根据地理距离进行排序</p>
</li>
<li>
<p>实现审计支持</p>
</li>
<li>
<p>实现 entity 生命周期回调</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-features.3-2-0"><a class="anchor" href="#new-features.3-2-0"></a>1.3. Spring Data Elasticsearch 3.2 新增功能</h3>
<div class="ulist">
<ul>
<li>
<p>提供基于 Basic Authentication 和 SSL 传输的 Elasticsearch 集群支持.</p>
</li>
<li>
<p>更新版本至 Elasticsearch 6.8.1.</p>
</li>
<li>
<p>通过 <a href="#elasticsearch.reactive.operations">Reactive Elasticsearch 操作</a> 和 <a href="#elasticsearch.reactive.repositories">Reactive Elasticsearch Repositories</a> 支持 Reactive programming.</p>
</li>
<li>
<p>引入 <a href="#elasticsearch.mapping.meta-model">ElasticsearchEntityMapper</a> 作为 Jackson <code>ObjectMapper</code> 的替代方案.</p>
</li>
<li>
<p><code>@Field</code> 自定义字段名称.</p>
</li>
<li>
<p>支持按查询删除.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="preface.metadata"><a class="anchor" href="#preface.metadata"></a>2. 项目元数据</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Version Control - <a href="https://github.com/spring-projects/spring-data-elasticsearch" class="bare">github.com/spring-projects/spring-data-elasticsearch</a></p>
</li>
<li>
<p>API Documentation - <a href="https://docs.spring.io/spring-data/elasticsearch/docs/current/api/" class="bare">docs.spring.io/spring-data/elasticsearch/docs/current/api/</a></p>
</li>
<li>
<p>Bugtracker - <a href="https://jira.spring.io/browse/DATAES" class="bare">jira.spring.io/browse/DATAES</a></p>
</li>
<li>
<p>Release repository - <a href="https://repo.spring.io/libs-release" class="bare">repo.spring.io/libs-release</a></p>
</li>
<li>
<p>Milestone repository - <a href="https://repo.spring.io/libs-milestone" class="bare">repo.spring.io/libs-milestone</a></p>
</li>
<li>
<p>Snapshot repository - <a href="https://repo.spring.io/libs-snapshot" class="bare">repo.spring.io/libs-snapshot</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="preface.requirements"><a class="anchor" href="#preface.requirements"></a>3. 要求</h2>
<div class="sectionbody">
<div class="paragraph">
<p>需要安装 <a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>.</p>
</div>
<div class="sect2">
<h3 id="preface.versions"><a class="anchor" href="#preface.versions"></a>3.1. 版本</h3>
<div class="paragraph">
<p>下表显示了 Spring Data 发布使用的 Elasticsearch 版本以及其中包含的 Spring Data Elasticsearch 的版本,以及引用该特定 Spring Data 发布的 Spring Boot 版本:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-center valign-top">Spring Data Release Train</th>
<th class="tableblock halign-center valign-top">Spring Data Elasticsearch</th>
<th class="tableblock halign-center valign-top">Elasticsearch</th>
<th class="tableblock halign-center valign-top">Spring Boot</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">2020.0.0<sup class="footnote" id="_footnote_cdv">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4.1.x<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7.9.3</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2.4.x<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Neumann</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">4.0.x</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">7.6.2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2.3.x</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Moore</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3.2.x</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6.8.12</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2.2.x</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Lovelace</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3.1.x</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">6.2.2</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2.1.x</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Kay<sup class="footnote" id="_footnote_oom">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">3.0.x<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">5.5.0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2.0.x<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top"><p class="tableblock">Ingalls<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2.1.x<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">2.4.0</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">1.5.x<sup class="footnoteref">[<a class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>持续跟进对即将推出的 Elasticsearch 版本的支持,并且提供使用 <a href="#elasticsearch.clients.rest">高级 REST client</a> 的兼容性</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repositories"><a class="anchor" href="#repositories"></a>4. 使用 Spring Data Repositories</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data 存储库抽象层的目标是减少为各种持久性存储实现数据访问所需的样板代码数量.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p><em>Spring 数据存储库文档和你的模块</em></p>
</div>
<div class="paragraph">
<p>本章介绍 Spring Data 存储库的核心概念和接口. 本章中的信息来自 Spring Data Commons 模块. 它使用 Java 持久性 API (JPA) 模块的配置和代码示例. 您应该将 XML 命名空间声明和要扩展的类型调整为您使用的特定模块的等同项. &#8220;<a href="#repositories.namespace-reference">命名空间参考</a>&#8221; 涵盖了所有支持存储库 API 的 Spring Data 模块支持的 XML 配置.
&#8220;<a href="#repository-query-keywords">存储库查询关键字</a>&#8221; 一般涵盖了存储库抽象支持的查询方法关键字. 有关模块特定功能的详细信息,请参阅本文档的该模块章节.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="repositories.core-concepts"><a class="anchor" href="#repositories.core-concepts"></a>4.1. 核心概念</h3>
<div class="paragraph">
<p>Spring Data 存储库抽象中的中心接口是 <code>Repository</code>. 它需要 domain 类以及 domain 的 ID 类型作为类型参数. 该接口主要作为标记接口来捕获要使用的类型,并帮助您发现该接口的子接口.  <code>CrudRepository</code> 实现了实体类复杂的 CRUD 功能.</p>
</div>
<div id="repositories.repository" class="exampleblock">
<div class="title">Example 1. <code>CrudRepository</code> 接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface CrudRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; {

  &lt;S extends T&gt; S save(S entity);      <i class="conum" data-value="1"></i><b>(1)</b>

  Optional&lt;T&gt; findById(ID primaryKey); <i class="conum" data-value="2"></i><b>(2)</b>

  Iterable&lt;T&gt; findAll();               <i class="conum" data-value="3"></i><b>(3)</b>

  long count();                        <i class="conum" data-value="4"></i><b>(4)</b>

  void delete(T entity);               <i class="conum" data-value="5"></i><b>(5)</b>

  boolean existsById(ID primaryKey);   <i class="conum" data-value="6"></i><b>(6)</b>

  // … more functionality omitted.
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>保存给定的实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>返回由给定 ID 标识的实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>返回所有实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>返回实体的数量.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>删除给定的实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>判断是否存在具有给定ID的实体.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
我们还提供持久性技术的特定抽象,如 <code>JpaRepository</code> 或 <code>MongoRepository</code>. 这些接口扩展 <code>CrudRepository</code> 并暴露了持久化技术的基本功能,以及通用的持久化技术,例如 <code>CrudRepository</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>除此之外 <code>CrudRepository</code>,还有一个 <a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/PagingAndSortingRepository.html"><code>PagingAndSortingRepository</code></a> 的抽象的接口,来简化对实体的分页操作:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. <code>PagingAndSortingRepository</code> 接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface PagingAndSortingRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; {

  Iterable&lt;T&gt; findAll(Sort sort);

  Page&lt;T&gt; findAll(Pageable pageable);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要访问 <code>User</code> 第二页,每页 20,您可以执行以下操作:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">PagingAndSortingRepository&lt;User, Long&gt; repository = // … get access to a bean
Page&lt;User&gt; users = repository.findAll(PageRequest.of(1, 20));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了查询方法外,count 和 delete 查询的相关扩展都是可用的. 以下列表扩展 count 查询的接口定义:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. 扩展 count 查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt; {

  long countByLastname(String lastname);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下列表扩展 delete 查询的接口定义:</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. 扩展删除查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt; {

  long deleteByLastname(String lastname);

  List&lt;User&gt; removeByLastname(String lastname);
}
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.query-methods"><a class="anchor" href="#repositories.query-methods"></a>4.2. 查询方法</h3>
<div class="paragraph">
<p>标准 CRUD 功能通常会在底层数据存储上进行查询. 使用 Spring Data,声明这些查询需要四步:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>声明一个扩展 <code>Repository</code> 或其子接口的接口,并输入它应该处理的 domain 类和 <code>ID</code> 类型,如以下示例所示:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, Long&gt; { … }
</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>在接口上声明查询方法.</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, Long&gt; {
  List&lt;Person&gt; findByLastname(String lastname);
}
</code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>使用 Spring  <a href="#repositories.create-instances.java-config">JavaConfig</a> 或 <a href="#repositories.create-instances">XML 配置</a> 为这些接口创建代理实例.</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>要使用 Java 配置,请创建类似于以下的类:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.data.jpa.repository.config.EnableJpaRepositories;

</span><span class="fold-block">@EnableJpaRepositories
class Config { … }
</span></code></pre>
</div>
</div>
</div>
</div>
</li>
<li>
<p>要使用XML配置,请定义一个类似于以下的 bean:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:jpa="http://www.springframework.org/schema/data/jpa"
   xsi:schemaLocation="http://www.springframework.org/schema/beans
     https://www.springframework.org/schema/beans/spring-beans.xsd
     http://www.springframework.org/schema/data/jpa
     https://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

   &lt;jpa:repositories base-package="com.acme.repositories"/&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个例子中使用了 JPA 命名空间. 如果您想使用其他的存储库,则需要将其更改为相应的命名空间声明. 换句话说,你应该替换 jpa,例如 <code>mongodb</code>.
另请注意,JavaConfig 不会显式配置包,因为默认情况下会使用注解类的包. 定制要扫描的软件包,请使用 <code>basePackage…</code> 特定于数据存储库的 <code>@Enable${store}Repositories</code> 注解的一个属性.</p>
</div>
</li>
</ol>
</div>
</li>
<li>
<p>注入资源库实例并使用它,如以下示例所示:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class SomeClient {

  private final PersonRepository repository;

  SomeClient(PersonRepository repository) {
    this.repository = repository;
  }

  void doSomething() {
    List&lt;Person&gt; persons = repository.findByLastname("Matthews");
  }
}
</code></pre>
</div>
</div>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下部分详细解释每一步:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#repositories.definition">定义 Repository  接口</a></p>
</li>
<li>
<p><a href="#repositories.query-methods.details">定义查询方法</a></p>
</li>
<li>
<p><a href="#repositories.create-instances">创建存储库实例</a></p>
</li>
<li>
<p><a href="#repositories.custom-implementations">Spring Data Repository  的自定义实现</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="repositories.definition"><a class="anchor" href="#repositories.definition"></a>4.3. 定义 Repository  接口</h3>
<div class="paragraph">
<p>首先,定义一个 domain 类特定的 repository 接口. 该接口必须扩展 <code>Repository</code> 并且输入 domain 类和 <code>ID</code> 类型. 如果您想暴露该 domain 类型的 CRUD 方法,请扩展 <code>CrudRepository</code> 而不是 <code>Repository</code>.</p>
</div>
<div class="sect3">
<h4 id="repositories.definition-tuning"><a class="anchor" href="#repositories.definition-tuning"></a>4.3.1. 微调 Repository  定义</h4>
<div class="paragraph">
<p>通常情况下,您的 Repository  接口扩展了 <code>Repository</code>,<code>CrudRepository</code> 或 <code>PagingAndSortingRepository</code>. 如果您不想扩展 Spring Data 接口,也可以使用 <code>@RepositoryDefinition</code> 注解您的 Repository 接口.
扩展 <code>CrudRepository</code> 暴露了一套完整的方法来操纵你的实体. 如果您想选择暴露的方法,请复制 <code>CrudRepository</code> 中要暴露的方法 到您的实体类 Repository 中.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这样做可以让您在提供的 Spring Data Repositories 功能之上定义自己的抽象.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示如何选择性地暴露 CRUD方法 (<code>findById</code> 以及 <code>save</code> 在这种情况下) :</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. 选择性地暴露 CRUD 方法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@NoRepositoryBean
interface MyBaseRepository&lt;T, ID&gt; extends Repository&lt;T, ID&gt; {

  Optional&lt;T&gt; findById(ID id);

  &lt;S extends T&gt; S save(S entity);
}

interface UserRepository extends MyBaseRepository&lt;User, Long&gt; {
  User findByEmailAddress(EmailAddress emailAddress);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中,您为所有 domain Repository 定义了一个通用的基本接口,并暴露了 <code>findById(…)</code> 和  <code>save(…)</code> 方法. 这些方法被路由到 Spring Data 提供的所选存储的基本存储库实现中 (例如,如果使用 JPA,则实现为 <code>SimpleJpaRepository</code>,因为它们与 <code>CrudRepository</code> 中的方法签名匹配.
因此,<code>UserRepository</code> 现在可以保存用户,通过ID查找单个用户,并触发查询以通过电子邮件地址查找 <code>Users</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
中间的 repository 接口用 <code>@NoRepositoryBean</code> 注解. 确保添加了该注解的 repository 接口不会在  Spring Data 运行时被创建实例.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.multiple-modules"><a class="anchor" href="#repositories.multiple-modules"></a>4.3.2. 将 Repositories  与多个 Spring Data 模块一起使用</h4>
<div class="paragraph">
<p>在您的应用程序中使用唯一的 Spring Data 模块很简单,因为已定义范围中的所有存储库接口均已绑定到该 Spring Data 模块.  有时,应用程序需要使用多个 Spring Data 模块.  在这种情况下,存储库的定义必须区分要使用哪个.
当它在类路径上检测到多个存储库工厂时,Spring Data 进入严格的存储库配置模式.  严格的配置使用 repository  或 domain 类上的详细信息来决定有关存储库定义的 Spring Data 模块:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果存储库扩展了<a href="#repositories.multiple-modules.types">特定于指定模块的存储库</a>,则它是特定 Spring Data 模块的有效候选者.</p>
</li>
<li>
<p>如果 domain 类使用模块<a href="#repositories.multiple-modules.annotations">特定的注解类型进行注解</a>,则它是特定 Spring Data 模块的有效候选者.  Spring Data 模块可以接受第三方注解 (例如 JPA 的 <code>@Entity</code>) ,也可以提供自己的注解 (例如 Spring Data MongoDB 的 <code>@Document</code> 和 Spring Data Elasticsearch) .</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下示例显示使用特定于模块的接口 (在这种情况下为 JPA) 的存储库:</p>
</div>
<div id="repositories.multiple-modules.types" class="exampleblock">
<div class="title">Example 6. 使用模块特定接口的存储库定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface MyRepository extends JpaRepository&lt;User, Long&gt; { }

@NoRepositoryBean
interface MyBaseRepository&lt;T, ID&gt; extends JpaRepository&lt;T, ID&gt; { … }

interface UserRepository extends MyBaseRepository&lt;User, Long&gt; { … }
</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MyRepository</code> 和 <code>UserRepository</code> 继承 <code>JpaRepository</code> .  它们是 Spring Data JPA 模块的有效候选者.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的例子展示了一个使用通用接口的存储库:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. 使用通用接口的存储库定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface AmbiguousRepository extends Repository&lt;User, Long&gt; { … }

@NoRepositoryBean
interface MyBaseRepository&lt;T, ID&gt; extends CrudRepository&lt;T, ID&gt; { … }

interface AmbiguousUserRepository extends MyBaseRepository&lt;User, Long&gt; { … }
</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AmbiguousRepository</code> 和 <code>AmbiguousUserRepository</code> 仅在其类型层次结构中扩展 <code>Repository</code> 和 <code>CrudRepository</code>.  尽管在使用唯一的 Spring Data 模块时没有什么问题,但是多个模块无法区分这些存储库应绑定到哪个特定的 Spring Data.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了使用带注解的 domain  类的存储库:</p>
</div>
<div id="repositories.multiple-modules.annotations" class="exampleblock">
<div class="title">Example 8. 使用带有注解的 domain 类的存储库定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, Long&gt; { … }

@Entity
class Person { … }

interface UserRepository extends Repository&lt;User, Long&gt; { … }

@Document
class User { … }
</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>PersonRepository</code> 引用使用JPA <code>@Entity</code> 注解进行注解的 <code>Person</code>,因此该存储库显然属于 Spring Data JPA.  <code>UserRepository</code> 引用 <code>User</code>,该 User 使用 Spring Data MongoDB 的 <code>@Document</code> 注解进行注解.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>以下错误的示例显示了使用带有混和注解的 domain 类的存储库:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. 使用带有混合注解的 domain 类的存储库定义</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface JpaPersonRepository extends Repository&lt;Person, Long&gt; { … }

interface MongoDBPersonRepository extends Repository&lt;Person, Long&gt; { … }

@Entity
@Document
class Person { … }
</code></pre>
</div>
</div>
<div class="paragraph">
<p>此示例显示了同时使用 JPA 和 Spring Data MongoDB 注解的 domain 类.  它定义了两个存储库,<code>JpaPersonRepository</code> 和 <code>MongoDBPersonRepository</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#repositories.multiple-modules.types">存储库类型详细信息</a> 和<a href="#repositories.multiple-modules.annotations">可区分的 domain 类注解</a> 用于配置严格的存储库,以标识特定 Spring Data 模块的存储库候选者.
在同一个 domain 类型上使用多个特定于持久性技术的注解是可能的,并且可以跨多种持久性技术重用 domain 类型.  但是,Spring Data 无法再确定用于绑定存储库的唯一模块.</p>
</div>
<div class="paragraph">
<p>区分存储库的最后一种方法是确定存储库 <code>basePackages</code> 的范围.  <code>basePackages</code> 包定义了扫描存储库接口定义的起点,这意味着将存储库定义放在适当的软件包中.  默认情况下,注解驱动的配置使用配置类的包.
 <a href="#repositories.create-instances.spring">基于 XML 的配置中</a>中的 <code>basePackages</code> 是必需的.</p>
</div>
<div class="paragraph">
<p>以下示例显示了基础包的注解驱动配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. <code>basePackages</code> 的注解驱动配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableJpaRepositories(basePackages = "com.acme.repositories.jpa")
@EnableMongoRepositories(basePackages = "com.acme.repositories.mongo")
class Configuration { … }
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.query-methods.details"><a class="anchor" href="#repositories.query-methods.details"></a>4.4. 定义查询方法</h3>
<div class="paragraph">
<p>存储库代理有两种从方法名称扩展特定查询的方式:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过直接从方法名称扩展查询.</p>
</li>
<li>
<p>通过使用手动定义的查询</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可用选项取决于实际存储. 但是,必须有一种策略可以决定要创建的实际查询. 下一节将介绍可用的选项.</p>
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-lookup-strategies"><a class="anchor" href="#repositories.query-methods.query-lookup-strategies"></a>4.4.1. 查询策略</h4>
<div class="paragraph">
<p>以下策略可用于存储库基础结构来解决查询. 使用 XML 配置,您可以通过 <code>query-lookup-strategy</code> 属性在命名空间中配置策略. 对于 Java 配置,可以使用 <code>Enable${store}Repositories</code> 注解的 <code>queryLookupStrategy</code> 属性. 某些数据存储可能不支持某些策略.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CREATE</code> 尝试从查询方法名称构造特定于存储的查询. 通用方法是从方法名称中删除一组给定的前缀,然后解析该方法的其余部分. 您可以在 &#8220;<a href="#repositories.query-methods.query-creation">查询创建</a>&#8221; 中阅读有关查询构造的更多信息.</p>
</li>
<li>
<p><code>USE_DECLARED_QUERY</code> 尝试查找已声明的查询,如果找不到则抛出异常. 该查询可以通过某处的注解定义,也可以通过其他方式声明. 请查阅特定存储的文档以找到该存储方式的可用选项. 如果在查询时找不到该方法的声明查询,则它将失败.</p>
</li>
<li>
<p><code>CREATE_IF_NOT_FOUND</code> (默认) 结合 <code>CREATE</code> 和 <code>USE_DECLARED_QUERY</code>. 它首先查找一个声明的查询,如果找不到声明的查询,它将创建一个基于名称的自定义方法查询. 这是默认的查找策略,因此,如果未显式配置任何内容,则使用该策略. 它允许通过方法名称快速定义查询,也可以通过根据需要引入已声明的查询来自定义调整这些查询.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-creation"><a class="anchor" href="#repositories.query-methods.query-creation"></a>4.4.2. 查询创建</h4>
<div class="paragraph">
<p>Spring Data 内置的查询机制对于在存储库实体上构建查询约束很有用. 该机制的前缀  <code>find…By</code>, <code>read…By</code>, <code>query…By</code>, <code>count…By</code>, 和 <code>get…By</code> 从所述方法和开始解析它的其余部分. <code>Introduction</code> 子句可以包含其他表达式,
例如,<code>Distinct</code> 以在要创建的查询上设置不同的标志. 但是,第一个 <code>By</code> 充当分隔符以指示实际查询的开始. 在此级别上,您可以定义实体属性的条件,并将其与 <code>And</code> 和 <code>Or</code> 串联 . 下面的示例演示如何创建许多查询:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. 从方法名查询创建</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, Long&gt; {

  List&lt;Person&gt; findByEmailAddressAndLastname(EmailAddress emailAddress, String lastname);

  // Enables the distinct flag for the query
  List&lt;Person&gt; findDistinctPeopleByLastnameOrFirstname(String lastname, String firstname);
  List&lt;Person&gt; findPeopleDistinctByLastnameOrFirstname(String lastname, String firstname);

  // Enabling ignoring case for an individual property
  List&lt;Person&gt; findByLastnameIgnoreCase(String lastname);
  // Enabling ignoring case for all suitable properties
  List&lt;Person&gt; findByLastnameAndFirstnameAllIgnoreCase(String lastname, String firstname);

  // Enabling static ORDER BY for a query
  List&lt;Person&gt; findByLastnameOrderByFirstnameAsc(String lastname);
  List&lt;Person&gt; findByLastnameOrderByFirstnameDesc(String lastname);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>解析查询方法的名称分为主题和断言.第一部分  (<code>find…By</code>, <code>exists…By</code>)  定义查询的主题,第二部分形成断言.
Introduction子句 (主题) 可以包含其他表达式. 任何在 <code>find</code> (或其他 introducing 关键字) 和 <code>By</code> 之间的任何文本都被视为描述性语句,除非使用结果限制关键字之一 (例如,<code>Distinct</code> ) 在要创建的查询上设置 distinct 的标记,或者 <a href="#repositories.limit-query-result"><code>Top</code>/<code>First</code>  以限制查询结果</a>.</p>
</div>
<div class="paragraph">
<p>附录包含 <a href="#appendix.query.method.subject">查询方法主题关键字的完整列表</a> 和 <a href="#appendix.query.method.predicate">包括排序和字母大小写修饰符的查询方法断言关键字</a>.
但是,第一个 <code>By</code> 充当分隔符,以指示实际标准断言的开始. 在此基础上,您可以定义实体属性的条件,并将其与 <code>And</code> 和 <code>Or</code> 连接起来.</p>
</div>
<div class="paragraph">
<p>解析该方法的实际结果取决于您为其创建查询的持久性存储. 但是,需要注意一些一般事项:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>表达式通常是属性遍历,并带有可串联的运算符.  您可以将属性表达式与 <code>AND</code> 和 <code>OR</code> 结合使用.  您还将获得属性表达式的支持,例如 <code>between</code>,<code>LessThan</code>,<code>GreaterThan</code> 和 <code>Like</code>.  支持的运算符可能因数据存储而异,因此请参考参考文档的相应部分.</p>
</li>
<li>
<p>方法解析器支持为单个属性 (例如,<code>findByLastnameIgnoreCase(…)</code>) 或支持忽略大小写的类型的所有属性 (通常为 <code>String</code> 实例,例如, <code>findByLastnameAndFirstnameAllIgnoreCase(…)</code>) 设置 <code>IgnoreCase</code> 标志.  是否支持忽略大小写可能因存储而异,因此请参考参考文档中有关存储特定查询方法的相关部分.</p>
</li>
<li>
<p>您可以通过将 <code>OrderBy</code> 子句附加到引用属性的查询方法并提供排序方向 (<code>Asc</code> 或 <code>Desc</code>) 来应用静态排序.  要创建支持动态排序的查询方法,请参见 &#8220;<a href="#repositories.special-parameters">特殊参数处理</a>&#8221;.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-methods.query-property-expressions"><a class="anchor" href="#repositories.query-methods.query-property-expressions"></a>4.4.3. 属性表达式</h4>
<div class="paragraph">
<p>如上例所示,属性表达式只能引用实体的直接属性.  在查询创建时,您需要确保已解析的属性是被管理 domain 类的属性.  但是,您也可以通过遍历嵌套属性来定义约束.  考虑以下方法签名:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;Person&gt; findByAddressZipCode(ZipCode zipCode);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>假设一个 <code>Person</code> (人) 的 <code>Address</code> (地址) 带有 <code>ZipCode</code> (邮政编码).  在这种情况下,该方法将创建遍历属性 <code>x.address.zipCode</code>.  解析算法首先将整个部分 (<code>AddressZipCode</code>) 解释为属性,然后在 domain 类中检查具有该名称的属性 (未大写) .
如果算法成功,它将使用该属性.  如果不是,该算法将按驼峰解析为头和尾,并尝试找到对应的属性,在我们的示例中为 <code>AddressZip</code> 和 <code>Code</code>.  如果该算法找到了具有该头部的属性,则它将采用该头部,并继续从那里开始构建,以刚才描述的方式将尾部向上拆分.  如果第一个拆分不匹配,则算法会将拆分点移到左侧 (<code>Address</code>, <code>ZipCode</code>) 并继续.</p>
</div>
<div class="paragraph">
<p>尽管这在大多数情况下应该可行,但是算法可能会选择错误的属性.  假设 <code>Person</code> 类也具有 <code>addressZip</code> 属性.  该算法将在第一轮拆分中匹配,选择错误的属性,然后失败 (因为 <code>addressZip</code> 的类型可能没有 <code>code</code> 属性) .</p>
</div>
<div class="paragraph">
<p>要解决这种歧义,您可以在方法名称中使用 <code>_</code> 手动定义遍历点.  因此,我们的方法名称如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">List&lt;Person&gt; findByAddress_ZipCode(ZipCode zipCode);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>因为我们将下划线字符视为保留字符,所以我们强烈建议您遵循以下标准 Java 命名约定 (即,在属性名称中不使用下划线,而使用驼峰大小写) .</p>
</div>
</div>
<div class="sect3">
<h4 id="repositories.special-parameters"><a class="anchor" href="#repositories.special-parameters"></a>4.4.4. 特殊参数处理</h4>
<div class="paragraph">
<p>要处理查询中的参数,请定义方法参数,如前面的示例所示.  除此之外,基本架构还可以识别某些特定类型,例如 <code>Pageable</code> 和 <code>Sort</code>,以将分页和排序动态应用于您的查询.  以下示例演示了这些功能:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. 在查询方法中使用 <code>Pageable</code>, <code>Slice</code>, 和 <code>Sort</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Page&lt;User&gt; findByLastname(String lastname, Pageable pageable);

Slice&lt;User&gt; findByLastname(String lastname, Pageable pageable);

List&lt;User&gt; findByLastname(String lastname, Sort sort);

List&lt;User&gt; findByLastname(String lastname, Pageable pageable);
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
采用 <code>Sort</code> 和 <code>Pageable</code> 的 API 期望将非 <code>null</code> 值传递到方法中.  如果您不想应用任何排序或分页,请使用 <code>Sort.unsorted()</code> 和 <code>Pageable.unpaged()</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>第一种方法使您可以将 <code>org.springframework.data.domain.Pageable</code> 实例传递给查询方法,以将分页动态添加到静态定义的查询中.  页面知道可用元素和页面的总数.  它是通过基础结构触发计数查询来计算总数来实现的.
由于这可能很耗时 (取决于所使用的存储) ,因此您可以返回一个 <code>Slice</code>.  切片仅知道下一个切片是否可用,当遍历较大的结果集时这可能就足够了.</p>
</div>
<div class="paragraph">
<p>排序选项也通过 <code>Pageable</code> 实例处理.  如果只需要排序,则将 <code>org.springframework.data.domain.Sort</code> 参数添加到您的方法中.  如您所见,返回列表也是可能的.  在这种情况下,将不会创建构建实际的 <code>Page</code> 实例所需的其他元数据 (这反过来意味着不会发出本来必要的其他计数查询) .  而是,它将查询限制为仅查找给定范围的实体.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
要找出整个查询可获得多少页,您必须触发其他计数查询.  默认情况下,此查询扩展自您实际触发的查询.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="repositories.paging-and-sorting"><a class="anchor" href="#repositories.paging-and-sorting"></a>Paging 和 Sorting</h5>
<div class="paragraph">
<p>可以使用属性名称定义简单的排序表达式.  可以将表达式连接起来,以将多个条件收集到一个表达式中.</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. 定义排序表达式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Sort sort = Sort.by("firstname").ascending()
  .and(Sort.by("lastname").descending());
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于排序表达式的类型安全性更高的方法,请从该类型开始为定义排序表达式,然后使用方法引用来定义要进行排序的属性.</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. 使用类型安全的 API 定义排序表达式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">TypedSort&lt;Person&gt; person = Sort.sort(Person.class);

TypedSort&lt;Person&gt; sort = person.by(Person::getFirstname).ascending()
  .and(person.by(Person::getLastname).descending());
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>TypedSort.by(…)</code> 通过 (通常) 使用 CGlib 来使用运行时代理,这在使用 Graal VM Native 等工具时可能会影响本地镜像的编译.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您的存储实现支持 Querydsl,则还可以使用生成的元模型类型来定义排序表达式:</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. 使用 Querydsl API 定义排序表达式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">QSort sort = QSort.by(QPerson.firstname.asc())
  .and(QSort.by(QPerson.lastname.desc()));
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.limit-query-result"><a class="anchor" href="#repositories.limit-query-result"></a>4.4.5. 限制查询结果</h4>
<div class="paragraph">
<p>可以通过使用 <code>first</code> 或 <code>top</code> 关键字来限制查询方法的结果,这些关键字可以互换使用.  可以在 <code>top</code> 或 <code>first</code>  附加可选的数值,以指定要返回的最大结果大小.  如果省略数字,则假定结果大小为 <code>1</code>.  以下示例显示了如何限制查询大小:</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. 使用 <code>first</code> 和 <code>top</code> 限制查询的结果大小</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">User findFirstByOrderByLastnameAsc();

User findTopByOrderByAgeDesc();

Page&lt;User&gt; queryFirst10ByLastname(String lastname, Pageable pageable);

Slice&lt;User&gt; findTop3ByLastname(String lastname, Pageable pageable);

List&lt;User&gt; findFirst10ByLastname(String lastname, Sort sort);

List&lt;User&gt; findTop10ByLastname(String lastname, Pageable pageable);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>限制表达式还支持 <code>Distinct</code> 关键字.  另外,对于将结果集限制为一个实例的查询,支持使用 <code>Optional</code> 关键字将结果包装到其中.</p>
</div>
<div class="paragraph">
<p>如果将分页或切片应用于限制查询分页 (以及对可用页面数的计算) ,则会在限制结果内应用分页或切片.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通过使用 <code>Sort</code> 参数将结果限制与动态排序结合使用,可以让您表达对最小的 "K" 元素和对 "K" 的最大元素的查询方法.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.collections-and-iterables"><a class="anchor" href="#repositories.collections-and-iterables"></a>4.4.6. 存储库方法返回集合或可迭代对象</h4>
<div class="paragraph">
<p>返回多个结果的查询方法可以使用标准的 Java <code>Iterable</code>,<code>List</code>,<code>Set</code>.  除此之外,我们还支持返回 Spring Data 的 <code>Streamable</code>,<code>Iterable</code> 的自定义扩展以及  <a href="https://www.vavr.io/">Vavr</a> 提供的集合类型.请参阅附录,了解所有可能的 <a href="#appendix.query.return.types">查询方法返回类型</a>.</p>
</div>
<div class="sect4">
<h5 id="repositories.collections-and-iterables.streamable"><a class="anchor" href="#repositories.collections-and-iterables.streamable"></a>使用 Streamable 作为查询方法返回类型</h5>
<div class="paragraph">
<p><code>Streamable</code> 可用作 <code>Iterable</code> 或任何集合类型的替代.  它提供了方便的方法来访问非并行流 (缺少 <code>Iterable</code>) ,可以直接在元素上进行  <code>….filter(…)</code> 和  <code>….map(…)</code> 并将 <code>Streamable</code> 连接到其他元素:</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. 使用 Streamable 合并查询方法结果</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, Long&gt; {
  Streamable&lt;Person&gt; findByFirstnameContaining(String firstname);
  Streamable&lt;Person&gt; findByLastnameContaining(String lastname);
}

Streamable&lt;Person&gt; result = repository.findByFirstnameContaining("av")
  .and(repository.findByLastnameContaining("ea"));
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="repositories.collections-and-iterables.streamable-wrapper"><a class="anchor" href="#repositories.collections-and-iterables.streamable-wrapper"></a>返回自定义 Streamable 包装器类型</h5>
<div class="paragraph">
<p>为集合提供专用的包装器类型是一种常用的模式,用于在返回多个元素的查询执行结果上提供 API.  通常,这些类型是通过调用存储库方法来返回类似集合的类型并手动创建包装类型的实例来使用的.  如果 Spring Data 满足以下条件,则可以将这些包装器类型用作查询方法返回类型,因此可以避免执行附加步骤:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>该类型实现 <code>Streamable</code>.</p>
</li>
<li>
<p>该类型以  <code>Streamable</code> 作为参数暴露构造函数或名为 <code>of(…)</code> 或 <code>valueOf(…)</code> 的静态工厂方法.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>示例用例如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Product {                                         <i class="conum" data-value="1"></i><b>(1)</b>
  MonetaryAmount getPrice() { … }
}

@RequiredArgConstructor(staticName = "of")
class Products implements Streamable&lt;Product&gt; {         <i class="conum" data-value="2"></i><b>(2)</b>

  private Streamable&lt;Product&gt; streamable;

  public MonetaryAmount getTotal() {                    <i class="conum" data-value="3"></i><b>(3)</b>
    return streamable.stream()
      .map(Priced::getPrice)
      .reduce(Money.of(0), MonetaryAmount::add);
  }


  @Override
  public Iterator&lt;Product&gt; iterator() {                 <i class="conum" data-value="4"></i><b>(4)</b>
    return streamable.iterator();
  }
}

interface ProductRepository implements Repository&lt;Product, Long&gt; {
  Products findAllByDescriptionContaining(String text); <i class="conum" data-value="5"></i><b>(5)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>暴露 API 以访问产品价格的 <code>Product</code> 实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>可以通过 <code>Products.of(…)</code>  (通过 Lombok 注解创建的工厂方法) 构造的 <code>Streamable&lt;Product&gt;</code>  的包装器类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>包装器类型在 <code>Streamable&lt;Product&gt;</code> 上暴露其他用于计算新值的 API.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>实现 <code>Streamable</code> 接口并且委托给实际结果.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>该包装器类型 <code>Products</code> 可以直接用作查询方法返回类型.  无需返回  <code>Stremable&lt;Product&gt;</code>  并在查询之后将其手动包装在存储库客户端中.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="repositories.collections-and-iterables.vavr"><a class="anchor" href="#repositories.collections-and-iterables.vavr"></a>支持 Vavr 集合</h5>
<div class="paragraph">
<p><a href="https://www.vavr.io/">Vavr</a> 是一个包含 Java 中函数式编程概念的库. 它附带一组可作为查询方法返回类型使用的自定义集合类型.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Vavr 集合类型</th>
<th class="tableblock halign-left valign-top">使用 Vavr 实现类型</th>
<th class="tableblock halign-left valign-top">验证 Java source 类型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.Seq</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.List</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Iterable</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.Set</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.LinkedHashSet</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Iterable</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.Map</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>io.vavr.collection.LinkedHashMap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>java.util.Map</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>第一列中的类型 (或其子类型) 可以用作查询方法返回类型,并将根据实际查询结果的 Java 类型 (第三列) 获取第二列中的类型作为实现类型.  或者,可以声明 <code>Traversable</code> (等效于 Vavr <code>Iterable</code>) ,然后从实际返回值扩展实现类,即 <code>java.util.List</code> 将变成 Vavr  <code>List</code>/<code>Seq</code>,而 <code>java.util.Set</code> 变为Vavr <code>LinkedHashSet</code>/<code>Set</code> 等</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.nullability"><a class="anchor" href="#repositories.nullability"></a>4.4.7. 存储库方法的空处理</h4>
<div class="paragraph">
<p>从 Spring Data 2.0 开始,返回单个聚合实例的存储库 CRUD 方法使用 Java 8 的 <code>Optional</code> 来指示可能缺少值.  除此之外,Spring Data 支持在查询方法上返回以下包装器类型:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.google.common.base.Optional</code></p>
</li>
<li>
<p><code>scala.Option</code></p>
</li>
<li>
<p><code>io.vavr.control.Option</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>另外,查询方法可以选择不使用包装器类型.  然后,通过返回 <code>null</code> 指示查询结果不存在.  保证返回集合,集合替代项,包装器和流的存储库方法永远不会返回 <code>null</code>,而是会返回相应的空表示形式.
有关详细信息,请参见 &#8220;<a href="#repository-query-return-types">存储库查询返回类型</a>&#8221; .</p>
</div>
<div class="sect4">
<h5 id="repositories.nullability.annotations"><a class="anchor" href="#repositories.nullability.annotations"></a>可空性注解</h5>
<div class="paragraph">
<p>您可以使用 <a href="https://docs.jcohy.com/docs/spring-framework/5.3.6/html5/zh-cn/core.html#null-safety">Spring Framework 的可空性注解</a> 来表达存储库方法的可空性约束.  它们提供了一种工具友好的方法,并在运行时提供了选择加入的 <code>null</code> 检查,如下所示:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.3.6/javadoc-api/org/springframework/lang/NonNullApi.html"><code>@NonNullApi</code></a>: 在包级别用于声明参数和返回值的默认行为是不为空值.</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.3.6/javadoc-api/org/springframework/lang/NonNull.html"><code>@NonNull</code></a>:用于不为空的参数或返回值 (<code>@NonNullApi</code> 适用的参数和返回值不需要) .</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/5.3.6/javadoc-api/org/springframework/lang/Nullable.html"><code>@Nullable</code></a>: 用于可以为空的参数或返回值.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring 注解使用 <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a> 注解进行元注解.  JSR 305 元注解使工具供应商 (如  <a href="https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html">IDEA</a>,
<a href="https://help.eclipse.org/oxygen/index.jsp?topic=/org.eclipse.jdt.doc.user/tasks/task-using_external_null_annotations.htm">Eclipse</a> 和 <a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">Kotlin</a> ) 以通用方式提供了空安全支持,而不必对 Spring 注解进行硬编码支持.
要对查询方法的可空性约束进行运行时检查,您需要使用 <code>package-info.java</code> 中的 Spring 的 <code>@NonNullApi</code> 在包级别激活非可空性,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. 在 <code>package-info.java</code> 中声明不可为空</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@org.springframework.lang.NonNullApi
package com.acme;
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦设置了非 <code>null</code> 默认值,就可以在运行时验证存储库查询方法的调用是否具有可空性约束.  如果查询执行结果违反了定义的约束,则会引发异常.  当方法将返回 <code>null</code> 但被声明为不可为 <code>null</code> 时 (在存储库所在的包中定义了注解的默认值) ,就会发生这种情况.  如果要再次选择接受可为空的结果,请在各个方法上有选择地使用 <code>@Nullable</code>.
使用本节开头提到的结果包装器类型可以按预期继续工作: 将空结果转换为表示缺少的值.</p>
</div>
<div class="paragraph">
<p>下面的示例显示了刚才描述的许多技术:</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. 使用不同的可空性约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block">package com.acme;                                                       <i class="conum" data-value="1"></i><b>(1)</b>

</span><span class="fold-block hide-when-folded">import org.springframework.lang.Nullable;

</span><span class="fold-block">interface UserRepository extends Repository&lt;User, Long&gt; {

  User getByEmailAddress(EmailAddress emailAddress);                    <i class="conum" data-value="2"></i><b>(2)</b>

  @Nullable
  User findByEmailAddress(@Nullable EmailAddress emailAdress);          <i class="conum" data-value="3"></i><b>(3)</b>

  Optional&lt;User&gt; findOptionalByEmailAddress(EmailAddress emailAddress); <i class="conum" data-value="4"></i><b>(4)</b>
}
</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>存储库位于我们上面定义的非空的包 (或子包) 中.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>当执行的查询未产生结果时,抛出 <code>EmptyResultDataAccessException</code>.  当传递给该方法的 <code>emailAddress</code> 为 <code>null</code> 时,抛出 <code>IllegalArgumentException</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>当执行的查询不产生结果时,返回 <code>null</code>.  还接受 <code>null</code> 作为 <code>emailAddress</code> 的值.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>当执行的查询不产生结果时,返回 <code>Optional.empty()</code>.  当传递给该方法的 <code>emailAddress</code> 为 <code>null</code> 时,抛出 <code>IllegalArgumentException</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="repositories.nullability.kotlin"><a class="anchor" href="#repositories.nullability.kotlin"></a>基于 Kotlin 的存储库中的可空性</h5>
<div class="paragraph">
<p>Kotlin 定义了语言中包含的 <a href="https://kotlinlang.org/docs/reference/null-safety.html">可空性约束</a> .  Kotlin 代码编译为字节码,字节码不通过方法签名来表达可空性约束,而是通过内置的元数据来表达.  请确保在您的项目中包含 <code>kotlin-reflect</code> 的JAR,以对 Kotlin 的可空性约束进行自省.  Spring Data 存储库使用语言机制来定义这些约束以应用相同的运行时检查,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. 在 Kotlin repository 上使用可空性约束</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">interface UserRepository : Repository&lt;User, String&gt; {

  fun findByUsername(username: String): User     <i class="conum" data-value="1"></i><b>(1)</b>

  fun findByFirstname(firstname: String?): User? <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>该方法将参数和结果都定义为不可为空 (Kotlin 默认值) .  Kotlin 编译器拒绝将 <code>null</code> 传递给方法的方法调用.  如果查询执行产生空结果,则抛出 <code>EmptyResultDataAccessException</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>此方法的 <code>firstname</code> 参数接受 <code>null</code>,如果查询执行未产生结果,则返回 <code>null</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-streaming"><a class="anchor" href="#repositories.query-streaming"></a>4.4.8. 流查询结果</h4>
<div class="paragraph">
<p>可以使用 Java 8 <code>Stream&lt;T&gt;</code> 作为返回类型来递增地处理查询方法的结果.  并非将查询结果包装在 <code>Stream</code> 中,而是使用特定于数据存储的方法来执行流传输,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. 用 Java 8  <code>Stream&lt;T&gt;</code> 流查询的结果</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Query("select u from User u")
Stream&lt;User&gt; findAllByCustomQueryAndStream();

Stream&lt;User&gt; readAllByFirstnameNotNull();

@Query("select u from User u")
Stream&lt;User&gt; streamAllPaged(Pageable pageable);
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Stream</code> 可能包装了特定于底层数据存储的资源,因此必须在使用后关闭.  您可以使用 <code>close()</code> 方法或使用 Java 7 <code>try-with-resources</code> 块来手动关闭 <code>Stream</code>,如以下示例所示:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 22. <code>Stream&lt;T&gt;</code> 的结果使用 try-with-resources 块</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try (Stream&lt;User&gt; stream = repository.findAllByCustomQueryAndStream()) {
  stream.forEach(…);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当前,并非所有的 Spring Data 模块都支持 <code>Stream&lt;T&gt;</code> 作为返回类型.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.query-async"><a class="anchor" href="#repositories.query-async"></a>4.4.9. 异步查询结果</h4>
<div class="paragraph">
<p>使用  <a href="https://docs.jcohy.com/docs/spring-framework/5.3.6/html5/zh-cn/integration.html#scheduling">Spring 的异步方法执行功能</a>,可以异步运行存储库查询.  这意味着该方法在调用时立即返回,而实际查询执行发生在已提交给 Spring <code>TaskExecutor</code> 的任务中.  异步查询执行与响应式查询执行不同,因此不应混为一谈.  有关响应式支持的更多详细信息,请参阅存储特定的文档.  以下示例显示了许多异步查询:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Async
Future&lt;User&gt; findByFirstname(String firstname);               <i class="conum" data-value="1"></i><b>(1)</b>

@Async
CompletableFuture&lt;User&gt; findOneByFirstname(String firstname); <i class="conum" data-value="2"></i><b>(2)</b>

@Async
ListenableFuture&lt;User&gt; findOneByLastname(String lastname);    <i class="conum" data-value="3"></i><b>(3)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>java.util.concurrent.Future</code> 作为返回类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 Java 8 <code>java.util.concurrent.CompletableFuture</code> 作为返回类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用 <code>org.springframework.util.concurrent.ListenableFuture</code> 作为返回类型.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.create-instances"><a class="anchor" href="#repositories.create-instances"></a>4.5. 创建存储库实例</h3>
<div class="paragraph">
<p>在本部分中,将为已定义的存储库接口创建实例和 Bean 定义.  一种方法是使用支持存储库机制的每个 Spring Data 模块随附的 Spring 命名空间,尽管我们通常建议使用 Java 配置.</p>
</div>
<div class="sect3">
<h4 id="repositories.create-instances.spring"><a class="anchor" href="#repositories.create-instances.spring"></a>4.5.1. XML 配置</h4>
<div class="paragraph">
<p>每个 Spring Data 模块都包含一个 <code>repositories</code> 元素,可用于定义 Spring 为其扫描的基本包,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. 通过 XML 启用 Spring Data repository</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans:beans xmlns:beans="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns="http://www.springframework.org/schema/data/jpa"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/jpa
    https://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;

  &lt;repositories base-package="com.acme.repositories" /&gt;

&lt;/beans:beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中,指示 Spring 扫描 <code>com.acme.repositories</code> 及其所有子包,以查找扩展 <code>Repository</code> 的接口或其子接口之一.  对于找到的每个接口,基础结构都会注册持久性技术特定的 <code>FactoryBean</code>,以创建处理查询方法调用的适当代理.
每个 bean 都使用从接口名称扩展的 bean 名称进行注册,因此 <code>UserRepository</code> 的接口将注册在 <code>userRepository</code> 下.  <code>base-package</code> 属性允许使用通配符,以便您可以定义扫描程序包的模式.</p>
</div>
<div class="sect4">
<h5 id="repositories.using-filters"><a class="anchor" href="#repositories.using-filters"></a>使用过滤器</h5>
<div class="paragraph">
<p>默认情况下,Spring Data 会自动扫描配置路径下的 <code>Repository</code> 子接口的每个接口,并为其创建一个 bean 实例.  但是,您可能希望更精细地控制哪些接口具有为其创建的 Bean 实例.
为此,请在 <code>&lt;repositories /&gt;</code> 元素内使用 <code>&lt;include-filter /&gt;</code> 和 <code>&lt;exclude-filter /&gt;</code> 元素.  语义完全等同于 Spring 的上下文命名空间中的元素.  有关详细信息,请参见这些元素的 <a href="https://docs.jcohy.com/docs/spring-framework/5.3.6/html5/zh-cn/core.html#beans-scanning-filters">Spring 参考文档</a> .</p>
</div>
<div class="paragraph">
<p>例如,要将某些接口从实例中排除为存储库 Bean,可以使用以下配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. 使用 exclude-filter 元素</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repositories"&gt;
  &lt;context:exclude-filter type="regex" expression=".*SomeRepository" /&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例将所有以 <code>SomeRepository</code> 结尾的接口都排除在实例化之外.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.create-instances.java-config"><a class="anchor" href="#repositories.create-instances.java-config"></a>4.5.2. Java 配置</h4>
<div class="paragraph">
<p>还可以在 JavaConfig 类上使用特定于存储的 <code>@Enable${store}Repositories</code>  注解来触发存储库基础架构.  有关 Spring 容器的基于 Java 的配置的介绍,请参见 <a href="https://docs.jcohy.com/docs/spring-framework/5.3.6/html5/zh-cn/core.html#beans-java">Spring 参考文档中的 JavaConfig</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. 基于注解的存储卡示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJpaRepositories("com.acme.repositories")
class ApplicationConfiguration {

  @Bean
  EntityManagerFactory entityManagerFactory() {
    // …
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
前面的示例使用特定于 JPA 的注解,您将根据实际使用的存储模块对其进行更改.  这同样适用于 <code>EntityManagerFactory</code> bean 的定义.  请参阅涵盖存储特定配置的部分.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="repositories.create-instances.standalone"><a class="anchor" href="#repositories.create-instances.standalone"></a>4.5.3. 独立使用</h4>
<div class="paragraph">
<p>您还可以在 Spring 容器之外使用存储库基础结构,例如在 CDI 环境中.  您的类路径中仍然需要一些 Spring 库,但是,通常,您也可以通过编程方式来设置存储库.  提供存储库支持的 Spring Data 模块附带了特定于持久性技术的 <code>RepositoryFactory</code>,您可以按以下方式使用它:</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. repository 工厂的独立使用</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RepositoryFactorySupport factory = … // Instantiate factory here
UserRepository repository = factory.getRepository(UserRepository.class);
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="repositories.custom-implementations"><a class="anchor" href="#repositories.custom-implementations"></a>4.6. Spring Data 存储库的自定义实现</h3>
<div class="paragraph">
<p>本节介绍存储库定制以及片段如何形成复合存储库.</p>
</div>
<div class="paragraph">
<p>当查询方法需要不同的行为或无法通过查询扩展实现时,则有必要提供自定义实现.  Spring Data 存储库使您可以提供自定义存储库代码,并将其与通用 CRUD 抽象和查询方法功能集成.</p>
</div>
<div class="sect3">
<h4 id="repositories.single-repository-behavior"><a class="anchor" href="#repositories.single-repository-behavior"></a>4.6.1. 自定义单个存储库</h4>
<div class="paragraph">
<p>要使用自定义功能丰富存储库,必须首先定义一个接口和自定义功能的实现,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. 定制 repository 功能的接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface CustomizedUserRepository {
  void someCustomMethod(User user);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 28. 自定义存储库功能的实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class CustomizedUserRepositoryImpl implements CustomizedUserRepository {

  public void someCustomMethod(User user) {
    // Your custom implementation
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
与这个接口相对应的类名称中最重要的部分是 <code>Impl</code> 后缀.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>实现本身不依赖于 Spring Data,可以是常规的 Spring bean.  因此,您可以使用标准的依赖注入行为来注入对其他 bean (例如 <code>JdbcTemplate</code>) 的引用,参与各个方面,等等.</p>
</div>
<div class="paragraph">
<p>然后,可以让您的存储库接口扩展此接口,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. 更改您的存储库接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt;, CustomizedUserRepository {

  // Declare query methods here
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>用存储库接口扩展此接口,将 CRUD 和自定义功能结合在一起,并使它可用于客户端.</p>
</div>
<div class="paragraph">
<p>Spring Data 存储库是通过使用构成存储库组成的片段来实现的.  片段是基础存储库,功能方面 (例如 <a href="#core.extensions.querydsl">QueryDsl</a>) 以及自定义接口及其实现.  每次向存储库接口添加接口时,都通过添加片段来增强组合.  每个 Spring Data 模块都提供了基础存储库和存储库方面的实现.</p>
</div>
<div class="paragraph">
<p>以下示例显示了自定义接口及其实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 30. 片段及其实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface HumanRepository {
  void someHumanMethod(User user);
}

class HumanRepositoryImpl implements HumanRepository {

  public void someHumanMethod(User user) {
    // Your custom implementation
  }
}

interface ContactRepository {

  void someContactMethod(User user);

  User anotherContactMethod(User user);
}

class ContactRepositoryImpl implements ContactRepository {

  public void someContactMethod(User user) {
    // Your custom implementation
  }

  public User anotherContactMethod(User user) {
    // Your custom implementation
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了扩展 <code>CrudRepository</code> 的自定义存储库的接口:</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. 更改您的存储库接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt;, HumanRepository, ContactRepository {

  // Declare query methods here
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>存储库可能由多个自定义实现组成,这些自定义实现按其声明顺序导入.  自定义实现比基础实现和存储库方面的优先级更高.  通过此顺序,您可以覆盖基础存储库和方面方法,并在两个片段贡献相同方法签名的情况下解决歧义.
存储库片段不限于在单个存储库界面中使用.  多个存储库可以使用片段接口,使您可以跨不同的存储库重用自定义项.</p>
</div>
<div class="paragraph">
<p>以下示例显示了存储库片段及其实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. 覆盖 Fragments <code>save(…)</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface CustomizedSave&lt;T&gt; {
  &lt;S extends T&gt; S save(S entity);
}

class CustomizedSaveImpl&lt;T&gt; implements CustomizedSave&lt;T&gt; {

  public &lt;S extends T&gt; S save(S entity) {
    // Your custom implementation
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了使用上述存储库片段的存储库:</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. 定制的存储库接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt;, CustomizedSave&lt;User&gt; {
}

interface PersonRepository extends CrudRepository&lt;Person, Long&gt;, CustomizedSave&lt;Person&gt; {
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="repositories.configuration"><a class="anchor" href="#repositories.configuration"></a>配置</h5>
<div class="paragraph">
<p>如果使用命名空间配置,则存储库基础结构会尝试通过扫描发现存储库的包下方的类来自动检测自定义实现片段.  这些类需要遵循将命名空间元素的 <code>repository-impl-postfix</code> 属性附加到片段接口名称的命名约定.  此后缀默认为 <code>Impl</code>.  以下示例显示了使用默认后缀的存储库和为后缀设置自定义值的存储库:</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. 配置示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repository" /&gt;

&lt;repositories base-package="com.acme.repository" repository-impl-postfix="MyPostfix" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上一示例中的第一个配置尝试查找一个名为 <code>com.acme.repository.CustomizedUserRepositoryImpl</code> 的类,以用作自定义存储库实现.  第二个示例尝试查找 <code>com.acme.repository.CustomizedUserRepositoryMyPostfix</code>.</p>
</div>
<div class="sect5">
<h6 id="repositories.single-repository-behaviour.ambiguity"><a class="anchor" href="#repositories.single-repository-behaviour.ambiguity"></a>解决歧义</h6>
<div class="paragraph">
<p>如果在不同的包中找到具有匹配类名的多个实现,Spring Data 将使用 Bean 名称来标识要使用的那个.</p>
</div>
<div class="paragraph">
<p>给定前面显示的 <code>CustomizedUserRepository</code> 的以下两个自定义实现,将使用第一个实现.  它的 bean 名称是 <code>customizedUserRepositoryImpl</code>,它与片段接口 (<code>CustomizedUserRepository</code>) 加上后缀 <code>Impl</code> 的名称匹配.</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. 解决歧义的实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.acme.impl.one;

class CustomizedUserRepositoryImpl implements CustomizedUserRepository {

  // Your custom implementation
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package com.acme.impl.two;

@Component("specialCustomImpl")
class CustomizedUserRepositoryImpl implements CustomizedUserRepository {

  // Your custom implementation
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用 <code>@Component("specialCustom")</code> 注解 <code>UserRepository</code> 接口,则 Bean 名称加 <code>Impl</code> 会与 <code>com.acme.impl.two</code> 中为存储库实现匹配定义一个,并使用它代替第一个.</p>
</div>
</div>
<div class="sect5">
<h6 id="repositories.manual-wiring"><a class="anchor" href="#repositories.manual-wiring"></a>手动织入</h6>
<div class="paragraph">
<p>如果您的自定义实现仅使用基于注解的配置和自动装配,则 <a href="#repositories.single-repository-behaviour.ambiguity">上述</a>显示的方法会很好地起作用,因为它被视为其他任何 Spring Bean.
如果实现片段 bean 需要特殊的拼接,则可以声明 bean 并根据上一节中描述的约定对其进行命名.  然后,基础结构通过名称引用手动定义的 bean 定义,而不是自己创建一个.  以下示例显示如何手动连接自定义实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. 手动织入自定义实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repository" /&gt;

&lt;beans:bean id="userRepositoryImpl" class="…"&gt;
  &lt;!-- further configuration --&gt;
&lt;/beans:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="repositories.customize-base-repository"><a class="anchor" href="#repositories.customize-base-repository"></a>4.6.2. 自定义基础存储库</h4>
<div class="paragraph">
<p>当您要自定义基本存储库行为时,<a href="#repositories.manual-wiring">上一节</a>  中描述的方法需要自定义每个存储库接口,以使所有存储库均受到影响.  要改为更改所有存储库的行为,您可以创建一个实现,以扩展特定于持久性技术的存储库基类.
然后,该类充当存储库代理的自定义基类,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. 定制存储库基类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class MyRepositoryImpl&lt;T, ID&gt;
  extends SimpleJpaRepository&lt;T, ID&gt; {

  private final EntityManager entityManager;

  MyRepositoryImpl(JpaEntityInformation entityInformation,
                          EntityManager entityManager) {
    super(entityInformation, entityManager);

    // Keep the EntityManager around to used from the newly introduced methods.
    this.entityManager = entityManager;
  }

  @Transactional
  public &lt;S extends T&gt; S save(S entity) {
    // implementation goes here
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
该类需要具有特定于存储库的存储库工厂实现使用的父类的构造函数.  如果存储库父类具有多个构造函数,则覆盖一个采用 <code>EntityInformation</code> 加上存储特定基础结构对象 (例如 <code>EntityManager</code> 或模板类) 的构造函数.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后一步是使 Spring Data 基础结构了解定制的存储库基类.  在 Java 配置中,可以通过使用 <code>@Enable${store}Repositories</code> 注解的 <code>repositoryBaseClass</code> 属性来实现,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 38. 使用 JavaConfig 配置自定义存储库基类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableJpaRepositories(repositoryBaseClass = MyRepositoryImpl.class)
class ApplicationConfiguration { … }
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>XML 命名空间中有相应的属性,如下例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 39. 使用 XML 配置自定义存储库基类</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories base-package="com.acme.repository"
     base-class="….MyRepositoryImpl" /&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="core.domain-events"><a class="anchor" href="#core.domain-events"></a>4.7. 从聚合根发布事件</h3>
<div class="paragraph">
<p>由存储库管理的实体是聚合根.  在领域驱动设计应用程序中,这些聚合根通常发布领域事件.  Spring Data 提供了一个称为 <code>@DomainEvents</code> 的注解,您可以在聚合根的方法上使用该注解,可以使发布事件变得简单,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. 从聚合根暴露领域事件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class AnAggregateRoot {

    @DomainEvents <i class="conum" data-value="1"></i><b>(1)</b>
    Collection&lt;Object&gt; domainEvents() {
        // … return events you want to get published here
    }

    @AfterDomainEventPublication <i class="conum" data-value="2"></i><b>(2)</b>
    void callbackMethod() {
       // … potentially clean up domain events list
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>@DomainEvents</code> 的方法可以返回单个事件实例或事件的集合.  它不能接受任何参数.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在发布所有事件之后,我们有一个用 <code>@AfterDomainEventPublication</code> 注解的方法.  它可以用来潜在地清除要发布的事件列表 (以及其他用途) .</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>每次调用 Spring Data Repository <code>save(&#8230;&#8203;)</code>, <code>saveAll(…)</code>, <code>delete(…)</code> or <code>deleteAll(…)</code>  方法之一时,将调用这些方法.</p>
</div>
</div>
<div class="sect2">
<h3 id="core.extensions"><a class="anchor" href="#core.extensions"></a>4.8. Spring Data 扩展</h3>
<div class="paragraph">
<p>本节记录了一组 Spring Data 扩展,这些扩展可在各种上下文中启用 Spring Data 使用.  当前,大多数集成都针对 Spring MVC.</p>
</div>
<div class="sect3">
<h4 id="core.extensions.querydsl"><a class="anchor" href="#core.extensions.querydsl"></a>4.8.1. Querydsl 扩展</h4>
<div class="paragraph">
<p><a href="http://www.querydsl.com/">Querydsl</a> 是一个框架,可通过其流式的 API 来构造静态类型的类似 SQL 的查询.</p>
</div>
<div class="paragraph">
<p>几个 Spring Data 模块通过 <code>QuerydslPredicateExecutor</code> 与 <code>Querydsl</code> 集成,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. QuerydslPredicateExecutor 接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface QuerydslPredicateExecutor&lt;T&gt; {

  Optional&lt;T&gt; findById(Predicate predicate);  <i class="conum" data-value="1"></i><b>(1)</b>

  Iterable&lt;T&gt; findAll(Predicate predicate);   <i class="conum" data-value="2"></i><b>(2)</b>

  long count(Predicate predicate);            <i class="conum" data-value="3"></i><b>(3)</b>

  boolean exists(Predicate predicate);        <i class="conum" data-value="4"></i><b>(4)</b>

  // … more functionality omitted.
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>查找并返回与 <code>Predicate</code> 匹配的单个实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>查找并返回与 <code>Predicate</code> 匹配的所有实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>返回与 <code>Predicate</code> 匹配的实体数.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>返回与 <code>Predicate</code> 匹配的实体是否存在.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>要使用 Querydsl 支持,请在存储库界面上扩展 <code>QuerydslPredicateExecutor</code>,如以下示例所示</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. repository 上的 Querydsl 集成</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, Long&gt;, QuerydslPredicateExecutor&lt;User&gt; {
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例使您可以使用 Querydsl  <code>Predicate</code>  实例编写类型安全查询,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Predicate predicate = user.firstname.equalsIgnoreCase("dave")
    .and(user.lastname.startsWithIgnoreCase("mathews"));

userRepository.findAll(predicate);
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core.web"><a class="anchor" href="#core.web"></a>4.8.2. Web 支持</h4>
<div class="paragraph">
<p>支持存储库编程模型的 Spring Data 模块附带了各种 Web 支持.  与 Web 相关的组件要求 Spring MVC JAR 位于类路径上.  其中一些甚至提供与 <a href="https://github.com/SpringSource/spring-hateoas">Spring HATEOAS</a> 的集成.
通常,通过在 JavaConfig 配置类中使用 <code>@EnableSpringDataWebSupport</code> 注解来启用集成支持,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. 启用 Spring Data web 支持</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
@EnableSpringDataWebSupport
class WebConfiguration {}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@EnableSpringDataWebSupport</code> 注解注册了一些我们稍后将讨论的组件.  它还将在类路径上检测 Spring HATEOAS,并为其注册集成组件 (如果存在) .</p>
</div>
<div class="paragraph">
<p>另外,如果您使用 XML 配置,则将 <code>SpringDataWebConfiguration</code> 或 <code>HateoasAwareSpringDataWebConfiguration</code> 注册为 Spring Bean,如以下示例所示 (对于 <code>SpringDataWebConfiguration</code>) :</p>
</div>
<div class="exampleblock">
<div class="title">Example 44. 在 XML中启用 Spring Data web 支持</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.data.web.config.SpringDataWebConfiguration" /&gt;

&lt;!-- If you use Spring HATEOAS, register this one *instead* of the former --&gt;
&lt;bean class="org.springframework.data.web.config.HateoasAwareSpringDataWebConfiguration" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="core.web.basic"><a class="anchor" href="#core.web.basic"></a>Basic Web 支持</h5>
<div class="paragraph">
<p><a href="#core.web">上一节</a> 中显示的配置注册了一些基本组件:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#core.web.basic.domain-class-converter">DomainClassConverter</a> 可让 Spring MVC 从请求参数或路径变量解析存储库管理的 domain 类的实例.</p>
</li>
<li>
<p><a href="#core.web.basic.paging-and-sorting"><code>HandlerMethodArgumentResolver</code></a> 实现,可让 Spring MVC 从请求参数中解析 <code>Pageable</code> 和 <code>Sort</code> 实例.</p>
</li>
<li>
<p><a href="#core.web.basic.jackson-mappers">Jackson Modules</a> 序列化或反序列化类似 <code>Point</code> 和 <code>Distance</code> 的类型, 或者其他特定的类型, 主要由您使用的 Spring Data Module 决定.</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="core.web.basic.domain-class-converter"><a class="anchor" href="#core.web.basic.domain-class-converter"></a>使用 <code>DomainClassConverter</code> 类</h6>
<div class="paragraph">
<p><code>DomainClassConverter</code> 允许您直接在 Spring MVC 控制器方法签名中使用 domain 类型,因此您无需通过存储库手动查找实例,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 45. 一个在方法签名中使用 domain 类型的 Spring MVC 控制器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/users")
class UserController {

  @RequestMapping("/{id}")
  String showUserForm(@PathVariable("id") User user, Model model) {

    model.addAttribute("user", user);
    return "userForm";
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见,该方法直接接收 <code>User</code> 实例,不需要进一步的查找.  可以通过让 Spring MVC 首先将路径变量转换为 domain 类的 <code>id</code> 类型并最终通过在为该类型注册的存储库实例上调用 <code>findById(…)</code> 来访问该实例来解析该实例.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当前,该存储库必须实现 <code>CrudRepository</code> 才有资格被发现以进行转换.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="core.web.basic.paging-and-sorting"><a class="anchor" href="#core.web.basic.paging-and-sorting"></a>用于分页和排序的 <code>HandlerMethodArgumentResolvers</code></h6>
<div class="paragraph">
<p><a href="#core.web.basic.domain-class-converter">上一节</a>中显示的配置代码段还注册了 <code>PageableHandlerMethodArgumentResolver</code> 以及 <code>SortHandlerMethodArgumentResolver</code> 的实例.  该注册启用了 <code>Pageable</code> 和 <code>Sort</code> 作为控制器方法参数,如以下示例所示</p>
</div>
<div class="exampleblock">
<div class="title">Example 46. 使用 Pageable 作为控制器方法参数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
@RequestMapping("/users")
class UserController {

  private final UserRepository repository;

  UserController(UserRepository repository) {
    this.repository = repository;
  }

  @RequestMapping
  String showUsers(Model model, Pageable pageable) {

    model.addAttribute("users", repository.findAll(pageable));
    return "users";
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的方法签名使 Spring MVC 尝试使用以下默认配置从请求参数扩展 <code>Pageable</code> 实例:</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 1. 请求为 <code>Pageable</code> 实例评估后的参数</caption>
<colgroup>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>page</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您要检索的页面.  0 索引,默认为 0.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>size</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">您要检索的页面大小.  默认为 20</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sort</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应该以格式属性 <code>property,property(,ASC|DESC)</code> 进行排序的属性.  默认排序方向为升序.  如果要切换排序,请使用多个排序参数. 例如, <code>?sort=firstname&amp;sort=lastname,asc</code>.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要自定义此行为,请注册分别实现 <code>PageableHandlerMethodArgumentResolverCustomizer</code> 接口或 <code>SortHandlerMethodArgumentResolverCustomizer</code> 接口的 bean.  它的 <code>customize()</code> 方法被调用,让您更改设置,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean SortHandlerMethodArgumentResolverCustomizer sortCustomizer() {
    return s -&gt; s.setPropertyDelimiter("&lt;--&gt;");
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果设置现有 <code>MethodArgumentResolver</code> 的属性不足以满足您的目的,请扩展 <code>SpringDataWebConfiguration</code> 或启用 HATEOAS ,重写 <code>pageableResolver()</code> 或 <code>sortResolver()</code> 方法,然后导入自定义的配置文件,而不使用 <code>@Enable</code> 注解.</p>
</div>
<div class="paragraph">
<p>如果您需要从请求中解析多个 <code>Pageable</code> 或 <code>Sort</code> 实例 (例如,对于多个表) ,则可以使用 Spring 的 <code>@Qualifier</code> 注解将一个实例与另一个实例区分开.  然后,请求参数必须以 <code>${qualifier}_</code> 为前缀.  以下示例显示了生成的方法签名:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String showUsers(Model model,
      @Qualifier("thing1") Pageable first,
      @Qualifier("thing2") Pageable second) { … }
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您必须填充 <code>thing1_page</code> 和 <code>thing2_page</code>,依此类推.</p>
</div>
<div class="paragraph">
<p>传递给该方法的默认 <code>Pageable</code> 等效于 <code>PageRequest.of(0, 20)</code>,但可以使用 <code>Pageable</code> 参数上的 <code>@PageableDefault</code> 注解注解进行自定义.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="core.web.pageables"><a class="anchor" href="#core.web.pageables"></a>超媒体对页面的支持</h5>
<div class="paragraph">
<p>Spring HATEOAS 附带了一个表示模型类 (<code>PagedResources</code>) ,该类允许使用必要的页面元数据以及链接来丰富 <code>Page</code> 实例的内容,并使客户端可以轻松浏览页面.  <code>Page</code> 到 <code>PagedResources</code> 的转换是通过 Spring HATEOAS <code>ResourceAssembler</code> 接口 (称为 <code>PagedResourcesAssembler</code>) 的实现完成的.  下面的示例演示如何将 <code>PagedResourcesAssembler</code> 用作控制器方法参数:</p>
</div>
<div class="exampleblock">
<div class="title">Example 47. 使用 PagedResourcesAssembler 作为控制器方法参数</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
class PersonController {

  @Autowired PersonRepository repository;

  @RequestMapping(value = "/persons", method = RequestMethod.GET)
  HttpEntity&lt;PagedResources&lt;Person&gt;&gt; persons(Pageable pageable,
    PagedResourcesAssembler assembler) {

    Page&lt;Person&gt; persons = repository.findAll(pageable);
    return new ResponseEntity&lt;&gt;(assembler.toResources(persons), HttpStatus.OK);
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如上例中所示启用配置,可以将 <code>PagedResourcesAssembler</code> 用作控制器方法参数.  对其调用  <code>toResources(…)</code> 具有以下效果:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Page</code> 的内容成为 <code>PagedResources</code> 实例的内容.</p>
</li>
<li>
<p><code>PagedResources</code> 对象获取附加的 <code>PageMetadata</code> 实例,并使用 <code>Page</code> 和基础 <code>PageRequest</code> 的信息填充该实例.</p>
</li>
<li>
<p><code>PagedResources</code> 可能会附加上一个和下一个链接,具体取决于页面的状态.  链接指向方法映射到的 URI.  添加到该方法的分页参数与 <code>PageableHandlerMethodArgumentResolver</code> 的设置匹配,以确保以后可以解析链接.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>假设数据库中有 30 个 Person 实例.  现在,您可以触发请求 (<code>GET <a href="http://localhost:8080/persons" class="bare">localhost:8080/persons</a></code> ) ,并查看类似于以下内容的输出:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{ "links" : [ { "rel" : "next",
                "href" : "http://localhost:8080/persons?page=1&amp;size=20 }
  ],
  "content" : [
     … // 20 Person instances rendered here
  ],
  "pageMetadata" : {
    "size" : 20,
    "totalElements" : 30,
    "totalPages" : 2,
    "number" : 0
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您会看到编译器生成了正确的 URI,并且还选择了默认配置以将参数解析为即将到来的请求的 <code>Pageable</code>.  这意味着,如果您更改该配置,则链接将自动遵循更改.  默认情况下,编译器指向调用它的控制器方法,但是可以通过传递自定义链接 (用作构建分页链接的基础) 进行自定义,这会使 <code>PagedResourcesAssembler.toResource(&#8230;&#8203;)</code> 方法过载.</p>
</div>
</div>
<div class="sect4">
<h5 id="core.web.basic.jackson-mappers"><a class="anchor" href="#core.web.basic.jackson-mappers"></a>Spring Data Jackson Modules</h5>
<div class="paragraph">
<p>core module 和 存储库特定的模块附带了一组用于类型的 Jackson 模块， 例如 <code>org.springframework.data.geo.Distance</code> 和 <code>org.springframework.data.geo.Point</code>, 使用 Spring Data domain.<br>
一旦启用 <a href="#core.web">web support</a> 这些模块将被导入， 并且 <code>com.fasterxml.jackson.databind.ObjectMapper</code> 可用.</p>
</div>
<div class="paragraph">
<p>在初始化期间， 像 <code>SpringDataJacksonConfiguration</code> 一样， <code>SpringDataJacksonModules</code> 会被自动检测， 以便声明的 <code>com.fasterxml.jackson.databind.Module</code> 可供 Jackson 的 <code>ObjectMapper</code> 使用.</p>
</div>
<div class="paragraph">
<p>Data binding mixins for the following domain types are registered by the common infrastructure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>org.springframework.data.geo.Distance
org.springframework.data.geo.Point
org.springframework.data.geo.Box
org.springframework.data.geo.Circle
org.springframework.data.geo.Polygon</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>各个模块可以提供附加的 <code>SpringDataJacksonModules</code>.<br>
请参阅存储库特定部分以获取更多详细信息.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="core.web.binding"><a class="anchor" href="#core.web.binding"></a>Web 数据绑定支持</h5>
<div class="paragraph">
<p>通过使用 <a href="https://goessner.net/articles/JsonPath/">JSONPath</a> 表达式 (需要 <a href="https://github.com/json-path/JsonPath">Jayway JsonPath</a> 或 <a href="https://www.w3.org/TR/xpath-31/">XPath</a>表达式 (需要 <a href="https://xmlbeam.org/">XmlBeam</a>) ) ,可以使用 Spring Data 投影 (在 <a href="#projections">Projections</a> 中描述) 来绑定传入的请求有效负载,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 48. 使用 JSONPath 或 XPath 表达式的 HTTP 有效负载绑定</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ProjectedPayload
public interface UserPayload {

  @XBRead("//firstname")
  @JsonPath("$..firstname")
  String getFirstname();

  @XBRead("/lastname")
  @JsonPath({ "$.lastname", "$.user.lastname" })
  String getLastname();
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面示例中显示的类型可以用作 Spring MVC 处理程序方法参数,也可以通过在 <code>RestTemplate</code> 的方法之一上使用 <code>ParameterizedTypeReference</code> 来使用.  前面的方法声明将尝试在给定文档中的任何位置查找名字.   <code>lastname</code> XML 查找是在传入文档的顶层执行的.
JSON 首先尝试使用顶层 <code>lastname</code> ,但是如果前者不返回值,则还尝试嵌套在用户子文档中的 <code>lastname</code> .  这样,无需客户端调用暴露的方法即可轻松缓解源文档结构的更改 (通常是基于类的有效负载绑定的缺点) .</p>
</div>
<div class="paragraph">
<p>如 <a href="#projections">投影</a>中所述,支持嵌套投影.  如果该方法返回复杂的非接口类型,则将使用 Jackson <code>ObjectMapper</code> 映射最终值.</p>
</div>
<div class="paragraph">
<p>对于 Spring MVC,<code>@EnableSpringDataWebSupport</code> 处于活动状态并且所需的依赖在类路径上可用后,会自动自动注册必要的转换器.  要与 <code>RestTemplate</code> 一起使用,请手动注册 <code>ProjectingJackson2HttpMessageConverter</code> (JSON)  或 <code>XmlBeamHttpMessageConverter</code>.</p>
</div>
<div class="paragraph">
<p>有关更多信息,请参见规范的 <a href="https://github.com/spring-projects/spring-data-examples">Spring Data Examples repository</a> 存储库中的 <a href="https://github.com/spring-projects/spring-data-examples/tree/master/web/projection">web projection example</a> .</p>
</div>
</div>
<div class="sect4">
<h5 id="core.web.type-safe"><a class="anchor" href="#core.web.type-safe"></a>Querydsl Web 支持</h5>
<div class="paragraph">
<p>对于那些具有 <a href="http://www.querydsl.com/">QueryDSL</a> 集成的存储,可以从 · 查询字符串中包含的属性扩展查询.</p>
</div>
<div class="paragraph">
<p>考虑以下查询字符串:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">?firstname=Dave&amp;lastname=Matthews</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>给定前面示例中的 <code>User</code> 对象,可以使用 <code>QuerydslPredicateArgumentResolver</code> 将查询字符串解析为以下值.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">QUser.user.firstname.eq("Dave").and(QUser.user.lastname.eq("Matthews"))</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在类路径上找到 Querydsl 时,将自动启用该功能以及 <code>@EnableSpringDataWebSupport</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>将 <code>@QuerydslPredicate</code> 添加到方法签名中可提供一个现成的 <code>Predicate</code>,可以使用 <code>QuerydslPredicateExecutor</code> 来运行它.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
类型信息通常从方法的返回类型中解析.  由于该信息不一定与 domain 类型匹配,因此使用 <code>QuerydslPredicate</code> 的 <code>root</code> 属性可能是一个好主意.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的示例演示如何在方法签名中使用 <code>@QuerydslPredicate</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
class UserController {

  @Autowired UserRepository repository;

  @RequestMapping(value = "/", method = RequestMethod.GET)
  String index(Model model, @QuerydslPredicate(root = User.class) Predicate predicate,    <i class="conum" data-value="1"></i><b>(1)</b>
          Pageable pageable, @RequestParam MultiValueMap&lt;String, String&gt; parameters) {

    model.addAttribute("users", repository.findAll(predicate, pageable));

    return "index";
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将查询字符串参数解析为与 <code>User</code> <code>Predicate</code> 匹配.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>默认绑定如下:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>简单属性上的对象如 <code>eq</code>.</p>
</li>
<li>
<p>集合上的对象,如 <code>contains</code> 的属性.</p>
</li>
<li>
<p>集合上的对象,如 <code>in</code> 的属性.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>可以通过 <code>@QuerydslPredicate</code> 的 <code>bindings</code> 属性或通过使用 Java 8 <code>default methods</code> 并将 <code>QuerydslBinderCustomizer</code> 方法添加到存储库接口来自定义那些绑定.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface UserRepository extends CrudRepository&lt;User, String&gt;,
                                 QuerydslPredicateExecutor&lt;User&gt;,                <i class="conum" data-value="1"></i><b>(1)</b>
                                 QuerydslBinderCustomizer&lt;QUser&gt; {               <i class="conum" data-value="2"></i><b>(2)</b>

  @Override
  default void customize(QuerydslBindings bindings, QUser user) {

    bindings.bind(user.username).first((path, value) -&gt; path.contains(value))    <i class="conum" data-value="3"></i><b>(3)</b>
    bindings.bind(String.class)
      .first((StringPath path, String value) -&gt; path.containsIgnoreCase(value)); <i class="conum" data-value="4"></i><b>(4)</b>
    bindings.excluding(user.password);                                           <i class="conum" data-value="5"></i><b>(5)</b>
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>QuerydslPredicateExecutor</code> 提供对断言的特定查找器方法的访问</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在存储库界面上定义的 <code>QuerydslBinderCustomizer</code> 会被自动提取,并提供 <code>@QuerydslPredicate(bindings=&#8230;&#8203;)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>将 <code>username</code> 属性的绑定定义为简单的 <code>contains</code>  绑定.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>将 <code>String</code> 属性的默认绑定定义为不区分大小写的 <code>contains</code> 匹配项.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>从  <code>Predicate</code> 解析中排除 <code>password</code> 属性.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="core.repository-populators"><a class="anchor" href="#core.repository-populators"></a>4.8.3. 存储库填充器</h4>
<div class="paragraph">
<p>如果您使用 Spring JDBC 模块,则可能熟悉使用 SQL 脚本填充 <code>DataSource</code> 的支持.  尽管它不使用 SQL 作为数据定义语言,因为它必须独立于存储,因此可以在存储库级别使用类似的抽象.  因此,填充器支持XML (通过 Spring 的 OXM 抽象) 和 JSON  (通过 Jackson) 来定义用于填充存储库的数据.</p>
</div>
<div class="paragraph">
<p>假设您有一个包含以下内容的 <code>data.json</code> 文件:</p>
</div>
<div class="exampleblock">
<div class="title">Example 49. JSON中定义的数据</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">[ { "_class" : "com.acme.Person",
 "firstname" : "Dave",
  "lastname" : "Matthews" },
  { "_class" : "com.acme.Person",
 "firstname" : "Carter",
  "lastname" : "Beauford" } ]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用 Spring Data Commons 中提供的存储库命名空间的 <code>populator</code> 元素来填充存储库.  要将前面的数据填充到 <code>PersonRepository</code> 中,请声明类似于以下内容的填充器:</p>
</div>
<div class="exampleblock">
<div class="title">Example 50. 声明一个 Jackson 存储库填充器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    https://www.springframework.org/schema/data/repository/spring-repository.xsd"&gt;

  &lt;repository:jackson2-populator locations="classpath:data.json" /&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的声明使 <code>Jackson.ObjectMapper</code> 读取并反序列化 <code>data.json</code> 文件.</p>
</div>
<div class="paragraph">
<p>通过检查JSON文档的 <code>_class</code> 属性来确定将 JSON 对象解组到的类型.  基础结构最终选择适当的存储库来处理反序列化的对象.</p>
</div>
<div class="paragraph">
<p>要改为使用 XML 定义应使用存储库填充的数据,可以使用 <code>unmarshaller-populator</code> 元素.  您可以将其配置为使用 Spring OXM 中可用的 XML marshaller 选项之一.  有关详细信息,请参见 <a href="https://docs.jcohy.com/docs/spring-framework/5.3.6/html5/zh-cn/data-access.html#oxm">Spring 参考文档</a>.  以下示例显示如何使用 JAXB 解组存储库填充器:</p>
</div>
<div class="exampleblock">
<div class="title">Example 51. 声明一个解组存储库填充器 (使用 JAXB)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:repository="http://www.springframework.org/schema/data/repository"
  xmlns:oxm="http://www.springframework.org/schema/oxm"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/data/repository
    https://www.springframework.org/schema/data/repository/spring-repository.xsd
    http://www.springframework.org/schema/oxm
    https://www.springframework.org/schema/oxm/spring-oxm.xsd"&gt;

  &lt;repository:unmarshaller-populator locations="classpath:data.json"
    unmarshaller-ref="unmarshaller" /&gt;

  &lt;oxm:jaxb2-marshaller contextPath="com.acme" /&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="projections"><a class="anchor" href="#projections"></a>4.9. 投影</h3>
<div class="paragraph">
<p>Spring Data 查询方法通常返回存储库管理的聚合根的一个或多个实例.  但是,有时可能需要根据这些类型的某些属性创建投影.  Spring Data 允许对专用的返回类型进行建模,以更选择性地检索托管聚合的部分视图.</p>
</div>
<div class="paragraph">
<p>想象一下一个存储库和聚合根类型,例如以下示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 52. 一个示例集合和存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {

  @Id UUID id;
  String firstname, lastname;
  Address address;

  static class Address {
    String zipCode, city, street;
  }
}

interface PersonRepository extends Repository&lt;Person, UUID&gt; {

  Collection&lt;Person&gt; findByLastname(String lastname);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在,假设我们只想检索此人的姓名属性.  Spring Data 提供什么手段来实现这一目标?  本章的其余部分将回答该问题.</p>
</div>
<div class="sect3">
<h4 id="projections.interfaces"><a class="anchor" href="#projections.interfaces"></a>4.9.1. 基于接口的投影</h4>
<div class="paragraph">
<p>将查询结果限制为仅 <code>name</code> 属性的最简单方法是声明一个接口,该接口暴露要读取的属性的 get 方法,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 53. 一个投影接口来检索属性的子集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  String getFirstname();
  String getLastname();
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此处重要的一点是,此处定义的属性与聚合根中的属性完全匹配.  这样做可以使查询方法添加如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 54. 使用基于接口的投影和查询方法的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, UUID&gt; {

  Collection&lt;NamesOnly&gt; findByLastname(String lastname);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>查询执行引擎在运行时为返回的每个元素创建该接口的代理实例,并将对暴露方法的调用转发给目标对象.</p>
</div>
<div id="projections.interfaces.nested" class="paragraph">
<p>投影可以递归使用.  如果还希望包括一些 <code>Address</code> 信息,则为此创建一个投影接口,并从 <code>getAddress()</code> 的声明返回该接口,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 55. 一个投影接口来检索属性的子集</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonSummary {

  String getFirstname();
  String getLastname();
  AddressSummary getAddress();

  interface AddressSummary {
    String getCity();
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在方法调用时,将获得目标实例的 <code>address</code> 属性,并将其包装到投影代理中.</p>
</div>
<div class="sect4">
<h5 id="projections.interfaces.closed"><a class="anchor" href="#projections.interfaces.closed"></a>封闭投影</h5>
<div class="paragraph">
<p>其 get 方法均与目标集合的属性完全匹配的投影接口被视为封闭投影.  下面的示例 (也在本章前面使用过) 是一个封闭的投影:</p>
</div>
<div class="exampleblock">
<div class="title">Example 56. 一个封闭的投影</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  String getFirstname();
  String getLastname();
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您使用封闭式投影,Spring Data 可以优化查询执行,因为我们知道支持投影代理所需的所有属性.  有关更多信息,请参见参考文档中特定于模块的部分.</p>
</div>
</div>
<div class="sect4">
<h5 id="projections.interfaces.open"><a class="anchor" href="#projections.interfaces.open"></a>打开投影</h5>
<div class="paragraph">
<p>投影接口中的 get 方法也可以通过使用 <code>@Value</code> 注解来计算新值,如以下示例所示:</p>
</div>
<div id="projections.interfaces.open.simple" class="exampleblock">
<div class="title">Example 57. 一个 打开投影</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  @Value("#{target.firstname + ' ' + target.lastname}")
  String getFullName();
  …
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在  <code>target</code>  变量中提供了支持投影的合计根.  使用 <code>@Value</code> 的投影接口是开放式投影.  在这种情况下,Spring Data 无法应用查询执行优化,因为 SpEL 表达式可以使用聚合根的任何属性.</p>
</div>
<div class="paragraph">
<p><code>@Value</code> 中使用的表达式应该不太复杂-您要避免在 <code>String</code> 变量中进行编程.  对于非常简单的表达式,一种选择可能是求助于默认方法 (在 Java 8 中引入) ,如以下示例所示:</p>
</div>
<div id="projections.interfaces.open.default" class="exampleblock">
<div class="title">Example 58. 使用默认方法自定义逻辑的投影接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  String getFirstname();
  String getLastname();

  default String getFullName() {
    return getFirstname().concat(" ").concat(getLastname());
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种方法要求您能够完全基于投影接口上暴露的其他 get 方法来实现逻辑.  第二个更灵活的选择是在 Spring bean 中实现自定义逻辑,然后从 SpEL 表达式中调用该自定义逻辑,如以下示例所示:</p>
</div>
<div id="projections.interfaces.open.bean-reference" class="exampleblock">
<div class="title">Example 59. 简单 Person 对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
class MyBean {

  String getFullName(Person person) {
    …
  }
}

interface NamesOnly {

  @Value("#{@myBean.getFullName(target)}")
  String getFullName();
  …
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意 SpEL 表达式如何引用 <code>myBean</code> 并调用  <code>getFullName(…)</code> 方法,并将投影目标作为方法参数转发.  SpEL 表达式评估支持的方法也可以使用方法参数,然后可以从表达式中引用这些参数.  方法参数可通过名为 <code>args</code> 的对象数组获得.
下面的示例演示如何从 <code>args</code> 数组获取方法参数:</p>
</div>
<div class="exampleblock">
<div class="title">Example 60. 简单 Person 对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  @Value("#{args[0] + ' ' + target.firstname + '!'}")
  String getSalutation(String prefix);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样,对于更复杂的表达式,您应该使用 Spring bean 并让该表达式调用方法,<a href="#projections.interfaces.open.bean-reference">如前所述</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="projections.interfaces.nullable-wrappers"><a class="anchor" href="#projections.interfaces.nullable-wrappers"></a>Nullable Wrappers</h5>
<div class="paragraph">
<p>投影接口中的 getter 可以使用可为空的包装器， 以提高 null-safety 的安全性.  当前支持的包装器类型为:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>java.util.Optional</code></p>
</li>
<li>
<p><code>com.google.common.base.Optional</code></p>
</li>
<li>
<p><code>scala.Option</code></p>
</li>
<li>
<p><code>io.vavr.control.Option</code></p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="title">Example 61. 使用 nullable 包装的投影接口</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface NamesOnly {

  Optional&lt;String&gt; getFirstname();
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果基础投影值不为  <code>null</code>， 则使用包装器类型的 present-representation 返回值.
如果默认值为 <code>null</code>， 则 getter 方法将返回使用的包装器类型的空表示形式.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="projections.dtos"><a class="anchor" href="#projections.dtos"></a>4.9.2. 基于类的投影 (DTO)</h4>
<div class="paragraph">
<p>定义投影的另一种方法是使用值类型DTO (数据传输对象) ,该类型DTO保留应该被检索的字段的属性.  这些 DTO 类型可以以与使用投影接口完全相同的方式使用,除了没有代理发生和不能应用嵌套投影之外.</p>
</div>
<div class="paragraph">
<p>如果存储通过限制要加载的字段来优化查询执行,则要加载的字段由暴露的构造函数的参数名称确定.</p>
</div>
<div class="paragraph">
<p>以下示例显示了一个预计的 DTO:</p>
</div>
<div class="exampleblock">
<div class="title">Example 62. 一个投影的 DTO</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class NamesOnly {

  private final String firstname, lastname;

  NamesOnly(String firstname, String lastname) {

    this.firstname = firstname;
    this.lastname = lastname;
  }

  String getFirstname() {
    return this.firstname;
  }

  String getLastname() {
    return this.lastname;
  }

  // equals(…) and hashCode() implementations
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">避免投影 DTO 的样板代码</div>
<div class="paragraph">
<p>您可以使用 <a href="https://projectlombok.org">Project Lombok</a> 大大简化DTO的代码,该项目提供了 <code>@Value</code> 注解 (不要与前面的界面示例中显示的 Spring 的 <code>@Value</code> 注解混淆) .  如果您使用 Project Lombok 的 <code>@Value</code> 注解,则前面显示的示例DTO将变为以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Value
class NamesOnly {
    String firstname, lastname;
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下,字段是  <code>private final</code> 的,并且该类暴露了一个构造函数,该构造函数接受所有字段并自动获取实现的 <code>equals(…)</code> 和 <code>hashCode()</code> 方法.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="projection.dynamic"><a class="anchor" href="#projection.dynamic"></a>4.9.3. 动态投影</h4>
<div class="paragraph">
<p>到目前为止,我们已经将投影类型用作集合的返回类型或元素类型.  但是,您可能想要选择在调用时要使用的类型 (这使它成为动态的) .  要应用动态投影,请使用查询方法,如以下示例中所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 63. 使用动态投影参数的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends Repository&lt;Person, UUID&gt; {

  &lt;T&gt; Collection&lt;T&gt; findByLastname(String lastname, Class&lt;T&gt; type);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过这种方式,该方法可以按原样或应用投影来获得聚合,如下例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 64. 使用带有动态投影的存储库</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void someMethod(PersonRepository people) {

  Collection&lt;Person&gt; aggregates =
    people.findByLastname("Matthews", Person.class);

  Collection&lt;NamesOnly&gt; aggregates =
    people.findByLastname("Matthews", NamesOnly.class);
}
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="reference" class="sect0"><a class="anchor" href="#reference"></a>参考文档</h1>
<div class="sect1">
<h2 id="elasticsearch.clients"><a class="anchor" href="#elasticsearch.clients"></a>5. Elasticsearch 客户端</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章介绍了如何配置和使用支持的 Elasticsearch 客户端的实现</p>
</div>
<div class="paragraph">
<p>Spring Data Elasticsearch 在连接到单个 Elasticsearch 节点或集群的 Elasticsearch 客户端上进行操作. 虽然可以使用 Elasticsearch Client 客户端与集群一起工作, 但使用 Spring Data Elasticsearch 通常使用更加高级的抽象 <a href="#elasticsearch.operations">Elasticsearch 操作</a> 和 <a href="#elasticsearch.repositories">Elasticsearch Repositories</a>.</p>
</div>
<div class="sect2">
<h3 id="elasticsearch.clients.transport"><a class="anchor" href="#elasticsearch.clients.transport"></a>5.1. Transport Client</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
众所周知,从 Elasticsearch 7 开始 <code>TransportClient</code> 已经被弃用,并且在  Elasticsearch 8 中删除. (<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/transport-client.html">see the Elasticsearch documentation</a>). Spring Data Elasticsearch 支持 <code>TransportClient</code> 只要它在已使用的 Elasticsearch  <a href="#preface.versions">版本</a>  中可用,但从4.0版本开始已弃用使用它的类.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>强烈建议使用  <a href="#elasticsearch.clients.rest">更高级别的 REST Client</a> 而不是 <code>TransportClient</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 65. Transport Client</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class TransportClientConfig extends ElasticsearchConfigurationSupport {

    @Bean
    public Client elasticsearchClient() throws UnknownHostException {
        Settings settings = Settings.builder().put("cluster.name", "elasticsearch").build();        <i class="conum" data-value="1"></i><b>(1)</b>
        TransportClient client = new PreBuiltTransportClient(settings);
        client.addTransportAddress(new TransportAddress(InetAddress.getByName("127.0.0.1"), 9300)); <i class="conum" data-value="2"></i><b>(2)</b>
        return client;
    }

    @Bean(name = { "elasticsearchOperations", "elasticsearchTemplate" })
    public ElasticsearchTemplate elasticsearchTemplate() throws UnknownHostException {
        return new ElasticsearchTemplate(elasticsearchClient());
    }
}

// ...

IndexRequest request = new IndexRequest("spring-data", "elasticsearch", randomID())
 .source(someObject)
 .setRefreshPolicy(IMMEDIATE);

IndexResponse response = client.index(request);
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>必须使用群集名称配置 <code>TransportClient</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>连接客户端的主机和端口.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.clients.rest"><a class="anchor" href="#elasticsearch.clients.rest"></a>5.2. 更高级别的 REST Client</h3>
<div class="paragraph">
<p>Java High Level REST Client 是 Elasticsearch 默认的客户端, 它可以直接替代 <code>TransportClient</code> 因为他们接受并返回完全相同的请求和响应.因此依赖于 Elasticsearch core 项目
异步调用是在客户端管理的线程池上进行的,并且要求在完成请求时通知回调.</p>
</div>
<div class="exampleblock">
<div class="title">Example 66. High Level REST Client</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class RestClientConfig extends AbstractElasticsearchConfiguration {

    @Override
    @Bean
    public RestHighLevelClient elasticsearchClient() {

        final ClientConfiguration clientConfiguration = ClientConfiguration.builder()  <i class="conum" data-value="1"></i><b>(1)</b>
            .connectedTo("localhost:9200")
            .build();

        return RestClients.create(clientConfiguration).rest();                         <i class="conum" data-value="2"></i><b>(2)</b>
    }
}

// ...

  @Autowired
  RestHighLevelClient highLevelClient;

  RestClient lowLevelClient = highLevelClient.lowLevelClient();                        <i class="conum" data-value="3"></i><b>(3)</b>

// ...

IndexRequest request = new IndexRequest("spring-data", "elasticsearch", randomID())
  .source(singletonMap("feature", "high-level-rest-client"))
  .setRefreshPolicy(IMMEDIATE);

IndexResponse response = highLevelClient.index(request);
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 builder 提供集群地址, 设置默认的 <code>HttpHeaders</code> 或 启用 SSL.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建 RestHighLevelClient.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>也可以获取 <code>lowLevelRest()</code> 客户端.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.clients.reactive"><a class="anchor" href="#elasticsearch.clients.reactive"></a>5.3. Reactive Client</h3>
<div class="paragraph">
<p><code>ReactiveElasticsearchClient</code> 是一个基于 <code>WebClient</code> 的非官方驱动程序.它使用 Elasticsearch core 项目提供的请求/响应对象.调用直接在响应式堆栈上操作,而不是将异步(线程池绑定)响应包装为响应式类型.</p>
</div>
<div class="exampleblock">
<div class="title">Example 67. Reactive REST Client</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">static class Config {

  @Bean
  ReactiveElasticsearchClient client() {

    ClientConfiguration clientConfiguration = ClientConfiguration.builder()   <i class="conum" data-value="1"></i><b>(1)</b>
      .connectedTo("localhost:9200", "localhost:9291")
      .withWebClientConfigurer(webClient -&gt; {                                 <i class="conum" data-value="2"></i><b>(2)</b>
        ExchangeStrategies exchangeStrategies = ExchangeStrategies.builder()
            .codecs(configurer -&gt; configurer.defaultCodecs()
                .maxInMemorySize(-1))
            .build();
        return webClient.mutate().exchangeStrategies(exchangeStrategies).build();
       })
      .build();

    return ReactiveRestClients.create(clientConfiguration);
  }
}

// ...

Mono&lt;IndexResponse&gt; response = client.index(request -&gt;

  request.index("spring-data")
    .type("elasticsearch")
    .id(randomID())
    .source(singletonMap("feature", "reactive-client"))
    .setRefreshPolicy(IMMEDIATE);
);
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 builder 提供集群地址, 设置默认的 <code>HttpHeaders</code> 或 启用 SSL.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>当配置一个响应式客户端时,可以使用 <code>withWebClientConfigurer</code> 钩子来自定义 web 客户端.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
ReactiveClient 响应, (特别是搜索操作)绑定到请求的 <code>from</code> (offset) &amp; <code>size</code> (limit) 选项.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.clients.configuration"><a class="anchor" href="#elasticsearch.clients.configuration"></a>5.4. Client 配置</h3>
<div class="paragraph">
<p>客户端行为可以通过 <code>ClientConfiguration</code> 更改,该配置允许设置 SSL、connect 和 socket timeouts, headers 和其他参数的选项.</p>
</div>
<div class="exampleblock">
<div class="title">Example 68. Client Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">HttpHeaders httpHeaders = new HttpHeaders();
httpHeaders.add("some-header", "on every request")                      <i class="conum" data-value="1"></i><b>(1)</b>

ClientConfiguration clientConfiguration = ClientConfiguration.builder()
  .connectedTo("localhost:9200", "localhost:9291")                      <i class="conum" data-value="2"></i><b>(2)</b>
  .useSsl()                                                             <i class="conum" data-value="3"></i><b>(3)</b>
  .withProxy("localhost:8888")                                          <i class="conum" data-value="4"></i><b>(4)</b>
  .withPathPrefix("ela")                                                <i class="conum" data-value="5"></i><b>(5)</b>
  .withConnectTimeout(Duration.ofSeconds(5))                            <i class="conum" data-value="6"></i><b>(6)</b>
  .withSocketTimeout(Duration.ofSeconds(3))                             <i class="conum" data-value="7"></i><b>(7)</b>
  .withDefaultHeaders(defaultHeaders)                                   <i class="conum" data-value="8"></i><b>(8)</b>
  .withBasicAuth(username, password)                                    <i class="conum" data-value="9"></i><b>(9)</b>
  .withHeaders(() -&gt; {                                                  <i class="conum" data-value="10"></i><b>(10)</b>
    HttpHeaders headers = new HttpHeaders();
    headers.add("currentTime", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
    return headers;
  })
  . // ... other options
  .build();
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>定义默认的 headers, 如有需要,可以自定义</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 builder 提供集群机制, 设置默认 <code>HttpHeaders</code> 或 启用 SSL.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>可选的,启用 SSL.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>可选的,设置代理.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>可选的,设置路径前缀, 主要用于不同的集群在某个反向代理后面.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>设置连接超时.默认值为 10 秒.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>设置 socket 超时.默认值为 5 秒</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>可选的.设置 headers.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>添加 basic 认证.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>可以指定一个 <code>Supplier&lt;Header&gt;</code> 函数,该函数在每次请求发送到 Elasticsearch 之前都会被调用——例如,上例中,当前时间被写入 header 中.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
如上例所示,可以将随时间变化请求头的注入到 Supplier 中, 例如身份验证 JWT 令牌. 如果这是在响应式中使用的,supplier 函数一定不能阻塞!
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.clients.logging"><a class="anchor" href="#elasticsearch.clients.logging"></a>5.5. Client 日志</h3>
<div class="paragraph">
<p>要查看实际发送到服务器和从服务器接收的内容,请按照以下代码片段中的说明打开在 transport 级别的 <code>Request</code> / <code>Response</code> 日志记录.</p>
</div>
<div class="listingblock">
<div class="title">Enable transport layer logging</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;logger name="org.springframework.data.elasticsearch.client.WIRE" level="trace"/&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当分别通过 <code>RestClients</code> 和 <code>ReactiveRestClients</code> 获得时,以上内容适用于 <code>RestHighLevelClient</code> 和 <code>ReactiveElasticsearchClient</code>,不适用于 <code>TransportClient</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elasticsearch.mapping"><a class="anchor" href="#elasticsearch.mapping"></a>6. Elasticsearch 对象映射</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data Elasticsearch Object Mapping 是将 Java 对象 (domain entity)和存储在 Elasticsearch 中的 JSON 相互映射的过程</p>
</div>
<div class="paragraph">
<p>早期的 Spring Data Elasticsearch 版本使用 Jackson 进行转换,Spring Data Elasticsearch 3.2.x 引入了 <a href="#elasticsearch.mapping.meta-model">Meta Model Object Mapping</a> 对象映射,基于 Jackson 的映射不再使用,而是使用 <code>MappingElasticsearchConverter</code></p>
</div>
<div class="paragraph">
<p>删除基于 Jackson 的映射的主要原因是:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>自定义字段的映射需要使用 <code>@JsonFormat</code> 或 <code>@JsonInclude</code> 之类的注解来完成. 当在不同的基于 JSON 的数据存储中使用相同的对象或使用 JSON 的 API 发送时.这通常会导致问题</p>
</li>
<li>
<p>自定义字段类型和格式也需要存储到 Elasticsearch 索引映射中. 基于 Jackson 的注解未完全提供表示 Elasticsearch 类型所需的所有信息..</p>
</li>
<li>
<p>不仅仅在实体之间转换需要字段映射,还必须在查询参数,返回数据以及其他地方映射字段.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用 <code>MappingElasticsearchConverter</code> 现在覆盖了所有这些情况.</p>
</div>
<div class="sect2">
<h3 id="elasticsearch.mapping.meta-model"><a class="anchor" href="#elasticsearch.mapping.meta-model"></a>6.1. Meta Model Object Mapping</h3>
<div class="paragraph">
<p>基于元模型的方法使用 domain 类型信息 读取/写入 Elasticsearch.这允许为特定的 domain 类型映射注册 <code>Converter</code> 实例.</p>
</div>
<div class="sect3">
<h4 id="elasticsearch.mapping.meta-model.annotations"><a class="anchor" href="#elasticsearch.mapping.meta-model.annotations"></a>6.1.1. 映射注解概述</h4>
<div class="paragraph">
<p><code>MappingElasticsearchConverter</code> 使用元数据来驱动对象到文档的映射.元数据来自可以注解的实体属性.</p>
</div>
<div class="paragraph">
<p>有以下注解可用:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>@Document</code>: 类级别注解,表示此类是映射到数据库的候选对象.以下为最重要的属性.:</p>
<div class="ulist">
<ul>
<li>
<p><code>indexName</code>: 此实体的索引名称</p>
</li>
<li>
<p><code>type</code>: <span class="line-through">映射类型. 如果未设置,则使用类的简单小写名称.</span> (从版本4.0开始不推荐使用)</p>
</li>
<li>
<p><code>shards</code>: 索引分片的数量</p>
</li>
<li>
<p><code>replicas</code>: 索引副本数量</p>
</li>
<li>
<p><code>refreshIntervall</code>: 索引刷新间隔.用于创建索引. 默认为 <em>"1s"</em>.</p>
</li>
<li>
<p><code>indexStoreType</code>:  索引的索引存储类型.用于创建索引. 默认为 <em>"fs"</em>.</p>
</li>
<li>
<p><code>createIndex</code>: 配置是否在 repository 加载时创建索引. 默认为 <em>true</em>.</p>
</li>
<li>
<p><code>versionType</code>: 版本管理配置. 默认为 <em>EXTERNAL</em>.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>@Id</code>: 字段级注解,标记字段本身的意图.</p>
</li>
<li>
<p><code>@Transient</code>: 默认情况下,存储或检索文档时,所有的字段都映射到文档中,此字段可以标识不映射该字段</p>
</li>
<li>
<p><code>@PersistenceConstructor</code>: 标记已有的构造函数 - 可以是一个 protected package - 当从数据库实例化对象时使用.按照构造函数参数名称映射到检索到的文档中的键值.</p>
</li>
<li>
<p><code>@Field</code>: 字段级注解,可以定义字段的属性, 大多数属性映射到各自的 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html">Elasticsearch Mapping</a> 定义 (以下列表不完整,请查看注解的 Javadoc 以获取完整的参考) :</p>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: 将在 Elasticsearch 文档中表示的字段名称,如果未设置,则使用 Java 字段名称.</p>
</li>
<li>
<p><code>type</code>: 字段类型,可以是 <em>Text, Keyword, Long, Integer, Short, Byte, Double, Float, Half_Float, Scaled_Float, Date, Date_Nanos, Boolean, Binary, Integer_Range, Float_Range, Long_Range, Double_Range, Date_Range, Ip_Range, Object, Nested, Ip, TokenCount, Percolator, Flattened, Search_As_You_Type</em>. 请参阅 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html">Elasticsearch 映射类型</a></p>
</li>
<li>
<p>为 <em>Date</em> 类型声明 <code>format</code> 和 <code>pattern</code> . 日期类型必须指定 <code>format</code> .</p>
</li>
<li>
<p><code>store</code>: 标记是否将原始字段值存储在 Elasticsearch 中, 默认为 <em>false</em>.</p>
</li>
<li>
<p><code>analyzer</code>, <code>searchAnalyzer</code>, <code>normalizer</code> 指定自定义 analyzers 和 normalizer.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>@GeoPoint</code>: 将字段标记为 <em>geo_point</em> 数据类型. 如果字段是 <code>GeoPoint</code> 类的实例,则可以省略.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从 <code>TemporalAccessor</code> 扩展 的属性必须具有类型为 <code>FieldType.Date</code> 的 <code>@Field</code> 注解,或必须为此类型注册自定义转换器.<br>
如果使用自定义日期格式,则需要使用 <em>uuuu</em> 作为年份而不是 <em>yyyy</em>. 这是 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/migrate-to-java-time.html#java-time-migration-incompatible-date-formats">Elasticsearch 7 中的变化</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>映射元数据基础架构是在 spring-data-commons 项目中定义的,该项目与技术无关..</p>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch.mapping.meta-model.rules"><a class="anchor" href="#elasticsearch.mapping.meta-model.rules"></a>6.1.2. 映射规则</h4>
<div class="sect4">
<h5 id="type-hints类型提示"><a class="anchor" href="#type-hints类型提示"></a>Type Hints(类型提示)</h5>
<div class="paragraph">
<p>映射使用发送到服务器的文档中的类型提示来允许通用类型映射. 这些类型提示在文档中表示为 <code>_class</code> 属性,并针对每个聚合根写入.</p>
</div>
<div class="exampleblock">
<div class="title">Example 69. Type Hints</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Person {              <i class="conum" data-value="1"></i><b>(1)</b>

  @Id String id;
  String firstname;
  String lastname;
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "_class" : "com.example.Person", <i class="conum" data-value="1"></i><b>(1)</b>
  "id" : "cb7bef",
  "firstname" : "Sarah",
  "lastname" : "Connor"
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>默认情况下,domain 类型类名用于类型提示.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>类型提示可以配置为保存自定义信息.. 使用 <code>@TypeAlias</code> 注解执行此操作.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请确保将具有 <code>@TypeAlias</code> 的类型添加到初始实体集(<code>AbstractElasticsearchConfiguration#getInitialEntitySet</code>)中,以便在首次从存储中读取数据时已经具有可用的实体信息.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 70. Type Hints with Alias</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@TypeAlias("human")                <i class="conum" data-value="1"></i><b>(1)</b>
public class Person {

  @Id String id;
  // ...
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "_class" : "human",              <i class="conum" data-value="1"></i><b>(1)</b>
  "id" : ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>编写实体时使用配置的别名.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
除非属性类型为 <code>Object</code>, 接口或实际值类型与属性声明不匹配,否则不会为嵌套对象编写类型提示.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="geospatial-类型"><a class="anchor" href="#geospatial-类型"></a>Geospatial 类型</h5>
<div class="paragraph">
<p>Geospatial 类型,比如 <code>Point</code> &amp; <code>GeoPoint</code> 将被转换为 <em>lat/lon</em> 对.</p>
</div>
<div class="exampleblock">
<div class="title">Example 71. Geospatial 类型</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Address {

  String city, street;
  Point location;
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "city" : "Los Angeles",
  "street" : "2800 East Observatory Road",
  "location" : { "lat" : 34.118347, "lon" : -118.3026284 }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="collections集合"><a class="anchor" href="#collections集合"></a>Collections(集合)</h5>
<div class="paragraph">
<p>对于集合中的值,在类型提示和 <a href="#elasticsearch.mapping.meta-model.conversions">自定义转换</a> 时,与聚合根具有相同的映射规则.</p>
</div>
<div class="exampleblock">
<div class="title">Example 72. Collections</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Person {

  // ...

  List&lt;Person&gt; friends;

}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  // ...

  "friends" : [ { "firstname" : "Kyle", "lastname" : "Reese" } ]
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="maps"><a class="anchor" href="#maps"></a>Maps</h5>
<div class="paragraph">
<p>对于 Maps 内的值,在类型提示和 <a href="#elasticsearch.mapping.meta-model.conversions">自定义转换</a> 时,与聚合根具有相同的映射规则.然而,Map 的 键 需要一个字符串来由 Elasticsearch 处理.</p>
</div>
<div class="exampleblock">
<div class="title">Example 73. Collections</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Person {

  // ...

  Map&lt;String, Address&gt; knownLocations;

}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  // ...

  "knownLocations" : {
    "arrivedAt" : {
       "city" : "Los Angeles",
       "street" : "2800 East Observatory Road",
       "location" : { "lat" : 34.118347, "lon" : -118.3026284 }
     }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch.mapping.meta-model.conversions"><a class="anchor" href="#elasticsearch.mapping.meta-model.conversions"></a>6.1.3. 自定义转换</h4>
<div class="paragraph">
<p>看看 <a href="#elasticsearch.mapping.meta-model">上一节</a>中的 <code>Configuration</code>,ElasticsearchCustomConversions 允许为  mapping domain 和简单类型注册特定规则.</p>
</div>
<div class="exampleblock">
<div class="title">Example 74. Meta Model Object Mapping Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class Config extends AbstractElasticsearchConfiguration {

  @Override
  public RestHighLevelClient elasticsearchClient() {
    return RestClients.create(ClientConfiguration.create("localhost:9200")).rest();
  }

  @Bean
  @Override
  public ElasticsearchCustomConversions elasticsearchCustomConversions() {
    return new ElasticsearchCustomConversions(
      Arrays.asList(new AddressToMap(), new MapToAddress()));       <i class="conum" data-value="1"></i><b>(1)</b>
  }

  @WritingConverter                                                 <i class="conum" data-value="2"></i><b>(2)</b>
  static class AddressToMap implements Converter&lt;Address, Map&lt;String, Object&gt;&gt; {

    @Override
    public Map&lt;String, Object&gt; convert(Address source) {

      LinkedHashMap&lt;String, Object&gt; target = new LinkedHashMap&lt;&gt;();
      target.put("ciudad", source.getCity());
      // ...

      return target;
    }
  }

  @ReadingConverter                                                 <i class="conum" data-value="3"></i><b>(3)</b>
  static class MapToAddress implements Converter&lt;Map&lt;String, Object&gt;, Address&gt; {

    @Override
    public Address convert(Map&lt;String, Object&gt; source) {

      // ...
      return address;
    }
  }
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "ciudad" : "Los Angeles",
  "calle" : "2800 East Observatory Road",
  "localidad" : { "lat" : 34.118347, "lon" : -118.3026284 }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>添加 <code>Converter</code> 实现.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置将 <code>DomainType</code> 类型写入到 Elasticsearch  的 <code>Converter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>设置从搜索结果中读取到 <code>DomainType</code> 类型的 <code>Converter</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elasticsearch.operations"><a class="anchor" href="#elasticsearch.operations"></a>7. Elasticsearch 操作</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data Elasticsearch 使用几个接口来定义对 Elasticsearch 索引调用的操作(有关响应式接口的描述,请参阅 <a href="#elasticsearch.reactive.operations">Reactive Elasticsearch 操作</a>).</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IndexOperations</code> 定义索引的动作,例如创建和删除索引</p>
</li>
<li>
<p><code>DocumentOperations</code> 定义根据实体 id 存储,更新和检索文档实体的操作</p>
</li>
<li>
<p><code>SearchOperations</code> 定义使用查询来搜索多个实体的动作</p>
</li>
<li>
<p><code>ElasticsearchOperations</code> 结合了 <code>DocumentOperations</code> 和 <code>SearchOperations</code> 接口.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些接口与 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/rest-apis.html">Elasticsearch API</a> 相对应.</p>
</div>
<div class="paragraph">
<p>接口的默认实现提供:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>管理索引.</p>
</li>
<li>
<p>domain 类型的读写映射.</p>
</li>
<li>
<p>丰富的查询和条件 API.</p>
</li>
<li>
<p>资源管理和异常转化.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<div class="title">索引管理以及自动创建索引和映射.</div>
<p>可以从 <code>ElasticsearchOperations</code> 接口中获得 <code>IndexOperations</code> 接口和其实现类 - 例如,调用  <code>operations.indexOps(clazz)</code>- 可以使用户能够创建索引, put mappings 或 store template 和 Elasticsearch 集群中的别名信息.</p>
</div>
<div class="paragraph">
<p><strong>这些操作都不是由</strong>  <code>IndexOperations</code> 或 <code>ElasticsearchOperations</code> 的实现自动完成的.  调用方法是用户的责任.</p>
</div>
<div class="paragraph">
<p>使用 Spring Data Elasticsearch repositories 时支持自动创建索引和写入映射,  请参见  <a href="#elasticsearch.repositories.autocreation">自动创建具有相应映射的索引</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="elasticsearch.operations.template"><a class="anchor" href="#elasticsearch.operations.template"></a>7.1. ElasticsearchTemplate</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从 4.0 版开始不推荐使用 ElasticsearchTemplate , 建议使用 ElasticsearchRestTemplate 替代.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ElasticsearchTemplate</code> 使用了 <a href="#elasticsearch.clients.transport">Transport Client</a> ,并实现了 <code>ElasticsearchOperations</code> 接口.</p>
</div>
<div class="exampleblock">
<div class="title">Example 75. ElasticsearchTemplate 配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class TransportClientConfig extends ElasticsearchConfigurationSupport {

  @Bean
  public Client elasticsearchClient() throws UnknownHostException {                 <i class="conum" data-value="1"></i><b>(1)</b>
    Settings settings = Settings.builder().put("cluster.name", "elasticsearch").build();
    TransportClient client = new PreBuiltTransportClient(settings);
    client.addTransportAddress(new TransportAddress(InetAddress.getByName("127.0.0.1"), 9300));
    return client;
  }

  @Bean(name = {"elasticsearchOperations", "elasticsearchTemplate"})
  public ElasticsearchTemplate elasticsearchTemplate() throws UnknownHostException { <i class="conum" data-value="2"></i><b>(2)</b>
    return new ElasticsearchTemplate(elasticsearchClient());
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置 <a href="#elasticsearch.clients.transport">Transport Client</a>. 从 4.0 版本开始废弃.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建 <code>ElasticsearchTemplate</code> bean, 并提供两个命名, <em>elasticsearchOperations</em> 和 <em>elasticsearchTemplate</em>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.operations.resttemplate"><a class="anchor" href="#elasticsearch.operations.resttemplate"></a>7.2. ElasticsearchRestTemplate</h3>
<div class="paragraph">
<p><code>ElasticsearchRestTemplate</code> 使用了 <a href="#elasticsearch.clients.rest">更高级别的 REST Client</a> 并实现了 <code>ElasticsearchOperations</code> 接口.</p>
</div>
<div class="exampleblock">
<div class="title">Example 76. ElasticsearchRestTemplate 配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class RestClientConfig extends AbstractElasticsearchConfiguration {
  @Override
  public RestHighLevelClient elasticsearchClient() {       <i class="conum" data-value="1"></i><b>(1)</b>
    return RestClients.create(ClientConfiguration.localhost()).rest();
  }

  // no special bean creation needed                       <i class="conum" data-value="2"></i><b>(2)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>设置 <a href="#elasticsearch.clients.rest">更高级别的 REST Client</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>AbstractElasticsearchConfiguration</code> 已经提供了 <code>elasticsearchTemplate</code> bean.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.operations.usage"><a class="anchor" href="#elasticsearch.operations.usage"></a>7.3. 使用案例</h3>
<div class="paragraph">
<p>因为 <code>ElasticsearchTemplate</code> 和 <code>ElasticsearchRestTemplate</code> 都实现了 <code>ElasticsearchOperations</code> 接口,所以在使用它们时的代码没有什么不同.这个例子展示了如何在 Spring REST 控制器中使用 <code>ElasticsearchOperations</code> 实例.如果使用的是 <code>TransportClient</code> 或 <code>RestClient</code>,则可以通过为相应的 Bean 提供上面所示的配置之一来做出决定.</p>
</div>
<div class="exampleblock">
<div class="title">Example 77. ElasticsearchOperations usage</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RestController
@RequestMapping("/")
public class TestController {

  private  ElasticsearchOperations elasticsearchOperations;

  public TestController(ElasticsearchOperations elasticsearchOperations) { <i class="conum" data-value="1"></i><b>(1)</b>
    this.elasticsearchOperations = elasticsearchOperations;
  }

  @PostMapping("/person")
  public String save(@RequestBody Person person) {                         <i class="conum" data-value="2"></i><b>(2)</b>

    IndexQuery indexQuery = new IndexQueryBuilder()
      .withId(person.getId().toString())
      .withObject(person)
      .build();
    String documentId = elasticsearchOperations.index(indexQuery);
    return documentId;
  }

  @GetMapping("/person/{id}")
  public Person findById(@PathVariable("id")  Long id) {                   <i class="conum" data-value="3"></i><b>(3)</b>
    Person person = elasticsearchOperations
      .queryForObject(GetQuery.getById(id.toString()), Person.class);
    return person;
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在构造函数中注入 <code>ElasticsearchOperations</code> bean.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在 Elasticsearch 集群中存储一些 entity.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>通过 id 搜索 entity.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>要查看 <code>ElasticsearchOperations</code> 的全部功能,请参阅 API 文档.</p>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.reactive.operations"><a class="anchor" href="#elasticsearch.reactive.operations"></a>7.4. Reactive Elasticsearch 操作</h3>
<div class="paragraph">
<p><code>ReactiveElasticsearchOperations</code> 是使用 <code>ReactiveElasticsearchClient</code> 对 Elasticsearch 集群执行高级命令的网关..</p>
</div>
<div class="paragraph">
<p><code>ReactiveElasticsearchTemplate</code> 是 <code>ReactiveElasticsearchOperations</code> 的默认实现.</p>
</div>
<div class="sect3">
<h4 id="elasticsearch.reactive.template"><a class="anchor" href="#elasticsearch.reactive.template"></a>7.4.1. Reactive Elasticsearch Template</h4>
<div class="paragraph">
<p>在使用 <code>ReactiveElasticsearchTemplate</code> 之前,需要先了解要使用的实际客户端,有关客户端的详细信息,请参见  <a href="#elasticsearch.clients.reactive">Reactive Client</a> .</p>
</div>
<div class="sect4">
<h5 id="elasticsearch.reactive.template.configuration"><a class="anchor" href="#elasticsearch.reactive.template.configuration"></a>Reactive Template 配置</h5>
<div class="paragraph">
<p>配置 <code>ReactiveElasticsearchTemplate</code> 最简单的方法就是通过 <code>AbstractReactiveElasticsearchConfiguration</code> 提供的
配置方法配置 <code>base package</code>, <code>initial entity set</code> 等.</p>
</div>
<div class="exampleblock">
<div class="title">Example 78. The AbstractReactiveElasticsearchConfiguration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class Config extends AbstractReactiveElasticsearchConfiguration {

  @Bean <i class="conum" data-value="1"></i><b>(1)</b>
  @Override
  public ReactiveElasticsearchClient reactiveElasticsearchClient() {
      // ...
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>配置要使用的客户端. 这可以由 <code>ReactiveRestClients</code> 或直接通过 <code>DefaultReactiveElasticsearchClient</code> 完成.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果要适用默认的`HttpHeaders` ,可以通过  <code>ReactiveElasticsearchClient</code> 的 <code>ClientConfiguration</code> 设置. 请参考 <a href="#elasticsearch.clients.configuration">Client 配置</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果需要配置 <code>ReactiveElasticsearchTemplate</code> 默认的 <code>RefreshPolicy</code> 和 <code>IndicesOptions</code> ,可以通过覆盖 <code>refreshPolicy()</code> 和 <code>indicesOptions()</code> 方法设置.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>但是,可能需要更多地控制实际组件,并使用更详细的方法.</p>
</div>
<div class="exampleblock">
<div class="title">Example 79. Configure the ReactiveElasticsearchTemplate</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class Config {

  @Bean <i class="conum" data-value="1"></i><b>(1)</b>
  public ReactiveElasticsearchClient reactiveElasticsearchClient() {
    // ...
  }
  @Bean <i class="conum" data-value="2"></i><b>(2)</b>
  public ElasticsearchConverter elasticsearchConverter() {
    return new MappingElasticsearchConverter(elasticsearchMappingContext());
  }
  @Bean <i class="conum" data-value="3"></i><b>(3)</b>
  public SimpleElasticsearchMappingContext elasticsearchMappingContext() {
    return new SimpleElasticsearchMappingContext();
  }
  @Bean <i class="conum" data-value="4"></i><b>(4)</b>
  public ReactiveElasticsearchOperations reactiveElasticsearchOperations() {
    return new ReactiveElasticsearchTemplate(reactiveElasticsearchClient(), elasticsearchConverter());
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>配置要使用的客户端. 这可以由 <code>ReactiveRestClients</code> 或直接通过 <code>DefaultReactiveElasticsearchClient</code> 完成.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用映射上下文提供的元数据设置来提供 doamin 类型映射的 <code>ElasticsearchConverter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>特定于 Elasticsearch 的 domain 类型元数据映射上下文.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>基于 client 和 conversion 结构的真实 template.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="elasticsearch.reactive.template.usage"><a class="anchor" href="#elasticsearch.reactive.template.usage"></a>Reactive Template 使用</h5>
<div class="paragraph">
<p><code>ReactiveElasticsearchTemplate</code> 使您可以保存,查找和删除 domain 对象,并将这些对象映射到存储在 Elasticsearch 中的文档..</p>
</div>
<div class="paragraph">
<p>如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 80. Use the ReactiveElasticsearchTemplate</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Document(indexName = "marvel")
public class Person {

  private @Id String id;
  private String name;
  private int age;
  // Getter/Setter omitted...
}
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">template.save(new Person("Bruce Banner", 42))                    <i class="conum" data-value="1"></i><b>(1)</b>
  .doOnNext(System.out::println)
  .flatMap(person -&gt; template.findById(person.id, Person.class)) <i class="conum" data-value="2"></i><b>(2)</b>
  .doOnNext(System.out::println)
  .flatMap(person -&gt; template.delete(person))                    <i class="conum" data-value="3"></i><b>(3)</b>
  .doOnNext(System.out::println)
  .flatMap(id -&gt; template.count(Person.class))                   <i class="conum" data-value="4"></i><b>(4)</b>
  .doOnNext(System.out::println)
  .subscribe(); <i class="conum" data-value="5"></i><b>(5)</b>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的输出如下.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">&gt; Person(id=QjWCWWcBXiLAnp77ksfR, name=Bruce Banner, age=42)
&gt; Person(id=QjWCWWcBXiLAnp77ksfR, name=Bruce Banner, age=42)
&gt; QjWCWWcBXiLAnp77ksfR
&gt; 0</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将一个新的 <code>Person</code> 文档插入到 <em>marvel</em> 索引下,类型为字符串. <code>id</code> 由服务端自动生成并返回实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在  <em>marvel</em>  索引中查找匹配 <code>id</code> 的 <code>Person</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在  <em>marvel</em>  索引中删除匹配 <code>id</code> 的 <code>Person</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>计算 <em>marvel</em> 索引下的文档总数.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>不要忘记了 <em>subscribe()</em>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.operations.searchresulttypes"><a class="anchor" href="#elasticsearch.operations.searchresulttypes"></a>7.5. 搜索结果类型</h3>
<div class="paragraph">
<p>使用 <code>DocumentOperations</code> 接口的方法搜索文档时,只返回匹配的实体. 使用 <code>SearchOperations</code> 接口的方法进行搜索时,每个实体都有额外的其他附加信息,例如,找到的的实体具有  <em>score</em> 或 <em>sortValues</em>.</p>
</div>
<div class="paragraph">
<p>为了返回此信息,每个实体都包装在一个 <code>SearchHit</code> 对象中,该对象包含该特定于实体的附加信息. 这些 <code>SearchHit</code> 对象本身在 <code>SearchHits</code> 对象中返回,该对象还包含有关整个搜索的信息,例如 <em>maxScore</em>  或请求的聚合. 现在可以使用以下类和接口:</p>
</div>
<div class="paragraph">
<div class="title">SearchHit&lt;T&gt;</div>
<p>包含以下信息:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Id</p>
</li>
<li>
<p>Score</p>
</li>
<li>
<p>Sort Values</p>
</li>
<li>
<p>Highlight fields</p>
</li>
<li>
<p>Inner hits (this is an embedded <code>SearchHits</code> object containing eventually returned inner hits)</p>
</li>
<li>
<p>The retrieved entity of type &lt;T&gt;</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">SearchHits&lt;T&gt;</div>
<p>包含以下信息:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Number of total hits</p>
</li>
<li>
<p>Total hits relation</p>
</li>
<li>
<p>Maximum score</p>
</li>
<li>
<p>A list of <code>SearchHit&lt;T&gt;</code> objects</p>
</li>
<li>
<p>Returned aggregations</p>
</li>
</ul>
</div>
<div class="paragraph">
<div class="title">SearchPage&lt;T&gt;</div>
<p>定义一个包含 <code>SearchHits&lt;T&gt;</code> 的 Spring Data <code>Page</code> 可以使用存储库方法进行分页访问..</p>
</div>
<div class="paragraph">
<div class="title">SearchScrollHits&lt;T&gt;</div>
<p>由 <code>ElasticsearchRestTemplate</code> 中的低级 scroll API 函数返回,它使用 Elasticsearch scroll ID 丰富了 <code>SearchHits&lt;T&gt;</code>.</p>
</div>
<div class="paragraph">
<div class="title">SearchHitsIterator&lt;T&gt;</div>
<p>由 <code>SearchOperations</code> 接口返回一个可迭代的流(Stream).</p>
</div>
</div>
<div class="sect2">
<h3 id="queries"><a class="anchor" href="#queries"></a>7.6. Queries</h3>
<div class="paragraph">
<p>几乎在 <code>SearchOperations</code> 和 <code>ReactiveSearchOperations</code> 接口中定义的所有方法都采用 <code>Query</code> 参数,  该参数定义要执行的查询以进行搜索.  <code>Query</code> 是一个接口,  Spring Data Elasticsearch 提供了三种实现: <code>CriteriaQuery</code>,  <code>StringQuery</code> 和 <code>NativeSearchQuery</code>.</p>
</div>
<div class="sect3">
<h4 id="criteriaquery"><a class="anchor" href="#criteriaquery"></a>7.6.1. CriteriaQuery</h4>
<div class="paragraph">
<p>基于 <code>CriteriaQuery</code> 的查询允许创建查询来搜索数据,  而无需了解 Elasticsearch 查询的语法或基础知识.  它们允许用户通过简单地链接和组合 <code>Criteria</code> 对象来构建查询,  这些对象指定了搜索文档必须满足的条件.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在谈论 AND 或 OR 时,  请牢记组合条件 在 Elasticsearch 中, AND 会被转换为 <strong>must</strong> 条件, OR 会被转换为 <strong>should</strong>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最好通过示例来说明 <code>Criteria</code> 的用法.(假设我们有一个具有 <code>price</code> 属性的 <code>Book</code> 实体):</p>
</div>
<div class="exampleblock">
<div class="title">Example 81. Get books with a given price</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Criteria criteria = new Criteria("price").is(42.0);
Query query = new CriteriaQuery(criteria);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以链接同一字段的条件,  这些条件将与逻辑 AND 相结合:</p>
</div>
<div class="exampleblock">
<div class="title">Example 82. Get books with a given price</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Criteria criteria = new Criteria("price").greaterThan(42.0).lessThan(34.0L);
Query query = new CriteriaQuery(criteria);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当链接 <code>Criteria</code> 时,  默认情况下使用 AND 逻辑:</p>
</div>
<div class="exampleblock">
<div class="title">Example 83. Get all persons with first name <em>James</em>  and last name <em>Miller</em>:</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Criteria criteria = new Criteria("lastname").is("Miller") <i class="conum" data-value="1"></i><b>(1)</b>
  .and("firstname").is("James")                           <i class="conum" data-value="2"></i><b>(2)</b>
Query query = new CriteriaQuery(criteria);
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>第一个 <code>Criteria</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>and() 创建一个新的 <code>Criteria</code> 并且将其链接到第一个.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果要创建嵌套查询,  则需要为此使用子查询.  假设我们要查找 last name 为 <em>Miller</em> 且 first name 为 <em>Jack</em> 或 <em>John</em> 的所有人:</p>
</div>
<div class="exampleblock">
<div class="title">Example 84. Nested subqueries</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Criteria miller = new Criteria("lastName").is("Miller")  <i class="conum" data-value="1"></i><b>(1)</b>
  .subCriteria(                                          <i class="conum" data-value="2"></i><b>(2)</b>
    new Criteria().or("firstName").is("John")            <i class="conum" data-value="3"></i><b>(3)</b>
      .or("firstName").is("Jack")                        <i class="conum" data-value="4"></i><b>(4)</b>
  );
Query query = new CriteriaQuery(criteria);
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>为 last name 创建第一个 <code>Criteria</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>这与 AND 合并为一个子条件</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>This sub Criteria is an OR combination for the first name <em>John</em></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>and the first name Jack</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>请参阅 <code>Criteria</code> 类的 API 文档以获取有关各种可用操作的完整概述.</p>
</div>
</div>
<div class="sect3">
<h4 id="stringquery"><a class="anchor" href="#stringquery"></a>7.6.2. StringQuery</h4>
<div class="paragraph">
<p>此类将 Elasticsearch 查询作为 JSON 字符串.
以下代码显示了一个查询,  该查询搜索 first name 为 "Jack" 的人:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Query query = new SearchQuery("{ \"match\": { \"firstname\": { \"query\": \"Jack\" } } } ");
SearchHits&lt;Person&gt; searchHits = operations.search(query, Person.class);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您已经有要使用的 Elasticsearch 查询,  则可以使用 <code>StringQuery</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="nativesearchquery"><a class="anchor" href="#nativesearchquery"></a>7.6.3. NativeSearchQuery</h4>
<div class="paragraph">
<p><code>NativeSearchQuery</code> 是当您有复杂查询或无法使用 <code>Criteria</code> API 表示的查询(例如,  在构建查询和使用聚合时)时使用的类.
它允许使用来自 Elasticsearch 库的所有不同的 <code>QueryBuilder</code> 实现,  因此命名为 "native"..</p>
</div>
<div class="paragraph">
<p>下面的代码显示了如何搜索具有给定名字的人,  并且找到的文档具有 terms 聚合,  这些 terms 对这些人的 lastnames 的出现次数进行了计数:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Query query = new NativeSearchQueryBuilder()
    .addAggregation(terms("lastnames").field("lastname").size(10)) //
    .withQuery(QueryBuilders.matchQuery("firstname", firstName))
    .build();

SearchHits&lt;Person&gt; searchHits = operations.search(query, Person.class);
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elasticsearch.repositories"><a class="anchor" href="#elasticsearch.repositories"></a>8. Elasticsearch Repositories</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章包括 Elasticsearch 存储库实现的详细信息.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>Book</code> 实体</p>
</li>
</ol>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Document(indexName="books")
class Book {
    @Id
    private String id;

    @Field(type = FieldType.text)
    private String name;

    @Field(type = FieldType.text)
    private String summary;

    @Field(type = FieldType.Integer)
    private Integer price;

    // getter/setter ...
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.repositories.autocreation"><a class="anchor" href="#elasticsearch.repositories.autocreation"></a>8.1. 自动创建具有相应映射的索引</h3>
<div class="paragraph">
<p><code>@Document</code> 注解有一个 <code>createIndex</code> 参数.  如果此参数设置为 <code>true</code> (这是默认值),  则 Spring Data Elasticsearch 将在引导应用程序启动时引导存储库支持期间检查是否存在由 <code>@Document</code> 注解定义的索引.</p>
</div>
<div class="paragraph">
<p>如果不存在,  则将创建索引,  并且将从实体的注解派生的映射(请参见 <a href="#elasticsearch.mapping">Elasticsearch 对象映射</a>)写入新创建的索引.</p>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.query-methods"><a class="anchor" href="#elasticsearch.query-methods"></a>8.2. 查询方法</h3>
<div class="sect3">
<h4 id="elasticsearch.query-methods.finders"><a class="anchor" href="#elasticsearch.query-methods.finders"></a>8.2.1. 查询方法查找策略</h4>
<div class="paragraph">
<p>Elasticsearch 模块支持所有基本的查询构建特性,如字符串查询、本地搜索查询、基于条件的查询或从方法名扩展的查询.</p>
</div>
<div class="sect4">
<h5 id="声明查询"><a class="anchor" href="#声明查询"></a>声明查询</h5>
<div class="paragraph">
<p>从方法名扩展的查询还远远不够,而且还可能导致不可读的方法名.在这种情况下,可以使用 <code>@Query</code> 注解(请参阅使用 <a href="#elasticsearch.query-methods.at-query">使用 @Query 注解</a>).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch.query-methods.criterions"><a class="anchor" href="#elasticsearch.query-methods.criterions"></a>8.2.2. 创建查询</h4>
<div class="paragraph">
<p>通常,Elasticsearch 的查询创建机制按 <a href="#repositories.query-methods">查询方法</a> 中所述运行. 这是 Elasticsearch 查询方法的转换简短示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 85. 从方法名创建查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface BookRepository extends Repository&lt;Book, String&gt; {
  List&lt;Book&gt; findByNameAndPrice(String name, Integer price);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的方法名称将被转换成以下 Elasticsearch json 查询</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
    "query": {
        "bool" : {
            "must" : [
                { "query_string" : { "query" : "?", "fields" : [ "name" ] } },
                { "query_string" : { "query" : "?", "fields" : [ "price" ] } }
            ]
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Elasticsearch 支持的关键字列表如下.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. 方法名中支持的关键字</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 50.0001%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">关键字</th>
<th class="tableblock halign-left valign-top">示例</th>
<th class="tableblock halign-left valign-top">Elasticsearch Query String</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>And</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByNameAndPrice</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
      { "query_string" : { "query" : "?", "fields" : [ "name" ] } },
      { "query_string" : { "query" : "?", "fields" : [ "price" ] } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Or</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByNameOrPrice</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"should" : [
      { "query_string" : { "query" : "?", "fields" : [ "name" ] } },
      { "query_string" : { "query" : "?", "fields" : [ "price" ] } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Is</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
      { "query_string" : { "query" : "?", "fields" : [ "name" ] } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Not</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByNameNot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must_not" : [
      { "query_string" : { "query" : "?", "fields" : [ "name" ] } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Between</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByPriceBetween</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
    {"range" : {"price" : {"from" : ?, "to" : ?, "include_lower" : true, "include_upper" : true } } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByPriceLessThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
    {"range" : {"price" : {"from" : null, "to" : ?, "include_lower" : true, "include_upper" : false } } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByPriceLessThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
    {"range" : {"price" : {"from" : null, "to" : ?, "include_lower" : true, "include_upper" : true } } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByPriceGreaterThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
    {"range" : {"price" : {"from" : ?, "to" : null, "include_lower" : false, "include_upper" : true } } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThanEqual</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByPriceGreaterThan</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
    {"range" : {"price" : {"from" : ?, "to" : null, "include_lower" : true, "include_upper" : true } } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Before</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByPriceBefore</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
    {"range" : {"price" : {"from" : null, "to" : ?, "include_lower" : true, "include_upper" : true } } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>After</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByPriceAfter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
    {"range" : {"price" : {"from" : ?, "to" : null, "include_lower" : true, "include_upper" : true } } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Like</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByNameLike</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
      { "query_string" : { "query" : "?*", "fields" : [ "name" ] }, "analyze_wildcard": true }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StartingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByNameStartingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
      { "query_string" : { "query" : "?*", "fields" : [ "name" ] }, "analyze_wildcard": true }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EndingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByNameEndingWith</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
      { "query_string" : { "query" : "*?", "fields" : [ "name" ] }, "analyze_wildcard": true }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Contains/Containing</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByNameContaining</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
      { "query_string" : { "query" : "*?*", "fields" : [ "name" ] }, "analyze_wildcard": true }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>In</code> (when annotated as FieldType.Keyword)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByNameIn(Collection&lt;String&gt;names)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
      {"bool" : {"must" : [
            {"terms" : {"name" : ["?","?"]}}
          ]
        }
      }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>In</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByNameIn(Collection&lt;String&gt;names)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query": {"bool": {"must": [{"query_string":{"query": "\"?\" \"?\"", "fields": ["name"]}}]}}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotIn</code>  (when annotated as FieldType.Keyword)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByNameNotIn(Collection&lt;String&gt;names)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
      {"bool" : {"must_not" : [
            {"terms" : {"name" : ["?","?"]}}
          ]
        }
      }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotIn</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByNameNotIn(Collection&lt;String&gt;names)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{"query": {"bool": {"must": [{"query_string": {"query": "NOT(\"?\" \"?\")", "fields": ["name"]}}]}}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Near</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByStoreNear</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Not Supported Yet !</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>True</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAvailableTrue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
      { "query_string" : { "query" : "true", "fields" : [ "available" ] } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>False</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAvailableFalse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
      { "query_string" : { "query" : "false", "fields" : [ "available" ] } }
    ]
  }
}}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OrderBy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAvailableTrueOrderByNameDesc</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "query" : {
"bool" : {
"must" : [
      { "query_string" : { "query" : "true", "fields" : [ "available" ] } }
    ]
  }
}, "sort":[{"name":{"order":"desc"}}]
}</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
不支持使用 <code>GeoJson</code> 参数构建 Geo-shape 查询的方法名称.
如果需要在存储库中具有这样的功能,  请在自定义存储库实现中将 <code>ElasticsearchOperations</code> 与 <code>CriteriaQuery</code> 一起使用.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="方法返回类型"><a class="anchor" href="#方法返回类型"></a>8.2.3. 方法返回类型</h4>
<div class="paragraph">
<p>Repository 可以定义为以下类型来返回多个元素:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>List&lt;T&gt;</code></p>
</li>
<li>
<p><code>Stream&lt;T&gt;</code></p>
</li>
<li>
<p><code>SearchHits&lt;T&gt;</code></p>
</li>
<li>
<p><code>List&lt;SearchHit&lt;T&gt;&gt;</code></p>
</li>
<li>
<p><code>Stream&lt;SearchHit&lt;T&gt;&gt;</code></p>
</li>
<li>
<p><code>SearchPage&lt;T&gt;</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch.query-methods.at-query"><a class="anchor" href="#elasticsearch.query-methods.at-query"></a>8.2.4. 使用 @Query 注解</h4>
<div class="exampleblock">
<div class="title">Example 86. 在方法上使用 <code>@Query</code> 注解声明查询.</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface BookRepository extends ElasticsearchRepository&lt;Book, String&gt; {
    @Query("{\"match\": {\"name\": {\"query\": \"?0\"}}}")
    Page&lt;Book&gt; findByName(String name,Pageable pageable);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>注解参数 String 必须是一个有效的 Elasticsearch JSON 查询.它将会作为 query 元素的 value 发送到 Elasticsearch 中;  例如,如果使用参数 <em>John</em> 调用该函数,它将产生以下查询内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "query": {
    "match": {
      "name": {
        "query": "John"
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.reactive.repositories"><a class="anchor" href="#elasticsearch.reactive.repositories"></a>8.3. Reactive Elasticsearch Repositories</h3>
<div class="paragraph">
<p>响应式 Elasticsearch 存储库支持建立在核心存储库支持的基础上,在使用  <a href="#repositories">使用 Spring Data Repositories</a> 时解释了如何利用 <a href="#elasticsearch.clients.reactive">Reactive Client</a> 执行的 <a href="#elasticsearch.reactive.operations">Reactive Elasticsearch 操作</a> 提供的操作.</p>
</div>
<div class="paragraph">
<p>Spring Data Elasticsearch 响应式存储库支持使用 <a href="https://projectreactor.io/">Project Reactor</a> 作为其响应式组合库的选择.</p>
</div>
<div class="paragraph">
<p>主要使用 3 个接口:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ReactiveRepository</code></p>
</li>
<li>
<p><code>ReactiveCrudRepository</code></p>
</li>
<li>
<p><code>ReactiveSortingRepository</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="elasticsearch.reactive.repositories.usage"><a class="anchor" href="#elasticsearch.reactive.repositories.usage"></a>8.3.1. 使用</h4>
<div class="paragraph">
<p>要使用 <code>Repository</code> 访问存储在 Elasticsearch 中的 domain 对象,只需为其创建一个接口.另外,您将需要一个实体.</p>
</div>
<div class="exampleblock">
<div class="title">Example 87. <code>Person</code> 实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Person {

  @Id
  private String id;
  private String firstname;
  private String lastname;
  private Address address;

  // … getters and setters omitted
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请注意 <code>id</code> 属性的类型必须是 <code>String</code>.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 88. 创建 repository interface 来持久化 Person 实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>interface ReactivePersonRepository extends ReactiveSortingRepository&lt;Person, String&gt; {

  Flux&lt;Person&gt; findByFirstname(String firstname);                                   <i class="conum" data-value="1"></i><b>(1)</b>

  Flux&lt;Person&gt; findByFirstname(Publisher&lt;String&gt; firstname);                        <i class="conum" data-value="2"></i><b>(2)</b>

  Flux&lt;Person&gt; findByFirstnameOrderByLastname(String firstname);                    <i class="conum" data-value="3"></i><b>(3)</b>

  Flux&lt;Person&gt; findByFirstname(String firstname, Sort sort);                        <i class="conum" data-value="4"></i><b>(4)</b>

  Flux&lt;Person&gt; findByFirstname(String firstname, Pageable page);                    <i class="conum" data-value="5"></i><b>(5)</b>

  Mono&lt;Person&gt; findByFirstnameAndLastname(String firstname, String lastname);       <i class="conum" data-value="6"></i><b>(6)</b>

  Mono&lt;Person&gt; findFirstByLastname(String lastname);                                <i class="conum" data-value="7"></i><b>(7)</b>

  @Query("{ \"bool\" : { \"must\" : { \"term\" : { \"lastname\" : \"?0\" } } } }")
  Flux&lt;Person&gt; findByLastname(String lastname);                                     <i class="conum" data-value="8"></i><b>(8)</b>

  Mono&lt;Long&gt; countByFirstname(String firstname)                                     <i class="conum" data-value="9"></i><b>(9)</b>

  Mono&lt;Boolean&gt; existsByFirstname(String firstname)                                 <i class="conum" data-value="10"></i><b>(10)</b>

  Mono&lt;Long&gt; deleteByFirstname(String firstname)                                    <i class="conum" data-value="11"></i><b>(11)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>根据 <code>lastname</code> 查询匹配的所有人.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>等待 <code>Publisher</code> 输入,为 <code>firstname</code> 绑定参数值.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>按 <code>lastname</code> 进行排序.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>按照 <code>Sort</code> 定义的排序规则进行排序.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>使用 <code>Pageable</code> 进行分页.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>使用 <code>And</code> / <code>Or</code> 关键字进行条件查询.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>查找第一个匹配的实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>根据 <code>lastname</code> 查询匹配的所有人, 方法使用 <code>@Query</code> 注解参数进行查询.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>计算所有匹配 <code>firstname</code> 的实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>检查是否至少存在一个与 <code>firstname</code> 匹配的实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>删除所有与 <code>firstname</code> 匹配的实体.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch.reactive.repositories.configuration"><a class="anchor" href="#elasticsearch.reactive.repositories.configuration"></a>8.3.2. 配置</h4>
<div class="paragraph">
<p>对于 Java 配置,请使用 <code>@EnableReactiveElasticsearchRepositories</code> 注解. 如果未配置 base package,则 SpringBoor 将扫描带 configuration 注解的类所在的包.</p>
</div>
<div class="paragraph">
<p>下面展示了如何使用 Java 配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 89. Java configuration for repositories</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableReactiveElasticsearchRepositories
public class Config extends AbstractReactiveElasticsearchConfiguration {

  @Override
  public ReactiveElasticsearchClient reactiveElasticsearchClient() {
    return ReactiveRestClients.create(ClientConfiguration.localhost());
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于上一个示例中的存储库扩展了 <code>ReactiveSortingRepository</code>,因此所有 CRUD 操作以及对实体的排序方法都可用. 使用存储库实例是将其注入客户端的依赖,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 90. Sorted access to Person entities</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class PersonRepositoryTests {

  @Autowired ReactivePersonRepository repository;

  @Test
  public void sortsElementsCorrectly() {

    Flux&lt;Person&gt; persons = repository.findAll(Sort.by(new Order(ASC, "lastname")));

    // ...
  }
}
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.repositories.annotations"><a class="anchor" href="#elasticsearch.repositories.annotations"></a>8.4. repository 方法注解</h3>
<div class="sect3">
<h4 id="highlight"><a class="anchor" href="#highlight"></a>8.4.1. @Highlight</h4>
<div class="paragraph">
<p><code>@Highlight</code> 注解定义了返回实体中那些字段需要高亮显示. 假如要在 <code>Book</code> 中将一些文本的 name 和 summary 高亮显示,可以使用一下存储库方法.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface BookRepository extends Repository&lt;Book, String&gt; {

    @Highlight(fields = {
        @HighlightField(name = "name"),
        @HighlightField(name = "summary")
    })
    List&lt;SearchHit&lt;Book&gt;&gt; findByNameOrSummary(String text, String summary);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以定义多个像上面那样高亮显示的字段,并且 <code>@Highlight</code> 和 <code>@HighlightField</code> 注解都可以通过 <code>@HighlightParameters</code> 注解进一步定制.查看 Javadocs 以获得可能的配置选项.</p>
</div>
<div class="paragraph">
<p>在搜索结果中,可以从 <code>SearchHit</code> 类中检索高亮显示的数据.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.annotation"><a class="anchor" href="#elasticsearch.annotation"></a>8.5. 基于注解的配置</h3>
<div class="paragraph">
<p>Spring Data Elasticsearch repositories 可以通过 JavaConfig 使用注解来启用.</p>
</div>
<div class="exampleblock">
<div class="title">Example 91. Spring Data Elasticsearch repositories using JavaConfig</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableElasticsearchRepositories(                             <i class="conum" data-value="1"></i><b>(1)</b>
  basePackages = "org.springframework.data.elasticsearch.repositories"
  )
static class Config {

  @Bean
  public ElasticsearchOperations elasticsearchTemplate() {    <i class="conum" data-value="2"></i><b>(2)</b>
      // ...
  }
}

class ProductService {

  private ProductRepository repository;                       <i class="conum" data-value="3"></i><b>(3)</b>

  public ProductService(ProductRepository repository) {
    this.repository = repository;
  }

  public Page&lt;Product&gt; findAvailableBookByName(String name, Pageable pageable) {
    return repository.findByAvailableTrueAndNameStartingWith(name, pageable);
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>EnableElasticsearchRepositories</code> 启用 Repository 支持. 如果没有配置 base package, 它将使用放在上面的配置类之一.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 <a href="#elasticsearch.operations">Elasticsearch 操作</a> 一章中显示的配置之一 提供一个名为 <code>elasticsearchTemplate</code> 的 <code>ElasticsearchOperations</code> bean</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>让 Spring 将 Repository bean 注入到您的类中.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.cdi"><a class="anchor" href="#elasticsearch.cdi"></a>8.6. Elasticsearch Repositories 使用 CDI</h3>
<div class="paragraph">
<p>还可以使用 CDI 功能设置 Spring Data Elasticsearch 存储库.</p>
</div>
<div class="exampleblock">
<div class="title">Example 92. Spring Data Elasticsearch repositories using CDI</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class ElasticsearchTemplateProducer {

  @Produces
  @ApplicationScoped
  public ElasticsearchOperations createElasticsearchTemplate() {
    // ...                               <i class="conum" data-value="1"></i><b>(1)</b>
  }
}

class ProductService {

  private ProductRepository repository;  <i class="conum" data-value="2"></i><b>(2)</b>
  public Page&lt;Product&gt; findAvailableBookByName(String name, Pageable pageable) {
    return repository.findByAvailableTrueAndNameStartingWith(name, pageable);
  }
  @Inject
  public void setRepository(ProductRepository repository) {
    this.repository = repository;
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>通过使用与 <a href="#elasticsearch.operations">Elasticsearch 操作</a> 一章中相同的方式来创建组件.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>让 CDI 框架将存储库注入到您的类中.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.namespace"><a class="anchor" href="#elasticsearch.namespace"></a>8.7. Spring 命名空间</h3>
<div class="paragraph">
<p>Spring Data Elasticsearch 模块包含一个自定义命名空间,允许定义存储库 bean 以及用于实例化 <code>ElasticsearchServer</code> 的元素.</p>
</div>
<div class="paragraph">
<p>如 <a href="#repositories.create-instances">创建存储库实例</a> 中所述,使用 <code>repositories</code> 元素查找 Spring Data 存储库.</p>
</div>
<div class="exampleblock">
<div class="title">Example 93. Setting up Elasticsearch repositories using Namespace</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:elasticsearch="http://www.springframework.org/schema/data/elasticsearch"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans-3.1.xsd
       http://www.springframework.org/schema/data/elasticsearch
       https://www.springframework.org/schema/data/elasticsearch/spring-elasticsearch-1.0.xsd"&gt;

  &lt;elasticsearch:repositories base-package="com.acme.repositories" /&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>Transport Client</code> 或 <code>Rest Client</code> 元素在上下文注册 <code>Elasticsearch Server</code> 实例.</p>
</div>
<div class="exampleblock">
<div class="title">Example 94. Transport Client using Namespace</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:elasticsearch="http://www.springframework.org/schema/data/elasticsearch"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans-3.1.xsd
       http://www.springframework.org/schema/data/elasticsearch
       https://www.springframework.org/schema/data/elasticsearch/spring-elasticsearch-1.0.xsd"&gt;

  &lt;elasticsearch:transport-client id="client" cluster-nodes="localhost:9300,someip:9300" /&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 95. Rest Client using Namespace</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:elasticsearch="http://www.springframework.org/schema/data/elasticsearch"
       xsi:schemaLocation="http://www.springframework.org/schema/data/elasticsearch
       https://www.springframework.org/schema/data/elasticsearch/spring-elasticsearch.xsd
       http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

  &lt;elasticsearch:rest-client id="restClient" hosts="http://localhost:9200"&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="auditing"><a class="anchor" href="#auditing"></a>9. 审计</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="auditing.basics"><a class="anchor" href="#auditing.basics"></a>9.1. 基础</h3>
<div class="paragraph">
<p>Spring Data 提供了完善的支持,可以透明地跟踪创建或更改实体的人员以及更改发生的时间.  要利用该功能,您必须为实体类配备审核元数据,该审核元数据可以使用注解或通过实现接口来定义.</p>
</div>
<div class="paragraph">
<p>此外， 必须通过注解配置或 XML 配置启用审核， 以注册所需的基础结构组件.
请参阅特定的存储库部分来获取帮助.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>仅跟踪创建和修改日期的应用程序不需要指定 <a href="#auditing.auditor-aware"><code>AuditorAware</code></a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="auditing.annotations"><a class="anchor" href="#auditing.annotations"></a>9.1.1. 基于注解的审核元数据</h4>
<div class="paragraph">
<p>我们提供 <code>@CreatedBy</code> 和 <code>@LastModifiedBy</code> 来捕获创建或修改实体的用户,并提供 <code>@CreatedDate</code> 和 <code>@LastModifiedDate</code> 来捕获更改发生的时间.</p>
</div>
<div class="exampleblock">
<div class="title">Example 96. 被审计实体</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Customer {

  @CreatedBy
  private User user;

  @CreatedDate
  private Instant createdDate;

  // … further properties omitted
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见,可以根据要捕获的信息有选择地应用注解.  捕获更改时捕获的注解可用于类型 <code>Joda-Time</code>,<code>DateTime</code>,旧版 Java <code>Date</code> 和 <code>Calendar</code>,JDK8 日期和时间类型以及 <code>long</code> 或 <code>Long</code> 的属性.</p>
</div>
<div class="paragraph">
<p>审计的元数据并不一定要存在于根级实体中， 而是可以添加内嵌的元数据 (取决于所使用的实际存储) ， 如下面的片段所示.</p>
</div>
<div class="exampleblock">
<div class="title">Example 97. Audit metadata in embedded entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Customer {

  private AuditMetadata auditingMetadata;

  // … further properties omitted
}

class AuditMetadata {

  @CreatedBy
  private User user;

  @CreatedDate
  private Instant createdDate;

}
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="auditing.interfaces"><a class="anchor" href="#auditing.interfaces"></a>9.1.2. 基于接口的审核元数据</h4>
<div class="paragraph">
<p>如果您不想使用注解来定义审核元数据,则可以让您的 domain 类实现 <code>Auditable</code> 接口.  它为所有审核属性暴露了setter方法.</p>
</div>
<div class="paragraph">
<p>还有一个便捷的基类 <code>AbstractAuditable</code>,可以对其进行扩展,以避免需要手动实现接口方法.  这样做会增加您的 domain 类与 Spring Data 的耦合,这可能是您要避免的事情.  通常,首选基于注解的方式来定义审核元数据,因为它侵入性较小且更灵活.</p>
</div>
</div>
<div class="sect3">
<h4 id="auditing.auditor-aware"><a class="anchor" href="#auditing.auditor-aware"></a>9.1.3. <code>AuditorAware</code></h4>
<div class="paragraph">
<p>如果使用 <code>@CreatedBy</code> 或 <code>@LastModifiedBy</code>,则审计基础结构需要以某种方式了解当前的主体.  为此,我们提供了 <code>AuditorAware&lt;T&gt;</code> SPI 接口,您必须实现该接口以告知基础结构与应用程序交互的当前用户或系统是谁.
通用类型T定义必须使用 <code>@CreatedBy</code> 或 <code>@LastModifiedBy</code> 注解的属性的类型.</p>
</div>
<div class="paragraph">
<p>以下示例显示了使用 Spring Security 的 <code>Authentication</code> 对象的接口的实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 98. 基于 Spring Security 的 <code>AuditorAware</code> 的实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class SpringSecurityAuditorAware implements AuditorAware&lt;User&gt; {

  @Override
  public Optional&lt;User&gt; getCurrentAuditor() {

    return Optional.ofNullable(SecurityContextHolder.getContext())
            .map(SecurityContext::getAuthentication)
            .filter(Authentication::isAuthenticated)
            .map(Authentication::getPrincipal)
            .map(User.class::cast);
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该实现访问 Spring Security 提供的 <code>Authentication</code> 对象,并查找您在 <code>UserDetailsService</code> 实现中创建的自定义 <code>UserDetails</code> 实例.  我们在这里假设您通过 <code>UserDetails</code> 实现暴露 domain 用户,但是根据找到的 <code>Authentication</code>,您还可以从任何地方查找它.</p>
</div>
</div>
<div class="sect3">
<h4 id="auditing.reactive-auditor-aware"><a class="anchor" href="#auditing.reactive-auditor-aware"></a>9.1.4. <code>ReactiveAuditorAware</code></h4>
<div class="paragraph">
<p>当使用响应式时， 您可能想利用上下文信息来提供 <code>@CreatedBy</code> 或 <code>@LastModifiedBy</code> 信息.
我们提供了一个 <code>ReactiveAuditorAware&lt;T&gt;</code> SPI 接口， 您必须实现该接口通知应用程序交互的当前用户或系统是谁.  通用类型 <code>T</code> 定义必须使用 <code>@CreatedBy</code> 或 <code>@LastModifiedBy</code> 注解的属性的类型.</p>
</div>
<div class="paragraph">
<p>以下示例显示了使用响应式 Spring Security 的 <code>Authentication</code> 对象的接口的实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 99. 基于 Spring Security 的 <code>ReactiveAuditorAware</code> 实现</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class SpringSecurityAuditorAware implements ReactiveAuditorAware&lt;User&gt; {

  @Override
  public Mono&lt;User&gt; getCurrentAuditor() {

    return ReactiveSecurityContextHolder.getContext()
                .map(SecurityContext::getAuthentication)
                .filter(Authentication::isAuthenticated)
                .map(Authentication::getPrincipal)
                .map(User.class::cast);
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该实现访问 Spring Security 提供的 <code>Authentication</code> 对象,并查找您在 <code>UserDetailsService</code> 实现中创建的自定义 <code>UserDetails</code> 实例.  我们在这里假设您通过 <code>UserDetails</code> 实现暴露 domain 用户,但是根据找到的 <code>Authentication</code>,您还可以从任何地方查找它.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.auditing"><a class="anchor" href="#elasticsearch.auditing"></a>9.2. Elasticsearch 审计</h3>
<div class="sect3">
<h4 id="准备实体"><a class="anchor" href="#准备实体"></a>9.2.1. 准备实体</h4>
<div class="paragraph">
<p>为了让审计代码能够判断一个实体实例是否是最新的,这个实体必须实现 <code>Persistable&lt;ID&gt;</code> 接口,定义如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block">package org.springframework.data.domain;

</span><span class="fold-block hide-when-folded">import org.springframework.lang.Nullable;

</span><span class="fold-block">public interface Persistable&lt;ID&gt; {
    @Nullable
    ID getId();

    boolean isNew();
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 Id 的存在不能够确定在 Elasticsearch 中实体是否是最新实体,所以我们还需一些附加信息. 一种方法是使用与创建审计相关的字段进行确定:</p>
</div>
<div class="paragraph">
<p>一个 <code>Person</code> 实体可能如下所示 - 为简洁起见,省略了 getter 和 setter 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Document(indexName = "person")
public class Person implements Persistable&lt;Long&gt; {
    @Id private Long id;
    private String lastName;
    private String firstName;
    @Field(type = FieldType.Date, format = DateFormat.basic_date_time)
    private Instant createdDate;
    private String createdBy
    @Field(type = FieldType.Date, format = DateFormat.basic_date_time)
    private Instant lastModifiedDate;
    private String lastModifiedBy;

    public Long getId() {                                                 <i class="conum" data-value="1"></i><b>(1)</b>
        return id;
    }

    @Override
    public boolean isNew() {
        return id == null || (createdDate == null &amp;&amp; createdBy == null);  <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个 getter 方法是此接口必须实现的</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果对象没有 <code>id</code>,或者没有设置包含创建属性的字段,那么该对象就是新的.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="启用审计"><a class="anchor" href="#启用审计"></a>9.2.2. 启用审计</h4>
<div class="paragraph">
<p>在实体设置好并提供 <code>AuditorAware</code> - 或 <code>ReactiveAuditorAware</code> 之后,审计必须通过在配置类上设置 <code>@EnableElasticsearchAuditing</code> 注解来启用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableElasticsearchRepositories
@EnableElasticsearchAuditing
class MyConfiguration {
   // configuration code
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>当使用 reactive 技术栈时必须按如下操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableReactiveElasticsearchRepositories
@EnableReactiveElasticsearchAuditing
class MyConfiguration {
   // configuration code
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您的代码包含多个针对不同类型的 <code>AuditorAware</code> bean,则必须提供该 bean 的名称,以用作 <code>@EnableElasticsearchAuditing</code> 注解的 <code>auditAwareRef</code> 参数的参数.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="entity-callbacks"><a class="anchor" href="#entity-callbacks"></a>10. Entity Callbacks (实体回调)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data 基础结构提供了用于在调用某些方法之前和之后修改实体的钩子.</p>
</div>
<div class="paragraph">
<p>这些所谓的 <code>EntityCallback</code> 实例提供了一种方便的方式来检查并可能以回调方式修改实体.</p>
</div>
<div class="paragraph">
<p><code>EntityCallback</code> 看起来很像 <code>ApplicationListener</code>. 一些 Spring Data 模块发布特定的存储库事件 (例如 <code>BeforeSaveEvent</code>) ,这些事件允许修改给定实体. 在某些情况下,例如使用不可变类型时,这些事件可能会引起麻烦. 同样,事件发布依赖于 <code>ApplicationEventMulticaster</code>. 如果使用异步 <code>TaskExecutor</code> 进行配置,则可能导致不可预测的结果,因为事件处理可以在不同的线程中执行.</p>
</div>
<div class="paragraph">
<p>实体回调为同步和响应式 API 提供集成点,以确保在处理链中定义明确的检查点处按顺序执行,并返回可能修改的实体或响应式包装器类型.</p>
</div>
<div class="paragraph">
<p>实体回调通常按 API 类型分开. 这种分离意味着同步 API 仅考虑同步实体回调,而响应式实现仅考虑响应式实体回调.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>实体回调 API 在 Spring Data Commons 2.2 引入. 这是应用实体修改的推荐方法. 在调用可能已注册的 <code>EntityCallback</code> 实例之前,仍将发布现有的特定于存储库的 <code>ApplicationEvents</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="entity-callbacks.implement"><a class="anchor" href="#entity-callbacks.implement"></a>10.1. 实现 Entity Callbacks</h3>
<div class="paragraph">
<p><code>EntityCallback</code> 通过其泛型类型参数直接与 domain 类型相关联. 每个 Spring Data 模块通常附带一组涵盖实体生命周期的预定义 <code>EntityCallback</code> 接口.</p>
</div>
<div class="exampleblock">
<div class="title">Example 100. Anatomy of an <code>EntityCallback</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@FunctionalInterface
public interface BeforeSaveCallback&lt;T&gt; extends EntityCallback&lt;T&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

    /**
     * Entity callback method invoked before a domain object is saved.
     * Can return either the same or a modified instance.
     *
     * @return the domain object to be persisted.
     */
    T onBeforeSave(T entity , <i class="conum" data-value="2"></i><b>(2)</b>
                String collection ); <i class="conum" data-value="3"></i><b>(3)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>保存实体之前要调用的 <code>BeforeSaveCallback</code> 方法. 返回一个可能被修改的实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>实体被持久化之前.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>许多 store 特定的参数,例如持久化的实体集合.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 101. Anatomy of a reactive <code>EntityCallback</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@FunctionalInterface
public interface ReactiveBeforeSaveCallback&lt;T&gt; extends EntityCallback&lt;T&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

    /**
     * Entity callback method invoked on subscription, before a domain object is saved.
     * The returned Publisher can emit either the same or a modified instance.
     *
     * @return Publisher emitting the domain object to be persisted.
     */
    Publisher&lt;T&gt; onBeforeSave(T entity ,  <i class="conum" data-value="2"></i><b>(2)</b>
                            String collection ); <i class="conum" data-value="3"></i><b>(3)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>保存实体之前,要在订阅上调用的 <code>BeforeSaveCallback</code> 特定方法. 发出可能已修改的实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>实体在持久化之前.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>许多 store 特定的参数,例如持久化的实体集合.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
可选的实体回调参数由实现中的 Spring Data 模块定义,并从 <code>EntityCallback.callback()</code> 的调用站点中推断出来.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>实现适合您的应用程序需求的接口,如下例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 102. <code>BeforeSaveCallback</code> 示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class DefaultingEntityCallback implements BeforeSaveCallback&lt;Person&gt;, Ordered {      <i class="conum" data-value="2"></i><b>(2)</b>

    @Override
    public Object onBeforeSave(Person entity, String collection) {                   <i class="conum" data-value="1"></i><b>(1)</b>

        if(collection == "user") {
            return // ...
        }

        return // ...
    }

    @Override
    public int getOrder() {
        return 100;                                                                  <i class="conum" data-value="2"></i><b>(2)</b>
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>根据您的要求实现回调.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果存在相同 domain 类型的多个实体回调,则可能对实体回调进行排序. 排序遵循最低优先级.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="entity-callbacks.register"><a class="anchor" href="#entity-callbacks.register"></a>10.2. 注册 Entity Callbacks</h3>
<div class="paragraph">
<p>如果实体的实现在 <code>ApplicationContext</code> 中注册,则由实体的实现获取 <code>EntityCallback</code> Bean. 大多数 template  API 已经实现了 <code>ApplicationContextAware</code>,因此可以访问 <code>ApplicationContext</code></p>
</div>
<div class="paragraph">
<p>以下示例说明了有效的实体回调注册的集合:</p>
</div>
<div class="exampleblock">
<div class="title">Example 103. <code>EntityCallback</code> Bean 注册示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Order(1)                                                           <i class="conum" data-value="1"></i><b>(1)</b>
@Component
class First implements BeforeSaveCallback&lt;Person&gt; {

    @Override
    public Person onBeforeSave(Person person) {
        return // ...
    }
}

@Component
class DefaultingEntityCallback implements BeforeSaveCallback&lt;Person&gt;,
                                                           Ordered { <i class="conum" data-value="2"></i><b>(2)</b>

    @Override
    public Object onBeforeSave(Person entity, String collection) {
        // ...
    }

    @Override
    public int getOrder() {
        return 100;                                                  <i class="conum" data-value="2"></i><b>(2)</b>
    }
}

@Configuration
public class EntityCallbackConfiguration {

    @Bean
    BeforeSaveCallback&lt;Person&gt; unorderedLambdaReceiverCallback() {   <i class="conum" data-value="3"></i><b>(3)</b>
        return (BeforeSaveCallback&lt;Person&gt;) it -&gt; // ...
    }
}

@Component
class UserCallbacks implements BeforeConvertCallback&lt;User&gt;,
                                        BeforeSaveCallback&lt;User&gt; {   <i class="conum" data-value="4"></i><b>(4)</b>

    @Override
    public Person onBeforeConvert(User user) {
        return // ...
    }

    @Override
    public Person onBeforeSave(User user) {
        return // ...
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>BeforeSaveCallback</code> 可以从 <code>@Order</code> 注解进行排序.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>BeforeSaveCallback</code> 可以实现 <code>Ordered</code> 接口排序.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>BeforeSaveCallback</code> 使用 lambda 表达式. 默认情况下无序,最后调用.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>将多个实体回调接口组合在一个实现类中.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.entity-callbacks"><a class="anchor" href="#elasticsearch.entity-callbacks"></a>10.3. Elasticsearch EntityCallbacks</h3>
<div class="paragraph">
<p>Spring Data Elasticsearch 在内部将 <code>EntityCallback</code> API 用于审计支持,并对以下回调进行响应:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Supported Entity Callbacks</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Callback</th>
<th class="tableblock halign-left valign-top">Method</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Order</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reactive/BeforeConvertCallback</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>onBeforeConvert(T entity, IndexCoordinates index)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invoked before a domain object is converted to <code>org.springframework.data.elasticsearch.core.document.Document</code>. Can return the <code>entity</code> or a modified entity which then will be converted.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.LOWEST_PRECEDENCE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reactive/AfterConvertCallback</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>onAfterConvert(T entity, Document document, IndexCoordinates indexCoordinates)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invoked after a domain object is converted from <code>org.springframework.data.elasticsearch.core.document.Document</code> on reading result data from Elasticsearch.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.LOWEST_PRECEDENCE</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reactive/AuditingEntityCallback</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>onBeforeConvert(Object entity, IndexCoordinates index)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Marks an auditable entity <em>created</em> or <em>modified</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reactive/AfterSaveCallback</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T onAfterSave(T entity, IndexCoordinates index)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invoked after a domain object is saved.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.LOWEST_PRECEDENCE</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elasticsearch.misc"><a class="anchor" href="#elasticsearch.misc"></a>11. 其他 Elasticsearch 操作支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章涵盖了对不能通过 repository 接口直接访问的 Elasticsearch 操作的额外支持.建议将这些操作添加为自定义实现,如 <a href="#repositories.custom-implementations">Spring Data 存储库的自定义实现</a> 中所述.</p>
</div>
<div class="sect2">
<h3 id="elasticsearch.misc.filter"><a class="anchor" href="#elasticsearch.misc.filter"></a>11.1. Filter Builder</h3>
<div class="paragraph">
<p>Filter Builder 提高查询速度.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private ElasticsearchOperations operations;

IndexCoordinates index = IndexCoordinates.of("sample-index");

SearchQuery searchQuery = new NativeSearchQueryBuilder()
  .withQuery(matchAllQuery())
  .withFilter(boolFilter().must(termFilter("id", documentId)))
  .build();

Page&lt;SampleEntity&gt; sampleEntities = operations.searchForPage(searchQuery, SampleEntity.class, index);
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.scroll"><a class="anchor" href="#elasticsearch.scroll"></a>11.2. 对的数据量大的结果集使用 Scroll</h3>
<div class="paragraph">
<p>Elasticsearch 有一个 scroll API,用于以块为单位获取较大的结果集. Spring Data Elasticsearch 在内部使用此方法来提供 <code>&lt;T&gt; SearchHitsIterator&lt;T&gt; SearchOperations.searchForStream(Query query, Class&lt;T&gt; clazz, IndexCoordinates index)</code> 方法的实现.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">IndexCoordinates index = IndexCoordinates.of("sample-index");

SearchQuery searchQuery = new NativeSearchQueryBuilder()
  .withQuery(matchAllQuery())
  .withFields("message")
  .withPageable(PageRequest.of(0, 10))
  .build();

SearchHitsIterator&lt;SampleEntity&gt; stream = elasticsearchTemplate.searchForStream(searchQuery, SampleEntity.class, index);

List&lt;SampleEntity&gt; sampleEntities = new ArrayList&lt;&gt;();
while (stream.hasNext()) {
  sampleEntities.add(stream.next());
}

stream.close();
</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>SearchOperations</code> API 中没有方法访问 scroll ID,如果必须访问 scroll ID,则可以使用 <code>ElasticsearchRestTemplate</code> 的以下方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowired ElasticsearchRestTemplate template;

IndexCoordinates index = IndexCoordinates.of("sample-index");

SearchQuery searchQuery = new NativeSearchQueryBuilder()
  .withQuery(matchAllQuery())
  .withFields("message")
  .withPageable(PageRequest.of(0, 10))
  .build();

SearchScrollHits&lt;SampleEntity&gt; scroll = template.searchScrollStart(1000, searchQuery, SampleEntity.class, index);

String scrollId = scroll.getScrollId();
List&lt;SampleEntity&gt; sampleEntities = new ArrayList&lt;&gt;();
while (scroll.hasSearchHits()) {
  sampleEntities.addAll(scroll.getSearchHits());
  scrollId = scroll.getScrollId();
  scroll = template.searchScrollContinue(scrollId, 1000, SampleEntity.class);
}
template.searchScrollClear(scrollId);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>要将 Scroll API 与存储库方法一起使用,返回类型必须在 <code>Elasticsearch</code> 存储库中定义为 <code>Stream</code>. 然后,该方法的实现将使用 <code>ElasticsearchTemplate</code> 中的 scroll 方法.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface SampleEntityRepository extends Repository&lt;SampleEntity, String&gt; {

    Stream&lt;SampleEntity&gt; findBy();

}
</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.misc.sorts"><a class="anchor" href="#elasticsearch.misc.sorts"></a>11.3. Sort 选项</h3>
<div class="paragraph">
<p>除了描述的默认排序选项之外,<a href="#repositories.paging-and-sorting">Paging 和 Sorting</a> Spring Data Elasticsearch 还具有 <code>GeoDistanceOrder</code> 类,该类可以将搜索结果按地理距离排序.</p>
</div>
<div class="paragraph">
<p>如果要搜索的类有 <em>location</em> 的 <code>GeoPoint</code> 属性,则下面的 <code>Sort</code> 将按到指定点的距离对结果进行排序:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Sort.by(new GeoDistanceOrder("location", new GeoPoint(48.137154, 11.5761247)))
</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch.misc.jointype"><a class="anchor" href="#elasticsearch.misc.jointype"></a>11.4. Join-Type 实现</h3>
<div class="paragraph">
<p>Spring Data Elasticsearch 支持 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/parent-join.html">Join data type</a>,  用于创建相应的索引映射并存储相关信息.</p>
</div>
<div class="sect3">
<h4 id="设置数据"><a class="anchor" href="#设置数据"></a>11.4.1. 设置数据</h4>
<div class="paragraph">
<p>对于具有父子关系的实体中,  它必须具有 <code>JoinField</code> 属性,  并且对其注解.
假设有一个 <code>Statement</code> 实体,  其中的语句可能是 <em>question</em>,   <em>answer</em>,  <em>comment</em> 或 <em>vote</em>(在此示例中也显示了 <em>Builder</em>,  但这不是必需的,  但稍后将在示例代码中使用):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Document(indexName = "statements")
public class Statement {
    @Id
    private String id;

    @Field(type = FieldType.Text)
    private String text;

    @JoinTypeRelations(
        relations =
            {
                @JoinTypeRelation(parent = "question", children = {"answer", "comment"}), <i class="conum" data-value="1"></i><b>(1)</b>
                @JoinTypeRelation(parent = "answer", children = "vote")                   <i class="conum" data-value="2"></i><b>(2)</b>
            }
    )
    private JoinField&lt;String&gt; relation;                                                   <i class="conum" data-value="3"></i><b>(3)</b>

    private Statement() {
    }

    public static StatementBuilder builder() {
        return new StatementBuilder();
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
    }

    public JoinField&lt;String&gt; getRelation() {
        return relation;
    }

    public void setRelation(JoinField&lt;String&gt; relation) {
        this.relation = relation;
    }

    public static final class StatementBuilder {
        private String id;
        private String text;
        private JoinField&lt;String&gt; relation;

        private StatementBuilder() {
        }

        public StatementBuilder withId(String id) {
            this.id = id;
            return this;
        }

        public StatementBuilder withText(String text) {
            this.text = text;
            return this;
        }

        public StatementBuilder withRelation(JoinField&lt;String&gt; relation) {
            this.relation = relation;
            return this;
        }

        public Statement build() {
            Statement statement = new Statement();
            statement.setId(id);
            statement.setText(text);
            statement.setRelation(relation);
            return statement;
        }
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>一个 question 可以有 answers 和 comments</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>一个 answer 可以有 votes</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>JoinField</code> 属性用于将相关联的名称 (<em>question</em>, <em>answer</em>, <em>comment</em> or <em>vote</em>) 和父 ID 组合在一起. 泛型类型必须与带注解的 <code>@Id</code> 属性相同.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Data Elasticsearch 将为此类构建以下映射:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "statements": {
    "mappings": {
      "properties": {
        "_class": {
          "type": "text",
          "fields": {
            "keyword": {
              "type": "keyword",
              "ignore_above": 256
            }
          }
        },
        "relation": {
          "type": "join",
          "eager_global_ordinals": true,
          "relations": {
            "question": [
              "answer",
              "comment"
            ],
            "answer": "vote"
          }
        },
        "text": {
          "type": "text"
        }
      }
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="存储数据"><a class="anchor" href="#存储数据"></a>11.4.2. 存储数据</h4>
<div class="paragraph">
<p>给定该类的存储库,  以下代码插入一个 question,  两个 answers,  一个 comment 和一个 vote:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void init() {
    repository.deleteAll();

    Statement savedWeather = repository.save(
        Statement.builder()
            .withText("How is the weather?")
            .withRelation(new JoinField&lt;&gt;("question"))                          <i class="conum" data-value="1"></i><b>(1)</b>
            .build());

    Statement sunnyAnswer = repository.save(
        Statement.builder()
            .withText("sunny")
            .withRelation(new JoinField&lt;&gt;("answer", savedWeather.getId()))      <i class="conum" data-value="2"></i><b>(2)</b>
            .build());

    repository.save(
        Statement.builder()
            .withText("rainy")
            .withRelation(new JoinField&lt;&gt;("answer", savedWeather.getId()))      <i class="conum" data-value="3"></i><b>(3)</b>
            .build());

    repository.save(
        Statement.builder()
            .withText("I don't like the rain")
            .withRelation(new JoinField&lt;&gt;("comment", savedWeather.getId()))     <i class="conum" data-value="4"></i><b>(4)</b>
            .build());

    repository.save(
        Statement.builder()
            .withText("+1 for the sun")
            .withRelation(new JoinField&lt;&gt;("vote", sunnyAnswer.getId()))         <i class="conum" data-value="5"></i><b>(5)</b>
            .build());
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>create a question statement</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>the first answer to the question</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>the second answer</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>a comment to the question</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>a vote for the first answer</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="检索数据"><a class="anchor" href="#检索数据"></a>11.4.3. 检索数据</h4>
<div class="paragraph">
<p>当前必须使用本地搜索查询来查询数据,  因此标准存储库方法不提供支持.  可以使用<a href="#repositories.custom-implementations">Spring Data 存储库的自定义实现</a> 代替.</p>
</div>
<div class="paragraph">
<p>下面的代码示例展示了如何使用 <code>ElasticsearchOperations</code> 实例检索所有具有 <em>vote</em> (必须为 <em>answers</em>,  因为只有 answers 才可以 vote) 的所有条目:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SearchHits&lt;Statement&gt; hasVotes() {
    NativeSearchQuery query = new NativeSearchQueryBuilder()
        .withQuery(hasChildQuery("vote", matchAllQuery(), ScoreMode.None))
        .build();

    return operations.search(query, Statement.class);
}
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="appendix" class="sect0"><a class="anchor" href="#appendix"></a>Appendix</h1>
<div class="sect1">
<h2 id="repositories.namespace-reference"><a class="anchor" href="#repositories.namespace-reference"></a>Appendix A: 命名空间参考</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="populator.namespace-dao-config"><a class="anchor" href="#populator.namespace-dao-config"></a><code>&lt;repositories /&gt;</code> 元素</h3>
<div class="paragraph">
<p><code>&lt;repositories /&gt;</code> 元素触发 Spring Data 存储库基础结构的设置.  最重要的属性是 <code>base-package</code>,它定义了要扫描 Spring Data 存储库接口的软件包.
请参阅 &#8220;<a href="#repositories.create-instances.spring">XML 配置</a>&#8221;.  下表描述了 <code>&lt;repositories /&gt;</code> 元素的属性:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. 属性</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>base-package</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义要扫描的软件包,以查找在自动检测模式下扩展 <code>*Repository</code>(实际接口由特定的 Spring Data 模块确定) 的存储库接口.  配置包下面的所有包也将被扫描.  允许使用通配符.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>repository-impl-postfix</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义后缀以自动检测自定义存储库实现.  名称以配置的后缀结尾的类被视为候选.  默认为 <code>Impl</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>query-lookup-strategy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">确定用于创建查找器查询的策略.  有关详细信息,请参见 &#8220;<a href="#repositories.query-methods.query-lookup-strategies">查询查找策略</a>&#8221;.  默认为 <code>create-if-not-found</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>named-queries-location</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">定义搜索包含外部定义查询的属性文件的位置.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>consider-nested-repositories</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否应考虑嵌套的存储库接口定义.  默认为 <code>false</code>.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="populator.namespace-reference"><a class="anchor" href="#populator.namespace-reference"></a>Appendix B: Populators  命名空间参考</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="namespace-dao-config"><a class="anchor" href="#namespace-dao-config"></a>&lt;populator /&gt; element</h3>
<div class="paragraph">
<p><code>&lt;populator /&gt;</code> 元素允许通过 Spring 数据存储库基础结构填充数据存储. <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup></p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. 属性</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>locations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从哪里可以找到要从存储库读取对象的文件,应在其中填充.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repository-query-keywords"><a class="anchor" href="#repository-query-keywords"></a>Appendix C: 存储库查询关键字</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="appendix.query.method.subject"><a class="anchor" href="#appendix.query.method.subject"></a>支持的查询方法主题关键字</h3>
<div class="paragraph">
<p>下表列出了 Spring Data 存储库查询扩展机制通常支持的表示断言的主题关键字.但是,请参阅 store-specific 的文档以获取受支持关键字的确切列表,因为 store-specific 可能不支持此处列出的某些关键字.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. Query 主题关键字</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">关键字</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>find…By</code>, <code>read…By</code>, <code>get…By</code>, <code>query…By</code>, <code>search…By</code>, <code>stream…By</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一般查询方法通常返回存储库类型,  <code>Collection</code> 或 <code>Streamable</code> 的子类型或包装类型 <code>Page</code>, <code>GeoResults</code> 或任何其他 store-specific 的结果包装器. 可以用作 <code>findBy…</code>, <code>findMyDomainTypeBy…</code> 或其他关键字结合使用.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exists…By</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">是否存在, 通常返回 <code>boolean</code> 类型.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>count…By</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">计算返回的结果数字</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>delete…By</code>, <code>remove…By</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除查询方法,不返回结果 (<code>void</code>) 或 delete count.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>…First&lt;number&gt;…</code>, <code>…Top&lt;number&gt;…</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">返回查询结果的第一个 <code>&lt;number&gt;</code> . 此关键字可以出现在主题 <code>find</code> (或其他关键字) 和 <code>by</code> 之间.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>…Distinct…</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 distinct 查询返回唯一的结果. 请查阅特定的文档以了解是否支持该功能. 此关键字可以出现在主题 <code>find</code> (或其他关键字) 和 <code>by</code> 之间.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="appendix.query.method.predicate"><a class="anchor" href="#appendix.query.method.predicate"></a>支持的查询方法断言关键字和修饰符</h3>
<div class="paragraph">
<p>下表列出了 Spring Data 存储库查询扩展机制通常支持的断言关键字.  但是,请参阅 store-specific 的文档以获取受支持关键字的确切列表,因为 store-specific 可能不支持此处列出的某些关键字.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. 查询断言关键字</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">逻辑关键字</th>
<th class="tableblock halign-left valign-top">关键字表达</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AND</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>And</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Or</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AFTER</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>After</code>, <code>IsAfter</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BEFORE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Before</code>, <code>IsBefore</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CONTAINING</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Containing</code>, <code>IsContaining</code>, <code>Contains</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BETWEEN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Between</code>, <code>IsBetween</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ENDING_WITH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EndingWith</code>, <code>IsEndingWith</code>, <code>EndsWith</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>EXISTS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Exists</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FALSE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>False</code>, <code>IsFalse</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GREATER_THAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThan</code>, <code>IsGreaterThan</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GREATER_THAN_EQUALS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GreaterThanEqual</code>, <code>IsGreaterThanEqual</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>In</code>, <code>IsIn</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Is</code>, <code>Equals</code>, (or no keyword)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_EMPTY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsEmpty</code>, <code>Empty</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_NOT_EMPTY</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsNotEmpty</code>, <code>NotEmpty</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_NOT_NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotNull</code>, <code>IsNotNull</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IS_NULL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Null</code>, <code>IsNull</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LESS_THAN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThan</code>, <code>IsLessThan</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LESS_THAN_EQUAL</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LessThanEqual</code>, <code>IsLessThanEqual</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LIKE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Like</code>, <code>IsLike</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NEAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Near</code>, <code>IsNear</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Not</code>, <code>IsNot</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT_IN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotIn</code>, <code>IsNotIn</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NOT_LIKE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>NotLike</code>, <code>IsNotLike</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REGEX</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Regex</code>, <code>MatchesRegex</code>, <code>Matches</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>STARTING_WITH</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StartingWith</code>, <code>IsStartingWith</code>, <code>StartsWith</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>TRUE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>True</code>, <code>IsTrue</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>WITHIN</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Within</code>, <code>IsWithin</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>除过滤断言外,还支持以下修饰符列表:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. 查询断言修饰符关键字</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">关键字</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IgnoreCase</code>, <code>IgnoringCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与福安艳关键字一起使用,不区分大小写的比较.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AllIgnoreCase</code>, <code>AllIgnoringCase</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">忽略所有属性的大小写. 在查询方法断言中的某处使用.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>OrderBy…</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定一个静态的排序顺序,后面跟属性的 path 和 方向 (例如. <code>OrderByFirstnameAscLastnameDesc</code>).</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="repository-query-return-types"><a class="anchor" href="#repository-query-return-types"></a>Appendix D: 储存库查询返回类型</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="appendix.query.return.types"><a class="anchor" href="#appendix.query.return.types"></a>支持的查询返回类型</h3>
<div class="paragraph">
<p>下表列出了 Spring Data 存储库通常支持的返回类型.  但是,请参阅 store-specific 的文档以获取受支持的退货类型的确切列表,因为特定 存储 可能不支持此处列出的某些类型.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
地理空间类型 (例如 <code>GeoResult</code>,<code>GeoResults</code> 和 <code>GeoPage</code>) 仅适用于支持地理空间查询的数据存储.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>某些存储模块可能会定义自己的结果包装器类型.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. 查询返回类型</caption>
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">返回类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">表示没有返回值.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Primitives</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 原语.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Wrapper types</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 包装器类型.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>T</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">唯一实体.  期望查询方法最多返回一个结果.  如果未找到结果,则返回 <code>null</code>.  一个以上的结果触发一个 <code>IncorrectResultSizeDataAccessException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterator&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterator</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Collection&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Collection</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>List</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Optional&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 8 或 <code>Guava</code> 可选.  期望查询方法最多返回一个结果.  如果未找到结果,则返回 <code>Optional.empty()</code> 或 <code>Optional.absent()</code>.  一个以上的结果触发一个 <code>IncorrectResultSizeDataAccessException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Option&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Scala 或 Vavr <code>Option</code> 类型.  语义上与前面描述的 Java 8 的 <code>Optional</code> 行为相同.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Stream&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 8 <code>Stream</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Streamable&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Iterable</code> 的便捷扩展,直接将方法暴露以流式处理,映射和过滤结果,将其串联等.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Types that implement <code>Streamable</code> and take a <code>Streamable</code> constructor or factory method argument</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">暴露构造函数或使用 Streamable 作为参数的  <code>….of(…)</code>/<code>….valueOf(…)</code> 工厂方法的类型.  有关详细信息,请参见返回<a href="#repositories.collections-and-iterables.streamable-wrapper">自定义流式包装器类型</a>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vavr <code>Seq</code>, <code>List</code>, <code>Map</code>, <code>Set</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vavr 集合类型.  有关详细信息,请参见 <a href="#repositories.collections-and-iterables.vavr">支持Vavr集合</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Future&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Future</code>.  期望使用 <code>@Async</code> 注解方法,并且需要启用 Spring 的异步方法执行功能.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CompletableFuture&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java 8 <code>CompletableFuture</code>.  期望使用 <code>@Async</code> 注解方法,并且需要启用 Spring 的异步方法执行功能.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ListenableFuture</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>org.springframework.util.concurrent.ListenableFuture</code>.  期望使用 <code>@Async</code> 注解方法,并且需要启用 Spring 的异步方法执行功能.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Slice&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一定大小的数据块,用于指示是否有更多可用数据.  需要 <code>Pageable</code> 方法参数.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Page&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有附加信息 (例如结果总数) 的 <code>Slice</code>.  需要 <code>Pageable</code> 方法参数.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoResult&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有附加信息 (例如到参考位置的距离) 的结果条目.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoResults&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含其他信息的 <code>GeoResult&lt;T&gt;</code> 列表,例如到参考位置的平均距离.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoPage&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有 <code>GeoResult&lt;T&gt;</code> 的页面,例如到参考位置的平均距离.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 Reactor 储存库发射零或一个元素的 Project Reactor Mono.  期望查询方法最多返回一个结果.  如果未找到结果,则返回 <code>Mono.empty()</code>.  一个以上的结果触发一个 <code>IncorrectResultSizeDataAccessException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 Reactor 存储库发射零,一个或多个元素的 Project Reactor 通量.  返回 <code>Flux</code> 的查询也可以发出无限数量的元素.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Single&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 Reactor 存储库发出 <code>Single</code>  元素的 RxJava Single.  期望查询方法最多返回一个结果.  如果未找到结果,则返回 <code>Mono.empty()</code>.  一个以上的结果触发一个 <code>IncorrectResultSizeDataAccessException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Maybe&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RxJava可能使用 Reactor 存储库发出零个或一个元素.  期望查询方法最多返回一个结果.  如果未找到结果,则返回 <code>Mono.empty()</code> .  一个以上的结果触发一个 <code>IncorrectResultSizeDataAccessException</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flowable&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">RxJava <code>Flowable</code> 使用响应式存储库发出零个,一个或多个元素.  返回 <code>Flowable</code> 的查询也可以发出无限数量的元素.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="elasticsearch.migration"><a class="anchor" href="#elasticsearch.migration"></a>Appendix E: Migration Guides</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="elasticsearch-migration-guide-3.2-4.0"><a class="anchor" href="#elasticsearch-migration-guide-3.2-4.0"></a>Upgrading from 3.2.x to 4.0.x</h3>
<div class="paragraph">
<p>This section describes breaking changes from version 3.2.x to 4.0.x and how removed features can be replaced by new introduced features.</p>
</div>
<div class="sect3">
<h4 id="elasticsearch-migration-guide-3.2-4.0.jackson-removal"><a class="anchor" href="#elasticsearch-migration-guide-3.2-4.0.jackson-removal"></a>Removal of the used Jackson Mapper</h4>
<div class="paragraph">
<p>One of the changes in version 4.0.x is that Spring Data Elasticsearch does not use the Jackson Mapper anymore to map an entity to the JSON representation needed for Elasticsearch (see <a href="#elasticsearch.mapping">Elasticsearch 对象映射</a>). In version 3.2.x the Jackson Mapper was the default that was used. It was possible to switch to the meta-model based converter (named <code>ElasticsearchEntityMapper</code>) by explicitly configuring it (<a href="#elasticsearch.mapping.meta-model">Meta Model Object Mapping</a>).</p>
</div>
<div class="paragraph">
<p>In version 4.0.x the meta-model based converter is the only one that is available and does not need to be configured explicitly. If you had a custom configuration to enable the meta-model converter by providing a bean like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
@Override
public EntityMapper entityMapper() {

  ElasticsearchEntityMapper entityMapper = new ElasticsearchEntityMapper(
    elasticsearchMappingContext(), new DefaultConversionService()
  );
  entityMapper.setConversions(elasticsearchCustomConversions());

  return entityMapper;
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>You now have to remove this bean, the <code>ElasticsearchEntityMapper</code> interface has been removed.</p>
</div>
<div class="paragraph">
<div class="title">Entity configuration</div>
<p>Some users had custom Jackson annotations on the entity class, for example in order to define a custom name for the mapped document in Elasticsearch or to configure date conversions. These are not taken into account anymore. The needed functionality is now provided with Spring Data Elasticsearch&#8217;s <code>@Field</code> annotation. Please see <a href="#elasticsearch.mapping.meta-model.annotations">映射注解概述</a> for detailed information.</p>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-migration-guide-3.2-4.0.implicit-index-name"><a class="anchor" href="#elasticsearch-migration-guide-3.2-4.0.implicit-index-name"></a>Removal of implicit index name from query objects</h4>
<div class="paragraph">
<p>In 3.2.x the different query classes like <code>IndexQuery</code> or <code>SearchQuery</code> had properties that were taking the index name or index names that they were operating upon. If these were not set, the passed in entity was inspected to retrieve the index name that was set in the <code>@Document</code> annotation.<br>
In 4.0.x the index name(s) must now be provided in an additional parameter of type <code>IndexCoordinates</code>. By separating this, it now is possible to use one query object against different indices.</p>
</div>
<div class="paragraph">
<p>So for example the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">IndexQuery indexQuery = new IndexQueryBuilder()
  .withId(person.getId().toString())
  .withObject(person)
  .build();

String documentId = elasticsearchOperations.index(indexQuery);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>must be changed to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">IndexCoordinates indexCoordinates = elasticsearchOperations.getIndexCoordinatesFor(person.getClass());

IndexQuery indexQuery = new IndexQueryBuilder()
  .withId(person.getId().toString())
  .withObject(person)
  .build();

String documentId = elasticsearchOperations.index(indexQuery, indexCoordinates);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>To make it easier to work with entities and use the index name that is contained in the entitie&#8217;s <code>@Document</code> annotation, new methods have been added like <code>DocumentOperations.save(T entity)</code>;</p>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-migration-guide-3.2-4.0.new-operations"><a class="anchor" href="#elasticsearch-migration-guide-3.2-4.0.new-operations"></a>The new Operations interfaces</h4>
<div class="paragraph">
<p>In version 3.2 there was the <code>ElasticsearchOperations</code> interface that defined all the methods for the <code>ElasticsearchTemplate</code> class. In version 4 the functions have been split into different interfaces, aligning these interfaces with the Elasticsearch API:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DocumentOperations</code> are the functions related documents like saving, or deleting</p>
</li>
<li>
<p><code>SearchOperations</code> contains the functions to search in Elasticsearch</p>
</li>
<li>
<p><code>IndexOperations</code> define the functions to operate on indexes, like index creation or mappings creation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ElasticsearchOperations</code> now extends <code>DocumentOperations</code> and <code>SearchOperations</code> and has methods get access to an <code>IndexOperations</code> instance.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
All the functions from the <code>ElasticsearchOperations</code> interface in version 3.2 that are now moved to the <code>IndexOperations</code> interface are still available, they are marked as deprecated and have default implementations that delegate to the new implementation:
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/**
 * Create an index for given indexName.
 *
 * @param indexName the name of the index
 * @return {@literal true} if the index was created
 * @deprecated since 4.0, use {@link IndexOperations#create()}
 */
@Deprecated
default boolean createIndex(String indexName) {
    return indexOps(IndexCoordinates.of(indexName)).create();
}
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-migration-guide-3.2-4.0.deprecations"><a class="anchor" href="#elasticsearch-migration-guide-3.2-4.0.deprecations"></a>Deprecations</h4>
<div class="sect4">
<h5 id="methods-and-classes"><a class="anchor" href="#methods-and-classes"></a>Methods and classes</h5>
<div class="paragraph">
<p>Many functions and classes have been deprecated. These functions still work, but the Javadocs show with what they should be replaced.</p>
</div>
<div class="listingblock">
<div class="title">Example from ElasticsearchOperations</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/*
 * Retrieves an object from an index.
 *
 * @param query the query defining the id of the object to get
 * @param clazz the type of the object to be returned
 * @return the found object
 * @deprecated since 4.0, use {@link #get(String, Class, IndexCoordinates)}
 */
@Deprecated
@Nullable
&lt;T&gt; T queryForObject(GetQuery query, Class&lt;T&gt; clazz);
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="elasticsearch-deprecations"><a class="anchor" href="#elasticsearch-deprecations"></a>Elasticsearch deprecations</h5>
<div class="paragraph">
<p>Since version 7 the Elasticsearch <code>TransportClient</code> is deprecated, it will be removed with Elasticsearch version 8. Spring Data Elasticsearch deprecates the <code>ElasticsearchTemplate</code> class which uses the <code>TransportClient</code> in version 4.0.</p>
</div>
<div class="paragraph">
<p>Mapping types were removed from Elasticsearch 7, they still exist as deprecated values in the Spring Data <code>@Document</code> annotation and the <code>IndexCoordinates</code> class but they are not used anymore internally.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-migration-guide-3.2-4.0.removal"><a class="anchor" href="#elasticsearch-migration-guide-3.2-4.0.removal"></a>Removals</h4>
<div class="ulist">
<ul>
<li>
<p>As already described, the <code>ElasticsearchEntityMapper</code> interface has been removed.</p>
</li>
<li>
<p>The <code>SearchQuery</code> interface has been merged into it&#8217;s base interface <code>Query</code>, so it&#8217;s occurrences can just be replaced with <code>Query</code>.</p>
</li>
<li>
<p>The method <code>org.springframework.data.elasticsearch.core.ElasticsearchOperations.query(SearchQuery query, ResultsExtractor&lt;T&gt; resultsExtractor);</code> and the <code>org.springframework.data.elasticsearch.core.ResultsExtractor</code> interface have been removed. These could be used to parse the result from Elasticsearch for cases in which the response mapping done with the Jackson based mapper was not enough. Since version 4.0, there are the new <a href="#elasticsearch.operations.searchresulttypes">搜索结果类型</a>  to return the information from an Elasticsearch response, so there is no need to expose this low level functionality.</p>
</li>
<li>
<p>The low level methods <code>startScroll</code>, <code>continueScroll</code> and <code>clearScroll</code> have been removed from the <code>ElasticsearchOperations</code> interface. For low level scroll API access, there now are <code>searchScrollStart</code>, <code>searchScrollContinue</code> and <code>searchScrollClear</code> methods on the <code>ElasticsearchRestTemplate</code> class.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="elasticsearch-migration-guide-4.0-4.1"><a class="anchor" href="#elasticsearch-migration-guide-4.0-4.1"></a>从 4.0.x 升级到 4.1.x</h3>
<div class="paragraph">
<p>本节介绍了从版本 4.0.x 到 4.1.x 的重大更改， 以及如何用新引入的功能替换已删除的功能.</p>
</div>
<div class="sect3">
<h4 id="elasticsearch-migration-guide-4.0-4.1.deprecations"><a class="anchor" href="#elasticsearch-migration-guide-4.0-4.1.deprecations"></a>弃用</h4>
<div class="paragraph">
<div class="title">定义 id 属性</div>
<p>通过使用 <code>id</code> 或  <code>document</code> 命名， 可以将实体的属性定义为 id 属性.
现在已弃用此行为， 并将产生警告.
请向我们提供 <code>@Id</code> 注解， 以将某个属性标记为 <code>id</code> 属性.</p>
</div>
<div class="paragraph">
<div class="title">索引映射</div>
<p>在 <code>ReactiveElasticsearchClient.Indices</code>  接口中， 不赞成使用  <code>updateMapping</code>  方法， 而建议使用 <code>putMapping</code> 方法.
它们执行相同的操作， 但是 <code>putMapping</code> 与 Elasticsearch API 中的命名一致:</p>
</div>
<div class="paragraph">
<div class="title">Alias handling</div>
<p>在 <code>IndexOperations</code> 接口中，  不赞成使用 <code>addAlias(AliasQuery)</code>, <code>removeAlias(AliasQuery)</code> 和 <code>queryForAlias()</code> 方法.
请使用的新的 <code>alias(AliasAction)</code>, <code>getAliases(String&#8230;&#8203;)</code> 和 <code>getAliasesForIndex(String&#8230;&#8203;)</code> 方法， 他们提供了更多功能和更简洁的 API.</p>
</div>
<div class="paragraph">
<div class="title">Parent-ID</div>
<p>从版本 6 开始， 已从 Elasticsearch 中删除了父代 ID 的用法. 我们现在弃用相应的字段和方法.</p>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-migration-guide-4.0-4.1.removal"><a class="anchor" href="#elasticsearch-migration-guide-4.0-4.1.removal"></a>删除</h4>
<div class="paragraph">
<div class="title">Type mappings</div>
<p>删除了 <code>@Document</code> 注解的 <em>type mappings</em> 参数和 <code>IndexCoordinates</code> 对象.
它们在 Spring Data Elasticsearch 4.0 中已弃用， 并且不再使用它们的值.</p>
</div>
</div>
<div class="sect3">
<h4 id="elasticsearch-migration-guide-4.0-4.1.breaking-changes"><a class="anchor" href="#elasticsearch-migration-guide-4.0-4.1.breaking-changes"></a>重大变化</h4>
<div class="sect4">
<h5 id="reactiveelasticsearchclient-indices-方法的返回类型"><a class="anchor" href="#reactiveelasticsearchclient-indices-方法的返回类型"></a>ReactiveElasticsearchClient.Indices 方法的返回类型</h5>
<div class="paragraph">
<p>到目前为止， 尚未使用 <code>ReactiveElasticsearchClient.Indices</code> 中的方法.
随着 <code>ReactiveIndexOperations</code> 的引入， 有必要更改一些返回类型:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>createIndex</code>  将返回 <code>Mono&lt;Boolean&gt;</code> 而不是 <code>Mono&lt;Void&gt;</code> 来指示成功创建索引.</p>
</li>
<li>
<p><code>updateMapping</code>  现在返回 <code>Mono&lt;Boolean&gt;</code> 而不是 <code>Mono&lt;Void&gt;</code> 来表示成功的映射存储.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="documentoperartions-bulkindex-方法的返回类型"><a class="anchor" href="#documentoperartions-bulkindex-方法的返回类型"></a>DocumentOperartions.bulkIndex 方法的返回类型</h5>
<div class="paragraph">
<p>这些方法正在重现包含新索引记录的 ID 的 <code>List&lt;String&gt;</code>.
现在他们返回一个 <code>List&lt;IndexedObjectInformation&gt;</code>; 这些对象包含 id 和有关乐观锁的信息(seq_no和primary_term)
:leveloffset: -1
:leveloffset: -1</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. Currently in development
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. Out of maintenance
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. 参阅 <a href="#repositories.create-instances.spring">XML 配置</a>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-09-13 15:57:27 +0800
</div>
</div>
</div>
  </div>
</div>
</body>
</html>
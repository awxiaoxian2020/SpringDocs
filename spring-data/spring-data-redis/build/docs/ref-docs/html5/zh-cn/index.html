<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.8">
<meta name="author" content="Costin Leau, Jennifer Hickey, Christoph Strobl, Thomas Darimont, Mark Paluch, Jay Bryant">
<title>Spring Data Redis</title>
<style>
@import 'http://resources.jcohy.com/css/spring.css';

.listingblock .switch {
    border-style: none;
    display: inline-block;
    position: relative;
    bottom: -3px;
}

.listingblock .switch--item {
    padding: 10px;
    background-color: #e6e1dc;
    color: #282c34;
    display: inline-block;
    cursor: pointer;
    border-top-left-radius: 4px;
    border-top-right-radius: 4px;
}

.listingblock .switch--item:not(:first-child) {
    border-style: none;
}

.listingblock .switch--item.selected {
    background-color: #282c34;
    color: #e6e1dc;
}

.listingblock pre.highlightjs {
    padding: 0;
}

</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
.hidden {
	display: none;
}

.switch {
	border-width: 1px 1px 0 1px;
	border-style: solid;
	border-color: #7a2518;
	display: inline-block;
}

.switch--item {
	padding: 10px;
	background-color: #ffffff;
	color: #7a2518;
	display: inline-block;
	cursor: pointer;
}

.switch--item:not(:first-child) {
	border-width: 0 0 0 1px;
	border-style: solid;
	border-color: #7a2518;
}

.switch--item.selected {
	background-color: #7a2519;
	color: #ffffff;
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/zepto/1.2.0/zepto.min.js"></script>
<script type="text/javascript">
function addBlockSwitches() {
	$('.primary').each(function() {
		primary = $(this);
		createSwitchItem(primary, createBlockSwitch(primary)).item.addClass("selected");
		primary.children('.title').remove();
	});
	$('.secondary').each(function(idx, node) {
		secondary = $(node);
		primary = findPrimary(secondary);
		switchItem = createSwitchItem(secondary, primary.children('.switch'));
		switchItem.content.addClass('hidden');
		findPrimary(secondary).append(switchItem.content);
		secondary.remove();
	});
}

function createBlockSwitch(primary) {
	blockSwitch = $('<div class="switch"></div>');
	primary.prepend(blockSwitch);
	return blockSwitch;
}

function findPrimary(secondary) {
	candidate = secondary.prev();
	while (!candidate.is('.primary')) {
		candidate = candidate.prev();
	}
	return candidate;
}

function createSwitchItem(block, blockSwitch) {
	blockName = block.children('.title').text();
	content = block.children('.content').first().append(block.next('.colist'));
	item = $('<div class="switch--item">' + blockName + '</div>');
	item.on('click', '', content, function(e) {
		$(this).addClass('selected');
		$(this).siblings().removeClass('selected');
		e.data.siblings('.content').addClass('hidden');
		e.data.removeClass('hidden');
	});
	blockSwitch.append(item);
	return {'item': item, 'content': content};
}

function globalSwitch() {
	$('.switch--item').each(function() {
		$(this).off('click');
		$(this).on('click', function() {
			selectedText = $(this).text()
			selectedIndex = $(this).index()
			$(".switch--item").filter(function() { return ($(this).text() === selectedText) }).each(function() {
				$(this).addClass('selected');
				$(this).siblings().removeClass('selected');
				selectedContent = $(this).parent().siblings(".content").eq(selectedIndex)
				selectedContent.removeClass('hidden');
				selectedContent.siblings().addClass('hidden');
			});
		});
	});
}

$(addBlockSwitches);
$(globalSwitch);

</script>

</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Spring Data Redis</h1>
<div class="details">
<span id="author" class="author">Costin Leau, Jennifer Hickey, Christoph Strobl, Thomas Darimont, Mark Paluch, Jay Bryant</span><br>
<span id="revnumber">version 2.3.6.RELEASE,</span>
<span id="revdate">2021-05-14</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#preface">前言</a>
<ul class="sectlevel1">
<li><a href="#get-started:first-steps:spring">1. 学习 Spring</a></li>
<li><a href="#get-started:first-steps:nosql">2. 学习 NoSQL 和 Key Value 存储</a>
<ul class="sectlevel2">
<li><a href="#get-started:first-steps:samples">2.1. 尝试示例</a></li>
</ul>
</li>
<li><a href="#requirements">3. 要求</a></li>
<li><a href="#get-started:help">4. 其他帮助资源</a></li>
<li><a href="#get-started:up-to-date">5. 后续发展</a></li>
<li><a href="#new-features">6. 新特性</a>
<ul class="sectlevel2">
<li><a href="#new-in-2.3.0">6.1. New in Spring Data Redis 2.3</a></li>
<li><a href="#new-in-2.2.0">6.2. Spring Data Redis 2.2</a></li>
<li><a href="#new-in-2.1.0">6.3. Spring Data Redis 2.1</a></li>
<li><a href="#new-in-2.0.0">6.4. New in Spring Data Redis 2.0</a></li>
<li><a href="#new-in-1.8.0">6.5. New in Spring Data Redis 1.8</a></li>
<li><a href="#new-in-1.7.0">6.6. New in Spring Data Redis 1.7</a></li>
<li><a href="#new-in-1-6-0">6.7. New in Spring Data Redis 1.6</a></li>
<li><a href="#new-in-1-5-0">6.8. New in Spring Data Redis 1.5</a></li>
</ul>
</li>
<li><a href="#dependencies">7. 依赖</a>
<ul class="sectlevel2">
<li><a href="#dependencies.spring-boot">7.1. Spring Boot 的依赖管理</a></li>
<li><a href="#dependencies.spring-framework">7.2. Spring Framework</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#reference">参考文档</a>
<ul class="sectlevel1">
<li><a href="#why-spring-redis">8. 为什么使用 Spring Data Redis?</a></li>
<li><a href="#redis">9. Redis 支持</a>
<ul class="sectlevel2">
<li><a href="#redis:setup">9.1. 开始使用</a></li>
<li><a href="#redis:requirements">9.2. Redis 要求</a></li>
<li><a href="#redis:architecture">9.3. Redis 支持高级视图</a></li>
<li><a href="#redis:connectors">9.4. 连接到 Redis</a>
<ul class="sectlevel3">
<li><a href="#redis:connectors:connection">9.4.1. RedisConnection 和 RedisConnectionFactory</a></li>
<li><a href="#redis:connectors:lettuce">9.4.2. 配置 Lettuce 连接器</a></li>
<li><a href="#redis:connectors:jedis">9.4.3. 配置 Jedis 连接器</a></li>
<li><a href="#redis:write-to-master-read-from-replica">9.4.4. 主从复制</a></li>
</ul>
</li>
<li><a href="#redis:sentinel">9.5. Redis Sentinel 支持</a></li>
<li><a href="#redis:template">9.6. 通过 RedisTemplate 处理对象</a></li>
<li><a href="#redis:string">9.7. String 的便捷操作</a></li>
<li><a href="#redis:serializer">9.8. 序列化器</a></li>
<li><a href="#redis.hashmappers.root">9.9. Hash 映射</a>
<ul class="sectlevel3">
<li><a href="#hash-mappers">9.9.1. Hash Mappers</a></li>
<li><a href="#redis.hashmappers.jackson2">9.9.2. Jackson2HashMapper</a></li>
</ul>
</li>
<li><a href="#pubsub">9.10. Redis 消息 (Pub/Sub)</a>
<ul class="sectlevel3">
<li><a href="#redis:pubsub:publish">9.10.1. Publishing (发送消息)</a></li>
<li><a href="#redis:pubsub:subscribe">9.10.2. Subscribing (接收消息)</a>
<ul class="sectlevel4">
<li><a href="#redis:pubsub:subscribe:containers">消息监听容器</a></li>
<li><a href="#redis:pubsub:subscribe:adapter">MessageListenerAdapter</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis.streams">9.11. Redis Streams</a>
<ul class="sectlevel3">
<li><a href="#redis.streams.send">9.11.1. 追加</a></li>
<li><a href="#redis.streams.receive">9.11.2. 消费</a>
<ul class="sectlevel4">
<li><a href="#redis.streams.receive.synchronous">同步接收</a></li>
<li><a href="#redis.streams.receive.containers">通过消息监听器容器进行异步接收</a></li>
<li><a href="#redis.streams.acknowledge"><code>Acknowledge</code> 策略</a></li>
<li><a href="#redis.streams.receive.readoffset"><code>ReadOffset</code> 策略</a></li>
<li><a href="#redis.streams.receive.serialization">序列化</a></li>
<li><a href="#redis.streams.hashing">Object Mapping</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tx">9.12. Redis 事务</a>
<ul class="sectlevel3">
<li><a href="#tx.spring">9.12.1. @Transactional 支持</a></li>
</ul>
</li>
<li><a href="#pipeline">9.13. 流水线</a></li>
<li><a href="#scripting">9.14. Redis 脚本</a></li>
<li><a href="#redis:support">9.15. 支持的类</a>
<ul class="sectlevel3">
<li><a href="#redis:support:cache-abstraction">9.15.1. 支持 Spring Cache 抽象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis:reactive">10. Reactive Redis 支持</a>
<ul class="sectlevel2">
<li><a href="#redis:reactive:requirements">10.1. Redis 要求</a></li>
<li><a href="#redis:reactive:connectors">10.2. 使用响应式驱动程序连接到 Redis</a>
<ul class="sectlevel3">
<li><a href="#redis:reactive:connectors:operation-modes">10.2.1. Redis操作模式</a></li>
<li><a href="#redis:reactive:connectors:connection">10.2.2. <code>ReactiveRedisConnection</code> 和 <code>ReactiveRedisConnectionFactory</code></a></li>
<li><a href="#redis:reactive:connectors:lettuce">10.2.3. 配置 Lettuce 连接器</a></li>
</ul>
</li>
<li><a href="#redis:reactive:template">10.3. 通过 ReactiveRedisTemplate 处理对象</a></li>
<li><a href="#redis:reactive:string">10.4. String 的便捷操作类</a></li>
<li><a href="#redis:reactive:pubsub">10.5. Redis Messaging/PubSub</a>
<ul class="sectlevel3">
<li><a href="#redis:reactive:pubsub:publish">10.5.1. Sending/Publishing messages</a></li>
<li><a href="#redis:reactive:pubsub:subscribe">10.5.2. Receiving/Subscribing for messages</a>
<ul class="sectlevel4">
<li><a href="#redis:reactive:pubsub:subscribe:containers">Message 监听容器</a></li>
<li><a href="#redis:reactive:pubsub:subscribe:template">通过模板API订阅</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis:reactive:scripting">10.6. Reactive 脚本</a></li>
</ul>
</li>
<li><a href="#cluster">11. Redis 集群</a>
<ul class="sectlevel2">
<li><a href="#启用-redis-集群">11.1. 启用 Redis 集群</a></li>
<li><a href="#cluster.working.with.cluster">11.2. 使用 Redis 群集连接</a></li>
<li><a href="#cluster.redistemplate">11.3. 使用 <code>RedisTemplate</code> 和 <code>ClusterOperations</code></a></li>
</ul>
</li>
<li><a href="#redis.repositories">12. Redis 存储库</a>
<ul class="sectlevel2">
<li><a href="#redis.repositories.usage">12.1. 使用</a></li>
<li><a href="#mapping.fundamentals">12.2. 对象映射基础</a>
<ul class="sectlevel3">
<li><a href="#mapping.object-creation">12.2.1. 创建对象</a></li>
<li><a href="#mapping.property-population">12.2.2. 属性 population</a></li>
<li><a href="#mapping.general-recommendations">12.2.3. 一般建议</a></li>
<li><a href="#mapping.kotlin">12.2.4. Kotlin 支持</a>
<ul class="sectlevel4">
<li><a href="#kotlin-对象创建">Kotlin 对象创建</a></li>
<li><a href="#property-population-of-kotlin-data-classes">Property population of Kotlin data classes</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis.repositories.mapping">12.3. 对象到哈希的映射</a>
<ul class="sectlevel3">
<li><a href="#自定义类型映射">12.3.1. 自定义类型映射</a>
<ul class="sectlevel4">
<li><a href="#配置自定义类型映射">配置自定义类型映射</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#redis.repositories.keyspaces">12.4. Keyspaces</a></li>
<li><a href="#redis.repositories.indexes">12.5. 二级索引</a>
<ul class="sectlevel3">
<li><a href="#redis.repositories.indexes.simple">12.5.1. 简单属性索引</a></li>
<li><a href="#redis.repositories.indexes.geospatial">12.5.2. 地理空间索引</a></li>
</ul>
</li>
<li><a href="#query-by-example">12.6. 查询例子</a>
<ul class="sectlevel3">
<li><a href="#query-by-example.introduction">12.6.1. 简介</a></li>
<li><a href="#query-by-example.usage">12.6.2. 使用</a></li>
<li><a href="#query-by-example.matchers">12.6.3. Example 匹配</a></li>
<li><a href="#query-by-example.execution">12.6.4. 执行一个例子</a></li>
</ul>
</li>
<li><a href="#redis.repositories.expirations">12.7. 生存时间</a></li>
<li><a href="#redis.repositories.references">12.8. 持久引用</a></li>
<li><a href="#redis.repositories.partial-updates">12.9. 持续部分更新</a></li>
<li><a href="#redis.repositories.queries">12.10. 查询和查询方法</a></li>
<li><a href="#redis.repositories.cluster">12.11. 在集群上运行的Redis存储库</a></li>
<li><a href="#redis.repositories.cdi-integration">12.12. CDI 集成</a></li>
<li><a href="#redis存储库原理">12.13. Redis存储库原理</a>
<ul class="sectlevel3">
<li><a href="#插入新值">12.13.1. 插入新值</a></li>
<li><a href="#redis.repositories.anatomy.replace">12.13.2. 替换存在的</a></li>
<li><a href="#redis.repositories.anatomy.geo">12.13.3. 保存 Geo 数据</a></li>
<li><a href="#redis.repositories.anatomy.index">12.13.4. 使用简单索引查找</a></li>
<li><a href="#redis.repositories.anatomy.geo-index">12.13.5. 使用地理位置索引查找</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendixes">附录</a>
<ul class="sectlevel1">
<li><a href="#appendix:schema">Appendix A: Schema</a></li>
<li><a href="#appendix:command-reference">Appendix B: 命令参考</a>
<ul class="sectlevel2">
<li><a href="#支持的命令">支持的命令</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>&#169; 2011-2020 The original authors.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
本文档的副本可以供您自己使用,也可以分发给其他人,但前提是您不对此类副本收取任何费用,并且还应确保每份副本均包含本版权声明(无论是印刷版本还是电子版本) .
</td>
</tr>
</table>
</div>
<!-- toc disabled -->
</div>
</div>
<h1 id="preface" class="sect0"><a class="anchor" href="#preface"></a>前言</h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>Spring Data Redis 项目通过使用 key-value 风格的数据存储将 Spring 的核心概念应用于开发解决方案. 我们提供了一个 发送和接收消息的 "模板” 作为高级抽象. 您可能会注意到与 Spring Framework 中的 JDBC 支持相似.</p>
</div>
<div class="paragraph">
<p>本文档是 Spring Data Redis(SDR) 模块支持的参考指南.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="get-started:first-steps:spring"><a class="anchor" href="#get-started:first-steps:spring"></a>1. 学习 Spring</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data 使用 Spring 框架的 <a href="https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/core.html">核心</a> 功能, 包括:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/core.html#beans">IoC</a> 容器</p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/core.html#validation">类型转换系统</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/core.html#expressions">语言表达式</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/integration.html#jmx">JMX 集成</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring/docs/{springVersion}/spring-framework-reference/data-access.html#dao-exceptions">DAO 异常层次</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然了解 Spring API 并不重要,但了解它们背后的概念很重要. 至少,应该了解 IoC 背后的想法.并且您应该熟悉选择使用的任何IoC容器.</p>
</div>
<div class="paragraph">
<p>Redis 支持的核心功能可以直接使用, 而无需调用 Spring 容器的 IoC 服务.  这非常类似于 <code>JdbcTemplate</code>, 它可以在没有 Spring 容器的任何其他服务的情况下 "独立" 使用.  为了利用 Spring Data Redis 的所有功能, 例如存储库支持, 您需要配置库的某些部分以使用 Spring.</p>
</div>
<div class="paragraph">
<p>话虽如此,您对 Spring 的了解越多,您就能更快地获取 Spring Data Redis. 可以参考 Spring 框架的参考文档,关于该主题有很多文章, 博客和书籍.
有关更多信息, 请参见 Spring 框架 <a href="https://spring.io/docs">home page</a>.</p>
</div>
<div class="paragraph">
<p>通常,这应该是想要尝试使用 Spring Data Redis 的开发人员的起点.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="get-started:first-steps:nosql"><a class="anchor" href="#get-started:first-steps:nosql"></a>2. 学习 NoSQL 和 Key Value 存储</h2>
<div class="sectionbody">
<div class="paragraph">
<p>NoSQL 存储席卷了存储世界. 它是一个广阔的领域,具有许多解决方案,术语和模式(更糟糕的是,甚至术语本身也具有 <a href="https://www.google.com/search?q=nosoql+acronym">多种含义</a>).
尽管某些原则很普遍,但一定程度上要熟悉 SDR 支持的 处处,这一点至关重要. 熟悉这些解决方案的最佳方法是阅读其文档并遵循其示例. 通常需要花费五到十分钟的时间来完成这些步骤,而且,如果您具有 RDMBS 的背景,那么这些练习通常会使人大开眼界.</p>
</div>
<div class="sect2">
<h3 id="get-started:first-steps:samples"><a class="anchor" href="#get-started:first-steps:samples"></a>2.1. 尝试示例</h3>
<div class="paragraph">
<p>您可以在 Spring Data 示例存储库中找到各种用于键值存储的示例,网址为 <a href="https://github.com/spring-projects/spring-data-keyvalue-examples">https://github.com/spring-projects/spring-data-keyvalue-examples</a>.
对于 Spring Data Redis,您应该特别注意 <code>retwisj</code> 示例,该示例是在 Redis 之上构建的 Twitter-clone,可以在本地运行或部署到云中. 有关更多信息,请参阅其 <a href="https://docs.spring.io/spring-data/data-keyvalue/examples/retwisj/current/">文档</a>,以下 <a href="https://spring.io/blog/2011/04/27/getting-started-redis-spring-cloud-foundry/">博客</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="requirements"><a class="anchor" href="#requirements"></a>3. 要求</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data Redis 2.x 需要 JDK 8.0 或更高版本以及 <a href="https://projects.spring.io/spring-framework/">Spring Framework</a> {springVersion} 或更高版本.</p>
</div>
<div class="paragraph">
<p>就 key-value 存储而言, 需要 <a href="https://redis.io">Redis</a> 2.6.x 或更高版本.  Spring Data Redis 当前已针对最新的 4.0 版本进行了测试.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="get-started:help"><a class="anchor" href="#get-started:help"></a>4. 其他帮助资源</h2>
<div class="sectionbody">
<div class="paragraph">
<p>学习新框架并不总是那么简单.  在本节中, 我们提供开始学习 Spring Data Redis 的简要指南.  但是, 如果遇到问题或需要建议, 请随时使用以下链接之一:</p>
</div>
<div class="dlist get-started:help:community]">
<dl>
<dt>社区论坛 </dt>
<dd>
<p><a href="https://stackoverflow.com/questions/tagged/spring-data">Stack Overflow</a> 上的 Spring Data 标签是一个留言板,供所有 Spring Data(不仅仅是文档)用户共享信息并互相帮助. 请注意,只有注册了才能发布.</p>
</dd>
</dl>
</div>
<div id="get-started:help:professional" class="dlist">
<dl>
<dt class="hdlist1">Professional Support </dt>
<dd>
<p>可从 Spring Data 和 Spring 背后的公司  <a href="https://www.pivotal.io/">Pivotal Software, Inc.</a> 获得专业的支持.</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="get-started:up-to-date"><a class="anchor" href="#get-started:up-to-date"></a>5. 后续发展</h2>
<div class="sectionbody">
<div class="paragraph">
<p>有关 Spring Data 源代码存储库,每夜构建和 snapshot artifacts 的信息,请参见 Spring Data <a href="https://spring.io/spring-data">主页</a>.</p>
</div>
<div class="paragraph">
<p>通过在 <a href="https://stackoverflow.com/questions/tagged/spring-data">spring-data</a> 或 <a href="https://stackoverflow.com/questions/tagged/spring-data-redis">spring-data-redis</a> 上的 Stack Overflow 上与开发人员进行交互,可以帮助使 Spring Data 最好地满足 Spring 社区的需求.</p>
</div>
<div class="paragraph">
<p>如果您遇到错误或要提出改进建议(包括本文档中的内容),请在 Spring Data 问题跟踪器上创建 <a href="https://jira.spring.io/browse/DATAREDIS">tracker</a>.</p>
</div>
<div class="paragraph">
<p>要了解 Spring 生态系统中的最新新闻和公告,请订阅 Spring Community <a href="https://spring.io/">Portal</a>.</p>
</div>
<div class="paragraph">
<p>最后,您可以在 Twitter 上关注 Spring  <a href="https://spring.io/blog/">blog</a> 或项目团队(<a href="https://twitter.com/SpringData">@SpringData</a>).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="new-features"><a class="anchor" href="#new-features"></a>6. 新特性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节简要介绍了最新版本中的新内容和值得注意的内容.</p>
</div>
<div class="sect2">
<h3 id="new-in-2.3.0"><a class="anchor" href="#new-in-2.3.0"></a>6.1. New in Spring Data Redis 2.3</h3>
<div class="ulist">
<ul>
<li>
<p>Template API 方法优化 <code>Duration</code> 和 <code>Instant</code>.</p>
</li>
<li>
<p>Stream Commands 扩展.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-in-2.2.0"><a class="anchor" href="#new-in-2.2.0"></a>6.2. Spring Data Redis 2.2</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#redis.streams">Redis Streams</a></p>
</li>
<li>
<p>接受单个 keys 集合的 <code>union</code>/<code>diff</code>/<code>intersect</code> 操作方法</p>
</li>
<li>
<p>更新至 Jedis 3.</p>
</li>
<li>
<p>添加对使用 Jedis Cluster 的脚本命令的支持.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-in-2.1.0"><a class="anchor" href="#new-in-2.1.0"></a>6.3. Spring Data Redis 2.1</h3>
<div class="ulist">
<ul>
<li>
<p>使用 <a href="#redis:connectors:lettuce">Lettuce</a>  的 Unix domain socket 连接</p>
</li>
<li>
<p>Lettuce <a href="#redis:write-to-master-read-from-replica">从主库写,从库读</a></p>
</li>
<li>
<p><a href="#query-by-example">查询示例</a></p>
</li>
<li>
<p><code>@TypeAlias</code> 支持 Redis 存储库.</p>
</li>
<li>
<p>Cluster-wide <code>SCAN</code> using Lettuce and <code>SCAN</code> execution on a selected node supported by both drivers.</p>
</li>
<li>
<p><a href="#redis:reactive:pubsub">Reactive Pub/Sub</a> to send and receive a message stream.</p>
</li>
<li>
<p><code>BITFIELD</code>, <code>BITPOS</code>, and <code>OBJECT</code> command support.</p>
</li>
<li>
<p>Align return types of <code>BoundZSetOperations</code> with <code>ZSetOperations</code>.</p>
</li>
<li>
<p>Reactive <code>SCAN</code>, <code>HSCAN</code>, <code>SSCAN</code>, and <code>ZSCAN</code> support.</p>
</li>
<li>
<p>Usage of <code>IsTrue</code> and <code>IsFalse</code> keywords in repository query methods.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-in-2.0.0"><a class="anchor" href="#new-in-2.0.0"></a>6.4. New in Spring Data Redis 2.0</h3>
<div class="ulist">
<ul>
<li>
<p>Upgrade to Java 8.</p>
</li>
<li>
<p>Upgrade to Lettuce 5.0.</p>
</li>
<li>
<p>Removed support for SRP and JRedis drivers.</p>
</li>
<li>
<p><a href="#redis:reactive">Reactive connection support using Lettuce</a>.</p>
</li>
<li>
<p>Introduce Redis feature-specific interfaces for <code>RedisConnection</code>.</p>
</li>
<li>
<p>Improved <code>RedisConnectionFactory</code> configuration with <code>JedisClientConfiguration</code> and <code>LettuceClientConfiguration</code>.</p>
</li>
<li>
<p>Revised <code>RedisCache</code> implementation.</p>
</li>
<li>
<p>Add <code>SPOP</code> with count command for Redis 3.2.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-in-1.8.0"><a class="anchor" href="#new-in-1.8.0"></a>6.5. New in Spring Data Redis 1.8</h3>
<div class="ulist">
<ul>
<li>
<p>Upgrade to Jedis 2.9.</p>
</li>
<li>
<p>Upgrade to <code>Lettuce</code> 4.2 (Note: Lettuce 4.2 requires Java 8).</p>
</li>
<li>
<p>Support for Redis <a href="https://redis.io/commands#geo">GEO</a> commands.</p>
</li>
<li>
<p>Support for Geospatial Indexes using Spring Data Repository abstractions (see <a href="#redis.repositories.indexes.geospatial">地理空间索引</a>).</p>
</li>
<li>
<p><code>MappingRedisConverter</code>-based <code>HashMapper</code> implementation (see <a href="#redis.hashmappers.root">Hash 映射</a>).</p>
</li>
<li>
<p>Support for <code>PartialUpdate</code> in repositories (see <a href="#redis.repositories.partial-updates">持续部分更新</a>).</p>
</li>
<li>
<p>SSL support for connections to Redis cluster.</p>
</li>
<li>
<p>Support for <code>client name</code> through <code>ConnectionFactory</code> when using Jedis.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-in-1.7.0"><a class="anchor" href="#new-in-1.7.0"></a>6.6. New in Spring Data Redis 1.7</h3>
<div class="ulist">
<ul>
<li>
<p>Support for <a href="https://redis.io/topics/cluster-tutorial">RedisCluster</a>.</p>
</li>
<li>
<p>Support for Spring Data Repository abstractions (see <a href="#redis.repositories">Redis 存储库</a>).</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-in-1-6-0"><a class="anchor" href="#new-in-1-6-0"></a>6.7. New in Spring Data Redis 1.6</h3>
<div class="ulist">
<ul>
<li>
<p>The <code>Lettuce</code> Redis driver switched from <a href="https://github.com/wg/lettuce">wg/lettuce</a> to <a href="https://github.com/mp911de/lettuce">mp911de/lettuce</a>.</p>
</li>
<li>
<p>Support for <code>ZRANGEBYLEX</code>.</p>
</li>
<li>
<p>Enhanced range operations for <code>ZSET</code>, including <code>+inf</code> / <code>-inf</code>.</p>
</li>
<li>
<p>Performance improvements in <code>RedisCache</code>, now releasing connections earlier.</p>
</li>
<li>
<p>Generic Jackson2 <code>RedisSerializer</code> making use of Jackson&#8217;s polymorphic deserialization.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="new-in-1-5-0"><a class="anchor" href="#new-in-1-5-0"></a>6.8. New in Spring Data Redis 1.5</h3>
<div class="ulist">
<ul>
<li>
<p>Add support for Redis HyperLogLog commands: <code>PFADD</code>, <code>PFCOUNT</code>, and <code>PFMERGE</code>.</p>
</li>
<li>
<p>Configurable <code>JavaType</code> lookup for Jackson-based <code>RedisSerializers</code>.</p>
</li>
<li>
<p><code>PropertySource</code>-based configuration for connecting to Redis Sentinel (see: <a href="#redis:sentinel">Redis Sentinel 支持</a>).</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dependencies"><a class="anchor" href="#dependencies"></a>7. 依赖</h2>
<div class="sectionbody">
<div class="paragraph">
<p>由于各个 Spring Data 模块的初始日期不同,它们中的大多数都带有不同的主版本号和次版本号. 寻找兼容版本的最简单方法是依靠我们随定义的兼容版本提供的 Spring Data Release BOM.
在 Maven 项目中,您将在 <code>&lt;dependencyManagement /&gt;</code> POM 的部分声明这种依赖,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. 使用 Spring Data 发行版 BOM</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
      &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt;
      &lt;version&gt;{releasetrainVersion}&lt;/version&gt;
      &lt;scope&gt;import&lt;/scope&gt;
      &lt;type&gt;pom&lt;/type&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
</div>
</div>
<div id="dependencies.train-names" class="paragraph">
<p>目前的发行版本是  <code>{releasetrainVersion}</code>. 名称按字母顺序上升,目前可用的 列车在  <a href="https://github.com/spring-projects/spring-data-commons/wiki/Release-planning">此处</a> 列出. 版本名称遵循以下模式: <code>${name}-${release}</code>,其中发布可以是下列之一:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BUILD-SNAPSHOT</code>: 当前快照</p>
</li>
<li>
<p><code>M1</code>, <code>M2</code>, 等: 里程碑</p>
</li>
<li>
<p><code>RC1</code>, <code>RC2</code>, 发布候选</p>
</li>
<li>
<p><code>RELEASE</code>: GA 版本</p>
</li>
<li>
<p><code>SR1</code>, <code>SR2</code>, 等: 服务版本</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在我们的 <a href="https://github.com/spring-projects/spring-data-examples/tree/master/bom">Spring Data 示例存储库</a> 中可以找到使用 BOM 的一个工作示例. 有了这个,你可以在你的模块中声明 Spring Data 模块而不需要版本 <code>&lt;dependencies /&gt;</code>,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. 声明一个依赖 Spring Data 模块</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;
  &lt;/dependency&gt;
&lt;dependencies&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dependencies.spring-boot"><a class="anchor" href="#dependencies.spring-boot"></a>7.1. Spring Boot 的依赖管理</h3>
<div class="paragraph">
<p>Spring Boot 为您选择最新版本的 Spring Data 模块. 如果您仍想升级到较新版本,请将该属性配置为您要使用  <code>spring-data-releasetrain.version</code>  的 <a href="#dependencies.train-names">火车名称迭代</a> .</p>
</div>
</div>
<div class="sect2">
<h3 id="dependencies.spring-framework"><a class="anchor" href="#dependencies.spring-framework"></a>7.2. Spring Framework</h3>
<div class="paragraph">
<p>当前版本的 Spring Data 模块需要版本  5.2.12.RELEASE  或更高版本的 Spring Framework. 这些模块也可能与该次要版本的旧版错误修复版本一起工作. 但是,强烈建议使用该代中的最新版本.</p>
</div>
</div>
</div>
</div>
<h1 id="reference" class="sect0"><a class="anchor" href="#reference"></a>参考文档</h1>
<div class="openblock partintro">
<div class="content">
<h2 id="introduction.structure" class="float">文档结构</h2>
<div class="paragraph">
<p>本文档是 Spring Data Redis(SDR) 提供的核心功能. 它解释了  Key-Value 模块的概念和语义以及各种 stores namespaces 的语法.</p>
</div>
<div class="paragraph">
<p>有关 Key-Value 存储,Spring 或 Spring Data 示例的介绍, 请查看 <a href="#get-started">[get-started]</a>.
本文档仅涉及 Spring Data Redis 支持,并且你熟悉 Key-Value 存储和 Spring 相关概念.</p>
</div>
<div class="paragraph">
<p><a href="#redis">Redis 支持</a> 介绍 Redis 模块功能.</p>
</div>
<div class="paragraph">
<p>&#8220;<a href="#redis.repositories">Redis 存储库</a>&#8221; 介绍了 Redis 的存储库支持.</p>
</div>
<div class="paragraph">
<p>本文档是 Spring Data Redis（SDR）支持的参考指南.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="why-spring-redis"><a class="anchor" href="#why-spring-redis"></a>8. 为什么使用 Spring Data Redis?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring 框架是领先的全栈 Java/JEE 应用程序框架. 它提供了一个轻量级的容器和一个非侵入性编程模型,该模型通过使用依赖注入,AOP和可移植服务抽象来实现.</p>
</div>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/NoSQL">NoSQL</a> 存储系统提供了传统 RDBMS 的替代产品,以实现水平可伸缩性和速度. 就实现而言,键值存储是 NoSQL 中使用最多的类型之一.</p>
</div>
<div class="paragraph">
<p>Spring Data Redis (SDR) 框架由 Spring 基础架构支持,消除了与存储交互的所需的冗余任务和样板代码,从而使编写使用 Redis 键值存储的 Spring 应用程序变得容易.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="redis"><a class="anchor" href="#redis"></a>9. Redis 支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Data 支持的 key-value 存储之一是 Redis. 下面这句话引用自 <a href="https://redis.io">Redis</a> 项目主页:</p>
</div>
<div class="quoteblock">
<blockquote>
Redis 是高级键值存储. 它类似于 memcached,但数据集是不易失的,值可以是字符串,就像在 memcached 中一样,也可以是列表,集合和有序集合.
所有这些数据类型都可以通过原子操作进行操作,以 push/pop 元素, add/remove 元素,包括 union,intersection,集合之间的差异等. Redis 支持不同种类的排序功能.
</blockquote>
</div>
<div class="paragraph">
<p>Spring Data Redis 提供了简单的配置,并可以从 Spring 应用程序访问 Redis. 它提供了与 store 交互的低层和高层抽象,使用户摆脱了基础配置的困扰.</p>
</div>
<div class="sect2">
<h3 id="redis:setup"><a class="anchor" href="#redis:setup"></a>9.1. 开始使用</h3>
<div class="paragraph">
<p>设置工作环境的一种简单方法是在 <a href="https://spring.io/tools/sts">STS</a> 中创建一个基于 Spring 的项目.</p>
</div>
<div class="paragraph">
<p>首先, 您需要设置一个正在运行的 Redis 服务器.</p>
</div>
<div class="paragraph">
<p>在 STS 中创建 Spring 项目:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>File &#8594; New &#8594; Spring Template Project &#8594; Simple Spring Utility Project, 然后在出现提示时按 Yes. 然后输入项目和包名称, 例如 <code>org.spring.redis.example</code>.
.将以下内容添加到 pom.xml 文件 <code>dependencies</code> 元素中:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;

  &lt;!-- other dependency elements omitted --&gt;

  &lt;dependency&gt;
    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;
    &lt;version&gt;2.3.6.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;

&lt;/dependencies&gt;</code></pre>
</div>
</div>
</li>
<li>
<p>在 pom.xml 中将 Spring 的版本更改为</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;spring.framework.version&gt;{springVersion}&lt;/spring.framework.version&gt;</code></pre>
</div>
</div>
</li>
<li>
<p>将 Spring Milestone 存储库添加到 <code>pom.xml</code> 文件中,  与 <code>&lt;dependencies/&gt;</code> 元素处于同一级别:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
  &lt;repository&gt;
    &lt;id&gt;spring-milestone&lt;/id&gt;
    &lt;name&gt;Spring Maven MILESTONE Repository&lt;/name&gt;
    &lt;url&gt;https://repo.spring.io/libs-milestone&lt;/url&gt;
  &lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>也可以在这里 <a href="https://repo.spring.io/milestone/org/springframework/data/">预览此存储库</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="redis:requirements"><a class="anchor" href="#redis:requirements"></a>9.2. Redis 要求</h3>
<div class="paragraph">
<p>Spring Redis 需要 Redis 2.6 或更高版本,Spring Data Redis 与 <a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a> 和 <a href="https://github.com/xetorthio/jedis">Jedis</a> 集成,这是两个流行的 Redis 开源 Java 库.</p>
</div>
</div>
<div class="sect2">
<h3 id="redis:architecture"><a class="anchor" href="#redis:architecture"></a>9.3. Redis 支持高级视图</h3>
<div class="paragraph">
<p>Redis 提供了几个组件. 对于大多数任务,高级抽象和支持服务是最佳选择. 请注意,您可以随时在视图之间移动. 例如,您可以获得底层连接(甚至本地库)以直接与 Redis 通信.</p>
</div>
</div>
<div class="sect2">
<h3 id="redis:connectors"><a class="anchor" href="#redis:connectors"></a>9.4. 连接到 Redis</h3>
<div class="paragraph">
<p>使用 Redis 和 Spring 时的首要任务之一是通过IoC容器连接到 store. 为此,需要 Java 连接器(或绑定). 无论选择哪种库,您都只需要使用一组 Spring Data Redis API(在所有连接器上都保持一致):
使用 <code>org.springframework.data.redis.connection</code> 包下的 <code>RedisConnection</code> 和 <code>RedisConnectionFactory</code> 接口即可自动检索 与 Redis 的活动连接.</p>
</div>
<div class="sect3">
<h4 id="redis:connectors:connection"><a class="anchor" href="#redis:connectors:connection"></a>9.4.1. RedisConnection 和 RedisConnectionFactory</h4>
<div class="paragraph">
<p><code>RedisConnection</code> 提供了 Redis 通信的核心模块,因为它处理与 Redis 服务端的通信. 它还会自动将底层连接库异常转换为 Spring 的 DAO 异常 <a href="https://docs.spring.io/spring/docs/5.2.12.RELEASE/spring-framework-reference/data-access.html#dao-exceptions">层次结构</a>,以便您可以在不更改任何代码的情况下切换连接器,因为操作语义保持不变.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
对于需要本地库API的特殊情况,<code>RedisConnection</code> 提供了专用方法(<code>getNativeConnection</code>),该方法返回用于通信的原始底层对象.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>激活的 <code>RedisConnection</code> 对象是通过 <code>RedisConnectionFactory</code> 创建的. 另外,工厂还充当 <code>PersistenceExceptionTranslator</code> 对象,这意味着一旦声明,它们就可以让您进行透明的异常转换.
例如,您可以使用 <code>@Repository</code> 注解和AOP进行异常转换. 有关更多信息,请参见 Spring Framework 文档中的 <a href="https://docs.spring.io/spring/docs/5.2.12.RELEASE/spring-framework-reference/data-access.html#orm-exception-translation">相关部分</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
根据底层配置,工厂可以返回新连接或现有连接(使用池或共享本地连接时).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用 <code>RedisConnectionFactory</code> 的最简单方法是通过IoC容器配置适当的连接器,并将其注入 using 类.</p>
</div>
<div class="paragraph">
<p>不幸的是,当前,并非所有连接器都支持所有 Redis 功能. 在底层库不支持的 Connection API 上调用方法时,将抛出 <code>UnsupportedOperationException</code>.</p>
</div>
<table id="redis:connectors:overview" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Feature Availability across Redis Connectors</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Supported Feature</th>
<th class="tableblock halign-left valign-top">Lettuce</th>
<th class="tableblock halign-left valign-top">Jedis</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Standalone Connections</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#redis:write-to-master-read-from-replica">Master/Replica Connections</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#redis:sentinel">Redis Sentinel</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Master Lookup, Sentinel Authentication, Replica Reads</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Master Lookup</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#cluster">Redis Cluster</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cluster Connections, Cluster Node Connections, Replica Reads</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cluster Connections, Cluster Node Connections</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transport Channels</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP, OS-native TCP (epoll, kqueue), Unix Domain Sockets</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Connection Pooling</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X (using <code>commons-pool2</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X (using <code>commons-pool2</code>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Other Connection Features</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Singleton-connection sharing for non-blocking commands</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JedisShardInfo</code> support</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SSL Support</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#pubsub">Pub/Sub</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#pipeline">Pipelining</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#tx">Transactions</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Datatype support</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Key, String, List, Set, Sorted Set, Hash, Server, Stream, Scripting, Geo, HyperLogLog</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Key, String, List, Set, Sorted Set, Hash, Server, Scripting, Geo, HyperLogLog</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#redis:reactive">Reactive (non-blocking) API</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="redis:connectors:lettuce"><a class="anchor" href="#redis:connectors:lettuce"></a>9.4.2. 配置 Lettuce 连接器</h4>
<div class="paragraph">
<p><a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a> 是一个基于 <a href="https://netty.io/">Netty</a> 的 开源连接器.Spring Data Redis 通过 <code>org.springframework.data.redis.connection.lettuce</code> 包提供支持. 以下示例显示了如何创建新的 Lettuce 连接工厂:</p>
</div>
<div class="listingblock">
<div class="title">Add the following to the pom.xml files <code>dependencies</code> element:</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;

  &lt;!-- other dependency elements omitted --&gt;

  &lt;dependency&gt;
    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
    &lt;version&gt;{lettuce}&lt;/version&gt;
  &lt;/dependency&gt;

&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了如何创建新的 Lettuce 连接工厂:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
class AppConfig {

  @Bean
  public LettuceConnectionFactory redisConnectionFactory() {

    return new LettuceConnectionFactory(new RedisStandaloneConfiguration("server", 6379));
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以调整  Lettuce 连接参数.<code>LettuceConnectionFactory</code> 创建的所有 <code>LettuceConnection</code> 实例并且对于所有非阻塞和非事务操作共享相同的线程安全本地连接. 要每次使用特定连接,请将 <code>shareNativeConnection</code> 设置为 <code>false</code>.
如果将 <code>shareNativeConnection</code> 设置为 <code>false</code>,则还可以将 <code>LettuceConnectionFactory</code> 配置为使用 <code>LettucePool</code> 来池化阻塞和事务连接或所有连接.</p>
</div>
<div class="paragraph">
<p>Lettuce 与 Netty 的 <a href="https://netty.io/wiki/native-transports.html">native transports</a> 集成,可让您使用Unix域套接字与Redis通信. 确保包括与您的运行时环境匹配的适当的本地传输依赖. 以下示例显示了如何在 <code>/var/run/redis.sock</code> 上为Unix域套接字创建 Lettuce Connection 工厂:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
class AppConfig {

  @Bean
  public LettuceConnectionFactory redisConnectionFactory() {

    return new LettuceConnectionFactory(new RedisSocketConfiguration("/var/run/redis.sock"));
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Netty 当前支持用于OS本地传输的 epoll(Linux)和 kqueue (BSD/macOS)接口.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="redis:connectors:jedis"><a class="anchor" href="#redis:connectors:jedis"></a>9.4.3. 配置 Jedis 连接器</h4>
<div class="paragraph">
<p>Jedis 是一个社区驱动的连接器, Spring Data Redis 模块通过 <code>org.springframework.data.redis.connection.jedis</code> 包支持.</p>
</div>
<div class="listingblock">
<div class="title">Add the following to the pom.xml files <code>dependencies</code> element:</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;

  &lt;!-- other dependency elements omitted --&gt;

  &lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;{jedis}&lt;/version&gt;
  &lt;/dependency&gt;

&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Jedis 配置以最简单的形式如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
class AppConfig {

  @Bean
  public JedisConnectionFactory redisConnectionFactory() {
    return new JedisConnectionFactory();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>但是,对于生产用途,您可能想要调整主机或密码等设置,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
class RedisConfiguration {

  @Bean
  public JedisConnectionFactory redisConnectionFactory() {

    RedisStandaloneConfiguration config = new RedisStandaloneConfiguration("server", 6379);
    return new JedisConnectionFactory(config);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redis:write-to-master-read-from-replica"><a class="anchor" href="#redis:write-to-master-read-from-replica"></a>9.4.4. 主从复制</h4>
<div class="paragraph">
<p>Redis 主从复制设置&#8201;&#8212;&#8201;没有自动故障转移(有关自动故障转移,请参见:<a href="#redis:sentinel">Sentinel</a>)允许将数据安全地存储在更多节点上.
通过使用 <a href="#redis:connectors:lettuce">Lettuce</a>,可以将数据写入 Master,然后从副本中读取. 您可以使用 <code>LettuceClientConfiguration</code> 设置 读/写策略,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
class WriteToMasterReadFromReplicaConfiguration {

  @Bean
  public LettuceConnectionFactory redisConnectionFactory() {

    LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
      .readFrom(SLAVE_PREFERRED)
      .build();

    RedisStandaloneConfiguration serverConfig = new RedisStandaloneConfiguration("server", 6379);

    return new LettuceConnectionFactory(serverConfig, clientConfig);
  }
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
对于通过 <code>INFO</code> 信息报告非公共地址的环境(例如,在使用AWS时),请使用 <code>RedisStaticMasterReplicaConfiguration</code> 而不是 <code>RedisStandaloneConfiguration</code>. 请注意,<code>RedisStaticMasterReplicaConfiguration</code> 不支持发布/订阅,因为缺少在各个服务器之间传播的 Pub/Sub 消息.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis:sentinel"><a class="anchor" href="#redis:sentinel"></a>9.5. Redis Sentinel 支持</h3>
<div class="paragraph">
<p>为了处理高可用性 Redis,Spring Data Redis 使用 <code>RedisSentinelConfiguration</code> 支持 <a href="https://redis.io/topics/sentinel">Redis Sentinel</a>,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/**
 * Jedis
 */
@Bean
public RedisConnectionFactory jedisConnectionFactory() {
  RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration()
  .master("mymaster")
  .sentinel("127.0.0.1", 26379)
  .sentinel("127.0.0.1", 26380);
  return new JedisConnectionFactory(sentinelConfig);
}

/**
 * Lettuce
 */
@Bean
public RedisConnectionFactory lettuceConnectionFactory() {
  RedisSentinelConfiguration sentinelConfig = new RedisSentinelConfiguration()
  .master("mymaster")
  .sentinel("127.0.0.1", 26379)
  .sentinel("127.0.0.1", 26380);
  return new LettuceConnectionFactory(sentinelConfig);
}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>还可以使用 <code>PropertySource</code> 定义 <code>RedisSentinelConfiguration</code>,它允许您设置以下属性:</p>
</div>
<div class="ulist">
<div class="title">Configuration Properties</div>
<ul>
<li>
<p><code>spring.redis.sentinel.master</code>: 主节点的名称</p>
</li>
<li>
<p><code>spring.redis.sentinel.nodes</code>: 以逗号分隔的 host:port 列表</p>
</li>
<li>
<p><code>spring.redis.sentinel.password</code>: 使用 Redis Sentinel 进行身份验证时要应用的密码</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有时,需要与其中一个哨兵进行直接互动. 使用 <code>RedisConnectionFactory.getSentinelConnection()</code> 或 <code>RedisConnection.getSentinelCommands()</code> 可以访问配置的第一个活动 Sentinel.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Sentinel身份验证仅在使用 <a href="https://lettuce.io/">Lettuce</a> 时可用.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="redis:template"><a class="anchor" href="#redis:template"></a>9.6. 通过 RedisTemplate 处理对象</h3>
<div class="paragraph">
<p>大多数用户可能会使用 RedisTemplate 及其相应的包 <code>org.springframework.data.redis.core</code>. 实际上,由于 template 具有丰富的功能,因此它是Redis模块的核心类. 该 template 为 Redis 交互提供了高级抽象.
尽管 <code>RedisConnection</code> 提供了接受和返回二进制值(字节数组)的底层方法,但是 template 负责序列化和连接管理,使用户无需处理此类细节.</p>
</div>
<div class="paragraph">
<p>此外,该 template 提供了操作视图(根据 Redis 命令 <a href="https://redis.io/commands">参考</a>进行分组),提供了丰富,通用的接口,用于处理特定类型或特定键(通过 KeyBound 接口),如下表所述:</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">Table 2. Operational 视图</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Interface</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><em>Key Type Operations</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>GeoOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis 地理空间操作, 例如 <code>GEOADD</code>, <code>GEORADIUS</code>,&#8230;&#8203;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HashOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis hash 操作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HyperLogLogOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis HyperLogLog 操作, 例如 <code>PFADD</code>, <code>PFCOUNT</code>,&#8230;&#8203;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ListOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis list 操作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SetOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis set 操作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ValueOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis string (or value) 操作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ZSetOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis zset (or sorted set) 操作</p></td>
</tr>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><em>Key 绑定 Operations</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BoundGeoOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis key bound geospatial 操作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BoundHashOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis hash key bound 操作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BoundKeyOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis key bound 操作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BoundListOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis list key bound 操作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BoundSetOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis set key bound 操作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BoundValueOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis string (or value) key bound 操作</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BoundZSetOperations</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis zset (or sorted set) key bound 操作</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>配置后,该 template 是线程安全的,并且可以在多个实例之间重用.</p>
</div>
<div class="paragraph">
<p><code>RedisTemplate</code> 的大多数操作都使用基于 Java 的序列化. 这意味着 template 读写任何对象都将通过 Java 进行序列化和反序列化. 您可以更改 template 上的序列化机制,<code>Redis</code> 模块提供了几种实现,这些实现在 <code>org.springframework.data.redis.serializer</code> 包中可用.
有关更多信息,请参见<a href="#redis:serializer">序列化器</a>. 您还可以将任何序列化器设置为 <code>null</code>,并通过将 <code>enableDefaultSerializer</code> 属性设置为 <code>false</code> 来将 RedisTemplate 与原始字节数组一起使用.
请注意,template 要求所有 key 都不为空. 但是,只要基础序列化器接受这些值,它们就可以为空. 阅读每个序列化器的 Javadoc,以获取更多信息.</p>
</div>
<div class="paragraph">
<p>对于需要特定 template 视图的情况,请将视图声明为依赖并注入template. 容器自动执行转换,从而消除了  <code>opsFor[X]</code>  调用,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

  &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" p:use-pool="true"/&gt;
  &lt;!-- redis template definition --&gt;
  &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate" p:connection-factory-ref="jedisConnectionFactory"/&gt;
  ...

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Example {

  // inject the actual template
  @Autowired
  private RedisTemplate&lt;String, String&gt; template;

  // inject the template as ListOperations
  @Resource(name="redisTemplate")
  private ListOperations&lt;String, String&gt; listOps;

  public void addLink(String userId, URL url) {
    listOps.leftPush(userId, url.toExternalForm());
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis:string"><a class="anchor" href="#redis:string"></a>9.7. String 的便捷操作</h3>
<div class="paragraph">
<p>由于 Redis 中存储的键和值通常是 <code>java.lang.String</code>,因此 Redis 模块提供了 <code>RedisConnection</code> 和 <code>RedisTemplate</code> 的两个扩展,分别是 <code>StringRedisConnection</code>(及其 <code>DefaultStringRedisConnection</code> 实现)和 <code>StringRedisTemplate</code>, 这是一种便捷的一站式解决方案 用于密集的String操作.
除了绑定到字符串键之外,template 和连接还使用下面的 <code>StringRedisSerializer</code>,这意味着存储的键和值是人类可读的(假定Redis和您的代码中使用相同的编码). 以下清单显示了一个示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p"
  xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

  &lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" p:use-pool="true"/&gt;

  &lt;bean id="stringRedisTemplate" class="org.springframework.data.redis.core.StringRedisTemplate" p:connection-factory-ref="jedisConnectionFactory"/&gt;
  ...
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Example {

  @Autowired
  private StringRedisTemplate redisTemplate;

  public void addLink(String userId, URL url) {
    redisTemplate.opsForList().leftPush(userId, url.toExternalForm());
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与其他 Spring templates 一样,<code>RedisTemplate</code> 和 <code>StringRedisTemplate</code> 允许您通过 <code>RedisCallback</code> 接口直接与 Redis 交互. 此功能直接与 <code>RedisConnection</code> 对话,因此可以进行完全控制.
请注意,当使用 <code>StringRedisTemplate</code> 时,回调将接收 <code>StringRedisConnection</code> 的实例. 以下示例显示如何使用 <code>RedisCallback</code> 接口:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public void useCallback() {

  redisTemplate.execute(new RedisCallback&lt;Object&gt;() {
    public Object doInRedis(RedisConnection connection) throws DataAccessException {
      Long size = connection.dbSize();
      // Can cast to StringRedisConnection if using a StringRedisTemplate
      ((StringRedisConnection)connection).set("key", "value");
    }
   });
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis:serializer"><a class="anchor" href="#redis:serializer"></a>9.8. 序列化器</h3>
<div class="paragraph">
<p>从框架的角度来看,Redis 中存储的数据仅为字节. 尽管 Redis 本身支持各种类型,但在大多数情况下,它们是指数据的存储方式,而不是其表示的内容. 由用户决定是否将信息转换为字符串或任何其他对象.</p>
</div>
<div class="paragraph">
<p>在 Spring Data 中,用户(自定义)类型和原始数据之间的转换(反之亦然)由 <code>org.springframework.data.redis.serializer</code> 包中的 Redis 处理.</p>
</div>
<div class="paragraph">
<p>该包中包含两种类型的序列化器,顾名思义,它们负责序列化过程:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基于 <code>RedisSerializer</code> 的双向序列化器.</p>
</li>
<li>
<p>使用 <code>RedisElementReader</code> 和 <code>RedisElementWriter</code> 的元素 readers 和 writers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>他们之间的主要区别在于,<code>RedisSerializer</code> 主要序列化为 <code>byte[]</code>,而 readers 和 writers 则使用 <code>ByteBuffer</code>.</p>
</div>
<div class="paragraph">
<p>有多种实现方式(包括本文档中已经提到的两种):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>JdkSerializationRedisSerializer</code>, 默认情况下用于 <code>RedisCache</code> 和 <code>RedisTemplate</code>.</p>
</li>
<li>
<p><code>StringRedisSerializer</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是,可以通过 Spring <a href="https://docs.spring.io/spring/docs/5.2.12.RELEASE/spring-framework-reference/data-access.html#oxm">OXM</a> 支持或使用 <code>Jackson2JsonRedisSerializer</code> 或 <code>GenericJackson2JsonRedisSerializer</code> 将 <code>OxmSerializer</code> 用于 对象/XML映射,以 <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> 格式存储数据.</p>
</div>
<div class="paragraph">
<p>请注意,存储格式不仅限于 values. 它可以不受限制地用于 keys,values 或 hashes.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下,<code>RedisCache</code> 和 <code>RedisTemplate</code> 配置为使用 Java 的序列化机制. Java 的序列化机制允许 payloads 引发的远程代码执行,这些 payloads 利用易受攻击的库和类注入未验证的字节码. 在反序列化步骤中,操纵输入可能导致应用程序中不需要的代码执行. 因此,请勿在不受信任的环境中使用此序列化. 通常,我们强烈建议您使用其他任何消息格式(例如JSON).</p>
</div>
<div class="paragraph">
<p>如果您担心由 Java 序列化引起的安全漏洞,请考虑在核心JVM级别上使用通用序列化过滤器机制,该机制最初是为 JDK 9 开发的,但后来又移植到 JDK 8、7 和 6:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://blogs.oracle.com/java-platform-group/entry/incoming_filter_serialization_data_a">Filter Incoming Serialization Data</a>.</p>
</li>
<li>
<p><a href="https://openjdk.java.net/jeps/290">JEP 290</a>.</p>
</li>
<li>
<p><a href="https://www.owasp.org/index.php/Deserialization_of_untrusted_data">OWASP: Deserialization of untrusted data</a>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="redis.hashmappers.root"><a class="anchor" href="#redis.hashmappers.root"></a>9.9. Hash 映射</h3>
<div class="paragraph">
<p>可以通过在 Redis 中使用各种数据结构来存储数据. <code>Jackson2JsonRedisSerializer</code> 可以转换  <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> 格式的对象. 理想情况下,json数据作为一个字符创 key 的值. 您可以使用 Redis hash 来实现结构化对象的更复杂的映射.
Spring Data Redis 提供了各种将数据映射到哈希的策略(取决于用例):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过使用 <code>HashOperations</code> 和 <a href="#redis:serializer">serializer</a> 进行直接映射</p>
</li>
<li>
<p>使用 <a href="#redis.repositories">Redis 存储库</a></p>
</li>
<li>
<p>使用 <code>HashMapper</code> 和 <code>HashOperations</code></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="hash-mappers"><a class="anchor" href="#hash-mappers"></a>9.9.1. Hash Mappers</h4>
<div class="paragraph">
<p>Hash mappers 是将 map 对象 转为 <code>Map&lt;K,V&gt;</code> 并返回. HashMapper 一般都与 Redis 哈希 一起使用.</p>
</div>
<div class="paragraph">
<p>有多种实现方式:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BeanUtilsHashMapper</code> 使用 Spring 的 <a href="https://docs.spring.io/spring/docs/5.2.12.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html">BeanUtils</a>.</p>
</li>
<li>
<p><code>ObjectHashMapper</code> 使用 <a href="#redis.repositories.mapping">对象到哈希的映射</a>.</p>
</li>
<li>
<p><a href="#redis.hashmappers.jackson2"><code>Jackson2HashMapper</code></a> 使用 <a href="https://github.com/FasterXML/jackson">FasterXML Jackson</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了一种实现哈希映射的方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Person {
  String firstname;
  String lastname;

  // …
}

public class HashMapping {

  @Autowired
  HashOperations&lt;String, byte[], byte[]&gt; hashOperations;

  HashMapper&lt;Object, byte[], byte[]&gt; mapper = new ObjectHashMapper();

  public void writeHash(String key, Person person) {

    Map&lt;byte[], byte[]&gt; mappedHash = mapper.toHash(person);
    hashOperations.putAll(key, mappedHash);
  }

  public Person loadHash(String key) {

    Map&lt;byte[], byte[]&gt; loadedHash = hashOperations.entries("key");
    return (Person) mapper.fromHash(loadedHash);
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redis.hashmappers.jackson2"><a class="anchor" href="#redis.hashmappers.jackson2"></a>9.9.2. Jackson2HashMapper</h4>
<div class="paragraph">
<p><code>Jackson2HashMapper</code> 通过使用 <a href="https://github.com/FasterXML/jackson">FasterXML Jackson</a> 为域对象提供 Redis 哈希映射. <code>Jackson2HashMapper</code> 可以将顶级属性映射为 Hash 字段名称,并且可以选择将结构展平. 简单类型映射到简单值. 复杂类型(嵌套对象,集合,地图等)表示为嵌套JSON.</p>
</div>
<div class="paragraph">
<p>拼合为所有嵌套属性创建单个哈希条目,并尽可能将复杂类型解析为简单类型.</p>
</div>
<div class="paragraph">
<p>考虑以下类及其包含的数据结构:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Person {
  String firstname;
  String lastname;
  Address address;
  Date date;
  LocalDateTime localDateTime;
}

public class Address {
  String city;
  String country;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>映射结果:</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">Table 3. Normal Mapping</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Hash Field</th>
<th class="tableblock halign-left valign-top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">firstname</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Jon</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lastname</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Snow</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">address</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>{ "city" : "Castle Black", "country" : "The North" }</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1561543964015</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">localDateTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-01-02T12:13:14</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Flat Mapping</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">Table 4. Flat Mapping</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Hash Field</th>
<th class="tableblock halign-left valign-top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">firstname</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Jon</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lastname</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Snow</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">address.city</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Castle Black</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">address.country</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>The North</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1561543964015</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">localDateTime</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2018-01-02T12:13:14</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Flattening 要求所有属性名称都不得干扰JSON路径. 使用 flattening 时,不支持在 map keys 中使用 点 或方括号或将其用作属性名称. 结果哈希不能映射为一个对象.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>java.util.Date</code> 和 <code>java.util.Calendar</code> 用毫秒表示. 假如 <code>jackson-datatype-jsr310</code> 在类路径上,JSR-310 Date/Time 类型的将被序列化为他们的 <code>toString</code> 形式.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pubsub"><a class="anchor" href="#pubsub"></a>9.10. Redis 消息 (Pub/Sub)</h3>
<div class="paragraph">
<p>Spring Data 为 Redis 提供了专用的消息传递集成,其功能和命名与 Spring Framework 中的 JMS 集成相似.</p>
</div>
<div class="paragraph">
<p>Redis 消息传递可以大致分为两个功能区域:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>消息的发布或产生</p>
</li>
<li>
<p>订阅或消费消息</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这是通常称为 "发布/订阅”(简称 "发布/订阅”)的模式的示例. <code>RedisTemplate</code> 类用于消息生成.
对于类似于 Java EE 消息驱动 bean 样式的异步接收,Spring Data 提供了一个专用的消息监听器容器,该容器用于创建消息驱动的 POJO(MDP),并用于同步接收 <code>RedisConnection</code> 契约.</p>
</div>
<div class="paragraph">
<p><code>org.springframework.data.redis.connection</code> 和 <code>org.springframework.data.redis.listener</code> 包提供了 Redis 消息的核心功能</p>
</div>
<div class="sect3">
<h4 id="redis:pubsub:publish"><a class="anchor" href="#redis:pubsub:publish"></a>9.10.1. Publishing (发送消息)</h4>
<div class="paragraph">
<p>要发布消息,可以与其他操作一起使用底层 <code>RedisConnection</code> 或高级别 <code>RedisTemplate</code>. 这两个实体都提供了 <code>publish</code> 方法,该方法接受消息和目标通道作为参数. 虽然 <code>RedisConnection</code> 需要原始数据(字节数组), 但 <code>RedisTemplate</code> 允许将任意对象作为消息传递,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// send message through connection RedisConnection con = ...
byte[] msg = ...
byte[] channel = ...
con.publish(msg, channel); // send message through RedisTemplate
RedisTemplate template = ...
template.convertAndSend("hello!", "world");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redis:pubsub:subscribe"><a class="anchor" href="#redis:pubsub:subscribe"></a>9.10.2. Subscribing (接收消息)</h4>
<div class="paragraph">
<p>在接收端,可以直接命名一个 channels 或使用模式匹配来订阅一个或多个 channels. 后一种方法非常有用,因为它不仅允许使用一个命令创建多个订阅,而且还可以监听在订阅时尚未创建的 channel(只要它们与模式匹配).</p>
</div>
<div class="paragraph">
<p>在低层,<code>RedisConnection</code> 提供了 <code>subscription</code> 和 <code>pSubscribe</code> 方法,它们分别映射 Redis 命令以分别按通道或按模式进行订阅. 注意,可以将多个通道或模式用作参数. 要更改订阅的连接或查询连接是否在监听,<code>RedisConnection</code> 提供了 <code>getSubscription</code> 和 <code>isSubscribed</code> 方法.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Data Redis 中的订阅命令是阻塞的. 也就是说,在连接上调用订阅会导致当前线程阻塞,等待消息返回. 仅当取消订阅时才释放线程,这是在另一个线程在同一连接上调用 <code>unsubscribe</code> 或 <code>pUnsubscribe</code> 时发生的. 有关此问题的解决方案,请参见 &#8220;<a href="#redis:pubsub:subscribe:containers">消息监听容器</a>&#8221; (在本文档后面).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如前所述,一旦订阅,连接即开始等待消息. 仅允许添加新订阅,修改现有订阅以及取消现有订阅的命令. 调用 <code>subscribe</code>,<code>pSubscribe</code>, <code>unsubscribe</code> 或 <code>pUnsubscribe</code> 之外的其他任何操作都会引发异常.</p>
</div>
<div class="paragraph">
<p>为了订阅消息,需要实现 <code>MessageListener</code> 回调. 每次收到新消息时,都会通过 <code>onMessage</code> 方法调用回调并运行用户代码. 该接口不仅可以访问实际消息,还可以访问已通过其接收的通道,以及订阅使用的与通道匹配的模式(如果有). 该信息使被叫方不仅可以按内容来区分各种消息,还可以检查其他细节.</p>
</div>
<div class="sect4">
<h5 id="redis:pubsub:subscribe:containers"><a class="anchor" href="#redis:pubsub:subscribe:containers"></a>消息监听容器</h5>
<div class="paragraph">
<p>由于其阻塞性质,底层订阅并不吸引人,因为它要求每个监听器都具有连接和线程管理. 为了减轻这个问题,Spring Data 提供了 <code>RedisMessageListenerContainer</code>,它可以完成所有繁重的工作. 如果您熟悉 EJB 和J MS,则应该熟悉这些概念,因为它被设计为尽可能接近 Spring Framework 及其消息驱动的 POJO(MDP)的支持.</p>
</div>
<div class="paragraph">
<p><code>RedisMessageListenerContainer</code> 充当消息监听器容器. 它用于接收来自 Redis 通道的消息,并驱动注入到其中的 <code>MessageListener</code> 实例. 监听器容器负责消息接收的所有线程,并分派到监听器中进行处理. 消息监听器容器是MDP与消息传递提供程序之间的中介,并负责注册接收消息,资源获取和释放,异常转换等.
这使您作为应用程序开发人员可以编写与接收消息(并对消息做出响应)相关的(可能很复杂的)业务逻辑,并将样板Redis基础结构问题委托给框架.</p>
</div>
<div class="paragraph">
<p>此外,为了最大限度地减少应用程序占用空间,<code>RedisMessageListenerContainer</code> 允许一个连接和一个线程由多个监听器共享,即使它们不共享订阅.因此,无论应用程序跟踪多少监听器或通道,运行时间成本在整个生命周期中都保持不变.
此外,该容器允许更改运行时配置,以便您可以在应用程序运行时添加或删除监听器,而无需重新启动.此外,容器使用延迟订阅方法,仅在需要时才使用 <code>RedisConnection</code>.如果所有监听器都未订阅,则将自动执行清除,然后释放线程.</p>
</div>
<div class="paragraph">
<p>为了帮助解决消息的异步特性,容器需要使用 <code>java.util.concurrent.Executor</code>(或 Spring 的 <code>TaskExecutor</code>)来调度消息.根据负载,监听器的数量或运行时环境,应更改或调整执行程序,以更好地满足您的需求.
特别是在托管环境(例如应用服务器)中,强烈建议选择合适的 <code>TaskExecutor</code> 以利用其运行时.</p>
</div>
</div>
<div class="sect4">
<h5 id="redis:pubsub:subscribe:adapter"><a class="anchor" href="#redis:pubsub:subscribe:adapter"></a>MessageListenerAdapter</h5>
<div class="paragraph">
<p><code>MessageListenerAdapter</code> 类是 Spring 异步消息支持中的最后一个组件. 简而言之,它使您几乎可以将任何类暴露为MDP(尽管存在一些约束).</p>
</div>
<div class="paragraph">
<p>考虑以下接口定义:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface MessageDelegate {
  void handleMessage(String message);
  void handleMessage(Map message); void handleMessage(byte[] message);
  void handleMessage(Serializable message);
  // pass the channel/pattern as well
  void handleMessage(Serializable message, String channel);
 }</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意,尽管该接口未扩展 <code>MessageListener</code> 接口,但仍可以通过使用 <code>MessageListenerAdapter</code> 类将其用作MDP. 还请注意,如何根据各种消息处理方法可以接收和处理的各种消息类型的内容来强类型化. 另外,可以将发送消息的通道或模式作为 String 类型的第二个参数传递给该方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class DefaultMessageDelegate implements MessageDelegate {
  // implementation elided for clarity...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意上面的 <code>MessageDelegate</code> 接口的实现(上面的 <code>DefaultMessageDelegate</code> 类)如何完全没有 Redis 依赖. 这确实是我们使用以下配置将 MPO 制成的 POJO:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
 &lt;beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:redis="http://www.springframework.org/schema/redis"
   xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
   http://www.springframework.org/schema/redis https://www.springframework.org/schema/redis/spring-redis.xsd"&gt;

&lt;!-- the default ConnectionFactory --&gt;
&lt;redis:listener-container&gt;
  &lt;!-- the method attribute can be skipped as the default method name is "handleMessage" --&gt;
  &lt;redis:listener ref="listener" method="handleMessage" topic="chatroom" /&gt;
&lt;/redis:listener-container&gt;

&lt;bean id="listener" class="redisexample.DefaultMessageDelegate"/&gt;
 ...
&lt;beans&gt;</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
监听器主题可以是通道(for example, <code>topic="chatroom"</code>) 或模式(for example, <code>topic="*room"</code>)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>前面的示例使用 Redis 命名空间声明消息监听器容器,并自动将POJO注册为监听器. 完整的定义如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="messageListener" class="org.springframework.data.redis.listener.adapter.MessageListenerAdapter"&gt;
  &lt;constructor-arg&gt;
    &lt;bean class="redisexample.DefaultMessageDelegate"/&gt;
  &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean id="redisContainer" class="org.springframework.data.redis.listener.RedisMessageListenerContainer"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
  &lt;property name="messageListeners"&gt;
    &lt;map&gt;
      &lt;entry key-ref="messageListener"&gt;
        &lt;bean class="org.springframework.data.redis.listener.ChannelTopic"&gt;
          &lt;constructor-arg value="chatroom"/&gt;
        &lt;/bean&gt;
      &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每次接收到消息时,适配器都会自动且透明地(使用配置的 <code>RedisSerializer</code>)在底层格式和所需对象类型之间执行转换. 容器捕获并处理由方法调用引起的任何异常(默认情况下,异常会被记录).</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis.streams"><a class="anchor" href="#redis.streams"></a>9.11. Redis Streams</h3>
<div class="paragraph">
<p>Redis Streams 以更抽象的方式模拟日志数据结构. 就像一个日志文件,通常实现为以只附加模式打开的文件,从一开始就在随机位置或通过流式传输新消息来使用日志.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://redis.io/topics/streams-intro">Redis 参考文档</a> 中获取有关 Redis Stream 的文档.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Redis Streams 可以大致分为两个功能区域:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>追加记录</p>
</li>
<li>
<p>消费记录</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>尽管此模式与发布/订阅有相似之处,但主要区别在于消息的持久性及其使用方式.</p>
</div>
<div class="paragraph">
<p>尽管发布/订阅依赖于广播瞬态消息(即,如果您不收听,则会错过一条消息),但 Redis Stream 使用一种持久的,仅追加的数据类型,该类型将保留消息,直到流被修剪为止. 消费方面的另一个区别是<a href="#pubsub">Pub/Sub</a> 注册了服务器端订阅. Redis Stream 需要活动轮询时,
Redis 将到达的消息推送到客户端.</p>
</div>
<div class="paragraph">
<p><code>org.springframework.data.redis.connection</code> 和 <code>org.springframework.data.redis.stream</code> 包提供 Redis Streams 的核心功能.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Redis Stream 支持当前仅可通过 <a href="#redis:connectors:lettuce">Lettuce 客户端</a> 获得,因为  <a href="#redis:connectors:jedis">Jedis</a> 尚不支持.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="redis.streams.send"><a class="anchor" href="#redis.streams.send"></a>9.11.1. 追加</h4>
<div class="paragraph">
<p>要发送记录,可以与其他操作一起使用底层 <code>RedisConnection</code> 或高级 <code>StreamOperations</code>. 这两个实体都提供 <code>add</code> (<code>xAdd</code>) 方法,该方法接受记录和目标流作为参数.
尽管 <code>RedisConnection</code> 需要原始数据(字节数组),但 <code>StreamOperations</code> 允许将任意对象作为记录传递,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// append message through connection
RedisConnection con = …
byte[] stream = …
ByteRecord record = StreamRecords.rawBytes(…).withStreamKey(stream);
con.xAdd(record);

// append message through RedisTemplate
RedisTemplate template = …
StringRecord record = StreamRecords.string(…).withStreamKey("my-stream");
template.streamOps().add(record);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Stream 记录携带 <code>Map</code>,键值元组作为其有效负载. 将记录追加到流将返回 RecordId,该 RecordId 可用作进一步参考.</p>
</div>
</div>
<div class="sect3">
<h4 id="redis.streams.receive"><a class="anchor" href="#redis.streams.receive"></a>9.11.2. 消费</h4>
<div class="paragraph">
<p>在消费方面,可以消费一个或多个流. Redis 流提供读取命令,该命令允许从已知流内容内的任意位置(流访问之外)的任意位置(随机访问)使用流,以消耗新的流记录.</p>
</div>
<div class="paragraph">
<p>在低层,<code>RedisConnection</code> 提供了 <code>xRead</code> 和 <code>xReadGroup</code> 方法,它们分别映射 Redis 命令以在使用者组中进行读取和读取. 请注意,可以将多个流用作参数.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Redis 中的订阅命令可能被阻塞. 也就是说,在连接上调用 <code>xRead</code> 会导致当前线程在开始等待消息并阻塞. 仅当读取命令超时或收到消息时才释放线程.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使用流消息,可以在应用程序代码中轮询消息,或者通过消息监听器容器使用两种 <a href="#redis.streams.receive.containers">通过消息监听器容器进行异步接收</a> 之一,即命令式或响应式. 每当有新记录到达时,容器都会通知应用程序代码.</p>
</div>
<div class="sect4">
<h5 id="redis.streams.receive.synchronous"><a class="anchor" href="#redis.streams.receive.synchronous"></a>同步接收</h5>
<div class="paragraph">
<p>虽然消费流通常与异步处理相关联,但是可以同步消费消息. 重载的  <code>StreamOperations.read(…)</code> 方法提供了此功能. 在同步接收期间,调用线程可能会阻塞,直到消息可用为止. <code>StreamReadOptions.block</code> 属性指定接收者在放弃等待消息之前应该等待多长时间.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Read message through RedisTemplate
RedisTemplate template = …

List&lt;MapRecord&lt;K, HK, HV&gt;&gt; messages = template.streamOps().read(StreamReadOptions.empty().count(2),
                StreamOffset.latest("my-stream"));

List&lt;MapRecord&lt;K, HK, HV&gt;&gt; messages = template.streamOps().read(Consumer.from("my-group", "my-consumer"),
                StreamReadOptions.empty().count(2),
                StreamOffset.create("my-stream", ReadOffset.lastConsumed()))</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="redis.streams.receive.containers"><a class="anchor" href="#redis.streams.receive.containers"></a>通过消息监听器容器进行异步接收</h5>
<div class="paragraph">
<p>由于其阻塞性质,低级别轮询没有吸引力,因为它需要每个单个使用者进行连接和线程管理. 为了减轻这个问题,Spring Data 提供了消息监听器,它可以完成所有繁重的工作. 如果您熟悉 EJB 和 JMS,则应该熟悉这些概念,因为它被设计为尽可能接近 Spring Framework 及其消息驱动的POJO(MDP)的支持.</p>
</div>
<div class="paragraph">
<p>Spring Data 附带了两种针对所用编程模型的实现:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>StreamMessageListenerContainer</code> 充当命令式编程模型的消息监听器容器. 它用于消耗Redis流中的记录并驱动注入其中的 <code>StreamListener</code> 实例.</p>
</li>
<li>
<p><code>StreamReceiver</code> 提供了消息监听器的响应式变体. 它用于将来自Redis流的消息作为潜在的无限流使用,并通过 <code>Flux</code> 发出流消息.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>StreamMessageListenerContainer</code> 和 <code>StreamReceiver</code> 负责消息接收的所有线程,并分派到监听器中进行处理. 消息监听器容器/接收器是MDP与消息传递提供程序之间的中介,并负责注册接收消息,资源获取和释放,异常转换等.
这使您作为应用程序开发人员可以编写与接收消息(并对消息做出响应)相关的(可能很复杂的)业务逻辑,并将样板 Redis 基础结构问题委托给框架.</p>
</div>
<div class="paragraph">
<p>这两个容器都允许更改运行时配置,因此您可以在应用程序运行时添加或删除订阅,而无需重新启动. 此外,容器使用延迟订阅方法,仅在需要时才使用 <code>RedisConnection</code>. 如果所有监听器都未订阅,它将自动执行清除,然后释放线程.</p>
</div>
<div class="sect5">
<h6 id="streammessagelistenercontainer"><a class="anchor" href="#streammessagelistenercontainer"></a><code>StreamMessageListenerContainer</code></h6>
<div class="paragraph">
<p>流驱动POJO(SDP)以类似于EJB世界中的消息驱动Bean(MDB)的方式充当流消息的接收者. SDP 的一个限制是它必须实现 <code>org.springframework.data.redis.stream.StreamListener</code> 接口. 还请注意,在POJO在多个线程上接收消息的情况下,确保您的实现是线程安全的很重要.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class ExampleStreamListener implements StreamListener&lt;String, MapRecord&lt;String, String, String&gt;&gt; {

    @Override
    public void onMessage(MapRecord&lt;String, String, String&gt; message) {

        System.out.println("MessageId: " + message.getId());
        System.out.println("Stream: " + message.getStream());
        System.out.println("Body: " + message.getValue());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>StreamListener</code> 表示一个功能接口,因此可以使用其 Lambda 形式重写实现:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">message -&gt; {

    System.out.println("MessageId: " + message.getId());
    System.out.println("Stream: " + message.getStream());
    System.out.println("Body: " + message.getValue());
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦实现了 <code>StreamListener</code>,就可以创建一个消息监听器容器并注册订阅了:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RedisConnectionFactory connectionFactory = …
StreamListener&lt;String, MapRecord&lt;String, String, String&gt;&gt; streamListener = …

StreamMessageListenerContainerOptions&lt;String, MapRecord&lt;String, String, String&gt;&gt; containerOptions = StreamMessageListenerContainerOptions
            .builder().pollTimeout(Duration.ofMillis(100)).build();

StreamMessageListenerContainer&lt;String, MapRecord&lt;String, String, String&gt;&gt; container = StreamMessageListenerContainer.create(connectionFactory,
                containerOptions);

Subscription subscription = container.receive(StreamOffset.fromStart("my-stream"), streamListener);</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅各种消息监听器容器的 Javadoc,以获取每个实现所支持功能的完整说明.</p>
</div>
</div>
<div class="sect5">
<h6 id="reactive-streamreceiver"><a class="anchor" href="#reactive-streamreceiver"></a>Reactive <code>StreamReceiver</code></h6>
<div class="paragraph">
<p>流式数据源的 Reactive consumption 通常通过 <code>Flux</code> 的事件或消息发生. 响应接收器实现由 <code>StreamReceiver</code> 和重载的 <code>receive(…)</code> 消息提供. 与 <code>StreamMessageListenerContainer</code> 相比,被动方法需要更少的基础结构资源,例如线程,因为它利用了驱动程序提供的线程资源. 接收流是 <code>StreamMessage</code> 的需求驱动的发布者:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;MapRecord&lt;String, String, String&gt;&gt; messages = …

return messages.doOnNext(it -&gt; {
    System.out.println("MessageId: " + message.getId());
    System.out.println("Stream: " + message.getStream());
    System.out.println("Body: " + message.getValue());
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们需要创建 <code>StreamReceiver</code> 并注册一个订阅以使用流消息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ReactiveRedisConnectionFactory connectionFactory = …

StreamReceiverOptions&lt;String, MapRecord&lt;String, String, String&gt;&gt; options = StreamReceiverOptions.builder().pollTimeout(Duration.ofMillis(100))
                .build();
StreamReceiver&lt;String, MapRecord&lt;String, String, String&gt;&gt; receiver = StreamReceiver.create(connectionFactory, options);

Flux&lt;MapRecord&lt;String, String, String&gt;&gt; messages = receiver.receive(StreamOffset.fromStart("my-stream"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅各种消息监听器容器的 Javadoc,以获取每个实现所支持功能的完整说明.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
需求驱动的消耗使用背压信号来激活和停用轮询. 如果满足需求,则 <code>StreamReceiver</code> 订阅将暂停轮询,直到订阅者发出进一步的请求. 根据 <code>ReadOffset</code> 策略,这可能导致消息被跳过.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="redis.streams.acknowledge"><a class="anchor" href="#redis.streams.acknowledge"></a><code>Acknowledge</code> 策略</h5>
<div class="paragraph">
<p>当您通过 <code>Consumer Group</code> 阅读邮件时,服务器将记住已传递给定邮件,并将其添加到"待处理条目列表”(PEL)中. 已发送但尚未确认的邮件列表.
消息必须通过 <code>StreamOperations.acknowledge</code> 进行确认,以便从待处理条目列表中删除,如下面的代码片段所示.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StreamMessageListenerContainer&lt;String, MapRecord&lt;String, String, String&gt;&gt; container = ...

container.receive(Consumer.from("my-group", "my-consumer"), <i class="conum" data-value="1"></i><b>(1)</b>
    StreamOffset.create("my-stream", ReadOffset.lastConsumed()),
    msg -&gt; {

        // ...
        redisTemplate.opsForStream().acknowledge("my-group", msg); <i class="conum" data-value="2"></i><b>(2)</b>
    });</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>从 <em>my-group</em> 组读取为 <em>my-consumer</em>. 收到的消息不被确认.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>处理后确认消息.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
要在接收时自动确认消息,请使用 <code>receiveAutoAck</code> 而不是 <code>receive</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="redis.streams.receive.readoffset"><a class="anchor" href="#redis.streams.receive.readoffset"></a><code>ReadOffset</code> 策略</h5>
<div class="paragraph">
<p>流读取操作接受读取偏移量规范以从给定偏移量开始消耗消息. <code>ReadOffset</code> 表示读取偏移量规范. Redis支持三种偏移量,具体取决于您是独立使用流还是在使用者组中使用流:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ReadOffset.latest()</code> – 阅读最新消息.</p>
</li>
<li>
<p><code>ReadOffset.from(…)</code> – 在特定消息ID之后阅读.</p>
</li>
<li>
<p><code>ReadOffset.lastConsumed()</code> – 在最后消耗的消息ID之后读取(仅针对消费者组).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在基于消息容器的使用情况下,我们在使用消息时需要提高(或增加)读取偏移量. 前进取决于请求的 <code>ReadOffset</code> 和消费模式(有/无消费组). 以下矩阵说明了容器如何提高 <code>ReadOffset</code>:</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 5. ReadOffset Advancing</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Read offset</th>
<th class="tableblock halign-left valign-top">Standalone</th>
<th class="tableblock halign-left valign-top">Consumer Group</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Latest</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read latest message</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read latest message</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specific Message Id</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use last seen message as the next MessageId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use last seen message as the next MessageId</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Last Consumed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use last seen message as the next MessageId</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Last consumed message as per consumer group</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>从特定消息ID和最后使用的消息读取可以被视为安全操作,可确保消耗附加到流中的所有消息. 使用最新消息进行读取可以跳过在轮询操作处于停滞时间状态时添加到流中的消息. 轮询会引入一个停滞时间,在该停滞时间内消息可以在各个轮询命令之间到达. 流消耗不是线性连续读取,
而是分成重复的 <code>XREAD</code> 调用.</p>
</div>
</div>
<div class="sect4">
<h5 id="redis.streams.receive.serialization"><a class="anchor" href="#redis.streams.receive.serialization"></a>序列化</h5>
<div class="paragraph">
<p>发送到流的任何记录都需要序列化为其二进制格式. 由于流与哈希数据结构非常接近,因此流键,字段名称和值使用在 <code>RedisTemplate</code> 上配置的相应序列化器.</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 6. Stream Serialization</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Stream Property</th>
<th class="tableblock halign-left valign-top">Serializer</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">key</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">keySerializer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">used for <code>Record#getStream()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">field</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hashKeySerializer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">used for each map key in the payload</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">value</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">hashValueSerializer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">used for each map value in the payload</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>请确保查看使用中的Redis  <code>RedisSerializer</code>,并注意,如果您决定不使用任何序列化器,则需要确保这些值已经是二进制的.</p>
</div>
</div>
<div class="sect4">
<h5 id="redis.streams.hashing"><a class="anchor" href="#redis.streams.hashing"></a>Object Mapping</h5>
<div class="sect5">
<h6 id="简单的值"><a class="anchor" href="#简单的值"></a>简单的值</h6>
<div class="paragraph">
<p><code>StreamOperations</code> 允许通过 <code>ObjectRecord</code> 将简单值直接附加到流,而不必将这些值放入 <code>Map</code> 结构中. 然后将该值分配给有效负载字段,并在读回该值时可以将其提取.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ObjectRecord&lt;String, String&gt; record = StreamRecords.newRecord()
    .in("my-stream")
    .ofObject("my-value");

redisTemplate()
    .opsForStream()
    .add(record); <i class="conum" data-value="1"></i><b>(1)</b>

List&lt;ObjectRecord&lt;String, String&gt;&gt; records = redisTemplate()
    .opsForStream()
    .read(String.class, StreamOffset.fromStart("my-stream"));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>XADD my-stream * "_class" "java.lang.String" "_raw" "my-value"</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ObjectRecord</code>s 与所有其他记录通过相同的序列化过程,因此 Record 也可以使用返回 <code>MapRecord</code> 的无类型读取操作获得.</p>
</div>
</div>
<div class="sect5">
<h6 id="复杂的值"><a class="anchor" href="#复杂的值"></a>复杂的值</h6>
<div class="paragraph">
<p>可以通过3种方式将复杂的值添加到流中:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用转换为简单值. 字符串JSON表示形式.</p>
</li>
<li>
<p>用合适的 <code>RedisSerializer</code> 序列化该值.</p>
</li>
<li>
<p>使用 <code>HashMapper</code> 将值转换为适合于序列化的 <code>Map</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>第一个变体是最直接的变体,但忽略了流结构提供的字段值功能,但流中的值仍可供其他使用者读取. 第二个选项具有与第一个选项相同的好处,但是可能会导致非常特殊的使用方限制,因为所有使用方都必须实现完全相同的序列化机制. <code>HashMapper</code> 方法是一种更复杂的方法,它使用了 Steam 哈希结构,但是却使源代码变得平坦. 只要选择了合适的序列化器组合,其他使用者仍然可以读取记录.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>HashMappers</code> 将有效负载转换为具有特定类型的Map. 确保使用能够(反)序列化哈希的哈希键和哈希值序列化程序.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ObjectRecord&lt;String, User&gt; record = StreamRecords.newRecord()
    .in("user-logon")
    .ofObject(new User("night", "angel"));

redisTemplate()
    .opsForStream()
    .add(record); <i class="conum" data-value="1"></i><b>(1)</b>

List&lt;ObjectRecord&lt;String, User&gt;&gt; records = redisTemplate()
    .opsForStream()
    .read(User.class, StreamOffset.fromStart("user-logon"));</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>XADD user-logon * "_class" "com.example.User" "firstname" "night" "lastname" "angel"</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下,<code>StreamOperations</code> 使用  <a href="#redis.repositories.mapping">ObjectHashMapper</a>. 获取 <code>StreamOperations</code> 时,可以提供适合您要求的 <code>HashMapper</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">redisTemplate()
    .opsForStream(new Jackson2HashMapper(true))
    .add(record); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>XADD user-logon * "firstname" "night" "@class" "com.example.User" "lastname" "angel"</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>StreamMessageListenerContainer</code> 可能并不知道 domain 类型上使用的任何 <code>@TypeAlias</code>, 因为需要通过 <code>MappingContext</code> 进行解析. 确保使用 <code>initialEntitySet</code> 初始化 <code>RedisMappingContext</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
RedisMappingContext redisMappingContext() {
    RedisMappingContext ctx = new RedisMappingContext();
    ctx.setInitialEntitySet(Collections.singleton(Person.class));
    return ctx;
}

@Bean
RedisConverter redisConverter(RedisMappingContext mappingContext) {
    return new MappingRedisConverter(mappingContext);
}

@Bean
ObjectHashMapper hashMapper(RedisConverter converter) {
    return new ObjectHashMapper(converter);
}

@Bean
StreamMessageListenerContainer streamMessageListenerContainer(RedisConnectionFactory connectionFactory, ObjectHashMapper hashMapper) {
    StreamMessageListenerContainerOptions&lt;String, ObjectRecord&lt;String, Object&gt;&gt; options = StreamMessageListenerContainerOptions.builder()
            .objectMapper(hashMapper)
            .build();

    return StreamMessageListenerContainer.create(connectionFactory, options);
}</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tx"><a class="anchor" href="#tx"></a>9.12. Redis 事务</h3>
<div class="paragraph">
<p>Redis通过 <code>multi</code>, <code>exec</code>, 和 <code>discard</code> 命令为 <a href="https://redis.io/topics/transactions">事务</a> 提供支持.  这些操作在 <code>RedisTemplate</code> 上可用. 但是,不能保证 <code>RedisTemplate</code> 使用相同的连接来执行事务中的所有操作.</p>
</div>
<div class="paragraph">
<p>当需要在同一连接上执行多个操作时,例如在使用 Redis 事务时,Spring Data Redis 提供了 <code>SessionCallback</code> 接口. 下面的示例使用 <code>multi</code> 方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">//execute a transaction
List&lt;Object&gt; txResults = redisTemplate.execute(new SessionCallback&lt;List&lt;Object&gt;&gt;() {
  public List&lt;Object&gt; execute(RedisOperations operations) throws DataAccessException {
    operations.multi();
    operations.opsForSet().add("key", "value1");

    // This will contain the results of all operations in the transaction
    return operations.exec();
  }
});
System.out.println("Number of items added to set: " + txResults.get(0));</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RedisTemplate</code> 使用其值,哈希键和哈希值序列化程序在返回之前反序列化 <code>exec</code> 的所有结果. 还有一个附加的 <code>exec</code> 方法,可让您传递自定义的序列化程序以获取事务结果.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从版本1.1开始,已对 <code>RedisConnection</code> 和 <code>RedisTemplate</code> 的 <code>exec</code> 方法进行了重要更改. 以前,这些方法直接从连接器返回事务处理的结果. 这意味着数据类型通常不同于 <code>RedisConnection</code> 方法返回的数据类型.
例如,<code>zAdd</code> 返回一个布尔值,指示该元素是否已添加到排序集中. 大多数连接器都会将此值返回为 <code>long</code>,而 Spring Data Redis 将执行转换. 另一个常见的区别是,大多数连接器针对诸如 <code>set</code> 之类的操作返回状态答复
(通常为字符串 <code>OK</code>). 这些答复通常被 Spring Data Redis 丢弃. 在1.1之前的版本中,未对 <code>exec</code> 的结果执行这些转换. 此外,结果未在 <code>RedisTemplate</code> 中反序列化,因此它们通常包含原始字节数组.
如果此更改使您的应用程序中断,请在 <code>RedisConnectionFactory</code> 上将 <code>convertPipelineAndTxResults</code> 设置为 <code>false</code> 以禁用此行为.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="tx.spring"><a class="anchor" href="#tx.spring"></a>9.12.1. @Transactional 支持</h4>
<div class="paragraph">
<p>默认情况下,事务支持是禁用的,必须通过设置  <code>setEnableTransactionSupport(true)</code> 为正在使用的每个 <code>RedisTemplate</code> 显式启用. 这样做会强制将当前 <code>RedisConnection</code> 绑定到触发 <code>MULTI</code> 的当前线程.
如果事务顺利完成,则调用 <code>EXEC</code>. 否则调用 <code>DISCARD</code>. 一旦进入 <code>MULTI</code>,<code>RedisConnection</code> 会将写入操作排队. 所有只读操作(例如 <code>KEYS</code>)都通过管道传递到新的(非线程绑定)<code>RedisConnection</code>.</p>
</div>
<div class="paragraph">
<p>以下示例显示如何配置事务管理:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Configuration enabling Transaction Management</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableTransactionManagement                                 <i class="conum" data-value="1"></i><b>(1)</b>
public class RedisTxContextConfiguration {

  @Bean
  public StringRedisTemplate redisTemplate() {
    StringRedisTemplate template = new StringRedisTemplate(redisConnectionFactory());
    // explicitly enable transaction support
    template.setEnableTransactionSupport(true);              <i class="conum" data-value="2"></i><b>(2)</b>
    return template;
  }

  @Bean
  public RedisConnectionFactory redisConnectionFactory() {
    // jedis || Lettuce
  }

  @Bean
  public PlatformTransactionManager transactionManager() throws SQLException {
    return new DataSourceTransactionManager(dataSource());   <i class="conum" data-value="3"></i><b>(3)</b>
  }

  @Bean
  public DataSource dataSource() throws SQLException {
    // ...
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>配置一个 Spring Context 来启用 <a href="https://docs.spring.io/spring/docs/5.2.12.RELEASE/spring-framework-reference/data-access.html#transaction-declarative">声明式事务管理</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>通过将连接绑定到当前线程来配置 <code>RedisTemplate</code> 参与事务.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>事务管理需要 <code>PlatformTransactionManager</code>. Spring Data Redis 不附带 <code>PlatformTransactionManager</code> 实现. 假设您的应用程序使用J DBC,Spring Data Redis 可以使用现有的事务管理器参与事务.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例每个都演示了使用约束:</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. Usage Constraints</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// must be performed on thread-bound connection
template.opsForValue().set("thing1", "thing2");

// read operation must be executed on a free (not transaction-aware) connection
template.keys("*");

// returns null as values set within a transaction are not visible
template.opsForValue().get("thing1");</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pipeline"><a class="anchor" href="#pipeline"></a>9.13. 流水线</h3>
<div class="paragraph">
<p>Redis 提供了对 <a href="https://redis.io/topics/pipelining">流水线</a> 的支持,该流水线涉及到向服务器发送多个命令,而无需等待答复,然后在一个步骤中读取答复. 当您需要连续发送多个命令(例如将多个元素添加到同一List)时,流水线可以提高性能.</p>
</div>
<div class="paragraph">
<p>Spring Data Redis 提供了几种 <code>RedisTemplate</code> 方法来执行流水线中的命令. 如果您不关心流水线操作的结果,则可以使用标准的 <code>execute</code> 方法,将流水线参数传递为 <code>true</code>. <code>executePipelined</code> 方法在流水线中运行提供的
<code>RedisCallback</code> 或 <code>SessionCallback</code> 并返回结果,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">//pop a specified number of items from a queue
List&lt;Object&gt; results = stringRedisTemplate.executePipelined(
  new RedisCallback&lt;Object&gt;() {
    public Object doInRedis(RedisConnection connection) throws DataAccessException {
      StringRedisConnection stringRedisConn = (StringRedisConnection)connection;
      for(int i=0; i&lt; batchSize; i++) {
        stringRedisConn.rPop("myqueue");
      }
    return null;
  }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例从流水线中的队列中运行项目的批量右弹出. 结果列表包含所有弹出项目. <code>RedisTemplate</code> 使用其值,哈希键和哈希值序列化器在返回之前对所有结果进行反序列化,因此前面示例中返回的项目为字符串.
还有其他的 <code>executePipelined</code> 方法,可让您传递自定义序列化程序以获取流水线结果.</p>
</div>
<div class="paragraph">
<p>请注意,从 <code>RedisCallback</code> 返回的值必须为 <code>null</code>,因为为了支持返回流水线命令的结果而将其丢弃.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Lettuce 驱动程序支持细粒度的刷新控制,该控件可以刷新出现的命令,在连接关闭时对其进行缓冲或发送.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">LettuceConnectionFactory factory = // ...
factory.setPipeliningFlushPolicy(PipeliningFlushPolicy.buffered(3)); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在第三个命令后本地缓冲并刷新.</td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从版本1.1开始,已对 <code>RedisConnection</code> 和 <code>RedisTemplate</code> 的 <code>exec</code> 方法进行了重要更改. 以前,这些方法直接从连接器返回事务处理的结果. 这意味着数据类型通常不同于 <code>RedisConnection</code> 方法返回的数据类型.
例如,<code>zAdd</code> 返回一个布尔值,指示该元素是否已添加到排序集中. 大多数连接器都会将此值返回为 <code>long</code>,而 Spring Data Redis 将执行转换. 另一个常见的区别是,大多数连接器针对诸如 <code>set</code> 之类的操作返回状态答复
(通常为字符串 <code>OK</code>). 这些答复通常被 Spring Data Redis 丢弃. 在1.1之前的版本中,未对 <code>exec</code> 的结果执行这些转换. 此外,结果未在 <code>RedisTemplate</code> 中反序列化,因此它们通常包含原始字节数组.
如果此更改使您的应用程序中断,请在 <code>RedisConnectionFactory</code> 上将 <code>convertPipelineAndTxResults</code> 设置为 <code>false</code> 以禁用此行为.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="scripting"><a class="anchor" href="#scripting"></a>9.14. Redis 脚本</h3>
<div class="paragraph">
<p>Redis 2.6及更高版本通过 <a href="https://redis.io/commands/eval">eval</a> 和 <a href="https://redis.io/commands/evalsha">evalsha</a> 命令提供了对 Lua 脚本执行的支持. Spring Data Redis 为脚本执行提供了高级抽象,该抽象处理了序列化并自动使用 Redis 脚本缓存.</p>
</div>
<div class="paragraph">
<p>可以通过调用 <code>RedisTemplate</code> 和 <code>ReactiveRedisTemplate</code> 的 <code>execute</code> 方法来运行脚本.两者都使用可配置的 <code>ScriptExecutor</code>(或 <code>ReactiveScriptExecutor</code>)来运行提供的脚本.默认情况下,<code>ScriptExecutor</code>(或 <code>ReactiveScriptExecutor</code>)负责序列化提供的键和参数并反序列化脚本结果.这是通过模板的键和值序列化程序完成的.还有一个额外的重载,可让您传递脚本参数和结果的自定义序列化程序.</p>
</div>
<div class="paragraph">
<p>默认的 <code>ScriptExecutor</code> 通过检索脚本的SHA1并首先尝试运行 evalsha 来优化性能,如果Redis脚本缓存中还没有该脚本,则回退到eval.</p>
</div>
<div class="paragraph">
<p>以下示例通过使用 Lua 脚本运行常见的  &#8220;check-and-set&#8221; 方案.这是 Redis 脚本的理想用例,因为它需要原子地运行一组命令,并且一个命令的行为会受到另一个命令的结果的影响.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public RedisScript&lt;Boolean&gt; script() {

  ScriptSource scriptSource = new ResourceScriptSource(new ClassPathResource("META-INF/scripts/checkandset.lua"));
  return RedisScript.of(scriptSource, Boolean.class);
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Example {

  @Autowired
  RedisScript&lt;Boolean&gt; script;

  public boolean checkAndSet(String expectedValue, String newValue) {
    return redisTemplate.execute(script, singletonList("key"), asList(expectedValue, newValue));
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-lua" data-lang="lua">-- checkandset.lua
local current = redis.call('GET', KEYS[1])
if current == ARGV[1]
  then redis.call('SET', KEYS[1], ARGV[2])
  return true
end
return false</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的代码配置 <code>RedisScript</code> 指向一个名为 <code>checkandset.lua</code> 的文件,该文件应返回布尔值. 脚本 <code>resultType</code> 应该是 <code>Long</code>,<code>Boolean</code>,<code>List</code> 或反序列化值类型之一. 如果脚本返回抛弃状态(特别是 <code>OK</code>),则它也可以为 <code>null</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
理想的是在您的应用程序上下文中配置 <code>DefaultRedisScript</code> 的单个实例,以避免在每次执行脚本时重新计算脚本的 SHA1.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后,上面的 <code>checkAndSet</code> 方法运行脚本. 脚本可以在 <code>SessionCallback</code> 内作为事务或管道的一部分运行. 有关更多信息,请参见 &#8220;<a href="#tx">Redis 事务</a>&#8221; 和  &#8220;<a href="#pipeline">流水线</a>&#8221; .</p>
</div>
<div class="paragraph">
<p>Spring Data Redis 提供的脚本支持还允许您通过使用 Spring Task 和 Scheduler 抽象来调度 Redis 脚本以定期执行. 有关更多详细信息,请参见 <a href="https://projects.spring.io/spring-framework/">Spring Framework</a> 文档.</p>
</div>
</div>
<div class="sect2">
<h3 id="redis:support"><a class="anchor" href="#redis:support"></a>9.15. 支持的类</h3>
<div class="paragraph">
<p><code>org.springframework.data.redis.support</code> 包供了各种依赖 Redis 的可重用组件. 当前,该包在 Redis 之上包含各种基于JDK的接口实现,例如 <a href="https://download.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html">atomic</a>和 JDK <a href="https://download.oracle.com/javase/8/docs/api/java/util/Collection.html">Collections</a>.</p>
</div>
<div class="paragraph">
<p>通过原子计数器,可以轻松的使 Redis key 递增,而集合则可以轻松管理 Redis key,并最大程度地减少存储风险或API泄漏. 特别是,<code>RedisSet</code> 和 <code>RedisZSet</code> 接口可轻松访问 Redis 支持的设置操作,例如交集和并集.
<code>RedisList</code> 在 Redis 之上实现 List,Queue 和 Deque 契约(及其等效的阻塞同级),将存储作为 FIFO(先进先出),LIFO(先进先出)或加盖 只需最少的配置即可收集. 以下示例显示了使用 <code>RedisList</code> 的bean的配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="
  http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

  &lt;bean id="queue" class="org.springframework.data.redis.support.collections.DefaultRedisList"&gt;
    &lt;constructor-arg ref="redisTemplate"/&gt;
    &lt;constructor-arg value="queue-key"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 Java 配置 <code>Deque</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AnotherExample {

  // injected
  private Deque&lt;String&gt; queue;

  public void addTag(String tag) {
    queue.push(tag);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前面的示例所示,使用代码与实际的存储实现分离. 实际上,没有迹象表明在下面使用了 Redis. 这使得从开发环境到生产环境的迁移变得透明,并大大提高了可测试性(Redis实施可替换为内存中的实施).</p>
</div>
<div class="sect3">
<h4 id="redis:support:cache-abstraction"><a class="anchor" href="#redis:support:cache-abstraction"></a>9.15.1. 支持 Spring Cache 抽象</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Changed in 2.0
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Redis 通过 <code>org.springframework.data.redis.cache</code> 包提供了 Spring <a href="https://docs.spring.io/spring/docs/5.2.12.RELEASE/spring-framework-reference/integration.html#cache">缓存抽象</a>的实现. 要将 Redis 用作实现,请将 <code>RedisCacheManager</code> 添加到您的配置中,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
    return RedisCacheManager.create(connectionFactory);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <code>RedisCacheManagerBuilder</code> 配置 <code>RedisCacheManager</code> 行为,让您设置默认的 <code>RedisCacheConfiguration</code>,事务行为和预定义的缓存.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RedisCacheManager cm = RedisCacheManager.builder(connectionFactory)
    .cacheDefaults(defaultCacheConfig())
    .withInitialCacheConfigurations(singletonMap("predefined", defaultCacheConfig().disableCachingNullValues()))
    .transactionAware()
    .build();</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前面的示例所示,<code>RedisCacheManager</code> 允许在每个缓存的基础上定义配置.</p>
</div>
<div class="paragraph">
<p>由 <code>RedisCacheManager</code> 创建的 <code>RedisCache</code> 的行为由 <code>RedisCacheConfiguration</code> 定义. 通过该配置,您可以设置 key 到期时间,前缀和 <code>RedisSerializer</code> 实现,以实现与二进制存储格式之间的相互转换,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
    .entryTtl(Duration.ofSeconds(1))
    .disableCachingNullValues();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RedisCacheManager</code> 默认使用无锁 <code>RedisCacheWriter</code> 来读写二进制值. 无锁缓存提高了吞吐量. 缺少条目锁定会导致 <code>putIfAbsent</code> 和 <code>clean</code> 方法的重叠,非原子性命令重叠,因为这些方法需要将多个命令发送到R edis.
锁定对方通过设置显式锁定键并检查该键是否存在来防止命令重叠,从而导致其他请求和潜在的命令等待时间.</p>
</div>
<div class="paragraph">
<p>可以选择如下锁定行为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RedisCacheManager cm = RedisCacheManager.build(RedisCacheWriter.lockingRedisCacheWriter())
    .cacheDefaults(defaultCacheConfig())
    ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下,缓存条目的任何 key 都以实际的缓存名称作为前缀,后跟两个冒号. 此行为可以更改为静态前缀和计算前缀.</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何设置静态前缀:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// static key prefix
RedisCacheConfiguration.defaultCacheConfig().prefixKeysWith("( ͡° ᴥ ͡°)");

The following example shows how to set a computed prefix:

// computed key prefix
RedisCacheConfiguration.defaultCacheConfig().computePrefixWith(cacheName -&gt; "¯\_(ツ)_/¯" + cacheName);</code></pre>
</div>
</div>
<div class="paragraph">
<p>下表列出了 <code>RedisCacheManager</code> 的默认设置</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">Table 7. <code>RedisCacheManager</code> defaults</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Setting</th>
<th class="tableblock halign-left valign-top">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cache Writer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Non-locking</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cache Configuration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RedisCacheConfiguration#defaultConfiguration</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Initial Caches</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">None</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Transaction Aware</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>下表列出了 <code>RedisCacheConfiguration</code> 的默认设置:</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">Table 8. RedisCacheConfiguration defaults</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key Expiration</th>
<th class="tableblock halign-left valign-top">None</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cache <code>null</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Prefix Keys</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default Prefix</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The actual cache name</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Key Serializer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StringRedisSerializer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value Serializer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JdkSerializationRedisSerializer</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Conversion Service</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DefaultFormattingConversionService</code> with default cache key converters</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="redis:reactive"><a class="anchor" href="#redis:reactive"></a>10. Reactive Redis 支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节介绍了响应式Redis支持以及入门方法. 响应式 Redis 支持与 <a href="#redis">命令式 Redis 支持</a> 有某些重叠.</p>
</div>
<div class="sect2">
<h3 id="redis:reactive:requirements"><a class="anchor" href="#redis:reactive:requirements"></a>10.1. Redis 要求</h3>
<div class="paragraph">
<p>Spring Data Redis当前与 <a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a> 集成为唯一的响应式 Java 连接器. <a href="https://projectreactor.io/">Project Reactor</a> 用作响应式库.</p>
</div>
</div>
<div class="sect2">
<h3 id="redis:reactive:connectors"><a class="anchor" href="#redis:reactive:connectors"></a>10.2. 使用响应式驱动程序连接到 Redis</h3>
<div class="paragraph">
<p>使用 Redis 和 Spring 时的首要任务之一是通过IoC容器连接到 store. 为此,需要Java连接器(或绑定).
无论选择哪种库,都必须使用 <code>org.springframework.data.redis.connection</code> 包及其 <code>ReactiveRedisConnection</code> 和 <code>ReactiveRedisConnectionFactory</code> 接口来使用和检索与Redis的活动连接.</p>
</div>
<div class="sect3">
<h4 id="redis:reactive:connectors:operation-modes"><a class="anchor" href="#redis:reactive:connectors:operation-modes"></a>10.2.1. Redis操作模式</h4>
<div class="paragraph">
<p>Redis可以使用  <a href="#redis:sentinel">Redis Sentinel</a> 作为独立服务器运行,也可以在  <a href="#cluster">Redis 集群</a> 模式下运行. <a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a> 支持所有前面提到的连接类型.</p>
</div>
</div>
<div class="sect3">
<h4 id="redis:reactive:connectors:connection"><a class="anchor" href="#redis:reactive:connectors:connection"></a>10.2.2. <code>ReactiveRedisConnection</code> 和 <code>ReactiveRedisConnectionFactory</code></h4>
<div class="paragraph">
<p><code>ReactiveRedisConnection</code> 是 Redis 通信的核心,因为它处理与 Redis 后端的通信. 它还会自动将底层驱动程序异常转换为 Spring 一致的DAO异常层次结构,因此您可以在不更改任何代码的情况下切换连接器,因为操作语义保持不变.</p>
</div>
<div class="paragraph">
<p><code>ReactiveRedisConnectionFactory</code> 创建活动的 <code>ReactiveRedisConnection</code> 实例. 另外,工厂还充当 <code>PersistenceExceptionTranslator</code> 实例,这意味着工厂一旦声明,就可以进行透明的异常转换-例如,通过使用 <code>@Repository</code> 注解和AOP进行异常转换.
有关更多信息,请参见Spring Framework文档中的 <a href="https://docs.spring.io/spring/docs/5.2.12.RELEASE/spring-framework-reference/data-access.html#orm-exception-translation">特定部分</a> .</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
根据基础配置,工厂可以返回新连接或现有连接(如果使用池或共享本地连接).
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
使用 <code>ReactiveRedisConnectionFactory</code> 的最简单方法是通过IoC容器配置适当的连接器,并将其注入 using 类.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="redis:reactive:connectors:lettuce"><a class="anchor" href="#redis:reactive:connectors:lettuce"></a>10.2.3. 配置 Lettuce 连接器</h4>
<div class="paragraph">
<p>Spring Data Redis 通过 <code>org.springframework.data.redis.connection.lettuce</code> 包支持 <a href="https://github.com/lettuce-io/lettuce-core">Lettuce</a>.</p>
</div>
<div class="paragraph">
<p>您可以按以下步骤配置 Lettuce <code>ReactiveRedisConnectionFactory</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ReactiveRedisConnectionFactory connectionFactory() {
  return new LettuceConnectionFactory("localhost", 6379);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了使用 <code>LettuceClientConfigurationBuilder</code> 的更复杂的配置,包括SSL和超时:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ReactiveRedisConnectionFactory lettuceConnectionFactory() {

  LettuceClientConfiguration clientConfig = LettuceClientConfiguration.builder()
    .useSsl().and()
    .commandTimeout(Duration.ofSeconds(2))
    .shutdownTimeout(Duration.ZERO)
    .build();

  return new LettuceConnectionFactory(new RedisStandaloneConfiguration("localhost", 6379), clientConfig);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更详细的客户端配置调整,请参阅 <a href="https://docs.spring.io/spring-data/redis/docs/2.3.6.RELEASE/api/org/springframework/data/redis/connection/lettuce/LettuceClientConfiguration.html"><code>LettuceClientConfiguration</code></a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis:reactive:template"><a class="anchor" href="#redis:reactive:template"></a>10.3. 通过 ReactiveRedisTemplate 处理对象</h3>
<div class="paragraph">
<p>大多数用户可能会使用 <code>ReactiveRedisTemplate</code> 及其相应的包 <code>org.springframework.data.redis.core</code>. 由于其丰富的功能集,该模板实际上是 Redis 模块的中心类. 该模板为Redis交互提供了高级抽象.
尽管 <code>ReactiveRedisConnection</code> 提供了接受和返回二进制值(ByteBuffer)的低级方法,但该模板负责序列化和连接管理,使您无需处理此类细节.</p>
</div>
<div class="paragraph">
<p>此外,该模板提供了操作视图(按照 Redis <a href="https://redis.io/commands">命令参考</a>进行分组之后),这些操作视图提供了丰富的通用接口来针对某种类型进行工作,如下表所述:</p>
</div>
<table class="tableblock frame-all grid-all" style="width: 80%;">
<caption class="title">Table 9. Operational views</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Interface</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-center valign-top" colspan="2"><p class="tableblock"><em>Key Type Operations</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ReactiveGeoOperations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis geospatial operations such as <code>GEOADD</code>, <code>GEORADIUS</code>, and others)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ReactiveHashOperations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis hash operations</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ReactiveHyperLogLogOperations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis HyperLogLog operations such as (<code>PFADD</code>, <code>PFCOUNT</code>, and others)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ReactiveListOperations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis list operations</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ReactiveSetOperations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis set operations</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ReactiveValueOperations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis string (or value) operations</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ReactiveZSetOperations</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Redis zset (or sorted set) operations</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>配置后,该模板是线程安全的,并且可以在多个实例之间重用.</p>
</div>
<div class="paragraph">
<p><code>ReactiveRedisTemplate</code> 的大多数操作都使用基于 Java 的序列化器. 这意味着通过 <code>RedisElementWriter</code> 或 <code>RedisElementReader</code> 序列化或反序列化由模板写入或读取的任何对象. 序列化上下文在构建时传递给模板,Redis 模块在 <code>org.springframework.data.redis.serializer</code> 包中提供了几种可用的实现. 有关更多信息,请参见  <a href="#redis:serializer">序列化器</a>.</p>
</div>
<div class="paragraph">
<p>以下示例显示了用于返回 <code>Mono</code> 的 <code>ReactiveRedisTemplate</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
class RedisConfiguration {

  @Bean
  ReactiveRedisTemplate&lt;String, String&gt; reactiveRedisTemplate(ReactiveRedisConnectionFactory factory) {
    return new ReactiveRedisTemplate&lt;&gt;(factory, RedisSerializationContext.string());
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Example {

  @Autowired
  private ReactiveRedisTemplate&lt;String, String&gt; template;

  public Mono&lt;Long&gt; addLink(String userId, URL url) {
    return template.opsForList().leftPush(userId, url.toExternalForm());
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis:reactive:string"><a class="anchor" href="#redis:reactive:string"></a>10.4. String 的便捷操作类</h3>
<div class="paragraph">
<p>由于 Redis 中存储的键和值通常是 <code>java.lang.String</code>,因此 Redis 模块为 <code>ReactiveRedisTemplate</code> 提供了基于 String 的扩展:`ReactiveStringRedisTemplate`. 这是用于密集型 String 操作的便捷的一站式解决方案. 除了绑定到字符串键之外,
该模板还使用基于字符串的 <code>RedisSerializationContext</code>,这意味着存储的键和值是人类可读的(假定Redis和您的代码使用相同的编码). 以下示例显示了正在使用的 <code>ReactiveStringRedisTemplate</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
class RedisConfiguration {

  @Bean
  ReactiveStringRedisTemplate reactiveRedisTemplate(ReactiveRedisConnectionFactory factory) {
    return new ReactiveStringRedisTemplate&lt;&gt;(factory);
  }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Example {

  @Autowired
  private ReactiveStringRedisTemplate redisTemplate;

  public Mono&lt;Long&gt; addLink(String userId, URL url) {
    return redisTemplate.opsForList().leftPush(userId, url.toExternalForm());
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis:reactive:pubsub"><a class="anchor" href="#redis:reactive:pubsub"></a>10.5. Redis Messaging/PubSub</h3>
<div class="paragraph">
<p>Spring Data 为 Redis 提供了专用的消息传递集成,其功能和命名与 Spring Framework 中的JMS集成非常相似; 实际上,熟悉 Spring 的 JMS 支持的用户应该有宾至如归的感觉.</p>
</div>
<div class="paragraph">
<p>Redis消息传递可以大致分为两个功能区域,即消息的产生或发布以及消息的使用或订阅,因此简称为 pubsub(发布/订阅). <code>ReactiveRedisTemplate</code> 类用于消息生成. 对于异步接收,Spring Data 提供了一个专用的消息监听器容器,该容器用于消耗消息流.
出于订阅目的,<code>ReactiveRedisTemplate</code> 提供了使用监听器容器的简化选择.</p>
</div>
<div class="paragraph">
<p><code>org.springframework.data.redis.connection</code> 和 <code>org.springframework.data.redis.listener</code> 包提供了使用Redis消息传递的核心功能.</p>
</div>
<div class="sect3">
<h4 id="redis:reactive:pubsub:publish"><a class="anchor" href="#redis:reactive:pubsub:publish"></a>10.5.1. Sending/Publishing messages</h4>
<div class="paragraph">
<p>要发布消息,可以与其他操作一样使用底层的 <code>ReactiveRedisConnection</code> 或高级 <code>ReactiveRedisTemplate</code>. 这两个实体都提供一种发布方法,该方法接受需要发送的消息以及目标通道作为参数. 尽管 <code>ReactiveRedisConnection</code> 需要原始数据,但 <code>ReactiveRedisTemplate</code> 允许将任意对象作为消息传递:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// send message through ReactiveRedisConnection
ByteBuffer msg = …
ByteBuffer channel = …
Mono&lt;Long&gt; publish = con.publish(msg, channel);

// send message through ReactiveRedisTemplate
ReactiveRedisTemplate template = …
Mono&lt;Long&gt; publish = template.convertAndSend("channel", "message");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redis:reactive:pubsub:subscribe"><a class="anchor" href="#redis:reactive:pubsub:subscribe"></a>10.5.2. Receiving/Subscribing for messages</h4>
<div class="paragraph">
<p>在接收端,可以直接命名一个通道或使用模式匹配来订阅一个或多个通道. 后一种方法非常有用,因为它不仅允许使用一个命令创建多个订阅,而且还可以监听在订阅时尚未创建的通道(只要它们与模式匹配).</p>
</div>
<div class="paragraph">
<p>在低层,<code>ReactiveRedisConnection</code> 提供了 subscription 和 <code>pSubscribe</code> 方法,它们映射Redis命令以分别按模式按通道进行订阅. 注意,可以将多个通道或模式用作参数. 要更改订阅,只需查询 <code>ReactiveSubscription</code> 的通道和模式.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Data Redis中的响应式订阅命令是非阻塞的,可以终止而不会发出任何元素.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如上所述,一旦订阅,连接就会开始等待消息. 除了添加新订阅或修改/取消现有订阅之外,无法在其上调用其他命令. 除 <code>subscribe</code>,<code>pSubscribe</code>,<code>unsubscribe</code> 或 <code>pUnsubscribe</code> 以外的命令是非法的,并且会导致异常.</p>
</div>
<div class="paragraph">
<p>为了接收消息,需要获得消息流. 请注意,订阅仅发布有关在该特定订阅中注册的通道和模式的消息. 消息流本身是一个热序列,它在不考虑需求的情况下生成元素. 确保注册足够的需求,以免耗尽消息缓冲区.</p>
</div>
<div class="sect4">
<h5 id="redis:reactive:pubsub:subscribe:containers"><a class="anchor" href="#redis:reactive:pubsub:subscribe:containers"></a>Message 监听容器</h5>
<div class="paragraph">
<p>Spring Data提供了 <code>ReactiveRedisMessageListenerContainer</code>,它代表用户完成所有繁重的转换和订阅状态管理.</p>
</div>
<div class="paragraph">
<p><code>ReactiveRedisMessageListenerContainer</code> 充当消息监听器容器. 它用于从 Redis 通道接收消息并暴露消息流,该消息流发出应用反序列化的通道消息. 它负责注册接收消息,资源获取和释放,异常转换等. 这使您作为应用程序开发人员, 可以编写与接收消息(并对消息做出响应)相关的(可能很复杂)业务逻辑,并将样板Redis基础结构问题委托给框架. 消息流在发布者订阅后在 Redis 中注册一个订阅,如果订阅被取消,则注销.</p>
</div>
<div class="paragraph">
<p>此外,为了最大程度地减少应用程序占用空间,<code>ReactiveRedisMessageListenerContainer</code> 允许一个连接和一个线程由多个监听器共享,即使它们不共享订阅. 因此,无论应用程序跟踪多少个监听器或通道,整个生命周期的运行时间成本都将保持不变.
此外,该容器允许更改运行时配置,因此可以在应用程序运行时添加或删除监听器,而无需重新启动. 此外,容器使用惰性订阅方法,仅在需要时才使用 <code>ReactiveRedisConnection</code>---- 如果所有监听器都未订阅,则将自动执行清除.</p>
</div>
<div class="paragraph">
<p>消息监听器容器本身不需要外部线程资源. 它使用驱动程序线程来发布消息.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ReactiveRedisConnectionFactory factory = …
ReactiveRedisMessageListenerContainer container = new ReactiveRedisMessageListenerContainer(factory);

Flux&lt;ChannelMessage&lt;String, String&gt;&gt; stream = container.receive(ChannelTopic.of("my-channel"));</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="redis:reactive:pubsub:subscribe:template"><a class="anchor" href="#redis:reactive:pubsub:subscribe:template"></a>通过模板API订阅</h5>
<div class="paragraph">
<p>如上所述,您可以直接使用 <code>ReactiveRedisTemplate</code> 订阅通道/模式. 这种方法提供了一种直接但有限的解决方案,因为您松开了在初始订阅之后添加订阅的选项. 不过,您仍然可以使用例如返回的 <code>Flux</code> 控制消息流. 服用(持续时间). 完成读取后,一旦出错或取消,所有绑定的资源将再次释放.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">redisTemplate.listenToChannel("channel1", "channel2").doOnNext(msg -&gt; {
    // message processing ...
}).subscribe();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis:reactive:scripting"><a class="anchor" href="#redis:reactive:scripting"></a>10.6. Reactive 脚本</h3>
<div class="paragraph">
<p>您可以通过使用 <code>ReactiveScriptExecutor</code> 在响应式的基础上运行 Redis 脚本, 最好通过 <code>ReactiveRedisTemplate</code> 访问.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Example {

  @Autowired
  private ReactiveRedisTemplate&lt;String, String&gt; template;

  public Flux&lt;Long&gt; theAnswerToLife() {

    DefaultRedisScript&lt;Long&gt; script = new DefaultRedisScript&lt;&gt;();
    script.setLocation(new ClassPathResource("META-INF/scripts/42.lua"));
    script.setResultType(Long.class);

    return reactiveTemplate.execute(script);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关脚本命令的更多详细信息,请参见 <a href="#scripting">脚本部分</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cluster"><a class="anchor" href="#cluster"></a>11. Redis 集群</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用 <a href="https://redis.io/topics/cluster-spec">Redis Cluster</a> 需要Redis Server 3.0+版本. 有关更多信息,请参见 <a href="https://redis.io/topics/cluster-tutorial">集群教程</a>.</p>
</div>
<div class="sect2">
<h3 id="启用-redis-集群"><a class="anchor" href="#启用-redis-集群"></a>11.1. 启用 Redis 集群</h3>
<div class="paragraph">
<p>群集支持基于与非群集通信相同的构造块. <code>RedisClusterConnection</code> 是 <code>RedisConnection</code> 的扩展,用于处理与 Redis 群集的通信,并将错误转换为 Spring DAO 异常层次结构. <code>RedisClusterConnection</code> 实例是使用 <code>RedisConnectionFactory</code> 创建的,
必须使用关联的 <code>RedisClusterConfiguration</code> 对其进行设置,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Redis 集群的示例 RedisConnectionFactory 配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
@ConfigurationProperties(prefix = "spring.redis.cluster")
public class ClusterConfigurationProperties {

    /*
     * spring.redis.cluster.nodes[0] = 127.0.0.1:7379
     * spring.redis.cluster.nodes[1] = 127.0.0.1:7380
     * ...
     */
    List&lt;String&gt; nodes;

    /**
     * Get initial collection of known cluster nodes in format {@code host:port}.
     *
     * @return
     */
    public List&lt;String&gt; getNodes() {
        return nodes;
    }

    public void setNodes(List&lt;String&gt; nodes) {
        this.nodes = nodes;
    }
}

@Configuration
public class AppConfig {

    /**
     * Type safe representation of application.properties
     */
    @Autowired ClusterConfigurationProperties clusterProperties;

    public @Bean RedisConnectionFactory connectionFactory() {

        return new JedisConnectionFactory(
            new RedisClusterConfiguration(clusterProperties.getNodes()));
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>RedisClusterConfiguration</code> 也可以通过 <code>PropertySource</code> 定义,并具有以下属性:</p>
</div>
<div class="ulist">
<div class="title">配置属性</div>
<ul>
<li>
<p><code>spring.redis.cluster.nodes</code>: 以逗号分隔的 host:port 列表.</p>
</li>
<li>
<p><code>spring.redis.cluster.max-redirects</code>: 允许的集群重定向数.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
初始配置将驱动程序库指向一组初始的群集节点. 由实时群集重新配置导致的更改仅保留在本地驱动程序中,而不会写回到配置中.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="cluster.working.with.cluster"><a class="anchor" href="#cluster.working.with.cluster"></a>11.2. 使用 Redis 群集连接</h3>
<div class="paragraph">
<p>如前所述,Redis 群集的行为与单节点 ​​Redis 甚至是 Sentinel 监视的主副本环境不同. 这是因为自动分片将密钥映射到16384个slots之一,该 slots 分布在节点上. 因此,涉及多个键的命令必须断言所有键都映射到完全相同的 slots ,以避免跨 slots 执行错误.
单个群集节点仅提供一组专用密钥. 针对一台特定服务器发出的命令仅针对该服务器提供的那些键返回结果. 作为一个简单的示例,请考虑  <code>KEYS</code>  命令. 当在集群环境中发布给服务器时,它仅返回请求发送到的节点所服务的密钥,而不一定返回集群中的所有密钥.
因此,要在群集环境中获取所有密钥,必须从所有已知的主节点读取密钥.</p>
</div>
<div class="paragraph">
<p>虽然将特定密钥重定向到相应的 slots 服务节点是由驱动程序库处理的,但是 <code>RedisClusterConnection</code> 涵盖了更高级别的功能,例如跨节点收集信息或向集群中的所有节点发送命令. 拾取前面的密钥示例,这意味着keys(pattern)方法将拾取群集中的每个主节点,
并同时在每个主节点上执行 <code>KEYS</code> 命令,同时拾取结果并返回累积的键集. 仅请求单个节点的键,<code>RedisClusterConnection</code> 为这些方法提供了重载(例如,<code>keys(node, pattern)</code>).</p>
</div>
<div class="paragraph">
<p>While redirects for specific keys to the corresponding slot-serving node are handled by the driver libraries, higher-level functions, such a
s collecting information across nodes or sending commands to all nodes in the cluster, are covered by <code>RedisClusterConnection</code>. Picking
up the keys example from earlier, this means that the <code>keys(pattern)</code> method picks up every master node in the cluster and simultaneously executes the <code>KEYS</code> co
mmand on every master node while picking up the results and returning the cumulated set of keys. To just request the keys of a single node <code>RedisClusterConnection</code> provide
s overloads for those methods (for example, <code>keys(node, pattern)</code>).</p>
</div>
<div class="paragraph">
<p>可以从 <code>RedisClusterConnection.clusterGetNodes</code> 获得 <code>RedisClusterNode</code>,也可以使用主机和端口或节点ID来构造它.</p>
</div>
<div class="paragraph">
<p>以下示例显示了在集群中运行的一组命令:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. 跨集群运行命令的示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">redis-cli@127.0.0.1:7379 &gt; cluster nodes

6b38bb... 127.0.0.1:7379 master - 0 0 25 connected 0-5460                      <i class="conum" data-value="1"></i><b>(1)</b>
7bb78c... 127.0.0.1:7380 master - 0 1449730618304 2 connected 5461-10922       <i class="conum" data-value="2"></i><b>(2)</b>
164888... 127.0.0.1:7381 master - 0 1449730618304 3 connected 10923-16383      <i class="conum" data-value="3"></i><b>(3)</b>
b8b5ee... 127.0.0.1:7382 slave 6b38bb... 0 1449730618304 25 connected          <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RedisClusterConnection connection = connectionFactory.getClusterConnnection();

connection.set("thing1", value);                                               <i class="conum" data-value="5"></i><b>(5)</b>
connection.set("thing2", value);                                               <i class="conum" data-value="6"></i><b>(6)</b>

connection.keys("*");                                                          <i class="conum" data-value="7"></i><b>(7)</b>

connection.keys(NODE_7379, "*");                                               <i class="conum" data-value="8"></i><b>(8)</b>
connection.keys(NODE_7380, "*");                                               <i class="conum" data-value="9"></i><b>(9)</b>
connection.keys(NODE_7381, "*");                                               <i class="conum" data-value="10"></i><b>(10)</b>
connection.keys(NODE_7382, "*");                                               <i class="conum" data-value="11"></i><b>(11)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Master node serving slots 0 to 5460 replicated to replica at 7382</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Master node serving slots 5461 to 10922</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Master node serving slots 10923 to 16383</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Replica node holding replicants of the master at 7379</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Request routed to node at 7381 serving slot 12182</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Request routed to node at 7379 serving slot 5061</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Request routed to nodes at 7379, 7380, 7381 &#8594; [thing1, thing2]</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Request routed to node at 7379 &#8594; [thing2]</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Request routed to node at 7380 &#8594; []</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Request routed to node at 7381 &#8594; [thing1]</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Request routed to node at 7382 &#8594; [thing2]</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>当所有键都映射到同一 slot 时,本地驱动程序库会自动处理跨 slots 请求,例如 <code>MGET</code>. 但是,一旦不是这种情况,<code>RedisClusterConnection</code> 会对 slots 服务节点执行多个并行的 <code>GET</code> 命令,然后再次返回累积的结果.
这比单 slot 执行的性能要差,因此应谨慎使用. 如有疑问,请考虑通过在大括号中提供前缀(例如 <code>{my-prefix}.thing1</code> 和 <code>{my-prefix}.thing2</code>)来将密钥固定到同一 slot ,这两者都将映射到相同的 slot 号. 以下示例显示了跨槽请求处理:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. Sample of Cross-Slot Request Handling</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">redis-cli@127.0.0.1:7379 &gt; cluster nodes

6b38bb... 127.0.0.1:7379 master - 0 0 25 connected 0-5460                      <i class="conum" data-value="1"></i><b>(1)</b>
7bb...</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RedisClusterConnection connection = connectionFactory.getClusterConnnection();

connection.set("thing1", value);           // slot: 12182
connection.set("{thing1}.thing2", value);  // slot: 12182
connection.set("thing2", value);           // slot:  5461

connection.mGet("thing1", "{thing1}.thing2");                                  <i class="conum" data-value="2"></i><b>(2)</b>

connection.mGet("thing1", "thing2");                                           <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>与之前示例中的配置相同.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Keys map to same slot &#8594; 127.0.0.1:7381 MGET thing1 {thing1}.thing2</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Keys map to different slots and get split up into single slot ones routed to the according nodes<br>
&#8594; 127.0.0.1:7379 GET thing2<br>
&#8594; 127.0.0.1:7381 GET thing1</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
前面的示例演示了Spring Data Redis遵循的一般策略. 请注意,某些操作可能需要将大量数据加载到内存中才能计算所需的命令. 此外,并非所有跨槽请求都可以安全地移植到多个单个槽请求,如果使用不当,则会出错(例如 <code>PFCOUNT</code>).
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="cluster.redistemplate"><a class="anchor" href="#cluster.redistemplate"></a>11.3. 使用 <code>RedisTemplate</code> 和 <code>ClusterOperations</code></h3>
<div class="paragraph">
<p>有关  <a href="#redis:template">通过 RedisTemplate 处理对象</a> 的一般用途,配置和用法的信息,请参见通过 <code>RedisTemplate</code> 使用对象.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
使用任何 JSON <code>RedisSerializer</code> 设置  <code>RedisTemplate#keySerializer</code> 时要小心,因为更改JSON结构会立即影响哈希槽的计算.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>RedisTemplate</code> 通过 <code>ClusterOperations</code> 接口提供对特定于集群的操作的访问,该接口可以从 <code>RedisTemplate.opsForCluster()</code> 获得. 这使您可以在群集内的单个节点上显式运行命令,同时保留为模板配置的序列化和反序列化功能.
它还提供管理命令(例如 <code>CLUSTER MEET</code>)或更高级的操作(例如,重新分片).</p>
</div>
<div class="paragraph">
<p>以下示例显示如何使用 <code>RedisTemplate</code> 访问 <code>RedisClusterConnection</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. Accessing <code>RedisClusterConnection</code> with <code>RedisTemplate</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">ClusterOperations clusterOps = redisTemplate.opsForCluster();
clusterOps.shutdown(NODE_7379);                                              <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Shut down node at 7379 and cross fingers there is a replica in place that can take over.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="redis.repositories"><a class="anchor" href="#redis.repositories"></a>12. Redis 存储库</h2>
<div class="sectionbody">
<div class="paragraph">
<p>通过使用 Redis 存储库,您可以无缝地在 Redis 哈希中转换和存储域对象,应用自定义映射策略以及使用二级索引.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Redis存储库至少需要 Redis Server 版本2.8.0,并且不适用于事务. 确保使用的 <code>RedisTemplate</code> <a href="#tx.spring">禁用了事务支持</a>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="redis.repositories.usage"><a class="anchor" href="#redis.repositories.usage"></a>12.1. 使用</h3>
<div class="paragraph">
<p>Spring Data Redis 使您可以轻松实现域实体,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. Sample Person Entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RedisHash("people")
public class Person {

  @Id String id;
  String firstname;
  String lastname;
  Address address;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们在这里有一个非常简单的域对象. 请注意,它的类型上带有 <code>@RedisHash</code> 注解,并带有 <code>org.springframework.data.annotation.Id</code> 注解的名为 <code>id</code> 的属性. 这两个选项负责创建实际的 key.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
用 <code>@Id</code> 注解的属性以及名为 <code>id</code> 的属性被视为标识符属性.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在要真正拥有负责存储和检索的组件,我们需要定义一个存储库接口,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. Basic Repository Interface To Persist Person Entities</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface PersonRepository extends CrudRepository&lt;Person, String&gt; {

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>随着我们的存储库扩展 <code>CrudRepository</code>,它提供了基本的 CRUD 和 finder 操作.我们需要将它们粘合在一起的是对应的 Spring 配置,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. JavaConfig for Redis Repositories</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableRedisRepositories
public class ApplicationConfig {

  @Bean
  public RedisConnectionFactory connectionFactory() {
    return new JedisConnectionFactory();
  }

  @Bean
  public RedisTemplate&lt;?, ?&gt; redisTemplate() {

    RedisTemplate&lt;byte[], byte[]&gt; template = new RedisTemplate&lt;byte[], byte[]&gt;();
    return template;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>给定前面的设置,我们可以将 <code>PersonRepository</code> 注入到我们的组件中,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. Access to Person Entities</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowired PersonRepository repo;

public void basicCrudOperations() {

  Person rand = new Person("rand", "al'thor");
  rand.setAddress(new Address("emond's field", "andor"));

  repo.save(rand);                                         <i class="conum" data-value="1"></i><b>(1)</b>

  repo.findOne(rand.getId());                              <i class="conum" data-value="2"></i><b>(2)</b>

  repo.count();                                            <i class="conum" data-value="3"></i><b>(3)</b>

  repo.delete(rand);                                       <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果当前值为 <code>null</code> 或已经存在 <code>id</code> 值,并在 Redis Hash 中存储类型为 Person 的属性,并使用  <code>keyspace:id</code> 的 key,则生成新的id:id-在这种情况下,可能是 <code>people:5d67b7e1-8640-4475-beeb-c666fab4c0e5</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用提供的 <code>ID</code> 在 <code>keyspace:id</code> 中搜索对象 .</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>计算 keyspace 可用的实体总数,由 <code>@RedisHash</code> 在 <code>Person</code> 上定义.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>从Redis中删除给定对象的 key.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mapping.fundamentals"><a class="anchor" href="#mapping.fundamentals"></a>12.2. 对象映射基础</h3>
<div class="paragraph">
<p>本节介绍了Spring Data对象映射,对象创建,字段和属性访问,可变性和不可变性的基础知识.
请注意,本节仅适用于不使用基础数据存储 (例如JPA) 的对象映射的Spring Data模块.
另外,请确保参考存储库特定的部分以获取存储库特定的对象映射,例如索引,自定义列或字段名称等.</p>
</div>
<div class="paragraph">
<p>Spring Data对象映射的核心职责是创建域对象的实例,并将存储本地数据结构映射到这些实例上.
这意味着我们需要两个基本步骤:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用暴露的构造函数之一创建实例.</p>
</li>
<li>
<p>实例填充以实现所有暴露的属性.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="mapping.object-creation"><a class="anchor" href="#mapping.object-creation"></a>12.2.1. 创建对象</h4>
<div class="paragraph">
<p>Spring Data会自动尝试检测要用于实现该类型对象的持久性实体的构造函数.
解析算法的工作原理如下:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果有一个无参数的构造函数,它将被使用.  其他构造函数将被忽略.</p>
</li>
<li>
<p>如果只有一个构造函数接受参数,则将使用它.</p>
</li>
<li>
<p>如果有多个接受参数的构造函数,则Spring Data要使用的那个必须用 <code>@PersistenceConstructor</code> 注解.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>值解析假定构造函数参数名称与实体的属性名称匹配,即,解析将像要填充该属性一样执行,包括映射中的所有自定义项 (不同的数据存储列或字段名称等) .
这也需要在类文件中可用的参数名称信息或在构造函数上存在的 <code>@ConstructorProperties</code> 注解.</p>
</div>
<div class="paragraph">
<p>可以通过使用特定于存储的SpEL表达式使用Spring Framework的 <code>@Value</code> 值注解来自定义值解析.
请参阅有关特定存储映射的部分以获取更多详细信息.</p>
</div>
<div id="mapping.object-creation.details" class="sidebarblock">
<div class="content">
<div class="title">创建内部对象</div>
<div class="paragraph">
<p>为了避免反射的开销,Spring Data对象的创建使用默认情况下在运行时生成的工厂类,该工厂类将直接调用 domain 类的构造函数.  即 对于此示例类型:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {
  Person(String firstname, String lastname) { … }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们将在运行时创建一个在语义上与此工厂等效的工厂类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class PersonObjectInstantiator implements ObjectInstantiator {

  Object newInstance(Object... args) {
    return new Person((String) args[0], (String) args[1]);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>与反射相比,这使我们的性能提高了约10％.  为了使域类有资格进行此类优化,它需要遵守一组约束:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它不能是 private 类</p>
</li>
<li>
<p>它不能是非静态内部类</p>
</li>
<li>
<p>它不能是 CGLib 代理类</p>
</li>
<li>
<p>Spring Data 使用的构造函数不能为 private</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果这些条件中的任何一个匹配,Spring Data将通过反射回退到实体实例化.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mapping.property-population"><a class="anchor" href="#mapping.property-population"></a>12.2.2. 属性 population</h4>
<div class="paragraph">
<p>创建实体的实例后,Spring Data会填充该类的所有剩余持久性属性.  除非实体的构造函数已经填充了该实体 (即通过其构造函数参数列表使用) ,否则将首先填充identifier属性,以允许解析循环对象引用.  之后,在实体实例上设置所有尚未由构造函数填充的非临时属性.  为此,我们使用以下算法:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果属性是不可变的,但使用 wither 方法 (请参见下文) ,则我们使用 <code>with…</code>  方法创建具有新属性值的新实体实例.</p>
</li>
<li>
<p>如果定义了属性访问权限 (即通过 getter 和 setter 的访问) ,则我们正在调用 setter 方法.</p>
</li>
<li>
<p>如果属性是可变的,则直接设置该字段.</p>
</li>
<li>
<p>如果属性是不可变的,那么我们将使用持久化操作使用的构造函数 (请参见 <a href="#mapping.object-creation">创建对象</a>) 来创建实例的副本.</p>
</li>
<li>
<p>默认情况下,直接设置字段值.</p>
</li>
</ol>
</div>
<div id="mapping.property-population.details" class="sidebarblock">
<div class="content">
<div class="title">Property population internals</div>
<div class="paragraph">
<p>与我们在<a href="#mapping.object-creation.details">构造对象的优化</a> 类似,我们还使用Spring Data运行时生成的访问器类与实体实例进行交互.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {

  private final Long id;
  private String firstname;
  private @AccessType(Type.PROPERTY) String lastname;

  Person() {
    this.id = null;
  }

  Person(Long id, String firstname, String lastname) {
    // Field assignments
  }

  Person withId(Long id) {
    return new Person(id, this.firstname, this.lastame);
  }

  void setLastname(String lastname) {
    this.lastname = lastname;
  }
}</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 13. 生成的属性访问器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class PersonPropertyAccessor implements PersistentPropertyAccessor {

  private static final MethodHandle firstname;              <i class="conum" data-value="2"></i><b>(2)</b>

  private Person person;                                    <i class="conum" data-value="1"></i><b>(1)</b>

  public void setProperty(PersistentProperty property, Object value) {

    String name = property.getName();

    if ("firstname".equals(name)) {
      firstname.invoke(person, (String) value);             <i class="conum" data-value="2"></i><b>(2)</b>
    } else if ("id".equals(name)) {
      this.person = person.withId((Long) value);            <i class="conum" data-value="3"></i><b>(3)</b>
    } else if ("lastname".equals(name)) {
      this.person.setLastname((String) value);              <i class="conum" data-value="4"></i><b>(4)</b>
    }
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>PropertyAccessor持有底层对象的一个可变实例. 这是为了允许对其他不可变的属性进行更改.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>默认情况下,Spring数据使用字段访问来读写属性值. 根据  <code>private</code> 字段的可见性规则,使用 <code>MethodHandles</code> 与字段交互.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>该类暴露了一个  <code>withId(…)</code> 方法,该方法用于设置标识符,例如,当一个实例被插入到数据存储并生成了一个标识符时. 调用  <code>withId(…)</code> 创建一个新的 <code>Person</code> 对象. 所有后续的突变都将在新实例中发生,而不影响先前的实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用属性访问允许直接调用方法而不使用  <code>MethodHandles</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>与反射相比,这使我们的性能提高了约25％.  为了使域类有资格进行此类优化,它需要遵守一组约束:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Types 不得位于默认值或java包下.</p>
</li>
<li>
<p>类型及其构造函数必须是 <code>public</code> 的</p>
</li>
<li>
<p>内部类的类型必须是静态的.</p>
</li>
<li>
<p>使用的Java运行时必须允许在原始 <code>ClassLoader</code> 中声明类.  Java 9和更高版本强加了某些限制.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下,Spring Data尝试使用生成的属性访问器,如果检测到限制,则回退到基于反射的属性访问器.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>让我们看一下以下实体:</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. A sample entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class Person {

  private final @Id Long id;                                                <i class="conum" data-value="1"></i><b>(1)</b>
  private final String firstname, lastname;                                 <i class="conum" data-value="2"></i><b>(2)</b>
  private final LocalDate birthday;
  private final int age;                                                    <i class="conum" data-value="3"></i><b>(3)</b>

  private String comment;                                                   <i class="conum" data-value="4"></i><b>(4)</b>
  private @AccessType(Type.PROPERTY) String remarks;                        <i class="conum" data-value="5"></i><b>(5)</b>

  static Person of(String firstname, String lastname, LocalDate birthday) { <i class="conum" data-value="6"></i><b>(6)</b>

    return new Person(null, firstname, lastname, birthday,
      Period.between(birthday, LocalDate.now()).getYears());
  }

  Person(Long id, String firstname, String lastname, LocalDate birthday, int age) { <i class="conum" data-value="6"></i><b>(6)</b>

    this.id = id;
    this.firstname = firstname;
    this.lastname = lastname;
    this.birthday = birthday;
    this.age = age;
  }

  Person withId(Long id) {                                                  <i class="conum" data-value="1"></i><b>(1)</b>
    return new Person(id, this.firstname, this.lastname, this.birthday, this.age);
  }

  void setRemarks(String remarks) {                                         <i class="conum" data-value="5"></i><b>(5)</b>
    this.remarks = remarks;
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>标识符属性是 <code>final</code>,但在构造函数中设置为 <code>null</code>.  该类暴露用于设置标识符的  <code>withId(…)`方法,例如 将实例插入数据存储区并已生成标识符时.  创建新实例后,原始 `Person</code> 实例保持不变.
通常将相同的模式应用于存储管理的其他属性,但可能需要为持久性操作进行更改.wither 方法是可选的,因为构造函数 (请参见6) 实际上是一个复制的构造函数,设置该属性将转换为使用新的值创建一个新实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>firstname</code> 和 <code>lastname</code> 属性是可能通过getter暴露的普通不可变属性.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>age</code> 属性是一个不变的,但从  <code>birthday</code>  属性扩展的属性.  通过显示的设计,数据库值将胜过默认值,因为 Spring Data 使用唯一声明的构造函数.  即使意图是首选计算,此构造函数也必须将 <code>age</code> 作为参数 (可能会忽略它) ,这一点很重要,因为否则属性填充步骤将尝试设置 <code>age</code> 字段并由于其不可变而失败,并且没有 <code>with…</code> 方法存在.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>通过直接设置其字段可以填充 <code>comment</code> 属性是可变的.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>remarks</code> 属性是可变的,可通过直接设置  <code>comment</code> 字段或通过调用setter方法来填充</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>该类暴露用于对象创建的工厂方法和构造函数.  这里的核心思想是使用工厂方法而不是其他构造函数,以避免通过 <code>@PersistenceConstructor</code> 消除构造函数歧义的需要.  相反,属性的默认设置是在工厂方法中处理的.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mapping.general-recommendations"><a class="anchor" href="#mapping.general-recommendations"></a>12.2.3. 一般建议</h4>
<div class="ulist">
<ul>
<li>
<p><em>尝试坚持不可变的对象</em>&#8201;&#8212;&#8201;不可变的对象很容易创建,因为实现一个对象只需调用其构造函数即可.  同样,这避免了用允许客户端代码操纵对象状态的setter方法乱扔您的域对象.  如果需要它们,则最好使它们受到程序包保护,以便只能由有限数量的同一位置类型调用它们.  仅限构造函数的实现比属性填充快30％.</p>
</li>
<li>
<p><em>提供一个全参数的构造函数</em>&#8201;&#8212;&#8201;即使您不能或不希望将实体建模为不可变的值,仍然可以提供一个将实体的所有属性作为参数 (包括可变属性) 作为参数的构造函数,因为这样做可以 对象映射以跳过属性填充以获得最佳性能.</p>
</li>
<li>
<p><em>使用工厂方法而不是重载的构造函数来避免  <code>@PersistenceConstructor</code></em>&#8201;&#8212;&#8201;为了获得最佳性能,需要使用全参数构造函数,我们通常希望暴露更多特定于应用程序用例的构造函数,从而省略了诸如自动生成的标识符等内容.  使用静态工厂方法暴露 <code>all-args</code> 构造函数的这些变体.</p>
</li>
<li>
<p><em>确保您遵守允许使用生成的实例化器和属性访问器类的约束</em>&#8201;&#8212;&#8201;</p>
</li>
<li>
<p><em>对于要生成的标识符,仍然将 final 字段与全参数构造函数  <code>with…</code> 方法结合使用</em>&#8201;&#8212;&#8201;</p>
</li>
<li>
<p><em>使用 Lombok 来避免样板代码</em>&#8201;&#8212;&#8201;由于持久性操作通常需要构造函数使用所有参数,因此它们的声明成为对字段分配的样板参数的繁琐重复,最好使用Lombok的 <code>@AllArgsConstructor</code> 来避免.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="mapping.kotlin"><a class="anchor" href="#mapping.kotlin"></a>12.2.4. Kotlin 支持</h4>
<div class="paragraph">
<p>Spring Data 修改了 Kotlin 的细节以允许对象创建和变异.</p>
</div>
<div class="sect4">
<h5 id="kotlin-对象创建"><a class="anchor" href="#kotlin-对象创建"></a>Kotlin 对象创建</h5>
<div class="paragraph">
<p>支持实例化 Kotlin 类,默认情况下所有类都是不可变的,并且需要显式属性声明来定义可变属性.
考虑以下  <code>data</code>  类 <code>Person</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">data class Person(val id: String, val name: String)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的类使用显式构造函数编译为典型类.  我们可以通过添加另一个构造函数来定制该类,并使用 <code>@PersistenceConstructor</code> 对其进行注解以指示构造函数的首选项:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">data class Person(var id: String, val name: String) {

    @PersistenceConstructor
    constructor(id: String) : this(id, "unknown")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Kotlin通过允许在未提供参数的情况下使用默认值来支持参数的可选性.  当Spring Data检测到带有参数默认值的构造函数时,如果数据存储区不提供值 (或简单地返回 <code>null</code>) ,则它将使这些参数不存在,因此Kotlin可以应用参数默认值.  考虑下面的类,该类将参数默认值用作 <code>name</code></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">data class Person(var id: String, val name: String = "unknown")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>每次 <code>name</code> 参数不是结果的一部分或值为 <code>null</code> 时, name` 默认为  <code>unknown</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="property-population-of-kotlin-data-classes"><a class="anchor" href="#property-population-of-kotlin-data-classes"></a>Property population of Kotlin data classes</h5>
<div class="paragraph">
<p>在Kotlin中,所有类默认都是不可变的,并且需要显式的属性声明来定义可变属性.  考虑以下 <code>data</code> 类Person:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">data class Person(val id: String, val name: String)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该类实际上是不可变的.  当Kotlin生成 <code>copy(…)</code> 方法时,它可以创建新的实例,该方法创建新的对象实例,该对象实例从现有对象复制所有属性值,并将作为参数提供的属性值应用于该方法.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis.repositories.mapping"><a class="anchor" href="#redis.repositories.mapping"></a>12.3. 对象到哈希的映射</h3>
<div class="paragraph">
<p>Redis 存储库支持将对象保留为哈希. 这需要由 <code>RedisConverter</code> 完成的对象到哈希的转换. 默认实现使用 <code>Converter</code> 将属性值与 Redis 本地 <code>byte[]</code> 之间进行映射.</p>
</div>
<div class="paragraph">
<p>给定前面几节中的 <code>Person</code> 类型,默认映射如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">_class = org.example.Person                 <i class="conum" data-value="1"></i><b>(1)</b>
id = e2c7dcee-b8cd-4424-883e-736ce564363e
firstname = rand                            <i class="conum" data-value="2"></i><b>(2)</b>
lastname = al’thor
address.city = emond's field                <i class="conum" data-value="3"></i><b>(3)</b>
address.country = andor</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>_class</code> 属性包含在根级别以及任何嵌套接口或抽象类型中.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>简单属性值按路径映射.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>复杂类型的属性按其点路径进行映射.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>下表描述了默认映射规则:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. 默认映射规则</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 33.3333%;">
<col style="width: 50.0001%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Sample</th>
<th class="tableblock halign-left valign-top">Mapped Value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Simple Type<br>
(for example, String)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String firstname = "rand";</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">firstname = "rand"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Complex Type<br>
(for example, Address)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Address address = new Address("emond&#8217;s field");</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">address.city = "emond&#8217;s field"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">List<br>
of Simple Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List&lt;String&gt; nicknames = asList("dragon reborn", "lews therin");</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">nicknames.[0] = "dragon reborn",<br>
nicknames.[1] = "lews therin"</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map<br>
of Simple Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map&lt;String, String&gt; atts = asMap({"eye-color", "grey"}, {"&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">atts.[eye-color] = "grey",<br>
atts.[hair-color] = "&#8230;&#8203;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">List<br>
of Complex Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">List&lt;Address&gt; addresses = asList(new Address("em&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">addresses.[0].city = "emond&#8217;s field",<br>
addresses.[1].city  = "&#8230;&#8203;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map<br>
of Complex Type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Map&lt;String, Address&gt; addresses = asMap({"home", new Address("em&#8230;&#8203;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">addresses.[home].city = "emond&#8217;s field",<br>
addresses.[work].city  = "&#8230;&#8203;</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
由于采用平面表示结构,因此 <code>Map</code> 的 key 必须是简单的类型,例如 <code>String</code> 或 <code>Number</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以通过在 <code>RedisCustomConversions</code> 中注册相应的 <code>Converter</code> 来自定义映射行为. 这些转换器可以处理与单个 <code>byte[]</code> 和 <code>Map&lt;String,byte[]&gt;</code> 之间的转换.
第一个适用于(例如)将复杂类型转换为(例如)仍使用默认映射哈希结构的二进制JSON表示形式. 第二个选项提供对生成的哈希的完全控制.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
将对象写入 Redis 哈希会删除哈希中的内容,并重新创建整个哈希,因此尚未映射的数据会丢失.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面的示例显示了两个示例字节数组转换器:</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. Sample byte[] Converters</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@WritingConverter
public class AddressToBytesConverter implements Converter&lt;Address, byte[]&gt; {

  private final Jackson2JsonRedisSerializer&lt;Address&gt; serializer;

  public AddressToBytesConverter() {

    serializer = new Jackson2JsonRedisSerializer&lt;Address&gt;(Address.class);
    serializer.setObjectMapper(new ObjectMapper());
  }

  @Override
  public byte[] convert(Address value) {
    return serializer.serialize(value);
  }
}

@ReadingConverter
public class BytesToAddressConverter implements Converter&lt;byte[], Address&gt; {

  private final Jackson2JsonRedisSerializer&lt;Address&gt; serializer;

  public BytesToAddressConverter() {

    serializer = new Jackson2JsonRedisSerializer&lt;Address&gt;(Address.class);
    serializer.setObjectMapper(new ObjectMapper());
  }

  @Override
  public Address convert(byte[] value) {
    return serializer.deserialize(value);
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用前面的字节数组 <code>Converter</code> 产生的输出类似于以下内容:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">_class = org.example.Person
id = e2c7dcee-b8cd-4424-883e-736ce564363e
firstname = rand
lastname = al’thor
address = { city : "emond's field", country : "andor" }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了两个 <code>Map</code> 转换器示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. Sample Map&lt;String,byte[]&gt; Converters</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@WritingConverter
public class AddressToMapConverter implements Converter&lt;Address, Map&lt;String,byte[]&gt;&gt; {

  @Override
  public Map&lt;String,byte[]&gt; convert(Address source) {
    return singletonMap("ciudad", source.getCity().getBytes());
  }
}

@ReadingConverter
public class MapToAddressConverter implements Converter&lt;Map&lt;String, byte[]&gt;, Address&gt; {

  @Override
  public Address convert(Map&lt;String,byte[]&gt; source) {
    return new Address(new String(source.get("ciudad")));
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用前面的 Map <code>Converter</code> 产生的输出类似于以下内容:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">_class = org.example.Person
id = e2c7dcee-b8cd-4424-883e-736ce564363e
firstname = rand
lastname = al’thor
ciudad = "emond's field"</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
自定义转换对索引解析没有影响. 即使对于自定义转换类型, <a href="#redis.repositories.indexes">二级索引</a> 仍会创建.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="自定义类型映射"><a class="anchor" href="#自定义类型映射"></a>12.3.1. 自定义类型映射</h4>
<div class="paragraph">
<p>如果要避免将整个 Java 类名称写为类型信息,并且希望使用键,则可以在要保留的实体类上使用 <code>@TypeAlias</code> 注解. 如果您需要进一步自定义映射,请查看 <a href="https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/convert/TypeInformationMapper.html"><code>TypeInformationMapper</code></a> 接口. 可以在 <code>DefaultRedisTypeMapper</code> 上配置该接口的实例,该实例可以在 <code>MappingRedisConverter</code> 上配置.</p>
</div>
<div class="paragraph">
<p>以下示例显示如何为实体定义类型别名:</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. 为实体定义 <code>@TypeAlias</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@TypeAlias("pers")
class Person {

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>生成的文档将 <code>pers</code> 作为 <code>_class</code> 字段中的值.</p>
</div>
<div class="sect4">
<h5 id="配置自定义类型映射"><a class="anchor" href="#配置自定义类型映射"></a>配置自定义类型映射</h5>
<div class="paragraph">
<p>以下示例演示如何在 <code>MappingRedisConverter</code> 中配置自定义 <code>RedisTypeMapper</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. 通过Spring Java Config配置自定义 <code>RedisTypeMapper</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class CustomRedisTypeMapper extends DefaultRedisTypeMapper {
  //implement custom type mapping here
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
class SampleRedisConfiguration {

  @Bean
  public MappingRedisConverter redisConverter(RedisMappingContext mappingContext,
        RedisCustomConversions customConversions, ReferenceResolver referenceResolver) {

    MappingRedisConverter mappingRedisConverter = new MappingRedisConverter(mappingContext, null, referenceResolver,
            customTypeMapper());

    mappingRedisConverter.setCustomConversions(customConversions);

    return mappingRedisConverter;
  }

  @Bean
  public RedisTypeMapper customTypeMapper() {
    return new CustomRedisTypeMapper();
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis.repositories.keyspaces"><a class="anchor" href="#redis.repositories.keyspaces"></a>12.4. Keyspaces</h3>
<div class="paragraph">
<p>Keyspaces 定义用于为 Redis 哈希创建实际 key 的前缀.</p>
</div>
<div class="paragraph">
<p>默认情况下,前缀设置为  <code>getClass().getName()</code>. 您可以通过在聚合根级别上设置 <code>@RedisHash</code> 或设置程序配置来更改此默认设置. 但是,带注解的 keyspaces 将取代任何其他配置.</p>
</div>
<div class="paragraph">
<p>下面的示例演示如何使用 <code>@EnableRedisRepositories</code> 注解设置密钥空间配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. 通过 <code>@EnableRedisRepositories</code> 进行 Keyspaces 设置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableRedisRepositories(keyspaceConfiguration = MyKeyspaceConfiguration.class)
public class ApplicationConfig {

  //... RedisConnectionFactory and RedisTemplate Bean definitions omitted

  public static class MyKeyspaceConfiguration extends KeyspaceConfiguration {

    @Override
    protected Iterable&lt;KeyspaceSettings&gt; initialConfiguration() {
      return Collections.singleton(new KeyspaceSettings(Person.class, "people"));
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的示例演示如何以编程方式设置 keyspace:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. Programmatic Keyspace setup</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableRedisRepositories
public class ApplicationConfig {

  //... RedisConnectionFactory and RedisTemplate Bean definitions omitted

  @Bean
  public RedisMappingContext keyValueMappingContext() {
    return new RedisMappingContext(
      new MappingConfiguration(new IndexConfiguration(), new MyKeyspaceConfiguration()));
  }

  public static class MyKeyspaceConfiguration extends KeyspaceConfiguration {

    @Override
    protected Iterable&lt;KeyspaceSettings&gt; initialConfiguration() {
      return Collections.singleton(new KeyspaceSettings(Person.class, "people"));
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis.repositories.indexes"><a class="anchor" href="#redis.repositories.indexes"></a>12.5. 二级索引</h3>
<div class="paragraph">
<p><a href="https://redis.io/topics/indexes">二级索引</a> 用于启用基于 本地 Redis结构的查找操作. 每次保存时,值都会写入相应的索引,并在删除或  <a href="#redis.repositories.expirations">过期</a> 对象时将其删除..</p>
</div>
<div class="sect3">
<h4 id="redis.repositories.indexes.simple"><a class="anchor" href="#redis.repositories.indexes.simple"></a>12.5.1. 简单属性索引</h4>
<div class="paragraph">
<p>给定前面显示的示例 <code>Person</code> 实体,我们可以通过使用 <code>@Indexed</code> 注解属性来为  <code>firstname</code> 创建索引,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. Annotation driven indexing</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RedisHash("people")
public class Person {

  @Id String id;
  @Indexed String firstname;
  String lastname;
  Address address;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为实际属性值建立索引. 保存两个人(例如,"rand" 和 "aviendha")会导致建立类似于以下内容的索引:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">SADD people:firstname:rand e2c7dcee-b8cd-4424-883e-736ce564363e
SADD people:firstname:aviendha a9d4b3a0-50d3-4538-a2fc-f7fc2581ee56</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>也可以在嵌套元素上使用索引.假定 <code>Address</code> 具有以 <code>@Indexed</code> 注解的 <code>city</code> 属性.在这种情况下,一旦 <code>person.address.city</code> 不为 <code>null</code>,我们将为每个城市设置 <code>Set</code>,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">SADD people:address.city:tear e2c7dcee-b8cd-4424-883e-736ce564363e</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此外,通过编程设置,您可以定义 map keys 和列表属性的索引,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RedisHash("people")
public class Person {

  // ... other properties omitted

  Map&lt;String,String&gt; attributes;      <i class="conum" data-value="1"></i><b>(1)</b>
  Map&lt;String Person&gt; relatives;       <i class="conum" data-value="2"></i><b>(2)</b>
  List&lt;Address&gt; addresses;            <i class="conum" data-value="3"></i><b>(3)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>SADD people:attributes.map-key:map-value e2c7dcee-b8cd-4424-883e-736ce564363e</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>SADD people:relatives.map-key.firstname:tam e2c7dcee-b8cd-4424-883e-736ce564363e</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>SADD people:addresses.city:tear e2c7dcee-b8cd-4424-883e-736ce564363e</code></td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
索引无法在 <a href="#redis.repositories.references">References</a> 上解析.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>与 keyspaces 一样,您可以配置索引而无需注解实际的 domain ,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. Index Setup with @EnableRedisRepositories</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableRedisRepositories(indexConfiguration = MyIndexConfiguration.class)
public class ApplicationConfig {

  //... RedisConnectionFactory and RedisTemplate Bean definitions omitted

  public static class MyIndexConfiguration extends IndexConfiguration {

    @Override
    protected Iterable&lt;IndexDefinition&gt; initialConfiguration() {
      return Collections.singleton(new SimpleIndexDefinition("people", "firstname"));
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>再次,与 keyspaces 一样,您可以以编程方式配置索引,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. Programmatic Index setup</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableRedisRepositories
public class ApplicationConfig {

  //... RedisConnectionFactory and RedisTemplate Bean definitions omitted

  @Bean
  public RedisMappingContext keyValueMappingContext() {
    return new RedisMappingContext(
      new MappingConfiguration(
        new KeyspaceConfiguration(), new MyIndexConfiguration()));
  }

  public static class MyIndexConfiguration extends IndexConfiguration {

    @Override
    protected Iterable&lt;IndexDefinition&gt; initialConfiguration() {
      return Collections.singleton(new SimpleIndexDefinition("people", "firstname"));
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redis.repositories.indexes.geospatial"><a class="anchor" href="#redis.repositories.indexes.geospatial"></a>12.5.2. 地理空间索引</h4>
<div class="paragraph">
<p>假设 <code>Address</code>  类型包含 <code>Point</code>  类型的  <code>location</code>  属性,其中包含特定地址的地理坐标. 通过使用 <code>@GeoIndexed</code> 注解属性,Spring Data Redis 使用 Redis GEO 命令添加这些值,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RedisHash("people")
public class Person {

  Address address;

  // ... other properties omitted
}

public class Address {

  @GeoIndexed Point location;

  // ... other properties omitted
}

public interface PersonRepository extends CrudRepository&lt;Person, String&gt; {

  List&lt;Person&gt; findByAddressLocationNear(Point point, Distance distance);     <i class="conum" data-value="1"></i><b>(1)</b>
  List&lt;Person&gt; findByAddressLocationWithin(Circle circle);                    <i class="conum" data-value="2"></i><b>(2)</b>
}

Person rand = new Person("rand", "al'thor");
rand.setAddress(new Address(new Point(13.361389D, 38.115556D)));

repository.save(rand);                                                        <i class="conum" data-value="3"></i><b>(3)</b>

repository.findByAddressLocationNear(new Point(15D, 37D), new Distance(200)); <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>Point</code> 和 <code>Distance</code> 在嵌套属性上的查询方法声明, .</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>嵌套属性上的查询方法声明, 使用 <code>Circle</code> 进行搜索.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>GEOADD people:address:location 13.361389 38.115556 e2c7dcee-b8cd-4424-883e-736ce564363e</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>GEORADIUS people:address:location 15.0 37.0 200.0 km</code></td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中,经度和纬度值是通过使用 <code>GEOADD</code> 存储的,而 <code>GEOADD</code> 使用对象的 <code>id</code> 作为成员的名称.查找器方法允许使用 <code>Circle</code> 或  <code>Point, Distance</code> 组合查询这些值.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
不可能将附近和内部与其他条件组合.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="query-by-example"><a class="anchor" href="#query-by-example"></a>12.6. 查询例子</h3>
<div class="sect3">
<h4 id="query-by-example.introduction"><a class="anchor" href="#query-by-example.introduction"></a>12.6.1. 简介</h4>
<div class="paragraph">
<p>本章对 "按示例查询" 进行了介绍,并说明了如何使用它.</p>
</div>
<div class="paragraph">
<p>示例查询 (QBE) 是一种具有简单界面的用户友好查询技术.  它允许动态查询创建,并且不需要您编写包含字段名称的查询.  实际上,"示例查询" 根本不需要您使用存储库特定的查询语言编写查询.</p>
</div>
</div>
<div class="sect3">
<h4 id="query-by-example.usage"><a class="anchor" href="#query-by-example.usage"></a>12.6.2. 使用</h4>
<div class="paragraph">
<p>示例查询由三部分组成:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Probe: 带有填充字段的 domain 对象的实际示例.</p>
</li>
<li>
<p><code>ExampleMatcher</code>: <code>ExampleMatcher</code> 包含有关如何匹配特定字段的详细信息.  可以在多个示例中重复使用它.</p>
</li>
<li>
<p><code>Example</code>: 示例包括探针和 <code>ExampleMatcher</code>.  它用于创建查询.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>示例查询非常适合几种用例:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用一组静态或动态约束来查询数据存储.</p>
</li>
<li>
<p>频繁重构 domain 对象,而不必担心破坏现有查询.</p>
</li>
<li>
<p>独立于基础数据存储 API 进行工作.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>示例查询也有一些限制:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不支持嵌套或分组属性约束,例如 <code>firstname = ?0 or (firstname = ?1 and lastname = ?2)</code>.</p>
</li>
<li>
<p>仅支持字符串的开始/包含/结束/正则表达式匹配,以及其他属性类型的完全匹配.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在开始使用示例查询之前,您需要具有一个 domain 对象.  首先,为您的存储库创建一个接口,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. Sample Person 对象</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class Person {

  @Id
  private String id;
  private String firstname;
  private String lastname;
  private Address address;

  // … getters and setters omitted
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例显示了一个简单的域对象.  您可以使用它来创建一个 <code>Example</code>.  默认情况下,具有 <code>null</code> 的字段将被忽略,并且使用存储特定的默认值来匹配字符串.  可以使用工厂方法或使用 <code>ExampleMatcher</code> 构建示例.  例子是一成不变的.  以下清单显示了一个简单的示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. Simple Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Person person = new Person();                         <i class="conum" data-value="1"></i><b>(1)</b>
person.setFirstname("Dave");                          <i class="conum" data-value="2"></i><b>(2)</b>

Example&lt;Person&gt; example = Example.of(person);         <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建  domain 对象的新实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置要查询的属性.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>创建 <code>Example</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>最好在存储库中执行示例.  为此,让您的存储库接口扩展 <code>QueryByExampleExecutor&lt;T&gt;</code>.  以下清单显示了 <code>QueryByExampleExecutor</code> 接口:</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. <code>QueryByExampleExecutor</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface QueryByExampleExecutor&lt;T&gt; {

  &lt;S extends T&gt; S findOne(Example&lt;S&gt; example);

  &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; example);

  // … more functionality omitted.
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="query-by-example.matchers"><a class="anchor" href="#query-by-example.matchers"></a>12.6.3. Example 匹配</h4>
<div class="paragraph">
<p>示例不限于默认设置.  您可以使用 <code>ExampleMatcher</code> 为字符串匹配,空值处理和特定于属性的设置指定自己的默认值,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. 具有定制匹配的例子匹配器</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Person person = new Person();                          <i class="conum" data-value="1"></i><b>(1)</b>
person.setFirstname("Dave");                           <i class="conum" data-value="2"></i><b>(2)</b>

ExampleMatcher matcher = ExampleMatcher.matching()     <i class="conum" data-value="3"></i><b>(3)</b>
  .withIgnorePaths("lastname")                         <i class="conum" data-value="4"></i><b>(4)</b>
  .withIncludeNullValues()                             <i class="conum" data-value="5"></i><b>(5)</b>
  .withStringMatcherEnding();                          <i class="conum" data-value="6"></i><b>(6)</b>

Example&lt;Person&gt; example = Example.of(person, matcher); <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建域对象的新实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置属性.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>创建一个 <code>ExampleMatcher</code> 以期望所有值都匹配.  即使没有进一步的配置,它也可以在此阶段使用.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径并包含空值.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>构造一个新的 <code>ExampleMatcher</code> 以忽略 <code>lastname</code> 属性路径,包括空值,并执行后缀字符串匹配.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>基于域对象和配置的 <code>ExampleMatcher</code> 创建一个新的 <code>Example</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下,<code>ExampleMatcher</code> 期望设置的所有值都匹配.  如果要获取与隐式定义的任何断言匹配的结果,请使用  <code>ExampleMatcher.matchingAny()</code>.</p>
</div>
<div class="paragraph">
<p>您可以为单个属性 (例如  "firstname" 和 "lastname",或者对于嵌套属性,"address.city") 指定行为.  您可以使用匹配选项和区分大小写对其进行调整,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. 配置匹配器选项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ExampleMatcher matcher = ExampleMatcher.matching()
  .withMatcher("firstname", endsWith())
  .withMatcher("lastname", startsWith().ignoreCase());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>配置匹配器选项的另一种方法是使用 lambda (在Java 8中引入) .  此方法创建一个回调,要求实现者修改匹配器.  您无需返回匹配器,因为配置选项保存在匹配器实例中.  以下示例显示了使用lambda的匹配器:</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. 用lambdas配置匹配器选项</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ExampleMatcher matcher = ExampleMatcher.matching()
  .withMatcher("firstname", match -&gt; match.endsWith())
  .withMatcher("firstname", match -&gt; match.startsWith());
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由 <code>Example</code> 创建的查询使用配置的合并视图.  可以在 <code>ExampleMatcher</code> 级别上设置默认的匹配设置,而可以将单个设置应用于特定的属性路径.  除非明确定义,否则 <code>ExampleMatcher</code> 上设置的设置将由属性路径设置继承.
属性修补程序上的设置优先于默认设置.  下表描述了各种 <code>ExampleMatcher</code> 设置的范围:</p>
</div>
<div class="paragraph">
<p>表4. <code>ExampleMatcher</code> 设置的范围</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. Scope of <code>ExampleMatcher</code> settings</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Setting</th>
<th class="tableblock halign-left valign-top">Scope</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Null-handling</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExampleMatcher</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">String matching</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExampleMatcher</code> and property path</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ignoring properties</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property path</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Case sensitivity</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExampleMatcher</code> and property path</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Value transformation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Property path</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="query-by-example.execution"><a class="anchor" href="#query-by-example.execution"></a>12.6.4. 执行一个例子</h4>
<div class="paragraph">
<p>以下示例对存储库使用"按示例查询”:</p>
</div>
<div class="exampleblock">
<div class="title">Example 30. 使用存储库按示例查询</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface PersonRepository extends QueryByExampleExecutor&lt;Person&gt; {
}

class PersonService {

  @Autowired PersonRepository personRepository;

  List&lt;Person&gt; findPeople(Person probe) {
    return personRepository.findAll(Example.of(probe));
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Redis 存储库及其二级索引支持 Spring Data 的按示例查询功能的子集. 特别是,仅使用精确的,区分大小写的和非 <code>null</code> 的值来构造查询.</p>
</div>
<div class="paragraph">
<p>二级索引使用基于集合的操作(集合相交,集合并集)来确定匹配的键. 向没有索引的查询添加属性不会返回任何结果,因为不存在索引. "按示例查询" 支持人员检查索引配置,以仅包括查询中由索引覆盖的属性. 这是为了防止意外包含未索引的属性.</p>
</div>
<div class="paragraph">
<p>不区分大小写的查询和不受支持的 <code>StringMatcher</code> 实例在运行时被拒绝.</p>
</div>
<div class="paragraph">
<p>以下列表显示了受支持的"按示例查询”选项:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>区分大小写,简单和嵌套属性的精确匹配</p>
</li>
<li>
<p>Any/All 匹配模式</p>
</li>
<li>
<p>标准值的值转换</p>
</li>
<li>
<p>从条件中排除 <code>null</code> 值</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下列表显示了 "按示例查询” 不支持的属性:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不区分大小写的匹配</p>
</li>
<li>
<p>正则表达式,前缀/包含/后缀字符串匹配</p>
</li>
<li>
<p>查询关联,集合和类似地图的属性</p>
</li>
<li>
<p>从条件中包含 <code>null</code> 值</p>
</li>
<li>
<p><code>findAll</code> 与排序</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis.repositories.expirations"><a class="anchor" href="#redis.repositories.expirations"></a>12.7. 生存时间</h3>
<div class="paragraph">
<p>Redis 中存储的对象可能仅在一定时间内有效. 这对于在 Redis 中持久保存短寿命的对象特别有用,而无需在寿命到期时手动将其删除. 可以使用 <code>@RedisHash(timeToLive=&#8230;&#8203;)</code> 以及使用 <code>KeyspaceSettings</code>(请参见  <a href="#redis.repositories.keyspaces">Keyspaces</a>)来设置以秒为单位的到期时间.</p>
</div>
<div class="paragraph">
<p>可以通过在数字属性或方法上使用 <code>@TimeToLive</code> 注解来设置更灵活的到期时间. 但是,不要将 <code>@TimeToLive</code> 应用于同一类中的方法和属性. 以下示例显示了属性和方法上的 <code>@TimeToLive</code> 注解:</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. Expirations</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class TimeToLiveOnProperty {

  @Id
  private String id;

  @TimeToLive
  private Long expiration;
}

public class TimeToLiveOnMethod {

  @Id
  private String id;

  @TimeToLive
  public long getTimeToLive() {
    return new Random().nextLong();
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
使用 <code>@TimeToLive</code> 显式注解属性会从 Redis 中读取实际的 <code>TTL</code> 或 <code>PTTL</code> 值. -1 表示该对象没有关联的到期时间.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>存储库实现可确保通过 <code>RedisMessageListenerContainer</code> 订阅 <a href="https://redis.io/topics/notifications">Redis keyspace notifications</a></p>
</div>
<div class="paragraph">
<p>当到期设置为正值时,将执行相应的 <code>EXPIRE</code> 命令. 除了保留原始副本外,幻影副本还将保留在 Redis 中,并设置为在原始副本后五分钟到期. 这样做是为了使存储库支持能够发布 <code>RedisKeyExpiredEvent</code>,并在键过期时将过期值保存在Spring的 <code>ApplicationEventPublisher</code> 中,
即使原始值已被删除也是如此. 在使用 Spring Data Redis 存储库的所有已连接应用程序上都会收到到期事件.</p>
</div>
<div class="paragraph">
<p>默认情况下,初始化应用程序时禁用密钥过期监听器. 可以在 <code>@EnableRedisRepositories</code> 或 <code>RedisKeyValueAdapter</code> 中调整启动模式,以通过应用程序或在第一次插入带有TTL的实体时启动监听器. 有关可能的值,请参见 <a href="https://docs.spring.io/spring-data/redis/docs/2.3.6.RELEASE/api/org/springframework/data/redis/core/RedisKeyValueAdapter.EnableKeyspaceEvents.html"><code>EnableKeyspaceEvents</code></a>.</p>
</div>
<div class="paragraph">
<p><code>RedisKeyExpiredEvent</code> 包含过期的域对象以及密钥的副本.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
延迟或禁用到期事件监听器的启动会影响 <code>RedisKeyExpiredEvent</code> 发布.禁用的事件监听器不会发布到期事件.由于延迟的监听器初始化,延迟的启动可能导致事件丢失.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
keyspace notification 消息监听器会更改Redis中的 <code>notify-keyspace-events</code> 设置(如果尚未设置). 现有设置不会被覆盖,因此您必须正确设置这些设置(或将其保留为空). 请注意,在AWS <code>ElastiCache</code> 上禁用了 <code>CONFIG</code>,并且启用监听器会导致错误.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Redis Pub/Sub messages 消息不是持久性的.如果在应用程序关闭时密钥过期,则不会处理过期事件,这可能会导致二级索引包含对过期对象的引用.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="redis.repositories.references"><a class="anchor" href="#redis.repositories.references"></a>12.8. 持久引用</h3>
<div class="paragraph">
<p>使用 <code>@Reference</code> 标记属性允许存储简单的键引用,而不是将值复制到哈希本身中.从 Redis 加载时,引用将自动解析并映射回该对象,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. Sample 属性参考</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">_class = org.example.Person
id = e2c7dcee-b8cd-4424-883e-736ce564363e
firstname = rand
lastname = al’thor
mother = people:a9d4b3a0-50d3-4538-a2fc-f7fc2581ee56      <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Reference stores the whole key (<code>keyspace:id</code>) of the referenced object.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
保存引用对象时,引用对象不会保留.由于仅存储引用,因此您必须分别对引用的对象进行更改.无法解析在引用类型的属性上设置的索引
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="redis.repositories.partial-updates"><a class="anchor" href="#redis.repositories.partial-updates"></a>12.9. 持续部分更新</h3>
<div class="paragraph">
<p>在某些情况下,您无需加载和重写整个实体就可以在其中设置新值. 最后一个活动时间的会话时间戳可能就是您要更改一个属性的情况. PartialUpdate 使您可以定义现有对象的 <code>set</code> 和  <code>delete</code> 操作,同时注意更新实体本身和索引结构的潜在到期时间. 以下示例显示了部分更新:</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. Sample Partial Update</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">PartialUpdate&lt;Person&gt; update = new PartialUpdate&lt;Person&gt;("e2c7dcee", Person.class)
  .set("firstname", "mat")                                                           <i class="conum" data-value="1"></i><b>(1)</b>
  .set("address.city", "emond's field")                                              <i class="conum" data-value="2"></i><b>(2)</b>
  .del("age");                                                                       <i class="conum" data-value="3"></i><b>(3)</b>

template.update(update);

update = new PartialUpdate&lt;Person&gt;("e2c7dcee", Person.class)
  .set("address", new Address("caemlyn", "andor"))                                   <i class="conum" data-value="4"></i><b>(4)</b>
  .set("attributes", singletonMap("eye-color", "grey"));                             <i class="conum" data-value="5"></i><b>(5)</b>

template.update(update);

update = new PartialUpdate&lt;Person&gt;("e2c7dcee", Person.class)
  .refreshTtl(true);                                                                 <i class="conum" data-value="6"></i><b>(6)</b>
  .set("expiration", 1000);

template.update(update);</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将 <code>firstname</code> 属性设置为 <code>mat</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>将 'address.city' 属性设置为 'emond&#8217;s field' 而不必传入整个对象. 注册自定义转换时,此功能不起作用.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>删除 <code>age</code> 属性.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>设置复杂的 <code>address</code> 属性.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>设置值的映射,该映射将删除先前存在的映射,并将值替换为给定的值.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>更改<a href="#redis.repositories.expirations">生存时间</a>时,将自动更新服务器的到期时间.Automatically update the server expiration time when altering .</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
更新复杂对象以及地图(或其他集合)结构需要与Redis进行进一步交互以确定现有值,这意味着重写整个实体可能会更快.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="redis.repositories.queries"><a class="anchor" href="#redis.repositories.queries"></a>12.10. 查询和查询方法</h3>
<div class="paragraph">
<p>查询方法允许从方法名称自动继承 简单查找程序查询,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. Sample Repository finder Method</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface PersonRepository extends CrudRepository&lt;Person, String&gt; {

  List&lt;Person&gt; findByFirstname(String firstname);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请确保设置查找程序方法中使用的属性以建立索引.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Redis存储库的查询方法仅支持对实体的查询以及带分页的实体集合.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>使用继承 的查询方法可能并不总是足以为要执行的查询建模. <code>RedisCallback</code> 提供了对索引结构甚至自定义索引的实际匹配的更多控制. 为此,提供一个 <code>RedisCallback</code>,它返回一组或一组可迭代的 <code>id</code> 值,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. Sample finder using RedisCallback</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String user = //...

List&lt;RedisSession&gt; sessionsByUser = template.find(new RedisCallback&lt;Set&lt;byte[]&gt;&gt;() {

  public Set&lt;byte[]&gt; doInRedis(RedisConnection connection) throws DataAccessException {
    return connection
      .sMembers("sessions:securityContext.authentication.principal.username:" + user);
  }}, RedisSession.class);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下表概述了Redis支持的关键字以及包含该关键字的方法的基本含义:</p>
</div>
<div class="exampleblock">
<div class="content">
<table class="tableblock frame-all grid-all fit-content">
<caption class="title">Table 12. 方法名称中支持的关键字</caption>
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Keyword</th>
<th class="tableblock halign-left valign-top">Sample</th>
<th class="tableblock halign-left valign-top">Redis snippet</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>And</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameAndFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SINTER …:firstname:rand …:lastname:al’thor</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Or</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByLastnameOrFirstname</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SUNION …:firstname:rand …:lastname:al’thor</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Is, Equals</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByFirstname</code>, <code>findByFirstnameIs</code>, <code>findByFirstnameEquals</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SINTER …:firstname:rand</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsTrue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FindByAliveIsTrue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SINTER …:alive:1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>IsFalse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findByAliveIsFalse</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SINTER …:alive:0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Top,First</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>findFirst10ByFirstname</code>,<code>findTop5ByFirstname</code></p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="redis.repositories.cluster"><a class="anchor" href="#redis.repositories.cluster"></a>12.11. 在集群上运行的Redis存储库</h3>
<div class="paragraph">
<p>您可以在集群 Redis 环境中使用 Redis 存储库支持. 有关 ConnectionFactory 配置的详细信息,请参见  &#8220;<a href="#cluster">Redis 集群</a>&#8221;  部分. 但是,还必须进行一些其他配置,因为默认的密钥分发会在整个群集及其 slot 中扩展实体和二级索引.</p>
</div>
<div class="paragraph">
<p>下表显示了群集上数据的详细信息(基于先前的示例):</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Slot</th>
<th class="tableblock halign-left valign-top">Node</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">people:e2c7dcee-b8cd-4424-883e-736ce564363e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">id for hash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">15171</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127.0.0.1:7381</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">people:a9d4b3a0-50d3-4538-a2fc-f7fc2581ee56</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">id for hash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7373</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127.0.0.1:7380</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">people:firstname:rand</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1700</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127.0.0.1:7379</p></td>
</tr>
</tbody>
</table>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>当所有涉及的键都映射到同一 slot 时,某些命令(例如 <code>SINTER</code> 和 <code>SUNION</code>)只能在服务器端处理. 否则,必须在客户端进行计算. 因此,将 keyspaces 固定到单个 slot 非常有用,这样可以立即利用 Redis 服务器端计算.
下表显示了您执行此操作时发生的情况(请注意 slot 列中的更改以及节点列中的端口值):</p>
</div>
<table class="tableblock frame-all grid-all fit-content">
<colgroup>
<col>
<col>
<col>
<col>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Key</th>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Slot</th>
<th class="tableblock halign-left valign-top">Node</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{people}:e2c7dcee-b8cd-4424-883e-736ce564363e</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">id for hash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2399</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127.0.0.1:7379</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{people}:a9d4b3a0-50d3-4538-a2fc-f7fc2581ee56</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">id for hash</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2399</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127.0.0.1:7379</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">{people}:firstname:rand</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">index</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2399</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">127.0.0.1:7379</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
使用Redis集群时,通过使用 <code>@RedisHash("{yourkeyspace}")</code> 将 keyspaces 定义和固定到特定 slots.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="redis.repositories.cdi-integration"><a class="anchor" href="#redis.repositories.cdi-integration"></a>12.12. CDI 集成</h3>
<div class="paragraph">
<p>存储库接口的实例通常由容器创建,在使用 Spring Data 时,Spring 是最自然的选择. Spring 提供了用于创建bean实例的高级工具. Spring Data Redis 附带了一个自定义 CDI 扩展,使您可以在 CDI 环境中使用存储库抽象. 该扩展是JAR的一部分,因此要激活它,请将Spring Data Redis JAR放到您的类路径中.</p>
</div>
<div class="paragraph">
<p>然后,您可以通过为 <code>RedisConnectionFactory</code> 和 <code>RedisOperations</code> 实现CDI生产者来设置基础结构,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class RedisOperationsProducer {


  @Produces
  RedisConnectionFactory redisConnectionFactory() {

    JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(new RedisStandaloneConfiguration());
    jedisConnectionFactory.afterPropertiesSet();

    return jedisConnectionFactory;
  }

  void disposeRedisConnectionFactory(@Disposes RedisConnectionFactory redisConnectionFactory) throws Exception {

    if (redisConnectionFactory instanceof DisposableBean) {
      ((DisposableBean) redisConnectionFactory).destroy();
    }
  }

  @Produces
  @ApplicationScoped
  RedisOperations&lt;byte[], byte[]&gt; redisOperationsProducer(RedisConnectionFactory redisConnectionFactory) {

    RedisTemplate&lt;byte[], byte[]&gt; template = new RedisTemplate&lt;byte[], byte[]&gt;();
    template.setConnectionFactory(redisConnectionFactory);
    template.afterPropertiesSet();

    return template;
  }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>必要的设置可能会有所不同,具体取决于您的 JavaEE 环境.</p>
</div>
<div class="paragraph">
<p>每当容器请求存储库类型的bean时,Spring Data Redis CDI 扩展都将所有可用的存储库用作 CDI bean,并为 Spring Data 存储库创建代理. 因此,获取 Spring Data 存储库的实例只需声明一个 <code>@Injected</code> 属性即可,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class RepositoryClient {

  @Inject
  PersonRepository repository;

  public void businessMethod() {
    List&lt;Person&gt; people = repository.findAll();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Redis存储库需要 <code>RedisKeyValueAdapter</code> 和 <code>RedisKeyValueTemplate</code> 实例. 如果找不到提供的 bean,那么这些 bean 由 Spring Data CDI 扩展创建和管理. 但是,您可以提供自己的 bean 来配置 <code>RedisKeyValueAdapter</code> 和 <code>RedisKeyValueTemplate</code> 的特定属性.</p>
</div>
</div>
<div class="sect2">
<h3 id="redis存储库原理"><a class="anchor" href="#redis存储库原理"></a>12.13. Redis存储库原理</h3>
<div class="paragraph">
<p>Redis作为村书库本身提供了一个非常狭窄的低级API,留给用户的是高级功能,例如二级索引和查询操作.</p>
</div>
<div class="paragraph">
<p>本节提供了由存储库抽象发出的命令的更详细视图,以更好地了解潜在的性能影响.</p>
</div>
<div class="paragraph">
<p>将以下实体类视为所有操作的起点:</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. Example entity</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RedisHash("people")
public class Person {

  @Id String id;
  @Indexed String firstname;
  String lastname;
  Address hometown;
}

public class Address {

  @GeoIndexed Point location;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="插入新值"><a class="anchor" href="#插入新值"></a>12.13.1. 插入新值</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">repository.save(new Person("rand", "al'thor"));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">HMSET "people:19315449-cda2-4f5c-b696-9cb8018fa1f9" "_class" "Person" "id" "19315449-cda2-4f5c-b696-9cb8018fa1f9" "firstname" "rand" "lastname" "al'thor" <i class="conum" data-value="1"></i><b>(1)</b>
SADD  "people" "19315449-cda2-4f5c-b696-9cb8018fa1f9"                           <i class="conum" data-value="2"></i><b>(2)</b>
SADD  "people:firstname:rand" "19315449-cda2-4f5c-b696-9cb8018fa1f9"            <i class="conum" data-value="3"></i><b>(3)</b>
SADD  "people:19315449-cda2-4f5c-b696-9cb8018fa1f9:idx" "people:firstname:rand" <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将展开的条目另存为哈希.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>将用 &lt;1&gt; 编写的哈希键添加到同一 keyspaces 中的实体的辅助索引中.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>将用&lt;2&gt;编写的哈希键添加到具有属性值的名字的二级索引中.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>将&lt;3&gt;的索引添加到帮助程序结构集以供输入,以跟踪删除/更新时要清理的索引.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redis.repositories.anatomy.replace"><a class="anchor" href="#redis.repositories.anatomy.replace"></a>12.13.2. 替换存在的</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">repository.save(new Person("e82908cf-e7d3-47c2-9eec-b4e0967ad0c9", "Dragon Reborn", "al'thor"));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">DEL       "people:e82908cf-e7d3-47c2-9eec-b4e0967ad0c9"                           <i class="conum" data-value="1"></i><b>(1)</b>
HMSET     "people:e82908cf-e7d3-47c2-9eec-b4e0967ad0c9" "_class" "Person" "id" "e82908cf-e7d3-47c2-9eec-b4e0967ad0c9" "firstname" "Dragon Reborn" "lastname" "al'thor" <i class="conum" data-value="2"></i><b>(2)</b>
SADD      "people" "e82908cf-e7d3-47c2-9eec-b4e0967ad0c9"                         <i class="conum" data-value="3"></i><b>(3)</b>
SMEMBERS  "people:e82908cf-e7d3-47c2-9eec-b4e0967ad0c9:idx"                       <i class="conum" data-value="4"></i><b>(4)</b>
TYPE      "people:firstname:rand"                                                 <i class="conum" data-value="5"></i><b>(5)</b>
SREM      "people:firstname:rand" "e82908cf-e7d3-47c2-9eec-b4e0967ad0c9"          <i class="conum" data-value="6"></i><b>(6)</b>
DEL       "people:e82908cf-e7d3-47c2-9eec-b4e0967ad0c9:idx"                       <i class="conum" data-value="7"></i><b>(7)</b>
SADD      "people:firstname:Dragon Reborn" "e82908cf-e7d3-47c2-9eec-b4e0967ad0c9" <i class="conum" data-value="8"></i><b>(8)</b>
SADD      "people:e82908cf-e7d3-47c2-9eec-b4e0967ad0c9:idx" "people:firstname:Dragon Reborn" <i class="conum" data-value="9"></i><b>(9)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>删除现有的散列,以避免可能不再存在的散列键剩余.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>将展开的条目另存为哈希.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>将用&lt;1&gt;编写的哈希键添加到同一 keyspaces 中的实体的辅助索引中.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>获取可能需要更新的现有索引结构.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>检查索引是否存在以及它是什么类型(文本,地理位置,…).</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>从索引中删除潜在的现有键.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>删除辅助程序持有索引信息.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>将在&lt;2&gt;中添加的哈希键添加到具有属性值的名字的二级索引中.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>将索引&lt;6&gt;添加到帮助程序结构集中,以进行输入,以跟踪删除/更新时要清除的索引.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redis.repositories.anatomy.geo"><a class="anchor" href="#redis.repositories.anatomy.geo"></a>12.13.3. 保存 Geo 数据</h4>
<div class="paragraph">
<p>地理索引遵循与基于普通文本的规则相同的规则,但是使用地理结构来存储值. 保存使用地理索引属性的实体将导致以下命令:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">GEOADD "people:hometown:location" "13.361389" "38.115556" "76900e94-b057-44bc-abcf-8126d51a621b"  <i class="conum" data-value="1"></i><b>(1)</b>
SADD   "people:76900e94-b057-44bc-abcf-8126d51a621b:idx" "people:hometown:location"               <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将已保存条目的键添加到地理位置索引</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>跟踪索引结构.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redis.repositories.anatomy.index"><a class="anchor" href="#redis.repositories.anatomy.index"></a>12.13.4. 使用简单索引查找</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">repository.findByFirstname("egwene");</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">SINTER  "people:firstname:egwene"                     <i class="conum" data-value="1"></i><b>(1)</b>
HGETALL "people:d70091b5-0b9a-4c0a-9551-519e61bc9ef3" <i class="conum" data-value="2"></i><b>(2)</b>
HGETALL ...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>提取二级索引中包含的键.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>分别获取&lt;1&gt;返回的每个键.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="redis.repositories.anatomy.geo-index"><a class="anchor" href="#redis.repositories.anatomy.geo-index"></a>12.13.5. 使用地理位置索引查找</h4>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">repository.findByHometownLocationNear(new Point(15, 37), new Distance(200, KILOMETERS));</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">GEORADIUS "people:hometown:location" "15.0" "37.0" "200.0" "km" <i class="conum" data-value="1"></i><b>(1)</b>
HGETALL   "people:76900e94-b057-44bc-abcf-8126d51a621b"         <i class="conum" data-value="2"></i><b>(2)</b>
HGETALL   ...</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>提取二级索引中包含的键.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>分别获取&lt;1&gt;返回的每个键.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="appendixes" class="sect0"><a class="anchor" href="#appendixes"></a>附录</h1>
<div class="openblock partintro">
<div class="content">
<h2 id="appendix-文档结构" class="float">Appendix 文档结构</h2>
<div class="paragraph">
<p>附录包含各种其他详细信息,可补充参考文档其余部分中的信息:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>&#8220;<a href="#appendix:schema">Schema</a>&#8221; 定义了 Spring Data Redis 提供的 schema.</p>
</li>
<li>
<p>&#8220;<a href="#appendix:command-reference">命令参考</a>&#8221; 详细介绍了 RedisTemplate 支持哪些命令.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix:schema"><a class="anchor" href="#appendix:schema"></a>Appendix A: Schema</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://www.springframework.org/schema/redis/spring-redis-1.0.xsd">Spring Data Redis Schema (redis-namespace)</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="appendix:command-reference"><a class="anchor" href="#appendix:command-reference"></a>Appendix B: 命令参考</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="支持的命令"><a class="anchor" href="#支持的命令"></a>支持的命令</h3>
<table class="tableblock frame-all grid-all" style="width: 50%;">
<caption class="title">Table 13. Redis commands supported by <code>RedisTemplate</code></caption>
<colgroup>
<col style="width: 66.6666%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Command</th>
<th class="tableblock halign-center valign-top">Template Support</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">APPEND</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AUTH</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BGREWRITEAOF</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BGSAVE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITCOUNT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITFIELD</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BITOP</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BLPOP</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BRPOP</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BRPOPLPUSH</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLIENT KILL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLIENT GETNAME</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLIENT LIST</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLIENT SETNAME</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CLUSTER SLOTS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COMMAND</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COMMAND COUNT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COMMAND GETKEYS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">COMMAND INFO</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONFIG GET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONFIG RESETSTAT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONFIG REWRITE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONFIG SET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DBSIZE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEBUG OBJECT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEBUG SEGFAULT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DECR</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DECRBY</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DEL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DISCARD</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DUMP</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ECHO</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EVAL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EVALSHA</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXEC</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXISTS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXPIRE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXPIREAT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FLUSHALL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FLUSHDB</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GETBIT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GETRANGE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GETSET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HDEL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HEXISTS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HGET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HGETALL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HINCRBY</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HINCRBYFLOAT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HKEYS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HLEN</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HMGET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HMSET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HSCAN</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HSET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HSETNX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HVALS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INCR</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INCRBY</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INCRBYFLOAT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">INFO</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">KEYS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LASTSAVE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LINDEX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LINSERT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LLEN</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LPOP</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LPUSH</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LPUSHX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LRANGE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LREM</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LSET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LTRIM</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MGET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MIGRATE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MONITOR</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MOVE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MSETNX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MULTI</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">OBJECT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PERSIST</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PEXIPRE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PEXPIREAT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PFADD</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PFCOUNT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PFMERGE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PING</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PSETEX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PSUBSCRIBE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PTTL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUBLISH</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUBSUB</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PUBSUBSCRIBE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">QUIT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RANDOMKEY</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RENAME</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RENAMENX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RESTORE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ROLE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RPOP</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RPOPLPUSH</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RPUSH</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RPUSHX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SADD</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SAVE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCAN</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCARD</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCRIPT EXITS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCRIPT FLUSH</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCRIPT KILL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCRIPT LOAD</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SDIFF</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SDIFFSTORE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SELECT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTINEL FAILOVER</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTINEL GET-MASTER-ADD-BY-NAME</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTINEL MASTER</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTINEL MASTERS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTINEL MONITOR</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTINEL REMOVE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTINEL RESET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTINEL SET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SENTINEL SLAVES</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SET</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SETBIT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SETEX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SETNX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SETRANGE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SHUTDOWN</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SINTER</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SINTERSTORE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SISMEMBER</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SLAVEOF</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SLOWLOG</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMEMBERS</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMOVE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SORT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SPOP</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SRANDMEMBER</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SREM</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SSCAN</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">STRLEN</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SUBSCRIBE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SUNION</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SUNIONSTORE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SYNC</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TIME</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TTL</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TYPE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNSUBSCRIBE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UNWATCH</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">WATCH</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZADD</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZCARD</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZCOUNT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZINCRBY</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZINTERSTORE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZLEXCOUNT</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZRANGE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZRANGEBYLEX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZREVRANGEBYLEX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZRANGEBYSCORE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZRANK</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZREM</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZREMRANGEBYLEX</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">-</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZREMRANGEBYRANK</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZREVRANGE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZREVRANGEBYSCORE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZREVRANK</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZSCAN</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZSCORE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZUNINONSTORE</p></td>
<td class="tableblock halign-center valign-top"><p class="tableblock">X</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2.3.6.RELEASE<br>
Last updated 2021-02-06 12:52:02 +0800
</div>
</div>
<script type="text/javascript" src="http://resources.jcohy.com/js/tocbot/tocbot.min.js"></script>
<script type="text/javascript" src="http://resources.jcohy.com/js/toc.js"></script>
<script type="text/javascript" src="http://resources.jcohy.com/js/switch-language.js"></script>
</body>
</html>
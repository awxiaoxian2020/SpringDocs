<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="author" content="Andy Wilkinson">
<title>Spring Boot Gradle Plugin Reference Guide</title>
<link rel="stylesheet" href="css/site.css">
<script src="js/setup.js"></script><script defer src="js/site.js"></script>

</head>
<body class="book toc2 toc-left"><div id="banner-container" class="container" role="banner">
  <div id="banner" class="contained" role="banner">
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </div>
</div>
<div id="tocbar-container" class="container" role="navigation">
  <div id="tocbar" class="contained" role="navigation">
    <button id="toggle-toc"></button>
  </div>
</div>
<div id="main-container" class="container">
  <div id="main" class="contained">
    <div id="doc" class="doc">
<div id="header">
<h1>Spring Boot Gradle Plugin Reference Guide</h1>
<div class="details">
<span id="author" class="author">Andy Wilkinson</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#introduction">1. 简介</a></li>
<li><a href="#getting-started">2. 入门</a></li>
<li><a href="#managing-dependencies">3. 依赖管理</a>
<ul class="sectlevel2">
<li><a href="#managing-dependencies-dependency-management-plugin">3.1. Managing Dependencies with the Dependency Management Plugin</a></li>
<li><a href="#managing-dependencies-dependency-management-plugin-customizing">3.2. 自定义管理版本号</a></li>
<li><a href="#managing-dependencies-dependency-management-plugin-using-in-isolation">3.3. 单独使用 Spring Boot 的依赖管理</a></li>
<li><a href="#managing-dependencies-learning-more">3.4. 更多</a></li>
<li><a href="#managing-dependencies-gradle-bom-support">3.5. 使用 Gradle 的 Bom 支持依赖管理</a>
<ul class="sectlevel3">
<li><a href="#managing-dependencies-gradle-bom-support-customizing">3.5.1. 自定义版本管理</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#packaging-executable">4. 打包可执行文件</a>
<ul class="sectlevel2">
<li><a href="#packaging-executable-jars">4.1. 打包可执行 jars</a></li>
<li><a href="#packaging-executable-wars">4.2. 打包可执行 wars</a>
<ul class="sectlevel3">
<li><a href="#packaging-executable-wars-deployable">4.2.1. 打包可执行和可部署的 wars</a></li>
</ul>
</li>
<li><a href="#packaging-executable-and-normal">4.3. 打包可执行和普通文件</a></li>
<li><a href="#packaging-executable-configuring">4.4. 配置可执行文件打包</a>
<ul class="sectlevel3">
<li><a href="#packaging-executable-configuring-main-class">4.4.1. 配置主类</a></li>
<li><a href="#packaging-executable-configuring-including-development-only-dependencies">4.4.2. Including Development-only Dependencies</a></li>
<li><a href="#packaging-executable-configuring-unpacking">4.4.3. 配置需要移除的库</a></li>
<li><a href="#packaging-executable-configuring-launch-script">4.4.4. 让文件完全可执行</a></li>
<li><a href="#packaging-executable-configuring-properties-launcher">4.4.5. 使用 <code>PropertiesLauncher</code></a></li>
<li><a href="#packaging-layered-jars">4.4.6. 打包分层的 Jars</a>
<ul class="sectlevel4">
<li><a href="#packaging-layers-configuration">自定义层的配置</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#build-image">5. 打包 OCI 镜像</a>
<ul class="sectlevel2">
<li><a href="#build-image-docker-daemon">5.1. Docker Daemon</a></li>
<li><a href="#build-image-docker-registry">5.2. Docker Registry</a></li>
<li><a href="#build-image-customization">5.3. 自定义镜像</a></li>
<li><a href="#build-image-examples">5.4. 示例</a>
<ul class="sectlevel3">
<li><a href="#build-image-example-custom-image-builder">5.4.1. Custom Image Builder and Run Image</a></li>
<li><a href="#build-image-example-builder-configuration">5.4.2. Builder Configuration</a></li>
<li><a href="#build-image-example-runtime-jvm-configuration">5.4.3. Runtime JVM Configuration</a></li>
<li><a href="#build-image-example-custom-image-name">5.4.4. 自定义镜像名称</a></li>
<li><a href="#build-image-example-publish">5.4.5. Image Publishing</a></li>
<li><a href="#build-image-example-docker">5.4.6. Docker 配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#publishing-your-application">6. 发布应用</a>
<ul class="sectlevel2">
<li><a href="#publishing-your-application-maven-publish">6.1. 使用 <code>maven-publish</code> 插件发布</a></li>
<li><a href="#publishing-your-application-maven">6.2. 使用 <code>maven</code> 插件发布应用</a></li>
<li><a href="#publishing-your-application-distribution">6.3. 使用 <code>application</code> 插件</a></li>
</ul>
</li>
<li><a href="#running-your-application">7. 使用 Gradle 运行程序</a>
<ul class="sectlevel2">
<li><a href="#running-your-application-passing-arguments">7.1. 将参数传递给您的应用程序</a></li>
<li><a href="#running-your-application-passing-system-properties">7.2. Passing System properties to your application</a></li>
<li><a href="#running-your-application-reloading-resources">7.3. 重加载资源</a></li>
</ul>
</li>
<li><a href="#integrating-with-actuator">8. 整合 Actuator</a>
<ul class="sectlevel2">
<li><a href="#integrating-with-actuator-build-info">8.1. 生成构建信息</a></li>
</ul>
</li>
<li><a href="#reacting-to-other-plugins">9. 其他插件行为</a>
<ul class="sectlevel2">
<li><a href="#reacting-to-other-plugins-java">9.1. Java 插件行为</a></li>
<li><a href="#reacting-to-other-plugins-kotlin">9.2. Kotlin 插件行为</a></li>
<li><a href="#reacting-to-other-plugins-war">9.3. war 插件行为</a></li>
<li><a href="#reacting-to-other-plugins-dependency-management">9.4. 依赖管理插件行为</a></li>
<li><a href="#reacting-to-other-plugins-application">9.5. application 插件行为</a></li>
<li><a href="#reacting-to-other-plugins-maven">9.6. Maven 插件行为</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="introduction"><a class="anchor" href="#introduction"></a>1. 简介</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot Gradle 插件在 <a href="https://gradle.org">Gradle</a> 中提供 Spring Boot 支持, 允许您打包可执行的 jar 或 war 文件, 运行 Spring Boot 应用程序, 并使用  <code>spring-boot-dependencies</code> 提供的依赖管理.
Spring Boot 的 Gradle 插件需要 6 (6.3 更高版本) (支持 Gradle 5.6 版本, 但在未来会移除) 的 Gradle.
当使用 Gradle 6.7 或更高版本时, 支持 Gradle 的  <a href="https://docs.gradle.org/current/userguide/configuration_cache.html">configuration cache</a>.</p>
</div>
<div class="paragraph">
<p>除了此用户指南, 还提供了 <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api">API 文档</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>2. 入门</h2>
<div class="sectionbody">
<div class="paragraph">
<p>想要开始插件, 首先需要把下面的代码加入你的程序中</p>
</div>
<div class="paragraph">
<p>使用这个插件可以让减少项目的改动. 而且, 会检测其他插件的使用或者更新. 比如, 当应用了 java 插件, 会自动在构建时打包成可执行的 jar.
一个经典的 Spring Boot 项目至少会使用  <a href="https://docs.gradle.org/current/userguide/groovy_plugin.html"><code>groovy</code></a>, <a href="https://docs.gradle.org/current/userguide/java_plugin.html"><code>java</code></a> 或 <a href="https://kotlinlang.org/docs/reference/using-gradle.html"><code>org.jetbrains.kotlin.jvm</code></a> 和 <a href="https://github.com/spring-gradle-plugins/dependency-management-plugin"><code>io.spring.dependency-management</code></a> 插件</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">apply plugin: 'java'
apply plugin: 'io.spring.dependency-management'</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">plugins {
    java
    id("org.springframework.boot") version "2.4.5"
}

apply(plugin = "io.spring.dependency-management")</code></pre>
</div>
</div>
<div class="paragraph">
<p>在使用其他插件的时候, Spring Boot 插件会有怎样的行为?
要了解有关在应用其他插件时 Spring Boot 插件的行为的更多信息, 请参见 <a href="#reacting-to-other-plugins">reacting to other plugins</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="managing-dependencies"><a class="anchor" href="#managing-dependencies"></a>3. 依赖管理</h2>
<div class="sectionbody">
<div class="paragraph">
<p>要管理 Spring Boot 应用程序中的依赖关系,可以应用 <code>io.spring.dependency-management</code> 插件,或者,如果您使用的是 Gradle 6 或更高版本,请使用 Gradle 的本地 bom 支持. 前者的主要优点是它提供了基于属性的托管版本的的自定义,而使用后者则会加快构建速度.</p>
</div>
<div class="sect2">
<h3 id="managing-dependencies-dependency-management-plugin"><a class="anchor" href="#managing-dependencies-dependency-management-plugin"></a>3.1. Managing Dependencies with the Dependency Management Plugin</h3>
<div class="paragraph">
<p>当使用了  <a href="https://github.com/spring-gradle-plugins/dependency-management-plugin"><code>io.spring.dependency-management</code></a> 插件, Spring Boot 的插件会自动地从你使用的 Spring Boot 版本里导入 <a href="#reacting-to-other-plugins-dependency-management">import the <code>spring-boot-dependencies</code> bom</a>.
Maven用户使用起来感觉区别不大. 比如, 允许你在声明依赖的时候忽略掉版本号, 使用这项功能, 只需要正常的声明依赖, 不用写版本号就可以了.</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation('org.springframework.boot:spring-boot-starter-web')
    implementation('org.springframework.boot:spring-boot-starter-data-jpa')
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="managing-dependencies-dependency-management-plugin-customizing"><a class="anchor" href="#managing-dependencies-dependency-management-plugin-customizing"></a>3.2. 自定义管理版本号</h3>
<div class="paragraph">
<p>当应用了依赖管理插件, <code>spring-boot-dependencies</code> bom 会被自动导入, 使用属性控制它管理的依赖的版本号. 点击  <a href="https://github.com/spring-projects/spring-boot/tree/{github-tag}/spring-boot-project/spring-boot-dependencies/pom.xml">bom</a> 查看完整的属性列表.</p>
</div>
<div class="paragraph">
<p>如果要自定义管理版本, 设置它的扩展属性. 比如, 自定义被管理的 SLF4J 的版本号, 设置  <code>slf4j.version</code>  属性:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">ext['slf4j.version'] = '1.7.20'</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">extra["slf4j.version"] = "1.7.20"</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
每个 Spring Boot 版本都与制定的第三方依赖设计和测试好了. 覆盖版本可能会造成兼容问题, 所以自定义的时候小心一点
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="managing-dependencies-dependency-management-plugin-using-in-isolation"><a class="anchor" href="#managing-dependencies-dependency-management-plugin-using-in-isolation"></a>3.3. 单独使用 Spring Boot 的依赖管理</h3>
<div class="paragraph">
<p>我们不用将 Spring Boot 的插件应用于项目, 也可以在项目中使用 Spring Boot 的依赖管理.  <code>SpringBootPlugin</code> 类提供一个 <code>BOM_COORDINATES</code> 常量, 可用于导入 Bom, 而不必知道其 artifact ID, group ID 或 version 号.</p>
</div>
<div class="paragraph">
<p>首先, 将项目配置为依赖于 Spring Boot 插件, 但不要应用它:</p>
</div>
<div class="paragraph">
<p>Spring Boot 插件对依赖管理插件的依赖意味着您可以使用依赖管理插件而不必声明对它的依赖.  这也意味着您将自动使用与 Spring Boot 使用的版本相同的依赖管理插件.</p>
</div>
<div class="paragraph">
<p>应用依赖管理插件, 然后将其配置为导入 Spring Boot 的 Bom:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">apply plugin: 'io.spring.dependency-management'

dependencyManagement {
    imports {
        mavenBom org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">apply(plugin = "io.spring.dependency-management")

the&lt;DependencyManagementExtension&gt;().apply {
    imports {
        mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的Kotlin代码有点尴尬.  那是因为我们使用命令式方式来应用依赖管理插件.</p>
</div>
<div class="paragraph">
<p>我们可以通过应用根父项目中的插件, 或者像在使用 Spring Boot 插件一样使用 <code>plugins</code> 块, 来减少代码的尴尬.  该方法的缺点是它迫使我们指定依赖管理插件的版本:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">plugins {
    java
    id("org.springframework.boot") version "2.4.5" apply false
    id("io.spring.dependency-management") version "{dependency-management-plugin-version}"
}

dependencyManagement {
    imports {
        mavenBom(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="managing-dependencies-learning-more"><a class="anchor" href="#managing-dependencies-learning-more"></a>3.4. 更多</h3>
<div class="paragraph">
<p>要了解有关依赖管理插件功能的更多信息, 请参阅其  <a href="https://github.com/spring-gradle-plugins/dependency-management-plugin/blob/master/README.md">documentation</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="managing-dependencies-gradle-bom-support"><a class="anchor" href="#managing-dependencies-gradle-bom-support"></a>3.5. 使用 Gradle 的 Bom 支持依赖管理</h3>
<div class="paragraph">
<p>Gradle 通过将 Bom 声明为  <code>platform</code> 或  <code>enforcedPlatform</code> 依赖,可用于管理项目的版本. <code>platform</code> 依赖将 bom 中的版本视为推荐版本,这可能会导致项目中的其他版本或者依赖关系中的其他版本与此 bom 声明的版本不同. <code>enforcedPlatform</code> 依赖将 bom 中的版本视为要求,它们将覆盖依赖关系中找到的任何其他版本.</p>
</div>
<div class="paragraph">
<p><code>SpringBootPlugin</code> 类提供 <code>BOM_COORDINATES</code> 常量,可用于声明对 Spring Boot 的 bom 的依赖关系,而不必知道其 group ID, artifact ID 或 version,如以下示例所示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation platform(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES)
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation(platform(org.springframework.boot.gradle.plugin.SpringBootPlugin.BOM_COORDINATES))
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>platform 或 enforced platform 将只在声明它的配置中具有约束性,或者在声明它的配置的扩展的地址.因此,可能需要在多个配置中声明相同的依赖.</p>
</div>
<div class="sect3">
<h4 id="managing-dependencies-gradle-bom-support-customizing"><a class="anchor" href="#managing-dependencies-gradle-bom-support-customizing"></a>3.5.1. 自定义版本管理</h4>
<div class="paragraph">
<p>使用 Gradle 的 bom 支持时,您不能使用 <code>spring-boot-dependencies</code> 中的属性来控制它管理的依赖的版本. 相反,您必须使用 Gradle 提供的一种机制. 一种这样的机制是解决策略. SLF4J 的模块全部在 <code>org.slf4j</code> 组中,因此可以通过将该组中的每个依赖配置为使用特定版本来控制其版本,如以下示例所示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">configurations.all {
    resolutionStrategy.eachDependency { DependencyResolveDetails details -&gt;
        if (details.requested.group == 'org.slf4j') {
            details.useVersion '1.7.20'
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">configurations.all {
    resolutionStrategy.eachDependency {
        if (requested.group == "org.slf4j") {
            useVersion("1.7.20")
        }
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
每个 Spring Boot 版本都是针对一组特定的第三方依赖进行设计和测试的.覆盖版本可能会引起兼容性问题,因此应格外小心.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="packaging-executable"><a class="anchor" href="#packaging-executable"></a>4. 打包可执行文件</h2>
<div class="sectionbody">
<div class="paragraph">
<p>插件可以创建可执行文件( jar 文件或者 war 文件), 里面包含所有应用的依赖并且可以使用 <code>java -jar</code> 执行.</p>
</div>
<div class="sect2">
<h3 id="packaging-executable-jars"><a class="anchor" href="#packaging-executable-jars"></a>4.1. 打包可执行 jars</h3>
<div class="paragraph">
<p>可以使用 <code>bootJar</code> 任务构建可执行的 jars. 如果应用了 java 插件, 这个任务会自动的创建, 并且是 <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootJar.html"><code>BootJar</code></a> 的实例. <code>assemble</code> 任务会自动配置依赖于 <code>bootJar</code> 任务, 所以运行 <code>assemble</code> (or <code>build</code>)  也会运行 <code>bootJar</code> 任务.</p>
</div>
</div>
<div class="sect2">
<h3 id="packaging-executable-wars"><a class="anchor" href="#packaging-executable-wars"></a>4.2. 打包可执行 wars</h3>
<div class="paragraph">
<p>可以使用 <code>bootWar</code> 任务构建可执行的 wars.如果应用了 <code>war</code> 插件,  这个任务会自动的创建, 并且是 <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootWar.html"><code>BootWar</code></a> 的实例. <code>assemble</code> 任务会自动配置依赖于 <code>bootWar</code> 任务, 所以运行 <code>assemble</code> (or <code>build</code>)  也会运行 <code>bootWar</code> 任务.</p>
</div>
<div class="sect3">
<h4 id="packaging-executable-wars-deployable"><a class="anchor" href="#packaging-executable-wars-deployable"></a>4.2.1. 打包可执行和可部署的 wars</h4>
<div class="paragraph">
<p>可以打包 war 文件, 以便可以使用 <code>java -jar</code> 执行该文件并将其部署到外部容器中.  为此, 应将嵌入式 Servlet 容器依赖添加到提供的 Runtime 配置中, 例如:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    implementation('org.springframework.boot:spring-boot-starter-web')
    providedRuntime('org.springframework.boot:spring-boot-starter-tomcat')
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    providedRuntime("org.springframework.boot:spring-boot-starter-tomcat")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样可以确保在打包后的 war 文件中的 <code>WEB-INF/lib-provided</code> 提供的目录中不会与外部容器自己的类冲突.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>providedRuntime</code> 优先于 Gradle 的  <code>compileOnly</code> 配置, 因为除其他限制外, compileOnly 依赖不在测试类路径上, 因此任何基于 Web 的集成测试都将失败.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="packaging-executable-and-normal"><a class="anchor" href="#packaging-executable-and-normal"></a>4.3. 打包可执行和普通文件</h3>
<div class="paragraph">
<p>默认的, 当 <code>bootJar</code> 或者 <code>bootWar</code> 任务配置了, <code>jar</code> 或者 <code>war</code> 任务会被禁用掉. 但是可以同时构建一个可执行和普通的文件通过设置 <code>jar</code> 或者 <code>war</code> 任务可用</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">jar {
    enabled = true
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;Jar&gt;("jar") {
    enabled = true
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了避免可执行文件和普通文件生成在同一个目录, 其中一个应该使用不同的位置. 一种方法就是配置一个 classifier:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootJar {
    classifier = 'boot'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
    classifier = "boot"
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="packaging-executable-configuring"><a class="anchor" href="#packaging-executable-configuring"></a>4.4. 配置可执行文件打包</h3>
<div class="paragraph">
<p>BootJar 和 BootWar</p>
</div>
<div class="paragraph">
<p><a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootJar.html"><code>BootJar</code></a> 和 <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootWar.html"><code>BootWar</code></a> 任务分别是 Gradle 的 <code>jar</code> 或者 <code>war</code> 任务的子类. 所以, 所有的在打包 <code>jar</code> 或者 <code>war</code> 时用的标准配置都对可执行的 <code>jar</code> 或者 <code>war</code> 可用.
当然也有对可执行 jars 或者 wars 的特殊配置.</p>
</div>
<div class="sect3">
<h4 id="packaging-executable-configuring-main-class"><a class="anchor" href="#packaging-executable-configuring-main-class"></a>4.4.1. 配置主类</h4>
<div class="paragraph">
<p>默认的, 可执行文件的主类会自动的在任务的类路径目录里查找一个带有 <code>public static void main(String[])</code> 的方法. 主类也可以显示的使用 <code>mainClass</code> 设置:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootJar {
    mainClass = 'com.example.ExampleApplication'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
    mainClass.set("com.example.ExampleApplication")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者, 可以使用 Spring Boot DSL 的 <code>mainClass</code> 属性在项目范围内配置主类名称:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">springBoot {
    mainClass = 'com.example.ExampleApplication'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">springBoot {
    mainClass.set("com.example.ExampleApplication")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 如果应用了 <a href="https://docs.gradle.org/current/userguide/application_plugin.html"><code>application</code> plugin</a> 可以这么设置 <code>mainClass</code> 属性:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">application {
    mainClass = 'com.example.ExampleApplication'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">application {
    mainClass.set("com.example.ExampleApplication")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后, <code>Start-Class</code> 属性可以在任务的 manifest 里配置:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootJar {
    manifest {
        attributes 'Start-Class': 'com.example.ExampleApplication'
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
    manifest {
        attributes("Start-Class" to "com.example.ExampleApplication")
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果主类是用 Kotlin 编写的,则应使用生成的 Java 类的名称. 默认情况下,这是添加了 <code>Kt</code> 后缀的 Kotlin 类的名称. 例如,<code>ExampleApplication</code> <code>变为ExampleApplicationKt</code>. 如果使用 <code>@JvmName</code> 定义了另一个名称,则应使用该名称.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="packaging-executable-configuring-including-development-only-dependencies"><a class="anchor" href="#packaging-executable-configuring-including-development-only-dependencies"></a>4.4.2. Including Development-only Dependencies</h4>
<div class="paragraph">
<p>默认情况下,<code>developmentOnly</code> 配置中声明的所有依赖将从可执行 jar 或 war 中排除.</p>
</div>
<div class="paragraph">
<p>如果要在归档中包括在 <code>developmentOnly</code> 配置中声明的依赖,请配置其任务的类路径以包括该配置,如 <code>bootWar</code> 任务的以下示例所示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootWar {
    classpath configurations.developmentOnly
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootWar&gt;("bootWar") {
    classpath(configurations["developmentOnly"])
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="packaging-executable-configuring-unpacking"><a class="anchor" href="#packaging-executable-configuring-unpacking"></a>4.4.3. 配置需要移除的库</h4>
<div class="paragraph">
<p>大多数库可以直接嵌套进可执行的文件里, 但是某些库可能有问题. 比如,JRuby 引入了它自己的内嵌 jar 支持, 比如 <code>jruby-complete.jar</code> 总是直接在文件系统上可用.</p>
</div>
<div class="paragraph">
<p>处理这个问题库, 可执行文件可以配置在运行(run)的时候移除指定的嵌套 jars 到临时目录. 库可以使用 Ant-style 模式匹配源 jar 文件的绝对路径移除需要的包:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootJar {
    requiresUnpack '**/jruby-complete-*.jar'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
    requiresUnpack("**/jruby-complete-*.jar")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了更好地控制, 也可以使用 closure.  该 closure 传递了一个 <code>FileTreeElement</code>, 并且应返回一个 <code>boolean</code>, 指示是否需要打包.</p>
</div>
</div>
<div class="sect3">
<h4 id="packaging-executable-configuring-launch-script"><a class="anchor" href="#packaging-executable-configuring-launch-script"></a>4.4.4. 让文件完全可执行</h4>
<div class="paragraph">
<p>Spring Boot 对完全可执行文件提供支持. 通过已知的如何启动应用的预 shell 脚步来制造完全可执行. 在类 Unix 平台上, 这个启动脚本运行文件可以像任何可执行文件直接运行或者作为服务安装.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当前,某些工具不接受此格式,因此您可能无法始终使用此技术. 例如,<code>jar -xf</code> 可能在无提示的情况下无法提取出已成为完全可执行的 jar 或 war. 建议仅在打算直接执行此选项时才启用此选项,而不是使用 <code>java -jar</code> 运行它,将其部署到 servlet 容器或将其包含在 OCI 镜像中.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>启用这个特性, launchScript 必须启用:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootJar {
    launchScript()
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
    launchScript()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将添加 Spring Boot 的默认脚本到文件里. 默认的启动脚本包含若干个属性并且设置了合适的默认值, 当然也可以通过 <code>properties</code> 属性自定义默认值:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootJar {
    launchScript {
        properties 'logFilename': 'example-app.log'
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
    launchScript {
        properties(mapOf("logFilename" to "example-app.log"))
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果启动脚本没有你想要的, <code>script</code> 属性可以提供一个自定义的启动脚本:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootJar {
    launchScript {
        script = file('src/custom.script')
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
    launchScript {
        script = file("src/custom.script")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="packaging-executable-configuring-properties-launcher"><a class="anchor" href="#packaging-executable-configuring-properties-launcher"></a>4.4.5. 使用 <code>PropertiesLauncher</code></h4>
<div class="paragraph">
<p>要想使用 <code>PropertiesLauncher</code> 启动可执行 jar 或者 war, 配置任务的 manifest 来设置 <code>Main-Class</code> 属性:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootWar {
    manifest {
        attributes 'Main-Class': 'org.springframework.boot.loader.PropertiesLauncher'
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootWar&gt;("bootWar") {
    manifest {
        attributes("Main-Class" to "org.springframework.boot.loader.PropertiesLauncher")
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="packaging-layered-jars"><a class="anchor" href="#packaging-layered-jars"></a>4.4.6. 打包分层的 Jars</h4>
<div class="paragraph">
<p>默认情况下,<code>bootJar</code>  任务会构建一个 archive 文件,其中包含应用程序的类和依赖关系,分别位于 <code>BOOT-INF/classes</code> 和 <code>BOOT-INF/lib</code> 中. 对于需要从 jar 的内容中构建 docker 镜像的情况,能够进一步分隔这些目录以便将它们写入不同的层中很有用.</p>
</div>
<div class="paragraph">
<p>分层的 jar 使用与常规重新打包的 jar 相同的布局,但是包括了描述每个层的附加元数据文件. 要使用此功能,必须启用分层功能:</p>
</div>
<div class="paragraph">
<p>默认情况下,定义了以下层:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>dependencies</code>:  包含所有的依赖,但不包括 <code>SNAPSHOT</code> 版本的依赖.</p>
</li>
<li>
<p><code>spring-boot-loader</code>:  用于加载 jar.</p>
</li>
<li>
<p><code>snapshot-dependencies</code>:  包含所有的 <code>SNAPSHOT</code> 版本依赖 .</p>
</li>
<li>
<p><code>application</code>:  应用程序类和资源.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>层的顺序很重要,因为它确定了部分应用程序更改时可以缓存先前的层的可能性. 默认顺序是 <code>dependencies</code>, <code>spring-boot-loader</code>, <code>snapshot-dependencies</code>, <code>application</code>. 应该首先添加最不可能更改的内容,然后添加有可能更改的层.</p>
</div>
<div class="paragraph">
<p>要禁用此功能, 您可以通过以下方式执行此操作:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootJar {
    layered {
        enabled = false
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
    layered {
        isEnabled = false
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建分层 jar 时,<code>spring-boot-jarmode-layertools</code> jar 将作为依赖添加到 jar 中. 将此 jar 放在类路径上,您可以在特殊模式下启动应用程序,该模式允许引导代码运行与您的应用程序完全不同的内容,例如,提取层的内容. 如果要排除此依赖关系,可以按以下方式进行:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootJar {
    layered {
        includeLayerTools = false
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
    layered {
        isIncludeLayerTools = false
    }
}</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="packaging-layers-configuration"><a class="anchor" href="#packaging-layers-configuration"></a>自定义层的配置</h5>
<div class="paragraph">
<p>根据您的应用程序,您可能想要调整层的创建方式和添加新层的方式.</p>
</div>
<div class="paragraph">
<p>这可以通过使用配置来完成,该配置描述了如何将 jar 分为几层,以及这些层的顺序.下面的示例显示如何显式定义上述默认顺序:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootJar {
    layered {
        application {
            intoLayer("spring-boot-loader") {
                include "org/springframework/boot/loader/**"
            }
            intoLayer("application")
        }
        dependencies {
            intoLayer("application") {
                includeProjectDependencies()
            }
            intoLayer("snapshot-dependencies") {
                include "*:*:*SNAPSHOT"
            }
            intoLayer("dependencies")
        }
        layerOrder = ["dependencies", "spring-boot-loader", "snapshot-dependencies", "application"]
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootJar&gt;("bootJar") {
    layered {
        application {
            intoLayer("spring-boot-loader") {
                include("org/springframework/boot/loader/**")
            }
            intoLayer("application")
        }
        dependencies {
            intoLayer("snapshot-dependencies") {
                include("*:*:*SNAPSHOT")
            }
            intoLayer("dependencies")
        }
        layerOrder = listOf("dependencies", "spring-boot-loader", "snapshot-dependencies", "application")
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>layered</code> DSL 包含三部分:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;application&gt;</code> 定义应如何对应用程序类和资源进行分层.</p>
</li>
<li>
<p><code>&lt;dependencies&gt;</code> 定义应层之间的依赖关系.</p>
</li>
<li>
<p><code>&lt;layerOrder&gt;</code> 定义应写入层的顺序.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>嵌套的 <code>intoLayer</code> 用于 <code>application</code> 和 <code>dependencies</code> 中,以声明层的内容. 从上到下,按照定义的顺序评估. 较早的块未声明的任何内容仍然可供后续块使用.</p>
</div>
<div class="paragraph">
<p><code>intoLayer</code> 块使用嵌套的 <code>include</code> 和 <code>exclude</code> 元素声明内容. <code>application</code> 对 include/exclude  表达式使用 Ant 风格的匹配模式. <code>dependencies</code> 使用 <code>group:artifact[:version]</code> 模式.它还提供了 <code>includeProjectDependencies()</code> 和 <code>excludeProjectDependencies()</code> 元素, 可以用来包含或排除项目依赖.</p>
</div>
<div class="paragraph">
<p>如果未定义 <code>include</code>,则将考虑所有内容 (较早的块未声明) .</p>
</div>
<div class="paragraph">
<p>如果未定义 <code>exclude</code>,则不应用任何排除项.</p>
</div>
<div class="paragraph">
<p>查看上面的 <code>dependencies</code> 示例,我们可以看到第一个 <code>intoLayer</code> 将声明所有的项目依赖, 第二个 <code>intoLayer</code> 将声明上又有 <code>snapshot-dependencies</code> 层的 SNAPSHOT 依赖. 最后的 <code>intoLayer</code> 将声明 <code>dependencies</code> 层的所有剩余内容 (在这种情况下,不是 项目 或 SNAPSHOT 的任何依赖) .</p>
</div>
<div class="paragraph">
<p><code>application</code> 块具有相似的规则. 首先声明 <code>spring-boot-loader</code> 层的 <code>org/springframework/boot/loader/**</code>  内容. 然后为 <code>application</code> 层声明所有剩余的类和资源.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>intoLayer</code> 块的定义顺序通常与层的写入顺序不同. 因此,必须始终包含 <code>layerOrder</code> 元素,并且必须覆盖 <code>intoLayer</code> 块引用的所有层.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="build-image"><a class="anchor" href="#build-image"></a>5. 打包 OCI 镜像</h2>
<div class="sectionbody">
<div class="paragraph">
<p>该插件可以使用 <a href="https://buildpacks.io">Cloud Native Buildpacks</a> (CNB) 从可执行 jar 文件创建 <a href="https://github.com/opencontainers/image-spec">OCI image</a>.可以使用 <code>bootBuildImage</code> 任务来构建镜像.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
出于安全原因,镜像以非 root 用户身份构建和运行.有关更多详细信息,请参见 <a href="https://buildpacks.io/docs/reference/spec/platform-api/#users">CNB specification</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>应用 <code>Java</code> 插件时,该任务会自动创建,并且是 <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootBuildImage.html"><code>BootBuildImage</code></a> 的实例.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>bootBuildImage</code> 任务不支持 <a href="#packaging-executable-wars">打包成 war</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>bootBuildImage</code> 任务不能与包含启动脚本的 <a href="#packaging-executable-configuring-launch-script">fully executable Spring Boot archive</a> 一起使用.在构建旨在与 bootBuildImage 一起使用的 jar 文件时,请在 <code>bootJar</code> 任务中禁用启动脚本配置.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="build-image-docker-daemon"><a class="anchor" href="#build-image-docker-daemon"></a>5.1. Docker Daemon</h3>
<div class="paragraph">
<p><code>bootBuildImage</code> 任务需要访问 Docker 守护程序. 默认情况下,它将通过本地连接与 Docker 守护程序通信. 无需配置即可在所有支持的平台上使用 <a href="https://docs.docker.com/install/">Docker Engine</a>.</p>
</div>
<div class="paragraph">
<p>可以设置环境变量以将 <code>bootBuildImage</code> 任务配置为使用 <a href="https://minikube.sigs.k8s.io/docs/tasks/docker_daemon/">minikube 提供的 Docker 守护程序</a> . 下表显示了环境变量及其值:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Environment variable</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOCKER_HOST</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URL containing the host and port for the Docker daemon - e.g. <code>tcp://192.168.99.100:2376</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOCKER_TLS_VERIFY</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enable secure HTTPS protocol when set to <code>1</code> (optional)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DOCKER_CERT_PATH</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Path to certificate and key files for HTTPS (required if <code>DOCKER_TLS_VERIFY=1</code>, ignored otherwise)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在 Linux 和 macOS 上,启动 minikube 之后,可以使用命令 <code>eval $(minikube docker-env)</code> 设置这些环境变量.</p>
</div>
<div class="paragraph">
<p>也可以使用插件配置中的 <code>docker</code> 参数提供 Docker 守护进程连接信息. 下表汇总了可用参数:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>host</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Docker daemon 主机和端口 URL  - e.g. <code>tcp://192.168.99.100:2376</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>tlsVerify</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当设置为 <code>true</code> 时,开启 HTTPS 协议(可选)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>certPath</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HTTPS 的证书和密钥文件的路径 (如果 <code>tlsVerify</code> 为 <code>true</code> 则需要, 否则将忽略)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>更多信息, 请查看 <a href="#build-image-example-docker">examples</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="build-image-docker-registry"><a class="anchor" href="#build-image-docker-registry"></a>5.2. Docker Registry</h3>
<div class="paragraph">
<p>如果由 <code>builder</code> 或 <code>runImage</code> 参数指定的 Docker 镜像存储在需要身份验证的私有 Docker image registry  中, 可以使用  <code>docker.builderRegistry</code> 参数提供身份验证凭据.</p>
</div>
<div class="paragraph">
<p>如果生成的 Docker 镜像要发布到  Docker image registry 中, 可以使用 <code>docker.publishRegistry</code>  参数提供身份验证凭据.</p>
</div>
<div class="paragraph">
<p>为用户身份验证或身份令牌验证提供了参数. 关于支持的身份验证方法的更多信息, 请参考 Docker registry 的文档.</p>
</div>
<div class="paragraph">
<p>下表总结了 <code>docker.builderRegistry</code> 和 <code>docker.publishRegistry</code> 的可用参数:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>username</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Username for the Docker image registry user. Required for user authentication.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>password</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Password for the Docker image registry user. Required for user authentication.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>url</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Address of the Docker image registry. Optional for user authentication.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>email</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">E-mail address for the Docker image registry user. Optional for user authentication.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>token</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Identity token for the Docker image registry user. Required for token authentication.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>更多信息, 请查看 <a href="#build-image-example-docker">examples</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="build-image-customization"><a class="anchor" href="#build-image-customization"></a>5.3. 自定义镜像</h3>
<div class="paragraph">
<p>该插件调用一个 <a href="https://buildpacks.io/docs/concepts/components/builder/">builder</a> 来协助镜像的生成. 该构建器包括多个  <a href="https://buildpacks.io/docs/concepts/components/buildpack">buildpacks</a>,可以检查应用程序以影响生成的镜像. 默认情况下,插件选择一个生成镜像. 生成的镜像名称是从项目属性推导出的.</p>
</div>
<div class="paragraph">
<p>任务属性可用于配置构建器应如何在项目上运行.下表总结了可用的属性及其默认值:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Command-line option</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Default value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>builder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>--builder</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the Builder image to use.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>paketobuildpacks/builder:base</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>runImage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>--runImage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the run image to use.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No default value, indicating the run image specified in Builder metadata should be used.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>imageName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>--imageName</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/api/org/springframework/boot/buildpack/platform/docker/type/ImageReference.html#of-java.lang.String-">Image name</a> for the generated image.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>docker.io/library/${project.name}:${project.version}</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pullPolicy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>--pullPolicy</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/api/org/springframework/boot/buildpack/platform/build/PullPolicy.html">Policy</a> used to determine when to pull the builder and run images from the registry.
Acceptable values are <code>ALWAYS</code>, <code>NEVER</code>, and <code>IF_NOT_PRESENT</code>.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ALWAYS</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>environment</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Environment variables that should be passed to the builder.</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cleanCache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>--cleanCache</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to clean the cache before building.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>verboseLogging</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Enables verbose logging of builder operations.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>publish</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>--publishImage</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Whether to publish the generated image to a Docker registry.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>false</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
该插件使用 JavaPlugin 的 <code>targetCompatibility</code> 属性检测目标项目的 Java 兼容性. 当使用默认的 Paketo 构建器和 buildpacks 时,插件会指示 buildpacks 安装相同的 Java 版本. 您可以覆盖此行为,如 <a href="#build-image-example-builder-configuration">builder configuration</a> 示例中所示.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="build-image-examples"><a class="anchor" href="#build-image-examples"></a>5.4. 示例</h3>
<div class="sect3">
<h4 id="build-image-example-custom-image-builder"><a class="anchor" href="#build-image-example-custom-image-builder"></a>5.4.1. Custom Image Builder and Run Image</h4>
<div class="paragraph">
<p>如果需要自定义用于创建镜像的构建器或用于启动生成的镜像的运行镜像,请配置任务,如以下示例所示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootBuildImage {
    builder = "mine/java-cnb-builder"
    runImage = "mine/java-cnb-run"
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootBuildImage&gt;("bootBuildImage") {
    builder = "mine/java-cnb-builder"
    runImage = "mine/java-cnb-run"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>此配置将使用名称为 <code>mine/java-cnb-builder</code> 的构建器镜像和最新的标签,以及名为 <code>mine/java-cnb-run</code> 的运行镜像和最新的标签.</p>
</div>
<div class="paragraph">
<p>生成器和运行镜像也可以在命令行上指定,如本示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle bootBuildImage --builder=mine/java-cnb-builder --runImage=mine/java-cnb-run</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="build-image-example-builder-configuration"><a class="anchor" href="#build-image-example-builder-configuration"></a>5.4.2. Builder Configuration</h4>
<div class="paragraph">
<p>如果构建器公开了配置选项,则可以使用环境属性进行设置.</p>
</div>
<div class="paragraph">
<p>以下是配置在构建时由 Paketo Java  <a href="https://paketo.io/docs/buildpacks/language-family-buildpacks/java/#configuring-the-jvm-version">configuring the JVM version</a> 的示例:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootBuildImage {
    environment = ["BP_JVM_VERSION" : "8.*"]
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootBuildImage&gt;("bootBuildImage") {
    environment = mapOf("BP_JVM_VERSION" to "8.*")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果构建器在其运行的 Docker 守护程序与构建打包下载 artifacts 的网络位置之间存在网络代理,则需要将构建器配置为使用代理. 使用 Paketo 构建器时,可以通过设置 <code>HTTPS_PROXY</code> 和/或 <code>HTTP_PROXY</code> 环境变量来实现,如以下示例所示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootBuildImage {
    environment = [
            "HTTP_PROXY" : "http://proxy.example.com",
            "HTTPS_PROXY": "https://proxy.example.com"
    ]
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootBuildImage&gt;("bootBuildImage") {
    environment = mapOf("HTTP_PROXY" to "http://proxy.example.com",
                        "HTTPS_PROXY" to "https://proxy.example.com")
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="build-image-example-runtime-jvm-configuration"><a class="anchor" href="#build-image-example-runtime-jvm-configuration"></a>5.4.3. Runtime JVM Configuration</h4>
<div class="paragraph">
<p>Paketo Java buildpacks 通过设置环境变量 <code>JAVA_TOOL_OPTIONS</code> 来 <a href="https://paketo.io/docs/buildpacks/language-family-buildpacks/java/#runtime-jvm-configuration">配置 JVM 运行时环境</a>.</p>
</div>
<div class="paragraph">
<p>当在容器中启动应用程序镜像时,  可以修改 buildpack 提供的 <code>JAVA_TOOL_OPTIONS</code> 值以自定义JVM运行时行为.</p>
</div>
<div class="paragraph">
<p>可以如 <a href="https://paketo.io/docs/buildpacks/configuration/#environment-variables">Paketo documentation</a> 中所述在镜像中配置并应用于每个部署的环境变量修改,  并在以下示例中显示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootBuildImage {
    environment = [
            "BPE_DELIM_JAVA_TOOL_OPTIONS" : " ",
            "BPE_APPEND_JAVA_TOOL_OPTIONS" : "-XX:+HeapDumpOnOutOfMemoryError"
    ]
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootBuildImage&gt;("bootBuildImage") {
    environment = mapOf(
        "BPE_DELIM_JAVA_TOOL_OPTIONS" to " ",
        "BPE_APPEND_JAVA_TOOL_OPTIONS" to "-XX:+HeapDumpOnOutOfMemoryError"
    )
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="build-image-example-custom-image-name"><a class="anchor" href="#build-image-example-custom-image-name"></a>5.4.4. 自定义镜像名称</h4>
<div class="paragraph">
<p>默认情况下,镜像名称是根据项目的  <code>name</code> 和  <code>version</code> 来推断的,例如 <code>docker.io/library/${project.name}:${project.version}</code>. 您可以通过设置任务属性来控制名称,如以下示例所示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootBuildImage {
    imageName = "example.com/library/${project.name}"
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootBuildImage&gt;("bootBuildImage") {
    imageName = "example.com/library/${project.name}"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意,此配置未提供明确的标记,因此使用了最新的标记. 也可以使用 <code>${project.version}</code>,构建中可用的任何属性或硬编码版本来指定标签.</p>
</div>
<div class="paragraph">
<p>镜像名称也可以在命令行上指定,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle bootBuildImage --imageName=example.com/library/my-app:v1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="build-image-example-publish"><a class="anchor" href="#build-image-example-publish"></a>5.4.5. Image Publishing</h4>
<div class="paragraph">
<p>生成的镜像可以发布到  Docker registry , 方法是启用  <code>publish</code>  选项并使用  <code>docker.publishRegistry</code> 配置 registry 的身份验证.</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootBuildImage {
    imageName = "docker.example.com/library/${project.name}"
    publish = true
    docker {
        publishRegistry {
            username = "user"
            password = "secret"
            url = "https://docker.example.com/v1/"
            email = "user@example.com"
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootBuildImage&gt;("bootBuildImage") {
    imageName = "docker.example.com/library/${project.name}"
    isPublish = true
    docker {
        publishRegistry {
            username = "user"
            password = "secret"
            url = "https://docker.example.com/v1/"
            email = "user@example.com"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>也可以在命令行上指定  <code>publish</code> 选项, 如下例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$ gradle bootBuildImage --imageName=docker.example.com/library/my-app:v1 --publishImage</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="build-image-example-docker"><a class="anchor" href="#build-image-example-docker"></a>5.4.6. Docker 配置</h4>
<div class="paragraph">
<p>如果你需要插件使用远程连接而不是默认的本地连接来与 Docker 守护进程通信, 可以使用  <code>docker</code>  属性提供连接细节, 如下所示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootBuildImage {
    docker {
        host = "tcp://192.168.99.100:2376"
        tlsVerify = true
        certPath = "/home/users/.minikube/certs"
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootBuildImage&gt;("bootBuildImage") {
    docker {
        host = "tcp://192.168.99.100:2376"
        isTlsVerify = true
        certPath = "/home/users/.minikube/certs"
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果构建器或运行镜像存储在支持用户身份验证的私有 Docker registry 中, 则可以使用 <code>docker.builderRegistry</code> 参数提供身份验证细节. 如下所示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootBuildImage {
    docker {
        builderRegistry {
            username = "user"
            password = "secret"
            url = "https://docker.example.com/v1/"
            email = "user@example.com"
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootBuildImage&gt;("bootBuildImage") {
    docker {
        builderRegistry {
            username = "user"
            password = "secret"
            url = "https://docker.example.com/v1/"
            email = "user@example.com"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果构建器或运行映像存储在支持令牌身份验证的私有 Docker registry  中, 则可以使用  <code>docker.builderRegistry</code> 参数提供令牌值. 如下所示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootBuildImage {
    docker {
        builderRegistry {
            token = "9cbaf023786cd7..."
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootBuildImage&gt;("bootBuildImage") {
    docker {
        builderRegistry {
            token = "9cbaf023786cd7..."
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="publishing-your-application"><a class="anchor" href="#publishing-your-application"></a>6. 发布应用</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="publishing-your-application-maven-publish"><a class="anchor" href="#publishing-your-application-maven-publish"></a>6.1. 使用 <code>maven-publish</code> 插件发布</h3>
<div class="paragraph">
<p>使用 <code>MavenPublication</code> 的 <code>artifact</code> 方法发布你的 Spring Boot jar 或者 war. 将任务传给到你想要发布的 <code>artifact</code> 方法上. 比如, 通过默认的 <code>bootJar</code> 任务发布 artifact:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">publishing {
    publications {
        bootJava(MavenPublication) {
            artifact bootJar
        }
    }
    repositories {
        maven {
            url 'https://repo.example.com'
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">publishing {
    publications {
        create&lt;MavenPublication&gt;("bootJava") {
            artifact(tasks.getByName("bootJar"))
        }
    }
    repositories {
        maven {
            url = uri("https://repo.example.com")
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="publishing-your-application-maven"><a class="anchor" href="#publishing-your-application-maven"></a>6.2. 使用 <code>maven</code> 插件发布应用</h3>
<div class="paragraph">
<p>应用了 <a href="https://docs.gradle.org/current/userguide/maven_plugin.html"><code>maven</code> plugin</a> ,将自动创建名为 <code>uploadBootArchives</code> 的 <code>bootArchives</code> 配置的 <code>Upload</code> 任务. 默认的, <code>bootArchives</code> 配置包含了 <code>bootJar</code> 或者 <code>bootWar</code> 任务产生文件.
<code>uploadBootArchives</code> 任务可以这么配置来发布到 Maven repository 里:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">uploadBootArchives {
    repositories {
        mavenDeployer {
            repository url: 'https://repo.example.com'
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;Upload&gt;("uploadBootArchives") {
    repositories.withGroovyBuilder {
        "mavenDeployer" {
            "repository"("url" to "https://repo.example.com")
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="publishing-your-application-distribution"><a class="anchor" href="#publishing-your-application-distribution"></a>6.3. 使用 <code>application</code> 插件</h3>
<div class="paragraph">
<p>当使用了 <a href="https://docs.gradle.org/current/userguide/application_plugin.html"><code>application</code> plugin</a> , 将创建一个名为 boot 的 distribution. 这个 distribution 包含了通过 <code>bootJar</code> 或者 <code>bootWar</code> 任务生成的文件和在 Unix 和 Windows 上启动的脚本.
可以分别通过 <code>bootDistZip</code> 和 <code>bootDistTar</code> 任务来构建 Zip 和 tar distributions.  要使用 <code>application</code> 插件, 必须使用应用程序主类的名称配置其 <code>mainClassName</code> 属性.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="running-your-application"><a class="anchor" href="#running-your-application"></a>7. 使用 Gradle 运行程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>使用 <code>bootRun</code> 任务来运行程序, 不需要产生文件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ ./gradlew bootRun</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>bootRun</code> 任务是 JavaExec 子类的 <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/run/BootRun.html"><code>BootRun</code></a> 的实例. 所以, 所有的 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.tasks.JavaExec.html">usual configuration options</a> 在 Gradle 里执行 Java 处理都可用.
任务会使用主源文件的运行期类路径自动配置.</p>
</div>
<div class="paragraph">
<p>默认的, 通过查找任务的类路径下的 <code>public static void main(String[])</code> 会自动配置.</p>
</div>
<div class="paragraph">
<p>主类也可以显示的配置:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootRun {
    main = 'com.example.ExampleApplication'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootRun&gt;("bootRun") {
    main = "com.example.ExampleApplication"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者, 可以使用 Spring Boot DSL 的 <code>mainClass</code> 属性在项目范围内配置主类名称:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">springBoot {
    mainClass = 'com.example.ExampleApplication'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">springBoot {
    mainClass.set("com.example.ExampleApplication")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下, <code>bootRun</code> 将配置 JVM 以优化其启动, 以在开发过程中加快启动速度.  可以通过使用 <code>optimizedLaunch</code> 属性来禁用此行为, 如以下示例所示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootRun {
    optimizedLaunch = false
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootRun&gt;("bootRun") {
    isOptimizedLaunch = false
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外, 如果使用了 <a href="https://docs.gradle.org/current/userguide/application_plugin.html"><code>application</code> plugin</a>, <code>mainClass</code> 项目属性可以被使用:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">application {
    mainClass = 'com.example.ExampleApplication'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">application {
    mainClass.set("com.example.ExampleApplication")
}</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="running-your-application-passing-arguments"><a class="anchor" href="#running-your-application-passing-arguments"></a>7.1. 将参数传递给您的应用程序</h3>
<div class="paragraph">
<p>与所有 <code>JavaExec</code> 任务一样, 在使用 Gradle 4.9 或更高版本时, 可以使用 <code>--args='&lt;arguments&gt;'</code> 从命令行将参数传递到 <code>bootRun</code> 中.  例如, 要使用名为 <code>dev</code> 环境运行您的应用程序, 可以使用以下命令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ ./gradlew bootRun --args='--spring.profiles.active=dev'</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息, 请参见 <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/JavaExec.html#setArgsString-java.lang.String-"><code>JavaExec.setArgsString</code> 的 javadoc</a></p>
</div>
</div>
<div class="sect2">
<h3 id="running-your-application-passing-system-properties"><a class="anchor" href="#running-your-application-passing-system-properties"></a>7.2. Passing System properties to your application</h3>
<div class="paragraph">
<p>由于 bootRun 是标准的 JavaExec 任务,因此可以通过在构建脚本中指定系统属性来将它们传递给应用程序的 JVM.
要使系统属性的值可配置,请使用  <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#N14FE1">project property</a> 设置其值. 若要使项目属性为可选,请使用 <code>findProperty</code> . 这样做还允许使用 <code>?:</code>  运算符提供默认值,如以下示例所示:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootRun {
    systemProperty 'com.example.property', findProperty('example') ?: 'default'
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootRun&gt;("bootRun") {
    systemProperty("com.example.property", findProperty("example") ?: "default")
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例将 <code>com.example.property</code> 系统属性设置为 example 属性的值. 如果未设置 example 属性,则系统属性的值为默认值.</p>
</div>
<div class="paragraph">
<p>Gradle 允许以多种方式设置项目属性,可以使用 <code>-P</code> 标志将这些值参数化并作为命令行上的属性传递.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ ./gradlew bootRun -Pexample=custom</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例将 example 属性的值设置为 <code>custom</code>.然后,<code>bootRun</code> 将使用它作为 <code>com.example.property</code> 系统属性的值.</p>
</div>
</div>
<div class="sect2">
<h3 id="running-your-application-reloading-resources"><a class="anchor" href="#running-your-application-reloading-resources"></a>7.3. 重加载资源</h3>
<div class="paragraph">
<p>如果项目里加入了 devtools, 它会自动的监控你的程序变化. 另外, 如果你配置了 <code>bootRun</code> 比如静态资源, 应用程序的静态资源会从源位置被加载:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">bootRun {
    sourceResources sourceSets.main
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">tasks.getByName&lt;BootRun&gt;("bootRun") {
    sourceResources(sourceSets["main"])
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这在开发时很有用.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="integrating-with-actuator"><a class="anchor" href="#integrating-with-actuator"></a>8. 整合 Actuator</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="integrating-with-actuator-build-info"><a class="anchor" href="#integrating-with-actuator-build-info"></a>8.1. 生成构建信息</h3>
<div class="paragraph">
<p>Spring Boot Actuator 的 <code>info</code> endpoint 自动发布 <code>META-INF/build-info.properties</code> 文件里的信息. <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/buildinfo/BuildInfo.html"><code>BuildInfo</code></a> 任务可以用来生成这个文件. 最简单的方式是通过插件的 DSL 使用任务:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">springBoot {
    buildInfo()
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">springBoot {
    buildInfo()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>这会配置一个  bootBuildInfo  的任务  <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/buildinfo/BuildInfo.html"><code>BuildInfo</code></a>, 并且如果他存在, 会让 Java 插件的 <code>classes</code> 任务基于它. 任务的目标目录将会是 <code>META-INF</code> 在主源设置的资源的输出目录(通常是 <code>build/resources/main</code>).</p>
</div>
<div class="paragraph">
<p>默认的, 生成的信息是从项目里扩展 出来的:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Property</th>
<th class="tableblock halign-left valign-top">Default value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>build.artifact</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bootJar</code> 或者 <code>bootWar</code> 任务的 base name, 如果没有就是 <code>unspecified</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>build.group</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The group of the project</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>build.name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The name of the project</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>build.version</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The version of the project</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>build.time</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The time at which the project is being built</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可以使用 DSL 自定义属性:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">springBoot {
    buildInfo {
        properties {
            artifact = 'example-app'
            version = '1.2.3'
            group = 'com.example'
            name = 'Example application'
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">springBoot {
    buildInfo {
        properties {
            artifact = "example-app"
            version = "1.2.3"
            group = "com.example"
            name = "Example application"
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>build.time</code> 的默认值为构建项目的瞬间.  这样做的副作用是该任务永远不会是最新的.  结果, 构建将花费更长的时间, 因为必须执行更多的任务, 包括项目的测试.
另一个副作用是任务的输出将始终更改, 因此构建将不会真正可重复.  如果您对构建性能或可重复性的重视程度高于 <code>build.time</code> 属性的准确性, 则将 <code>time</code> 设置为 <code>null</code> 或固定值.</p>
</div>
<div class="paragraph">
<p>可以添加额外的构建信息:</p>
</div>
<div class="listingblock primary">
<div class="title">Groovy</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">springBoot {
    buildInfo {
        properties {
            additional = [
                'a': 'alpha',
                'b': 'bravo'
            ]
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">springBoot {
    buildInfo {
        properties {
            additional = mapOf(
                "a" to "alpha",
                "b" to "bravo"
            )
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reacting-to-other-plugins"><a class="anchor" href="#reacting-to-other-plugins"></a>9. 其他插件行为</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当应用另一个插件时，Spring Boot 插件会通过对项目配置进行各种更改来做出反应。本节介绍这些更改.</p>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-java"><a class="anchor" href="#reacting-to-other-plugins-java"></a>9.1. Java 插件行为</h3>
<div class="paragraph">
<p>当项目里使用了 <a href="https://docs.gradle.org/current/userguide/java_plugin.html"><code>java</code> plugin</a>,Spring Boot 插件会:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>C创建一个名为 <code>bootJar</code> 的 <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootJar.html"><code>BootJar</code></a> 任务, 它会为项目创建一个可执行的 fat jar. jar会包含所有 main source set 下运行时的类路径; 类会被打包进 <code>BOOT-INF/classes</code> 里, jars 会被打包进 <code>BOOT-INF/lib</code> 里.</p>
</li>
<li>
<p>配置一个依赖于 <code>bootJar</code> 任务的 <code>assemble</code> 任务.</p>
</li>
<li>
<p>禁止 <code>jar</code> 任务</p>
</li>
<li>
<p>创建一个名为 <code>bootBuildImage</code> 的 <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootBuildImage.html"><code>BootBuildImage</code></a> 任务,该任务将使用 <a href="https://buildpacks.io">buildpack</a> 创建一个 OCI 镜像..</p>
</li>
<li>
<p>创建一个名为 <code>bootRun</code> 的 <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/run/BootRun.html"><code>BootRun</code></a> 任务,  用来运行你的程序.</p>
</li>
<li>
<p>创建一个名为 <code>bootArchives</code> 的配置包含通过 <code>bootJar</code> 产生的 artifact.</p>
</li>
<li>
<p>创建一个名为 <code>developmentOnly</code> 的配置,为仅在开发时需要的依赖 (例如 Spring Boot 的 Devtools) ,不应将其打包在可执行的 jar 和 wars 中.</p>
</li>
<li>
<p>无需配置, 所有的 <code>JavaCompile</code> 任务都使用 <code>UTF-8</code>.</p>
</li>
<li>
<p>无需配置, 所有的 <code>JavaCompile</code> 任务都使用 <code>-parameters</code> 编译器参数.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-kotlin"><a class="anchor" href="#reacting-to-other-plugins-kotlin"></a>9.2. Kotlin 插件行为</h3>
<div class="paragraph">
<p>当项目里使用了 <a href="https://kotlinlang.org/docs/reference/using-gradle.html">Kotlin&#8217;s Gradle plugin</a> ,Spring Boot 插件会:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将 Spring Boot 的依赖管理中使用的 Kotlin 版本与该插件的版本保持一致.  这可以通过将  <code>kotlin.version</code> 属性设置为与 Kotlin 插件的版本匹配的值来实现.
This is achieved by setting the <code>kotlin.version</code> property with a value that matches the version of the Kotlin plugin.</p>
</li>
<li>
<p>将任何 <code>KotlinCompile</code> 任务配置为使用 <code>-java-parameters</code> 编译器参数.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-war"><a class="anchor" href="#reacting-to-other-plugins-war"></a>9.3. war 插件行为</h3>
<div class="paragraph">
<p>当项目里使用了 <a href="https://docs.gradle.org/current/userguide/war_plugin.html"><code>war</code> plugin</a> ,Spring Boot 插件会:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建一个名为 <code>bootWar</code> 的  <a href="https://docs.jcohy.com/docs/spring-boot/2.4.5/html5/zh-cn/gradle-plugin/api/org/springframework/boot/gradle/tasks/bundling/BootWar.html"><code>BootWar</code></a> 任务, 用来为项目创建可执行的, far war. 另外对于标准的打包, 所以是 <code>providedRuntime</code> 的配置都会打包进 <code>WEB-INF/lib-provided</code> 里;</p>
</li>
<li>
<p>配置一个依赖于 <code>bootWar</code> 任务的 <code>assemble</code> 任务;</p>
</li>
<li>
<p>禁止 <code>war</code> 任务;</p>
</li>
<li>
<p>配置 <code>bootArchives</code> 任务包含通过 <code>bootWar</code> 任务产生的 <code>artifact</code>.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-dependency-management"><a class="anchor" href="#reacting-to-other-plugins-dependency-management"></a>9.4. 依赖管理插件行为</h3>
<div class="paragraph">
<p>当项目里使用了 <a href="https://github.com/spring-gradle-plugins/dependency-management-plugin"><code>io.spring.dependency-management</code> plugin</a> ,Spring Boot 插件会自动导入 <code>spring-boot-dependencies</code> bom</p>
</div>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-application"><a class="anchor" href="#reacting-to-other-plugins-application"></a>9.5. application 插件行为</h3>
<div class="paragraph">
<p>当项目里使用了 <a href="https://docs.gradle.org/current/userguide/application_plugin.html"><code>application</code> plugin</a> ,Spring Boot 插件会:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建一个名为 <code>bootStartScripts</code> 的 <code>CreateStartScripts</code> 的任务, 它会创建一个脚本用来使用 <code>java -jar</code> 命令启动在 <code>bootArchives</code> 配置里的 artifact. 该任务使用配置的 <code>applicationDefaultJvmArgs</code> 属性作为其 <code>defaultJvmOpts</code> 属性.</p>
</li>
<li>
<p>创建一个名为 <code>boot</code> 的新的 distribution , 并将其配置为在其 <code>lib</code> 目录的 <code>bootArchives</code> 配置中包含 artifact, 在其 <code>bin</code> 目录中包含启动脚本.</p>
</li>
<li>
<p>使用 <code>mainClassName</code> 作为 <code>main</code> 属性配置 <code>bootRun</code> 任务.</p>
</li>
<li>
<p>使用 <code>applicationDefaultJvmArgs</code> 参数作为 <code>jvmArgs</code> 属性配置 <code>bootRun</code> 任务.</p>
</li>
<li>
<p>使用 <code>mainClassName</code> 属性在 <code>mainifest</code> 作为 <code>Start-Class</code> 入口配置 <code>bootJar</code> 任务.</p>
</li>
<li>
<p>使用 <code>mainClassName</code> 作为 <code>mainifest</code> 的 <code>Start-Class</code> 入口配置 bootWar 任务.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="reacting-to-other-plugins-maven"><a class="anchor" href="#reacting-to-other-plugins-maven"></a>9.6. Maven 插件行为</h3>
<div class="paragraph">
<p>当使用了 Gradle 的 <a href="https://docs.gradle.org/current/userguide/maven_plugin.html"><code>maven</code> plugin</a>, Spring Boot 插件会配置一个 <code>uploadBootArchives</code> <code>Upload</code> 任务保证在它产生的 pom 里没有依赖被声明.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-09-13 15:59:46 +0800
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/run_prettify.min.js"></script>
</div>
  </div>
</div>
</body>
</html>
<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<title>配置元数据</title>
<link rel="stylesheet" href="css/site.css">
<script src="js/setup.js"></script><script defer src="js/site.js"></script>

</head>
<body id="configuration-metadata" class="book toc2 toc-left"><div id="banner-container" class="container" role="banner">
  <div id="banner" class="contained" role="banner">
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </div>
</div>
<div id="tocbar-container" class="container" role="navigation">
  <div id="tocbar" class="contained" role="navigation">
    <button id="toggle-toc"></button>
  </div>
</div>
<div id="main-container" class="container">
  <div id="main" class="contained">
    <div id="doc" class="doc">
<div id="header">
<h1>配置元数据</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<span id="back-to-index"><a href="index.html">Back to index</a></span><ul class="sectlevel1">
<li><a href="#configuration-metadata-format">1. Metadata 格式</a>
<ul class="sectlevel2">
<li><a href="#configuration-metadata-group-attributes">1.1. Group 属性</a></li>
<li><a href="#configuration-metadata-property-attributes">1.2. Property 属性</a></li>
<li><a href="#configuration-metadata-hints-attributes">1.3. Hint 属性</a></li>
<li><a href="#configuration-metadata-repeated-items">1.4. 重复的元数据项</a></li>
</ul>
</li>
<li><a href="#configuration-metadata-providing-manual-hints">2. 提供手动提示</a>
<ul class="sectlevel2">
<li><a href="#value-hint">2.1. Value Hint</a></li>
<li><a href="#value-providers">2.2. Value Providers</a>
<ul class="sectlevel3">
<li><a href="#any">2.2.1. Any</a></li>
<li><a href="#class-引用">2.2.2. Class 引用</a></li>
<li><a href="#handle-as">2.2.3. Handle As</a></li>
<li><a href="#logger-名">2.2.4. Logger 名</a></li>
<li><a href="#spring-bean-引用">2.2.5. Spring Bean 引用</a></li>
<li><a href="#spring-profile-名">2.2.6. Spring Profile 名</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#configuration-metadata-annotation-processor">3. 使用注解处理器生成您自己的元数据</a>
<ul class="sectlevel2">
<li><a href="#configuration-metadata-annotation-processor-setup">3.1. 配置注解处理器</a></li>
<li><a href="#configuration-metadata-annotation-processor-metadata-generation">3.2. 自动生成元数据</a></li>
<li><a href="#configuration-metadata-nested-properties">3.3. 嵌套属性</a></li>
<li><a href="#configuration-metadata-additional-metadata">3.4. 添加其他元数据</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring Boot jar 包含元数据文件,提供所有支持的配置属性的详细信息.这些文件旨在允许 IDE 开发人员在用户使用 <code>application.properties</code> 或 <code>application.yml</code> 文件时提供上下文帮助和"代码完成” .</p>
</div>
<div class="paragraph">
<p>主要的元数据文件是在编译器通过处理所有被 <code>@ConfigurationProperties</code> 注解的节点来自动生成的.但是,对于极端情况或更高级的用例,可以<a href="#configuration-metadata-additional-metadata">手动编写部分元数据</a> .</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration-metadata-format"><a class="anchor" href="#configuration-metadata-format"></a>1. Metadata 格式</h2>
<div class="sectionbody">
<div class="paragraph">
<p>配置元数据文件位于 jars 文件中的 <code>META-INF/spring-configuration-metadata.json</code> .  它们使用一个具有 &#8220;groups&#8221; 或 &#8220;properties&#8221; 分类节点的简单 JSON 格式,并将其他值提示归类为 "hints",如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{"groups": [
    {
        "name": "server",
        "type": "org.springframework.boot.autoconfigure.web.ServerProperties",
        "sourceType": "org.springframework.boot.autoconfigure.web.ServerProperties"
    },
    {
        "name": "spring.jpa.hibernate",
        "type": "org.springframework.boot.autoconfigure.orm.jpa.JpaProperties$Hibernate",
        "sourceType": "org.springframework.boot.autoconfigure.orm.jpa.JpaProperties",
        "sourceMethod": "getHibernate()"
    }
    ...
],"properties": [
    {
        "name": "server.port",
        "type": "java.lang.Integer",
        "sourceType": "org.springframework.boot.autoconfigure.web.ServerProperties"
    },
    {
        "name": "server.address",
        "type": "java.net.InetAddress",
        "sourceType": "org.springframework.boot.autoconfigure.web.ServerProperties"
    },
    {
          "name": "spring.jpa.hibernate.ddl-auto",
          "type": "java.lang.String",
          "description": "DDL mode. This is actually a shortcut for the \"hibernate.hbm2ddl.auto\" property.",
          "sourceType": "org.springframework.boot.autoconfigure.orm.jpa.JpaProperties$Hibernate"
    }
    ...
],"hints": [
    {
        "name": "spring.jpa.hibernate.ddl-auto",
        "values": [
            {
                "value": "none",
                "description": "Disable DDL handling."
            },
            {
                "value": "validate",
                "description": "Validate the schema, make no changes to the database."
            },
            {
                "value": "update",
                "description": "Update the schema if necessary."
            },
            {
                "value": "create",
                "description": "Create the schema and destroy previous data."
            },
            {
                "value": "create-drop",
                "description": "Create and then destroy the schema at the end of the session."
            }
        ]
    }
]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个  &#8220;property&#8221;  都是用户使用给定值指定的配置项.  例如,可以在 <code>application.properties</code> 中指定 <code>server.port</code> 和 <code>server.address</code>,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-properties" data-lang="properties">server.port=9090
server.address=127.0.0.1</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8220;groups&#8221; 是高级别的节点,它们本身不指定一个值,但为 properties 提供一个有上下文关联的分组.  例如,<code>server.port</code> 和 <code>server.address</code> 属性是 <code>server</code> 组的一部分.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
不需要每个  &#8220;property&#8221; 都有一个 &#8220;group&#8221;.  一些属性可以以自己的形式存在.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后, &#8220;hints&#8221; 是用于帮助用户配置给定属性的其他信息.  例如,当开发人员配置 <code>spring.jpa.hibernate.ddl-auto</code> 属性时,工具可以使用提示 <code>none</code>, <code>validate</code>, <code>update</code>, <code>create</code> 和 <code>create-drop</code> 值 .</p>
</div>
<div class="sect2">
<h3 id="configuration-metadata-group-attributes"><a class="anchor" href="#configuration-metadata-group-attributes"></a>1.1. Group 属性</h3>
<div class="paragraph">
<p><code>groups</code> 数组包含的 JSON 对象可以由以下属性组成:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组的全名.  此属性是必需的.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组数据类型的类名.  group 数据类型的类名.例如,如果 group 是基于一个被 <code>@ConfigurationProperties</code> 注解的类,该属性将包含该类的全限定名.如果基于一个 <code>@Bean</code> 方法,它将是该方法的返回类型.如果该类型未知,则该属性将被忽略</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>description</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个简短的group描述,用于展示给用户.如果没有可用描述,该属性将被忽略.推荐使用一个简短的段落描述,第一行提供一个简洁的总结,最后一行以句号结尾</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sourceType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">贡献该组的来源类名.例如,如果组基于一个被 <code>@ConfigurationProperties</code> 注解的 <code>@Bean</code> 方法,该属性将包含 <code>@Configuration</code> 类的全限定名,该类包含此方法.如果来源类型未知,则该属性将被忽略</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sourceMethod</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">贡献该组的方法的全名(包含括号及参数类型).例如,被 <code>@ConfigurationProperties</code> 注解的 <code>@Bean</code> 方法名.如果源方法未知,该属性将被忽略</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="configuration-metadata-property-attributes"><a class="anchor" href="#configuration-metadata-property-attributes"></a>1.2. Property 属性</h3>
<div class="paragraph">
<p><code>properties</code> 数组中包含的JSON对象可由以下属性构成:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">属性的全名.  名称以小写的句点分隔(例如,<code>server.address</code>) .  此属性是必需的.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">property 数据类型的类名(例如,<code>java.lang.String</code>) ,还具有完整的泛型类型(例如,<code>java.util.Map&lt;java.lang.String,acme.MyEnum&gt;</code>) .
该属性可以用来指导用户他们可以输入值的类型.为了保持一致,原生类型使用它们的包装类代替(例如,<code>boolean</code>  变为 <code>java.lang.Boolean</code>) .  注意,这个类可能是个从一个字符串转换而来的复杂类型.如果类型未知则该属性会被忽略</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>description</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一个简短的组的描述,用于展示给用户.如果没有描述可用则该属性会被忽略.推荐使用一个简短的段落描述,开头提供一个简洁的总结,最后一行以句号结束</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sourceType</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">贡献 property 的来源类名.例如,如果 property 来自一个被 <code>@ConfigurationProperties</code> 注解的类,该属性将包括该类的全限定名.如果来源类型未知则该属性会被忽略</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>defaultValue</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 property 没有定义时使用的默认值.如果property类型是个数组则该属性也可以是个数组.如果默认值未知则该属性会被忽略</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>deprecation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deprecation</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定该 property 是否过期.如果该字段没有过期或该信息未知则该属性会被忽略.  下表提供了有关  <code>deprecation</code> 属性的更多详细信息.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>每个 <code>properties</code> 元素的 <code>deprecation</code> 属性中包含的JSON对象可以包含以下属性:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>level</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">弃用级别,可以是警告(默认) 或错误.  当某个属性具有警告弃用级别时,它仍应绑定在环境中.  但是,当它具有错误弃用级别时,该属性将不再受管理且未绑定.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>reason</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">简短描述了该资源被弃用的原因.如果没有理由可以省略.建议描述是一个简短的段落,第一行提供简明扼要的摘要.说明中的最后一行应以(<code>.</code>) 结尾.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>replacement</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">正在替换此不推荐使用的属性的属性的全名.如果没有替换此属性,可以省略.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在 Spring Boot 1.3 之前,可以使用单个  <code>deprecated</code> 使用的布尔属性来代替 <code>deprecation</code> 元素.  这仍然以不推荐的方式支持,不应再使用.如果没有理由和替换可用, deprecation 应该设置一个空的对象.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>也可以在代码中以声明方式指定弃用,方法是将 <code>@DeprecatedConfigurationProperty</code> 注解添加到暴露弃用属性的 getter 中.  例如,假设 <code>app.acme.target</code> 属性令人困惑,并将其重命名为 <code>app.acme.name</code>.  以下示例显示了如何处理这种情况:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("app.acme")
public class AcmeProperties {

    private String name;

    public String getName() { ... }

    public void setName(String name) { ... }

    @DeprecatedConfigurationProperty(replacement = "app.acme.name")
    @Deprecated
    public String getTarget() {
        return getName();
    }

    @Deprecated
    public void setTarget(String target) {
        setName(target);
    }
}
</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
无法设置级别.  由于代码仍在处理该属性,因此始终 <code>warning</code> .
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>前面的代码确保不推荐使用的属性仍然有效(将其委托给幕后的 name 属性) .  一旦可以从公共 API 中删除 <code>getTarget</code> 和 <code>setTarget</code> 方法,元数据中的自动弃用提示也将消失.
如果要保留提示,请添加具有错误弃用级别的手动元数据,以确保仍然向用户通知该属性.  进行替换时,这样做特别有用.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuration-metadata-hints-attributes"><a class="anchor" href="#configuration-metadata-hints-attributes"></a>1.3. Hint 属性</h3>
<div class="paragraph">
<p><code>hints</code> 数组中包含的 JSON 对象可以包含以下属性:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该提示所引用的属性的全名.  名称采用小写的句点分隔形式(例如 <code>spring.mvc.servlet.path</code>) .  如果属性引用映射(例如 <code>system.contexts</code>) ,则提示将应用于映射的键(<code>system.contexts.keys</code>) 或映射的值(<code>system.contexts.values</code>) . 此属性是必需的.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>values</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ValueHint[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由 <code>ValueHint</code> 对象定义的有效值列表(如下表所述) .  每个条目都定义该值,并且可以具有描述.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providers</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ValueProvider[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由 <code>ValueProvider</code> 对象定义的提供者列表(在本文档的后面介绍) .  每个条目定义提供者的名称及其参数(如果有) .</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>每个  <code>hint</code> 元素的 <code>values</code> 属性中包含的 JSON 对象可以包含下表中描述的属性:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>value</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">提示所引用元素的有效值.  如果属性的类型是数组,则它也可以是值的数组.  此属性是必需的.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>description</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以显示给用户的值的简短描述.  如果没有可用的描述,则可以省略.  建议使用简短的描述,第一行提供简要的摘要.  说明中的最后一行应以句点(<code>.</code>) 结尾.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>每个 <code>hint</code> 元素的 <code>providers</code> 属性中包含的 JSON 对象可以包含下表中描述的属性:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 66.6668%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于为提示所引用的元素提供附加内容帮助的提供者的名称.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>parameters</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">JSON object</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">provider 支持的任何其他参数(有关更多详细信息,请参阅 provider 的文档) .</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="configuration-metadata-repeated-items"><a class="anchor" href="#configuration-metadata-repeated-items"></a>1.4. 重复的元数据项</h3>
<div class="paragraph">
<p>具有相同 &#8220;property&#8221; 和 &#8220;group&#8221; 名称的对象可以在元数据文件中多次出现.  例如,您可以将两个单独的类绑定到同一前缀,每个类具有可能重叠的属性名称.  虽然相同的名称多次出现在元数据中应该不常见,但元数据的使用者应注意确保它们支持该名称.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration-metadata-providing-manual-hints"><a class="anchor" href="#configuration-metadata-providing-manual-hints"></a>2. 提供手动提示</h2>
<div class="sectionbody">
<div class="paragraph">
<p>为了改善用户体验并进一步帮助用户配置给定属性,您可以提供其他元数据,这些元数据可以:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>描述属性的潜在值列表.</p>
</li>
<li>
<p>关联提供者,以将定义良好的语义附加到属性,以便工具可以根据项目的上下文来发现潜在值的列表.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="value-hint"><a class="anchor" href="#value-hint"></a>2.1. Value Hint</h3>
<div class="paragraph">
<p>每个提示的 <code>name</code> 属性是指属性的名称.  在<a href="#configuration-metadata-format">前面显示的初始示例</a>中,我们为 <code>spring.jpa.hibernate.ddl-auto</code> 属性提供了五个值: <code>none</code>, <code>validate</code>, <code>update</code>, <code>create</code>, 和 <code>create-drop</code>.  每个值也可以具有描述.</p>
</div>
<div class="paragraph">
<p>如果您的属性属于 <code>Map</code> 类型,则可以提供键和值的提示(但不提供 map 本身的提示) .  特殊的 <code>.keys</code> 和 <code>.values</code> 后缀必须分别引用键和值.</p>
</div>
<div class="paragraph">
<p>假设有一个 <code>sample.contexts</code> 的 Map&lt;String,Integer&gt;,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ConfigurationProperties("sample")
public class SampleProperties {

    private Map&lt;String,Integer&gt; contexts;
    // getters and setters
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>String (在此示例中) 为 <code>sample1</code> 和 <code>sample2</code>.  为了为 key 提供其他内容提示,您可以将以下 JSON<a href="#configuration-metadata-additional-metadata">添加到模块的手动元数据</a>中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{"hints": [
    {
        "name": "sample.contexts.keys",
        "values": [
            {
                "value": "sample1"
            },
            {
                "value": "sample2"
            }
        ]
    }
]}</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
我们建议您对这两个值使用枚举.  如果您的 IDE 支持,这是迄今为止最有效的自动完成方法.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="value-providers"><a class="anchor" href="#value-providers"></a>2.2. Value Providers</h3>
<div class="paragraph">
<p>Providers  是一种将语义附加到属性的强有力的方法,我们将定义可以用于您自己的提示的官方 Providers.  但是,您最喜欢的 IDE 可能只实现其中一些,也可能没有实现.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
由于这是一项新功能,IDE 供应商必须赶上它的工作方式.  采用时间自然会有所不同.
下表总结了受支持的 provider 的列表:
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 66.6667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名字</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>any</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许提供任何附加值.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>class-reference</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动完成项目中可用的类.  通常受 <code>target</code> 参数指定的基类的约束.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>handle-as</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如同按强制  <code>target</code>  参数定义的类型定义属性一样处理属性.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>logger-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动完成有效的记录器名称和  <a href="spring-boot-features.html#boot-features-custom-log-groups">记录器组</a>.  通常,可以自动完成当前项目中可用的包和类名以及定义的组. .</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-bean-reference</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动完成当前项目中的可用bean名称.  通常受 <code>target</code> 参数指定的基类的约束.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-profile-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动完成项目中可用的 Spring profile 名称.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
对于给定的属性,只有一个 provider 可以处于 active 状态,但是如果它们都可以通过某种方式管理该属性,则可以指定多个 provider .  确保将最有用的 provider 放在首位,因为 IDE 必须使用它可以处理的JSON部分中的第一个.  如果不支持给定属性的 provider ,则也不提供特殊的内容帮助.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="any"><a class="anchor" href="#any"></a>2.2.1. Any</h4>
<div class="paragraph">
<p>这个特殊的 provider 允许提供任何其他值.  如果支持,则应基于属性类型进行常规值验证.</p>
</div>
<div class="paragraph">
<p>如果您具有值列表,并且任何其他值应视为有效,则通常使用此 provider .</p>
</div>
<div class="paragraph">
<p>以下示例提供了 <code>system.state</code> 的自动完成值的 <code>on</code> 和 <code>off</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{"hints": [
    {
        "name": "system.state",
        "values": [
            {
                "value": "on"
            },
            {
                "value": "off"
            }
        ],
        "providers": [
            {
                "name": "any"
            }
        ]
    }
]}</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意,在前面的示例中,还允许任何其他值.</p>
</div>
</div>
<div class="sect3">
<h4 id="class-引用"><a class="anchor" href="#class-引用"></a>2.2.2. Class 引用</h4>
<div class="paragraph">
<p><strong>类引用</strong>  provider 自动完成项目中可用的类.  此 provider 支持以下参数:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">参数</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code> (<code>Class</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>none</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应分配给所选值的类的完全限定名称.  通常用于过滤掉非候选类.  请注意,可以通过暴露具有适当上限的类来由类型本身提供此信息.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>concrete</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定是否仅将具体类视为有效候选者.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下元数据片段对应于标准 <code>server.servlet.jsp.class-name</code> 属性,该属性定义了要使用的 <code>JspServlet</code> 类名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{"hints": [
    {
        "name": "server.servlet.jsp.class-name",
        "providers": [
            {
                "name": "class-reference",
                "parameters": {
                    "target": "javax.servlet.http.HttpServlet"
                }
            }
        ]
    }
]}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handle-as"><a class="anchor" href="#handle-as"></a>2.2.3. Handle As</h4>
<div class="paragraph">
<p><strong>handle-as</strong>  provider 使您可以将属性的类型替换为更高级的类型.  当该属性具有 <code>java.lang.String</code> 类型时,通常会发生这种情况,因为您不希望配置类依赖于可能不在类路径中的类.  此 provider 支持以下参数:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">参数</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong><code>target</code></strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code> (<code>Class</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>none</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">要为属性考虑的类型的标准名称.  此参数是必需的.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可以使用以下类型:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任何 <code>java.lang.Enum</code>: 列出属性的可能值.  (我们建议使用 <code>Enum</code> 类型定义属性,因为IDE不需要其他提示即可自动完成值)</p>
</li>
<li>
<p><code>java.nio.charset.Charset</code>: 支持字符集/编码值(例如 <code>UTF-8</code>) 的自动完成</p>
</li>
<li>
<p><code>java.util.Locale</code>: 语言环境的自动完成(例如 <code>en_US</code>)</p>
</li>
<li>
<p><code>org.springframework.util.MimeType</code>: 支持内容类型值(例如 <code>text/plain</code>) 的自动完成</p>
</li>
<li>
<p><code>org.springframework.core.io.Resource</code>: 支持自动完成 Spring 资源抽象以引用文件系统或类路径上的文件(例如 <code>classpath:/sample.properties</code>)</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果可以提供多个值,请使用 <code>Collection</code> 或 <code>Array</code> 类型向IDE讲解.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下元数据片段对应于标准 <code>spring.liquibase.change-log</code> 属性,该属性定义了要使用的更改日志的路径.  实际上,它在内部用作 <code>org.springframework.core.io.Resource</code>,但不能这样暴露,因为我们需要保留原始的String值以将其传递给Liquibase API.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{"hints": [
    {
        "name": "spring.liquibase.change-log",
        "providers": [
            {
                "name": "handle-as",
                "parameters": {
                    "target": "org.springframework.core.io.Resource"
                }
            }
        ]
    }
]}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="logger-名"><a class="anchor" href="#logger-名"></a>2.2.4. Logger 名</h4>
<div class="paragraph">
<p><strong>logger-name</strong> provider 会自动完成有效的记录器名称和 <a href="spring-boot-features.html#boot-features-custom-log-groups">记录器组</a>.  通常,可以自动完成当前项目中可用的程序包和类名.  如果启用了组(默认) ,并且在配置中标识了自定义记录程序组,则应为其提供自动完成功能.  特定的框架可能还具有其他可以支持的魔法值记录器名称.</p>
</div>
<div class="paragraph">
<p>此 provider 支持以下参数:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">参数</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>group</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>true</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定是否应考虑已知组.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>由于记录器名称可以是任意名称,因此该 provider 应允许使用任何值,但可以突出显示项目的类路径中不可用的有效程序包和类名称.</p>
</div>
<div class="paragraph">
<p>以下元数据片段对应于标准 <code>logging.level</code> 属性.  键是记录器名称,其值对应于标准日志级别或任何自定义级别.  当 Spring Boot 开箱即用地定义了一些记录器组时,已经为它们添加了专用的值提示.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{"hints": [
    {
        "name": "logging.level.keys",
        "values": [
            {
                "value": "root",
                "description": "Root logger used to assign the default logging level."
            },
            {
                "value": "sql",
                "description": "SQL logging group including Hibernate SQL logger."
            },
            {
                "value": "web",
                "description": "Web logging group including codecs."
            }
        ],
        "providers": [
            {
                "name": "logger-name"
            }
        ]
    },
    {
        "name": "logging.level.values",
        "values": [
            {
                "value": "trace"
            },
            {
                "value": "debug"
            },
            {
                "value": "info"
            },
            {
                "value": "warn"
            },
            {
                "value": "error"
            },
            {
                "value": "fatal"
            },
            {
                "value": "off"
            }

        ],
        "providers": [
            {
                "name": "any"
            }
        ]
    }
]}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="spring-bean-引用"><a class="anchor" href="#spring-bean-引用"></a>2.2.5. Spring Bean 引用</h4>
<div class="paragraph">
<p><strong>spring-bean-reference</strong> provider 自动完成在当前项目的配置中定义的 bean.  此 provider 支持以下参数:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 12.5%;">
<col style="width: 25%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">参数</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">默认值</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>target</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code> (<code>Class</code>)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>none</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应分配给候选者的Bean类的完全限定名称.  通常用于过滤掉非候选 bean.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下元数据片段对应于标准 <code>spring.jmx.server</code> 属性,该属性定义了要使用的 <code>MBeanServer</code> bean 的名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{"hints": [
    {
        "name": "spring.jmx.server",
        "providers": [
            {
                "name": "spring-bean-reference",
                "parameters": {
                    "target": "javax.management.MBeanServer"
                }
            }
        ]
    }
]}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
binder 不会自动装配日这些元数据,如果提供了该提示,则仍需要使用 <code>ApplicationContext</code> 将 Bean 名称转换为实际的 Bean 引用. .
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="spring-profile-名"><a class="anchor" href="#spring-profile-名"></a>2.2.6. Spring Profile 名</h4>
<div class="paragraph">
<p><strong>spring-profile-name</strong> provider 自动完成在当前项目的配置中定义的 Spring profile.</p>
</div>
<div class="paragraph">
<p>以下元数据片段对应于标准 <code>spring.profiles.active</code> 属性,该属性定义了要启用的 Spring profile 的名称:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{"hints": [
    {
        "name": "spring.profiles.active",
        "providers": [
            {
                "name": "spring-profile-name"
            }
        ]
    }
]}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration-metadata-annotation-processor"><a class="anchor" href="#configuration-metadata-annotation-processor"></a>3. 使用注解处理器生成您自己的元数据</h2>
<div class="sectionbody">
<div class="paragraph">
<p>您可以使用 <code>spring-boot-configuration-processor</code> jar 从带有 <code>@ConfigurationProperties</code> 注解的项目中轻松生成自己的配置元数据文件.
该 jar 包含一个 Java 注解处理器,在您的项目被编译时会被调用.</p>
</div>
<div class="sect2">
<h3 id="configuration-metadata-annotation-processor-setup"><a class="anchor" href="#configuration-metadata-annotation-processor-setup"></a>3.1. 配置注解处理器</h3>
<div class="paragraph">
<p>要使用处理器,请添加 <code>spring-boot-configuration-processor</code> 的依赖.</p>
</div>
<div class="paragraph">
<p>使用 Maven,依赖应声明为可选,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 Gradle,应该在 <code>annotationProcessor</code> 配置中声明依赖,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    compileOnly "org.springframework.boot:spring-boot-configuration-processor"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 Gradle 4.6 和更高版本,应在 <code>annotationProcessor</code> 配置中声明依赖,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    annotationProcessor "org.springframework.boot:spring-boot-configuration-processor"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用的是额外的 <code>spring-configuration-metadata.json</code> 文件,则应将 <code>compileJava</code> 任务配置为依赖于 <code>processResources</code> 任务,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">compileJava.inputs.files(processResources)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种依赖确保注解处理器在编译期间运行时,其他元数据可用.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果在项目中使用 AspectJ,则需要确保注解处理器只运行一次,有很多方法可以实现这一点.</p>
</div>
<div class="paragraph">
<p>在 Maven 中,你可以配置  <code>maven-apt-plugin</code> 并将依赖只添加到注解处理器中.
您还可以让 AspectJ 插件在 <code>maven-compiler-plugin</code> 配置中执行所有处理时禁用注解处理,如下所示</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;plugin&gt;
    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;proc&gt;none&lt;/proc&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="configuration-metadata-annotation-processor-metadata-generation"><a class="anchor" href="#configuration-metadata-annotation-processor-metadata-generation"></a>3.2. 自动生成元数据</h3>
<div class="paragraph">
<p>处理器选择用 <code>@ConfigurationProperties</code> 注解的类和方法.</p>
</div>
<div class="paragraph">
<p>如果该类也使用了  <code>@ConstructorBinding</code> 注解,则应使用单个构造函数,并为每个构造函数参数创建一个属性.否则,将通过存在标准的 <code>getter</code> 和 <code>setter</code> 并对集合和 Map 类型进行特殊处理来发现属性(即使仅存在 getter 也会被检测到).注解处理器还支持使用 <code>@Data</code>,<code>@Getter</code> 和 <code>@Setter</code> lombok 注解.</p>
</div>
<div class="paragraph">
<p>考虑以下类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="server")
public class ServerProperties {

    /**
    * Name of the server.
    */
    private String name;

    /**
     * IP address to listen to.
     */
    private String ip = "127.0.0.1";

    /**
    * Port to listener to.
    */
    private int port = 9797;

    // ... getter and setters

}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这暴露了三个属性,其中 <code>server.name</code> 没有默认值,<code>server.ip</code> 和 <code>server.port</code> 分别默认为 <code>"127.0.0.1"</code> 和 <code>9797</code>.
字段值的 Javadoc 用于填充 <code>description</code> 属性.. 例如,<code>server.ip</code> 的描述是 "IP address to listen to".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
您仅应将简单文本与 <code>@ConfigurationProperties</code> 字段 Javadoc 一起使用,因为在将它们添加到 JSON 之前不会对其进行处理.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>注解处理器应用多种启发式方法从源模型中提取默认值.必须静态提供默认值. 特别是不要引用另一个类中定义的常量. 另外,注解处理器无法自动检测  <code>Enum</code> 和 <code>Collections</code> 的默认值.</p>
</div>
<div class="paragraph">
<p>如果该类具有一个带有至少一个参数的构造函数,则为每个构造函数参数创建一个属性.  否则,将通过存在标准的 <code>getter</code> 和 <code>setter</code> 并对集合类型进行特殊处理来发现属性(即使仅存在getter也会被检测到) .</p>
</div>
<div class="paragraph">
<p>对于无法检测到默认值的情况,应提供<a href="#configuration-metadata-additional-metadata">手动元数据</a>.</p>
</div>
<div class="paragraph">
<p>考虑以下类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix = "acme.messaging")
public class MessagingProperties {

    private List&lt;String&gt; addresses = new ArrayList&lt;&gt;(Arrays.asList("a", "b"));

    private ContainerType containerType = ContainerType.SIMPLE;

    // ... getter and setters

    public enum ContainerType {

        SIMPLE,
        DIRECT

    }

}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了记录以上类中属性的默认值,您可以将以下内容<a href="#configuration-metadata-additional-metadata">添加到模块的手动元数据</a>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{"properties": [
    {
        "name": "acme.messaging.addresses",
        "defaultValue": ["a", "b"]
    },
    {
        "name": "acme.messaging.container-type",
        "defaultValue": "simple"
    }
]}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
只需要属性 <code>name</code>  即可记录带有手动元数据的其他字段.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="configuration-metadata-nested-properties"><a class="anchor" href="#configuration-metadata-nested-properties"></a>3.3. 嵌套属性</h3>
<div class="paragraph">
<p>注解处理器自动将内部类视为嵌套属性.我们可以为它创建一个子命名空间,而不是在根命名空间的记录 <code>ip</code> 和 <code>port</code>.考虑更新后的示例:  考虑以下类:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ConfigurationProperties(prefix="server")
public class ServerProperties {

    private String name;

    private Host host;

    // ... getter and setters

    public static class Host {

        private String ip;

        private int port;

        // ... getter and setters

    }

}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例为 <code>server.name</code>,<code>server.host.ip</code> 和 <code>server.host.port</code> 属性生成元数据信息.  您可以在字段上使用 <code>@NestedConfigurationProperty</code> 注解,以指示应将常规(非内部) 类视为嵌套类.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
这对集合和地图没有影响,因为这些类型会自动识别,并且会为每个集合生成一个元数据属性.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="configuration-metadata-additional-metadata"><a class="anchor" href="#configuration-metadata-additional-metadata"></a>3.4. 添加其他元数据</h3>
<div class="paragraph">
<p>Spring Boot 的配置文件处理非常灵活,通常情况下可能存在未绑定到 <code>@ConfigurationProperties</code> bean的属性.  您可能还需要调整现有键的某些属性.
为了支持这种情况,并允许您提供自定义的 "hints",注解处理器会自动将 <code>META-INF/additional-spring-configuration-metadata.json</code> 中的项目合并到主元数据文件中.</p>
</div>
<div class="paragraph">
<p>如果引用了已自动检测到的属性,则如果指定了描述,默认值和弃用信息,则它们将被覆盖.  如果在当前模块中未标识手动属性声明,则将其添加为新属性.</p>
</div>
<div class="paragraph">
<p>另外,<code>spring-configuration-metadata.json</code> 文件的格式与常规的 <code>spring-configuration-metadata.json</code> 完全相同.  附加属性文件是可选的.  如果没有任何其他属性,请不要添加文件.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-09-13 15:54:50 +0800
</div>
</div>
</div>
  </div>
</div>
</body>
</html>
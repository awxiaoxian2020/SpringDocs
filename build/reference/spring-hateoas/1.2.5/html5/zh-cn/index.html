<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="author" content="Oliver Gierke, Greg Turnquist, Jay Bryant">
<title>Spring HATEOAS - 参考指南</title>
<link rel="stylesheet" href="css/site.css">
<script src="js/setup.js"></script><script defer src="js/site.js"></script>

</head>
<body id="spring-hateoas-reference" class="book toc2 toc-left"><div id="banner-container" class="container" role="banner">
  <div id="banner" class="contained" role="banner">
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </div>
</div>
<div id="tocbar-container" class="container" role="navigation">
  <div id="tocbar" class="contained" role="navigation">
    <button id="toggle-toc"></button>
  </div>
</div>
<div id="main-container" class="container">
  <div id="main" class="contained">
    <div id="doc" class="doc">
<div id="header">
<h1>Spring HATEOAS - 参考指南</h1>
<div class="details">
<span id="author" class="author">Oliver Gierke</span><br>
<span id="author2" class="author">Greg Turnquist</span><br>
<span id="author3" class="author">Jay Bryant</span><br>
<span id="revdate">2021-09-13</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#preface">1. 前言</a>
<ul class="sectlevel2">
<li><a href="#migrate-to-1.0">1.1. Migrating to Spring HATEOAS 1.0</a>
<ul class="sectlevel3">
<li><a href="#migrate-to-1.0.changes">1.1.1. 改变</a>
<ul class="sectlevel4">
<li><a href="#migrate-to-1.0.changes.representation-models">表示模型</a></li>
</ul>
</li>
<li><a href="#migrate-to-1.0.script">1.1.2. 迁移脚本</a></li>
<li><a href="#migration.1-0-M3-to-1-0-RC1">1.1.3. 从 1.0 M3 迁移到 1.0 RC1</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#fundamentals">2. Fundamentals</a>
<ul class="sectlevel2">
<li><a href="#fundamentals.links">2.1. Links</a></li>
<li><a href="#fundamentals.uri-templates">2.2. URI 模板</a></li>
<li><a href="#fundamentals.link-relations">2.3. Link 关系</a>
<ul class="sectlevel3">
<li><a href="#fundamentals.link-relations.iana">2.3.1. IANA link 关系</a></li>
</ul>
</li>
<li><a href="#fundamentals.representation-models">2.4.  表示模型</a>
<ul class="sectlevel3">
<li><a href="#fundamentals.entity-model">2.4.1. 模型表示子资源</a></li>
<li><a href="#模型表示集合资源">2.4.2. 模型表示集合资源</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#server">3. Server-side support</a>
<ul class="sectlevel2">
<li><a href="#server.link-builder.webmvc">3.1.   在 Spring MVC 中创建 links</a>
<ul class="sectlevel3">
<li><a href="#fundamentals.obtaining-links.builder.methods">3.1.1. 建立指向方法的链接</a></li>
</ul>
</li>
<li><a href="#server.link-builder.webflux">3.2. 在 Spring WebFlux 中建立链接</a></li>
<li><a href="#server.affordances">3.3. 功能可见性</a>
<ul class="sectlevel3">
<li><a href="#server.affordances.api">3.3.1. 手动创建 affordances</a></li>
</ul>
</li>
<li><a href="#server.link-builder.forwarded-headers">3.4. 转发报头处理</a></li>
<li><a href="#fundamentals.obtaining-links.entity-links">3.5. 使用 EntityLinks interface</a>
<ul class="sectlevel3">
<li><a href="#server.entity-links.controller">3.5.1. 基于 Spring MVC controllers 的 EntityLinks</a></li>
<li><a href="#server.entity-links.api">3.5.2. EntityLinks API 细节</a>
<ul class="sectlevel4">
<li><a href="#server.entity-links.api.typed">TypedEntityLinks</a></li>
</ul>
</li>
<li><a href="#server.entity-links.spi">3.5.3. EntityLinks 作为 SPI</a></li>
</ul>
</li>
<li><a href="#server.representation-model-assembler">3.6.  表示模型汇编器</a></li>
<li><a href="#server.processors">3.7. 表示模型处理器</a></li>
<li><a href="#spis.rel-provider">3.8. 使用 <code>LinkRelationProvider</code> API</a></li>
</ul>
</li>
<li><a href="#mediatypes">4. 媒体类型</a>
<ul class="sectlevel2">
<li><a href="#mediatypes.hal">4.1. HAL – Hypertext Application Language</a>
<ul class="sectlevel3">
<li><a href="#mediatypes.hal.models">4.1.1. 构建 HAL representation 模型</a></li>
<li><a href="#mediatypes.hal.configuration">4.1.2. 配置链接渲染</a></li>
<li><a href="#mediatypes.hal.i18n">4.1.3. 链接标题国际化</a></li>
<li><a href="#mediatypes.hal.curie-provider">4.1.4.  使用 <code>CurieProvider</code> API</a></li>
</ul>
</li>
<li><a href="#mediatypes.hal-forms">4.2. HAL-FORMS</a>
<ul class="sectlevel3">
<li><a href="#mediatypes.hal-forms.metadata">4.2.1. 定义 HAL-FORMS 元数据</a></li>
<li><a href="#mediatypes.hal-forms.i18n">4.2.2. 表单属性的国际化</a>
<ul class="sectlevel4">
<li><a href="#template-titles">Template titles</a></li>
<li><a href="#属性提示">属性提示</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#mediatypes.http-problem">4.3. HTTP Problem Details</a></li>
<li><a href="#mediatypes.collection-json">4.4. Collection+JSON</a></li>
<li><a href="#mediatypes.uber">4.5. UBER - 交换代表的统一依据</a></li>
<li><a href="#mediatypes.alps">4.6. ALPS - Application-Level Profile Semantics</a></li>
<li><a href="#mediatypes.community">4.7. 基于社区的媒体类型</a>
<ul class="sectlevel3">
<li><a href="#mediatypes.community.json:api">4.7.1. JSON:API</a></li>
<li><a href="#mediatypes.community.siren">4.7.2. Siren</a></li>
</ul>
</li>
<li><a href="#mediatypes.custom">4.8. 注册自定义媒体类型</a>
<ul class="sectlevel3">
<li><a href="#mediatypes.custom.configuration">4.8.1. 自定义媒体类型配置</a></li>
<li><a href="#mediatypes.custom.recommendation">4.8.2. 建议</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#configuration">5. 配置</a>
<ul class="sectlevel2">
<li><a href="#configuration.at-enable">5.1. 使用 <code>@EnableHypermediaSupport</code></a>
<ul class="sectlevel3">
<li><a href="#configuration.at-enable.stacks">5.1.1. 明确启用对专用 Web 堆栈的支持</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#client">6. 客户端支持</a>
<ul class="sectlevel2">
<li><a href="#client.traverson">6.1. Traverson</a>
<ul class="sectlevel3">
<li><a href="#entitymodelt-vs-collectionmodelt">6.1.1. <code>EntityModel&lt;T&gt;</code> vs. <code>CollectionModel&lt;T&gt;</code></a></li>
</ul>
</li>
<li><a href="#client.link-discoverer">6.2. 使用 <code>LinkDiscoverer</code> 实例</a></li>
<li><a href="#client.web-client">6.3. 配置 WebClient 实例</a></li>
<li><a href="#client.web-test-client">6.4. 配置 <code>WebTestClient</code> 实例</a></li>
<li><a href="#client.rest-template">6.5. 配置 RestTemplate 实例</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>该项目提供了一些 API,以简化在使用 Spring 特别是 Spring MVC 时遵循 <a href="https://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a> 原理的 REST 表示形式的过程. 它试图解决的核心问题是创建链接和表示组装.</p>
</div>
<div class="paragraph">
<p>&#169; 2012-2020 The original authors.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
本文档的副本可以供您自己使用,也可以分发给其他人,但前提是您不对此类副本收取任何费用,并且还应确保每份副本均包含本版权声明 (无论是印刷版本还是电子版本) .
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="preface"><a class="anchor" href="#preface"></a>1. 前言</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="migrate-to-1.0"><a class="anchor" href="#migrate-to-1.0"></a>1.1. Migrating to Spring HATEOAS 1.0</h3>
<div class="paragraph">
<p>对于1.0版本，我们借此机会重新评估了 0.x 分支所做的一些设计和包结构选择。并且已经获得了大量的反馈，主要版本的碰撞似乎是重构它们的最自然的地方。</p>
</div>
<div class="sect3">
<h4 id="migrate-to-1.0.changes"><a class="anchor" href="#migrate-to-1.0.changes"></a>1.1.1. 改变</h4>
<div class="paragraph">
<p>包结构的最大变化是引入超媒体类型注册 API ,以支持 Spring HATEOAS 中的其他媒体类型. 这导致客户端和服务器 API(分别命名的包)以及 <code>mediatype</code> 包中的媒体类型实现的明确分离.</p>
</div>
<div class="paragraph">
<p>将代码库升级到新 API 的最简单方法是使用 <a href="#migrate-to-1.0.script">migration script</a>. 在我们开始之前,这些都已经了解了这些变化.</p>
</div>
<div class="sect4">
<h5 id="migrate-to-1.0.changes.representation-models"><a class="anchor" href="#migrate-to-1.0.changes.representation-models"></a>表示模型</h5>
<div class="paragraph">
<p><code>ResourceSupport</code>/<code>Resource</code>/<code>Resources</code>/<code>PagedResources</code> 这些类从未被真正恰当地命名过,毕竟,这些类型实际上并不代表资源,而是表示模型.可以通过超媒体信息和提供的内容来丰富它们. 这是新名称映射到旧名称的方式:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ResourceSupport</code> 现在是 <code>RepresentationModel</code></p>
</li>
<li>
<p><code>Resource</code> 现在是 <code>EntityModel</code></p>
</li>
<li>
<p><code>Resources</code> 现在是 <code>CollectionModel</code></p>
</li>
<li>
<p><code>PagedResources</code> 现在是 <code>PagedModel</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此, <code>ResourceAssembler</code> 已重命名为 <code>RepresentationModelAssembler</code> 它的 <code>toResource(…)</code> 和 <code>toResources(…)</code> 方法被重命名为 <code>toModel(…)</code> 和 <code>toCollectionModel(…)</code> .
名称的变化也反映在 <code>TypeReferences</code> 包含的类中.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>RepresentationModel.getLinks()</code> 现在暴露一个 <code>Links</code> 实例 (在 <code>List&lt;Link&gt;</code> 上) 因为它暴露了其他 API,以使用各种策略来连接和合并不同的 <code>Links</code> 实例. 同样,它会自动绑定泛型类型,以允许向实例添加链接的方法返回实例本身.</p>
</li>
<li>
<p><code>LinkDiscoverer</code> APIs 已移至 <code>client</code> 包下.</p>
</li>
<li>
<p><code>LinkBuilder</code> 和 <code>EntityLinks</code> APIs 已移至 <code>server</code> 包下.</p>
</li>
<li>
<p><code>ControllerLinkBuilder</code> 已移到 <code>server.mvc</code> 中,不建议使用 <code>WebMvcLinkBuilder</code> 替代.</p>
</li>
<li>
<p><code>RelProvider</code> 已重命名为 <code>LinkRelationProvider</code> 并返回 <code>LinkRelation</code> 实例而不是 <code>String</code>s.</p>
</li>
<li>
<p><code>VndError</code> 已移至 <code>mediatype.vnderror</code> 包下.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="migrate-to-1.0.script"><a class="anchor" href="#migrate-to-1.0.script"></a>1.1.2. 迁移脚本</h4>
<div class="paragraph">
<p>您可以在应用程序根目录放置 <a href="https://github.com/spring-projects/spring-hateoas/tree/master/etc">一个脚本</a>,该脚本会将所有导入语句和静态方法引用更新为在源代码仓库中移动的 Spring HATEOAS 类型.
只需下载该文件,然后从您的项目根目录中运行它即可. 默认情况下,它将检查所有 Java 源文件,并用新的替换旧的 Spring HATEOAS 类型引用.</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Sample application of the migration script</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>$ ./migrate-to-1.0.sh

Migrating Spring HATEOAS references to 1.0 for files : *.java

Adapting ./src/main/java/…
…

Done!</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意,该脚本不一定能够完全修复所有更改,但应涵盖最重要的重构.</p>
</div>
<div class="paragraph">
<p>现在,您可以检测 Git 客户端中的文件所做的更改,并进行适当的提交. 如果您发现未迁移的方法或类型引用, 请在问题跟踪器中打开一个票据.</p>
</div>
</div>
<div class="sect3">
<h4 id="migration.1-0-M3-to-1-0-RC1"><a class="anchor" href="#migration.1-0-M3-to-1-0-RC1"></a>1.1.3. 从 1.0 M3 迁移到 1.0 RC1</h4>
<div class="ulist">
<ul>
<li>
<p><code>Link.andAffordance(…)</code> 的 Affordance 详细信息已移至 <code>Affordances</code>. 现在,要手动构建 <code>Affordance</code> 实例,请使用 <code>Affordances.of(link).afford(…)</code>. 另请注意,<code>Affordances</code> 暴露了新的 <code>AffordanceBuilder</code> 类型,以使其流式使用. 有关详细信息,请参见 <a href="#server.affordances">功能可见性</a>.</p>
</li>
<li>
<p><code>AffordanceModelFactory.getAffordanceModel(…)</code> 现在接收 <code>InputPayloadMetadata</code> 和 <code>PayloadMetadata</code> 实例,而不是 <code>ResolvableType</code>s 实例 ,以允许基于非类型的实现. 自定义媒体类型的实现必须相应地进行调整.</p>
</li>
<li>
<p>如果 HAL Forms 的属性值遵循规范中定义的默认属性,则现在不呈现属性属性. 即 如果先前将 <code>required</code> 显式设置为 <code>false</code>,则现在我们省略了 <code>required</code> 条目. 现在,对于使用 <code>PATCH</code> 作为HTTP方法的模板,我们现在也只强制不需要使用它们.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="fundamentals"><a class="anchor" href="#fundamentals"></a>2. Fundamentals</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节介绍 Spring HATEOAS 的基础知识及其基本域抽象.</p>
</div>
<div class="sect2">
<h3 id="fundamentals.links"><a class="anchor" href="#fundamentals.links"></a>2.1. Links</h3>
<div class="paragraph">
<p>超媒体的基本思想是用超媒体元素丰富资源的表示.
最简单的形式是链接.
它们指示客户端可以导航到特定资源.
相关资源的语义是在所谓的链接关系中定义的.
您可能已经在 HTML 文件的标题中看到了这一点:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. A link in an HTML document</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;link href="theme.css" rel="stylesheet" type="text/css" /&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见,链接指向资源 <code>theme.css</code> 并指示它是样式表. 链接通常包含其他信息,例如资源将返回的媒体类型. 但是,链接的基本构建块是其引用和关系.</p>
</div>
<div class="paragraph">
<p>Spring HATEOAS 使您可以通过其不可变的 <code>Link</code> 值类型来处理链接. 它的构造函数同时接受超文本引用和链接关系,后者默认为 IANA 链接 <code>self</code>. 在<a href="#fundamentals.link-relations">Link 关系</a>阅读有关后者的更多信息.</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. Using links</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Link link = Link.of("/something");
assertThat(link.getHref()).isEqualTo("/something");
assertThat(link.getRel()).isEqualTo(IanaLinkRelations.SELF);

link = Link.of("/something", "my-rel");
assertThat(link.getHref()).isEqualTo("/something");
assertThat(link.getRel()).isEqualTo(LinkRelation.of("my-rel"));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>Link</code> 暴露了 <a href="https://tools.ietf.org/html/rfc8288">RFC-8288</a> 中定义的其他属性. 您可以通过在 <code>Link</code> 实例上调用相应的 wither 方法来设置它们.</p>
</div>
<div class="paragraph">
<p>在 Spring MVC 的构建链接和 Spring WebFlux 的构建链接中找到有关如何创建指向  <a href="#server.link-builder.webmvc">  在 Spring MVC 中创建 links</a>  和 <a href="#server.link-builder.webflux">在 Spring WebFlux 中建立链接</a> 控制器的链接的更多信息.</p>
</div>
</div>
<div class="sect2">
<h3 id="fundamentals.uri-templates"><a class="anchor" href="#fundamentals.uri-templates"></a>2.2. URI 模板</h3>
<div class="paragraph">
<p>对于 Spring HATEOAS  <code>Link</code>,超文本引用不仅可以是 URI,而且可以是根据 <a href="https://tools.ietf.org/html/rfc6570">RFC-6570</a> 的 URI 模板. URI 模板包含所谓的模板变量,并允许扩展这些参数. 这样,客户端就可以将参数化的模板转换为 URI,而不必了解最终 URI 的结构,它只需要知道变量的名称即可.</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. Using links with templated URIs</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Link link = Link.of("/{segment}/something{?parameter}");
assertThat(link.isTemplated()).isTrue(); <i class="conum" data-value="1"></i><b>(1)</b>
assertThat(link.getVariableNames()).contains("segment", "parameter"); <i class="conum" data-value="2"></i><b>(2)</b>

Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
values.put("segment", "path");
values.put("parameter", 42);

assertThat(link.expand(values).getHref()) <i class="conum" data-value="3"></i><b>(3)</b>
    .isEqualTo("/path/something?parameter=42");
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Link</code> 实例指示已被模板化,即它包含URI模板.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>它暴露了模板中包含的参数</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>它允许扩展参数.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>可以手动构造 URI 模板,稍后再添加模板变量.</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. Working with URI templates</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">UriTemplate template = UriTemplate.of("/{segment}/something")
  .with(new TemplateVariable("parameter", VariableType.REQUEST_PARAM);

assertThat(template.toString()).isEqualTo("/{segment}/something{?parameter}");
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fundamentals.link-relations"><a class="anchor" href="#fundamentals.link-relations"></a>2.3. Link 关系</h3>
<div class="paragraph">
<p>为了指示目标资源与当前的关系,使用了一种所谓的链接关系. Spring HATEOAS 提供了 <code>LinkRelation</code> 类型,可以轻松地创建基于 String 的实例.</p>
</div>
<div class="sect3">
<h4 id="fundamentals.link-relations.iana"><a class="anchor" href="#fundamentals.link-relations.iana"></a>2.3.1. IANA link 关系</h4>
<div class="paragraph">
<p>Internet 分配号码授权机构包含一组 <a href="https://www.iana.org/assignments/link-relations/link-relations.xhtml">预定义的链接关系</a>. 可以通过 <code>IanaLinkRelations</code> 引用它们.</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. Using IANA link relations</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Link link = Link.of("/some-resource"), IanaLinkRelations.NEXT);

assertThat(link.getRel()).isEqualTo(LinkRelation.of("next"));
assertThat(IanaLinkRelation.isIanaRel(link.getRel())).isTrue();
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fundamentals.representation-models"><a class="anchor" href="#fundamentals.representation-models"></a>2.4. <a id="fundamentals.resources"></a> 表示模型</h3>
<div class="paragraph">
<p>为了轻松创建丰富的超媒体表示,Spring HATEOAS 提供了一组在其根处具有 <code>RepresentationModel</code> 的类. 它基本上是用于收集链接的容器,并具有方便的方法将其添加到模型中.
以后可以将模型呈现为各种媒体类型格式,这些格式将定义超媒体元素在表示中的外观. 有关此的更多信息,请查看<a href="#mediatypes">媒体类型</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. The <code>RepresentationModel</code> class hierarchy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-diagram-classes" data-lang="diagram-classes">class RepresentationModel
class EntityModel
class CollectionModel
class PagedModel

EntityModel -|&gt; RepresentationModel
CollectionModel -|&gt; RepresentationModel
PagedModel -|&gt; CollectionModel</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>RepresentationModel</code> 的默认方法是创建其子类,以包含该表示应包含的所有属性,创建该类的实例,填充这些属性,并使用链接对其进行充实.</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. A sample representation model type</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class PersonModel extends RepresentationModel&lt;PersonModel&gt; {

  String firstname, lastname;
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要让  <code>RepresentationModel.add(…)</code>  返回其自身的实例,必须进行通用的输入.现在可以像这样使用模型类型:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. Using the person representation model</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">PersonModel model = new PersonModel();
model.firstname = "Dave";
model.lastname = "Matthews";
model.add(Link.of("https://myhost/people/42"));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您从 Spring MVC 或 WebFlux 控制器返回了这样的实例,并且客户端发送了一个  <code>Accept</code>  头集设置为 <code>application/hal+json</code>,则响应将如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. The HAL representation generated for the person representation model</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "_links" : {
    "self" : {
      "href" : "https://myhost/people/42"
    }
  },
  "firstname" : "Dave",
  "lastname" : "Matthews"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fundamentals.entity-model"><a class="anchor" href="#fundamentals.entity-model"></a>2.4.1. 模型表示子资源</h4>
<div class="paragraph">
<p>对于由单个对象或概念支持的资源,存在便利的 <code>EntityModel</code> 类型. 不必为每个概念创建自定义模型类型,您只需重用一个已经存在的类型并将其实例包装到 <code>EntityModel</code> 中即可.</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. Using <code>EntityModel</code> to wrap existing objects</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Person person = new Person("Dave", "Matthews");
EntityModel&lt;Person&gt; model = EntityModel.of(person);
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="模型表示集合资源"><a class="anchor" href="#模型表示集合资源"></a>2.4.2. 模型表示集合资源</h4>
<div class="paragraph">
<p>对于概念上是集合的资源,可以使用 <code>CollectionModel</code>. 它的元素可以是简单对象,也可以是 <code>RepresentationModel</code> 实例.</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. Using <code>CollectionModel</code> to wrap a collection of existing objects</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Collection&lt;Person&gt; people = Collections.singleton(new Person("Dave", "Matthews"));
CollectionModel&lt;Person&gt; model = CollectionModel.of(people);
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="server"><a class="anchor" href="#server"></a>3. Server-side support</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="server.link-builder.webmvc"><a class="anchor" href="#server.link-builder.webmvc"></a>3.1. <a id="fundamentals.obtaining-links"></a> <a id="fundamentals.obtaining-links.builder"></a> 在 Spring MVC 中创建 links</h3>
<div class="paragraph">
<p>虽然我们现在已经有了 domain 词汇表,但挑战仍然存在:如何以不脆弱的方式创建实际的 URI,以将其包装到 <code>Link</code> 实例中. 现在,我们将不得不在各处复制 URI 字符串. 这样做是脆弱且不可维持的.</p>
</div>
<div class="paragraph">
<p>假设您已按照以下方式实现了 Spring MVC 控制器:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
class PersonController {

  @GetMapping("/people")
  HttpEntity&lt;PersonModel&gt; showAll() { … }

  @GetMapping(value = "/{person}", method = RequestMethod.GET)
  HttpEntity&lt;PersonModel&gt; show(@PathVariable Long person) { … }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们在这里看到两个约定. 第一个是通过控制器方法的  <code>@GetMapping</code> 注解暴露的集合资源,该集合的各个元素作为直接子资源暴露. 集合资源可以在一个简单的 URI (如刚刚所示)或更复杂的 URI (例如 <code>/people/{id}/addresses</code>)中暴露. 假设您想要链接到所有人的集合资源。按照上面的方法会导致两个问题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>要创建绝对 URI,您需要查找协议,主机名,端口,Servlet 地址和其他值. 这很麻烦,并且需要手动编写字符串连接代码.</p>
</li>
<li>
<p>您可能不希望将  <code>/people</code> 连接到基本 URI 之上,因为这样就必须在多个位置维护信息. 如果更改映射,则必须更改所有指向该映射的客户端.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring HATEOAS 现在提供了一个 <code>WebMvcLinkBuilder</code>,使您可以通过指向控制器类来创建链接. 以下示例显示了如何执行此操作:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import static org.sfw.hateoas.server.mvc.WebMvcLinkBuilder.*;

</span><span class="fold-block">Link link = linkTo(PersonController.class).withRel("people");

assertThat(link.getRel()).isEqualTo(LinkRelation.of("people"));
assertThat(link.getHref()).endsWith("/people");
</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>WebMvcLinkBuilder</code> 使用 Spring 的 <code>ServletUriComponentsBuilder</code> 来从当前请求中获取基本 URI 信息. 假设您的应用程序在 <code><a href="http://localhost:8080/your-app" class="bare">localhost:8080/your-app</a></code> 上运行,那么这正是您要在其上构建其他部分的 URI.
现在,构建器将检查给定控制器类的根映射,从而以 <code><a href="http://localhost:8080/your-app/people" class="bare">localhost:8080/your-app/people</a></code> 结尾. 您还可以构建更多的嵌套链接. 以下示例显示了如何执行此操作:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Person person = new Person(1L, "Dave", "Matthews");
//                 /person                 /     1
Link link = linkTo(PersonController.class).slash(person.getId()).withSelfRel();
assertThat(link.getRel(), is(IanaLinkRelation.SELF.value()));
assertThat(link.getHref(), endsWith("/people/1"));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该构建器还允许创建 URI 实例以进行构建(例如,响应头值):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">HttpHeaders headers = new HttpHeaders();
headers.setLocation(linkTo(PersonController.class).slash(person).toUri());

return new ResponseEntity&lt;PersonModel&gt;(headers, HttpStatus.CREATED);
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fundamentals.obtaining-links.builder.methods"><a class="anchor" href="#fundamentals.obtaining-links.builder.methods"></a>3.1.1. 建立指向方法的链接</h4>
<div class="paragraph">
<p>您甚至可以建立指向方法的链接,或创建虚拟控制器方法调用. 第一种方法是将 <code>Method</code> 实例传递给 <code>WebMvcLinkBuilder</code>. 以下示例显示了如何执行此操作:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Method method = PersonController.class.getMethod("show", Long.class);
Link link = linkTo(method, 2L).withSelfRel();

assertThat(link.getHref()).endsWith("/people/2"));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这仍然有点令人不满意,因为我们必须首先获取一个 <code>Method</code> 实例,该实例会引发异常,并且通常很麻烦. 至少我们不重复映射. 更好的方法是在控制器代理上对目标方法进行伪方法调用,我们可以使用  <code>methodOn(…)</code> 帮助器创建该方法. 以下示例显示了如何执行此操作:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Link link = linkTo(methodOn(PersonController.class).show(2L)).withSelfRel();

assertThat(link.getHref()).endsWith("/people/2");
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>methodOn(…)</code> 创建记录方法调用的控制器类的代理,并在为方法的返回类型创建的代理中暴露它.这样就可以流式地表达我们希望获得映射的方法.但是,在使用这种技术可以获得的方法上有一些限制</p>
</div>
<div class="ulist">
<ul>
<li>
<p>返回类型必须能够代理,因为我们需要暴露对其的方法调用.</p>
</li>
<li>
<p>通常忽略传递给方法的参数(通过 <code>@PathVariable</code> 引用的参数除外,因为它们构成了 URI).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="server.link-builder.webflux"><a class="anchor" href="#server.link-builder.webflux"></a>3.2. 在 Spring WebFlux 中建立链接</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="server.affordances"><a class="anchor" href="#server.affordances"></a>3.3. 功能可见性</h3>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The affordances of the environment are what it offers … what it provides or furnishes, either for good or ill. The verb 'to afford' is found in the dictionary, but the noun 'affordance' is not. I have made it up.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; James J. Gibson<br>
<cite>The Ecological Approach to Visual Perception (page 126)</cite>
</div>
</div>
<div class="paragraph">
<p>基于 REST 的资源不仅提供数据,还提供一些功能. 一个具有灵活性的服务的最后一个要素是有关如何使用各种功能的详细内容. 由于功能可见性是与链接相关联的,因此 Spring HATEOAS 提供了一个 API,可以将所需的尽可能多的相关方法附加到链接上.
就像您可以通过指向 Spring MVC 控制器方法来创建链接一样(请参见在  <a href="#server.link-builder.webmvc">  在 Spring MVC 中创建 links</a>  中构建链接以了解详细信息),您&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>下面的代码显示了如何  <strong>self</strong>  链接</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. Connecting affordances to <code>GET /employees/{id}</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/employees/{id}")
public EntityModel&lt;Employee&gt; findOne(@PathVariable Integer id) {

  Class&lt;EmployeeController&gt; controllerClass = EmployeeController.class;

  // Start the affordance with the "self" link, i.e. this method.
  Link findOneLink = linkTo(methodOn(controllerClass).findOne(id)).withSelfRel(); <i class="conum" data-value="1"></i><b>(1)</b>

  // Return the affordance + a link back to the entire collection resource.
  return EntityModel.of(EMPLOYEES.get(id), //
      findOneLink //
          .andAffordance(afford(methodOn(controllerClass).updateEmployee(null, id))) <i class="conum" data-value="2"></i><b>(2)</b>
          .andAffordance(afford(methodOn(controllerClass).partiallyUpdateEmployee(null, id)))); <i class="conum" data-value="3"></i><b>(3)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建 <strong>self</strong> 链接.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>将 <code>updateEmployee</code> 方法与 <code>self</code> 链接相关联.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>将 <code>partiallyUpdateEmployee</code> 方法与 <code>self</code> 链接相关联.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>使用  <code>.andAffordance(afford(&#8230;&#8203;))</code>,您可以使用控制器的方法将 <code>PUT</code> 和 <code>PATCH</code> 操作连接到 <code>GET</code> 操作. 想象一下,上面提供的相关方法如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. <code>updateEmpoyee</code> method that responds to <code>PUT /employees/{id}</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PutMapping("/employees/{id}")
public ResponseEntity&lt;?&gt; updateEmployee( //
    @RequestBody EntityModel&lt;Employee&gt; employee, @PathVariable Integer id)
</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 15. <code>partiallyUpdateEmployee</code> method that responds to <code>PATCH /employees/{id}</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PatchMapping("/employees/{id}")
public ResponseEntity&lt;?&gt; partiallyUpdateEmployee( //
    @RequestBody EntityModel&lt;Employee&gt; employee, @PathVariable Integer id)
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>afford(…)</code> 方法指向这些方法将导致 Spring HATEOAS 分析请求正文和响应类型并捕获元数据,以允许不同的媒体类型实现使用该信息将该信息转换为输入和输出的描述.</p>
</div>
<div class="sect3">
<h4 id="server.affordances.api"><a class="anchor" href="#server.affordances.api"></a>3.3.1. 手动创建 affordances</h4>
<div class="paragraph">
<p>尽管是注册链接功能的主要方式,但可能有必要手动构建其中的一些功能. 这可以通过使用 <code>Affordances</code> API 来实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. Using the <code>Affordances</code> API to manually register affordances</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">var methodInvocation = methodOn(EmployeeController.class).all();

var link = Affordances.of(linkTo(methodInvocation).withSelfRel()) <i class="conum" data-value="1"></i><b>(1)</b>

    .afford(HttpMethod.POST) <i class="conum" data-value="2"></i><b>(2)</b>
    .withInputAndOutput(Employee.class) //
    .withName("createEmployee") //

    .andAfford(HttpMethod.GET) <i class="conum" data-value="3"></i><b>(3)</b>
    .withOutput(Employee.class) //
    .addParameters(//
        QueryParameter.optional("name"), //
        QueryParameter.optional("role")) //
    .withName("search") //

    .toLink();
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>首先,从一个 <code>Link</code> 实例创建 <code>Affordances</code> 实例,然后创建一个用于描述能力的上下文.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>每种功能都应以其应支持的HTTP方法开始. 然后,我们将类型注册为有效负载描述,并显式命名提供. 后者可以省略,并且默认名称将从HTTP方法和输入类型名称继承. 这有效地创建了与创建的  <code>EmployeeController.newEmployee(…)</code>  指针相同的能力</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>建立下一个 affordance 是为了反映指向 <code>EmployeeController.search(…)</code> 的指针发生了什么. 在这里,我们将 <code>Employee</code> 定义为创建的响应的模型,并显式注册 <code>QueryParameters</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Affordances 由媒体类型特定的 Affordances 模型支持,该模型将一般 Affordances 元数据转换为特定的表示形式. 请确保检查  <a href="#mediatypes">媒体类型</a> 部分中有关 affordances 的部分,以查找有关如何控制该元数据的显示量的更多详细信息.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="server.link-builder.forwarded-headers"><a class="anchor" href="#server.link-builder.forwarded-headers"></a>3.4. 转发报头处理</h3>
<div class="paragraph">
<p>当您的应用程序位于代理,负载均衡器之后或在云中时,最常使用 <a href="https://tools.ietf.org/html/rfc7239">RFC-7239 forwarding headers</a>. 实际接收 Web 请求的节点是基础结构的一部分,并将请求转发到您的应用程序.</p>
</div>
<div class="paragraph">
<p>您的应用程序可能正在  <code>localhost:8080</code> 上运行,但对于外界,您应该位于 <code>reallycoolsite.com</code>(和网络的标准端口80)上. 通过使代理包括额外的 header (许多人已经这样做了),Spring HATEOAS 可以正确地生成链接,因为它使用 Spring Framework 功能来获取原始请求的基本 URI</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
任何可以根据外部输入更改根 URI 的内容都必须得到适当的保护. 这就是默认情况下  <strong>disabled</strong> 转发 header 处理的原因. 您必须使它能够运行. 如果您要部署到云中或控制代理和负载均衡器的配置中,那么您肯定会希望使用此功能.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要启用转发 header 处理,您需要在应用程序中注册 Spring 的 Spring MVC 的 <code>ForwardedHeaderFilter</code>( <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#filters-forwarded-headers">详细信息</a>)或 Spring WebFlux 的 <code>ForwardedHeaderTransformer</code>(<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-embedded-container-servlets-filters-listeners-beans">详细信息</a>). 在 Spring Boot 应用程序中,这些组件可以简单地声明为 Spring Bean,如此处所述.</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. Registering a <code>ForwardedHeaderFilter</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ForwardedHeaderFilter forwardedHeaderFilter() {
    return new ForwardedHeaderFilter();
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将创建一个处理所有  <code>X-Forwarded-…</code>   header 的 servlet 过滤器. 并且它将在 servlet 处理程序中正确注册.</p>
</div>
<div class="paragraph">
<p>对于 Spring WebFlux 应用程序,reactive 对应的是 <code>ForwardedHeaderTransformer</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. Registering a <code>ForwardedHeaderTransformer</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ForwardedHeaderTransformer forwardedHeaderTransformer() {
    return new ForwardedHeaderTransformer();
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将创建一个转换响应式 Web 请求,处理 <code>X-Forwarded-…</code>  header 的函数. 并且它将在 WebFlux 中正确注册.</p>
</div>
<div class="paragraph">
<p>有了上面显示的配置,传递 <code>X-Forwarded-…</code>  header 的请求将看到那些反映在生成的链接中:</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. A request using <code>X-Forwarded-…</code> headers</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">curl -v localhost:8080/employees \
    -H 'X-Forwarded-Proto: https' \
    -H 'X-Forwarded-Host: example.com' \
    -H 'X-Forwarded-Port: 9001'</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 20. 带有生成考虑这些标题的链接的相应响应</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "_embedded": {
    "employees": [
      {
        "id": 1,
        "name": "Bilbo Baggins",
        "role": "burglar",
        "_links": {
          "self": {
            "href": "https://example.com:9001/employees/1"
          },
          "employees": {
            "href": "https://example.com:9001/employees"
          }
        }
      }
    ]
  },
  "_links": {
    "self": {
      "href": "https://example.com:9001/employees"
    },
    "root": {
      "href": "https://example.com:9001"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fundamentals.obtaining-links.entity-links"><a class="anchor" href="#fundamentals.obtaining-links.entity-links"></a>3.5. 使用 EntityLinks interface</h3>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
当前未为 Spring WebFlux 应用程序提供 <code>EntityLinks</code> 及其各种实现. <code>EntityLinks</code> SPI 中定义的合同最初是针对 Spring Web MVC 的,不考虑 Reactor 类型. 开发支持响应式编程的可比合同仍在进行中.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>到目前为止,我们已经通过指向 Web 框架实现(即 Spring MVC 控制器)创建了链接,并检查了映射. 在许多情况下,这些类实质上是读取和写入由模型类支持的表示形式.</p>
</div>
<div class="paragraph">
<p><code>EntityLinks</code> 接口现在暴露一个 API,以根据模型类型查找 <code>Link</code> 或 <code>LinkBuilder</code>. 这些方法实质上返回的链接要么指向集合资源(例如 <code>/people</code>),要么指向 item 资源(例如 <code>/people/1</code>). 以下示例显示如何使用 <code>EntityLinks</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">EntityLinks links = …;
LinkBuilder builder = links.linkFor(Customer.class);
Link link = links.linkToItemResource(Customer.class, 1L);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过在 Spring MVC 配置中激活 <code>@EnableHypermediaSupport</code>,可以通过依赖注入来使用 <code>EntityLinks</code>. 这将导致注册 <code>EntityLink</code> 的各种默认实现. 最基础的是检查 SpringMVC 控制器类的 <code>ControllerEntityLinks</code>. 如果要注册自己的 <code>EntityLinks</code> 实现,请查看 <a href="#server.entity-links.spi">本节</a>.</p>
</div>
<div class="sect3">
<h4 id="server.entity-links.controller"><a class="anchor" href="#server.entity-links.controller"></a>3.5.1. 基于 Spring MVC controllers 的 EntityLinks</h4>
<div class="paragraph">
<p>激活实体链接功能将导致检查当前 <code>ApplicationContext</code> 中可用的所有 Spring MVC 控制器的  <code>@ExposesResourceFor(…)</code>  注解. 注解暴露了控制器管理的模型类型. 除此之外,我们假设您遵守以下 URI 映射设置和约定:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>类型级别 <code>@ExposesResourceFor(…)</code> 声明控制器暴露其集合和 items 资源的实体类型.</p>
</li>
<li>
<p>表示集合资源的类级别的基本映射.</p>
</li>
<li>
<p>附加的方法级别映射,该映射扩展了映射以将标识符附加为附加的路径段.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例显示了支持 <code>EntityLinks</code> 的控制器的实现:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
@ExposesResourceFor(Order.class) <i class="conum" data-value="1"></i><b>(1)</b>
@RequestMapping("/orders") <i class="conum" data-value="2"></i><b>(2)</b>
class OrderController {

  @GetMapping <i class="conum" data-value="3"></i><b>(3)</b>
  ResponseEntity orders(…) { … }

  @GetMapping("{id}") <i class="conum" data-value="4"></i><b>(4)</b>
  ResponseEntity order(@PathVariable("id") … ) { … }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>控制器表示它正在暴露实体 <code>Order</code> 的集合和 items 资源.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>其收集资源显示在 <code>/orders</code> 下</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>该收集资源可以处理 <code>GET</code> 请求. 在方便时,为其他 HTTP 方法添加更多方法.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>一种附加的控制器方法,用于处理带有路径变量的从属资源,以暴露 items 资源,即单个 <code>Order</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>有了此功能,当您在 Spring MVC 配置中启用 <code>EntityLinks</code> <code>@EnableHypermediaSupport</code> 时,可以按以下方式创建到控制器的链接:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
class PaymentController {

  private final EntityLinks entityLinks;

  PaymentController(EntityLinks entityLinks) { <i class="conum" data-value="1"></i><b>(1)</b>
    this.entityLinks = entityLinks;
  }

  @PutMapping(…)
  ResponseEntity payment(@PathVariable Long orderId) {

    Link link = entityLinks.linkToItemResource(Order.class, orderId); <i class="conum" data-value="2"></i><b>(2)</b>
    …
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注入由 <code>EntityLinks</code> 在您的配置中提供的 <code>EntityLink</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 API 通过使用实体类型而不是控制器类来构建链接.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见,您可以引用管理 <code>Order</code> 实例的资源,而无需显式引用 <code>OrderController</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="server.entity-links.api"><a class="anchor" href="#server.entity-links.api"></a>3.5.2. EntityLinks API 细节</h4>
<div class="paragraph">
<p>从根本上讲,<code>EntityLinks</code> 允许构建 <code>LinkBuilder</code> 和 <code>Link</code> 实例以收集实体类型的集合资源和 items 资源. 以  <code>linkFor…</code>  开头的方法将为您生成 <code>LinkBuilder</code> 实例,以供您扩展和扩充其他路径段,参数等.以  <code>linkTo</code>  开头的方法将生成完全准备好的 <code>Link</code> 实例.</p>
</div>
<div class="paragraph">
<p>虽然对于收集资源而言,提供一个实体类型就足够了,但指向 items 资源的链接将需要提供一个标识符. 通常如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. Obtaining a link to an item resource</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">entityLinks.linkToItemResource(order, order.getId());
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您发现自己重复了这些方法调用,则可以将标识符提取步骤提取到可重用的  <code>Function</code>  中,以在不同的调用中重用:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Function&lt;Order, Object&gt; idExtractor = Order::getId; <i class="conum" data-value="1"></i><b>(1)</b>

entityLinks.linkToItemResource(order, idExtractor); <i class="conum" data-value="2"></i><b>(2)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>标识符提取已外部化,因此可以保存在一个字段中或保持不变.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用提取器的链接查找.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="server.entity-links.api.typed"><a class="anchor" href="#server.entity-links.api.typed"></a>TypedEntityLinks</h5>
<div class="paragraph">
<p>由于控制器的实现通常围绕实体类型进行分组,因此您经常会在整个控制器类中使用相同的提取器功能(详细信息请参见 <a href="#server.entity-links.api">EntityLinks API 细节</a> ). 通过获取一次提供提取器的 <code>TypedEntityLinks</code> 实例,我们可以进一步集中标识符提取逻辑,以便实际查找根本不再需要处理提取.</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. Using TypedEntityLinks</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class OrderController {

  private final TypedEntityLinks&lt;Order&gt; links;

  OrderController(EntityLinks entityLinks) { <i class="conum" data-value="1"></i><b>(1)</b>
    this.links = entityLinks.forType(Order::getId); <i class="conum" data-value="2"></i><b>(2)</b>
  }

  @GetMapping
  ResponseEntity&lt;Order&gt; someMethod(…) {

    Order order = … // lookup order

    Link link = links.linkToItemResource(order); <i class="conum" data-value="3"></i><b>(3)</b>
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注入 <code>EntityLinks</code> 实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>表示您要使用特定的标识符提取器功能查找 <code>Order</code> 实例.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>根据唯一的 <code>Order</code> 实例查找商品资源链接.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="server.entity-links.spi"><a class="anchor" href="#server.entity-links.spi"></a>3.5.3. EntityLinks 作为 SPI</h4>
<div class="paragraph">
<p><code>@EnableHypermediaSupport</code> 创建的 <code>EntityLinks</code> 实例的类型为 <code>DelegatingEntityLinks</code>,它将依次拾取 <code>ApplicationContext</code> 中可作为 bean 使用的所有其他 <code>EntityLinks</code> 实现. 它已注册为 primary bean,
因此通常在您注入 <code>EntityLink</code> 时始终是唯一的注入候选对象. <code>ControllerEntityLinks</code> 是设置中将包含的默认实现,但是用户可以自由实现和注册自己的实现. 使那些对 <code>EntityLinks</code> 实例可用的对象可用于注入是将实现注册为 Spring bean 的问题.</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. Declaring a custom EntityLinks implementation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
class CustomEntityLinksConfiguration {

  @Bean
  MyEntityLinks myEntityLinks(…) {
    return new MyEntityLinks(…);
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种数据可扩展性的一个例子是 Spring Data REST 的 <a href="https://github.com/spring-projects/spring-data-rest/blob/3a0cba94a2cc8739375ecf24086da2f7c3bbf038/spring-data-rest-webmvc/src/main/java/org/springframework/data/rest/webmvc/support/RepositoryEntityLinks.java"><code>RepositoryEntityLinks</code></a>,它使用存储库映射信息来创建指向由 Spring Data 存储库支持的资源的链接. 同时,它甚至暴露了其他类型资源的其他查找方法. 如果要使用这些,只需显式注入 <code>RepositoryEntityLinks</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="server.representation-model-assembler"><a class="anchor" href="#server.representation-model-assembler"></a>3.6. <a id="fundamentals.resource-assembler"></a> 表示模型汇编器</h3>
<div class="paragraph">
<p>由于必须在多个地方使用从实体到表示模型的映射,因此创建一个负责这样做的专用类是有意义的. 转换包含非常自定义的步骤,但也包含一些样板步骤:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>模型类的实例化</p>
</li>
<li>
<p>添加一个具有 <code>rel</code> of <code>self</code> 关系的链接,指向要渲染的资源</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Spring HATEOAS 现在提供了 <code>RepresentationModelAssemblerSupport</code> 基类,该基类有助于减少您需要编写的代码量. 以下示例显示了如何使用它:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class PersonModelAssembler extends RepresentationModelAssemblerSupport&lt;Person, PersonModel&gt; {

  public PersonModelAssembler() {
    super(PersonController.class, PersonModel.class);
  }

  @Override
  public PersonModel toModel(Person person) {

    PersonModel resource = createResource(person);
    // … do further mapping
    return resource;
  }
}
</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>createResource(&#8230;&#8203;)</code> 是您编写的代码,用于在给定 <code>Person</code> 对象的情况下实例化 <code>PersonModel</code> 对象. 它应该只专注于设置属性,而不是填充链接.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>像前面的示例中一样设置类,可以为您带来以下好处:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有几个 <code>createModelWithId(…)</code> 方法可让您创建资源的实例,并为它添加一个带有  <code>self</code>  属性的 <code>Link</code>, 该链接的 href 由配置的控制器的请求映射加上实体的 ID(for example, <code>/people/1</code>).</p>
</li>
<li>
<p>资源类型通过反射实例化,并且需要一个无参数的构造函数. 如果要使用专用的构造函数或避免反射性能开销,则可以重写 <code>instantiateModel(…)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>然后,您可以使用汇编器来组装 <code>RepresentationModel</code> 或 <code>CollectionModel</code>.
以下示例创建 <code>PersonModel</code> 实例的 <code>CollectionModel</code></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Person person = new Person(…);
Iterable&lt;Person&gt; people = Collections.singletonList(person);

PersonModelAssembler assembler = new PersonModelAssembler();
PersonModel model = assembler.toModel(person);
CollectionModel&lt;PersonModel&gt; model = assembler.toCollectionModel(people);
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="server.processors"><a class="anchor" href="#server.processors"></a>3.7. 表示模型处理器</h3>
<div class="paragraph">
<p>有时,您需要在 <a href="#server.representation-model-assembler">assembled</a> 超媒体表示后对其进行调整和调整.</p>
</div>
<div class="paragraph">
<p>一个完美的例子是,当您有一个负责处理订单履行的控制器,但您需要添加与付款相关的链接.</p>
</div>
<div class="paragraph">
<p>想象一下,让您的 Order 系统生产这种类型的超媒体:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "orderId" : "42",
  "state" : "AWAITING_PAYMENT",
  "_links" : {
    "self" : {
      "href" : "http://localhost/orders/999"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您希望添加一个链接,以便客户可以付款,但不想将有关 <code>PaymentController</code> 的详细信息混入 <code>OrderController</code> 中.</p>
</div>
<div class="paragraph">
<p>您可以像下面这样编写 <code>RepresentationModelProcessor</code>,而不用污染 Order 系统的详细信息:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class PaymentProcessor implements RepresentationModelProcessor&lt;EntityModel&lt;Order&gt;&gt; { <i class="conum" data-value="1"></i><b>(1)</b>

  @Override
  public EntityModel&lt;Order&gt; process(EntityModel&lt;Order&gt; model) {

    model.add( <i class="conum" data-value="2"></i><b>(2)</b>
        Link.of("/payments/{orderId}").withRel(LinkRelation.of("payments")) //
            .expand(model.getContent().getOrderId()));

    return model; <i class="conum" data-value="3"></i><b>(3)</b>
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>该处理器将仅应用于 <code>EntityModel&lt;Order&gt;</code> 对象.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>通过添加无条件链接来处理现有的 <code>EntityModel</code> 对象.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>返回 <code>EntityModel</code> 以便可以将其序列化为请求的媒体类型.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在您的应用程序中注册处理器:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class PaymentProcessingApp {

  @Bean
  PaymentProcessor paymentProcessor() {
    return new PaymentProcessor();
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在,当您发布 <code>Order</code> 的超媒体表示时,客户端会收到以下信息:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">{
  "orderId" : "42",
  "state" : "AWAITING_PAYMENT",
  "_links" : {
    "self" : {
      "href" : "http://localhost/orders/999"
    },
    "payments" : { <i class="conum" data-value="1"></i><b>(1)</b>
      "href" : "/payments/42" <i class="conum" data-value="2"></i><b>(2)</b>
    }
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>您会看到此链接的关系已插入 <code>LinkRelation.of("payments")</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>URI由处理器提供.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>这个例子很简单,但是您可以轻松地:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 <code>WebMvcLinkBuilder</code> 或 <code>WebFluxLinkBuilder</code> 构造到您的 <code>PaymentController</code> 的动态链接.</p>
</li>
<li>
<p>注入必要的服务,以有条件地添加由状态驱动的其他链接 (e.g. <code>cancel</code>, <code>amend</code>) .</p>
</li>
<li>
<p>利用诸如 Spring Security 之类的跨领域服务根据当前用户的上下文添加,删除或修改链接.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>同样,在此示例中,<code>PaymentProcessor</code> 更改提供的  <code>EntityModel&lt;Order&gt;</code>. 您也可以将其替换为另一个对象. 请注意,API 要求返回类型等于输入类型.</p>
</div>
</div>
<div class="sect2">
<h3 id="spis.rel-provider"><a class="anchor" href="#spis.rel-provider"></a>3.8. 使用 <code>LinkRelationProvider</code> API</h3>
<div class="paragraph">
<p>构建链接时,通常需要确定要用于链接的关系类型. 在大多数情况下,关系类型与(域)类型直接关联. 我们封装了详细的算法,以在LinkRelationProvider API 之后查找关系类型,该 API 使您可以确定单个资源和集合资源的关系类型. 查找关系类型的算法如下:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果使用 <code>@Relation</code>, 则使用注解中配置的值.</p>
</li>
<li>
<p>如果不是,我们默认为不使用大写字母的简单类名,再加上集合 <code>rel</code> 的附加列表. <code>List</code> for the collection <code>rel</code>.</p>
</li>
<li>
<p>如果 <a href="https://github.com/atteo/evo-inflector">EVO inflector</a> 位于类路径中,则使用复数算法提供的多个单资源 <code>rel</code>.</p>
</li>
<li>
<p>用 <code>@ExposesResourceFor</code> 注解的 <code>@Controller</code> (有关详细信息,请参见 <a href="#fundamentals.obtaining-links.entity-links">使用 EntityLinks interface</a> ) 透明地查找注解中配置的类型的关系类型,以便您可以使用 <code>LinkRelationProvider.getItemResourceRelFor(MyController.class)</code> 并获取  domain 暴露.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>使用 <code>@EnableHypermediaSupport</code> 时,<code>LinkRelationProvider</code> 自动显示为 Spring Bean. 您可以通过实现接口并依次将其暴露为 Spring bean 来插入自定义提供程序.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mediatypes"><a class="anchor" href="#mediatypes"></a>4. 媒体类型</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="mediatypes.hal"><a class="anchor" href="#mediatypes.hal"></a>4.1. HAL – Hypertext Application Language</h3>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/draft-kelly-json-hal-08">JSON Hypertext Application Language</a> 或 HAL 是不基于任何 Web 栈的最简单,使用最广泛的超媒体类型之一.</p>
</div>
<div class="paragraph">
<p>这是 Spring HATEOAS 采用的第一种基于规范的媒体类型.</p>
</div>
<div class="sect3">
<h4 id="mediatypes.hal.models"><a class="anchor" href="#mediatypes.hal.models"></a>4.1.1. 构建 HAL representation 模型</h4>
<div class="paragraph">
<p>从 Spring HATEOAS 1.1 开始, 我们提供了专用的 <code>HalModelBuilder</code>, 该模型允许通过 HAL 惯用 API 创建 <code>RepresentationModel</code> 实例.  这些是其基础假设:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>HAL representation 可以由构建 representation 中包含的 domain 字段的任意对象(实体)支持.</p>
</li>
<li>
<p>representation 可以通过各种嵌入文档来丰富, 这些文档可以是任意对象, 也可以是 HAL representation 本身(即包含嵌套的嵌入和链接). .</p>
</li>
<li>
<p>某些特定的 HAL 模式(例如预览)可以直接在 API 中使用, 这样设置 representation 的代码读起来就像你在按照这些习语描述 HAL representation 一样. .</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这是使用的 API 的示例: :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// An order
var order = new Order(…); <i class="conum" data-value="1"></i><b>(1)</b>

// The customer who placed the order
var customer = customer.findById(order.getCustomerId());

var customerLink = Link.of("/orders/{id}/customer") <i class="conum" data-value="2"></i><b>(2)</b>
  .expand(order.getId())
  .withRel("customer");

var additional = …

var model = HalModelBuilder.halModel(order)
  .preview(new CustomerSummary(customer)) <i class="conum" data-value="3"></i><b>(3)</b>
  .forLink(customerLink) <i class="conum" data-value="4"></i><b>(4)</b>
  .embed(additional) <i class="conum" data-value="5"></i><b>(5)</b>
  .link(Link.of(…, IanaLinkRelations.SELF));
  .build();
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们设置一些 domain 类型. 在本示例中,order 和 customer 具有一定的关系.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们准备了一个链接, 指向将公开 customer 详细信息的资源</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们通过提供应该在 <code>_embeddable</code> 子句中呈现的有效负载开始构建预览.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们通过提供目标链接来结束预览. 它被透明地添加到 <code>_links</code> 对象中, 它的链接关系被用作上一步中提供的对象的键.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>可以添加其他对象以显示在 <code>_embedded</code> 下.
它们所列的键来自对象关系设置. 它们可以通过  <code>@Relation</code> 或专用的 <code>LinkRelationProvider</code> 自定义它们 (see <a href="#spis.rel-provider">使用 <code>LinkRelationProvider</code> API</a> for details).</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "_links" : {
    "self" : { "href" : "…" }, <i class="conum" data-value="1"></i><b>(1)</b>
    "customer" : { "href" : "/orders/4711/customer" } <i class="conum" data-value="2"></i><b>(2)</b>
  },
  "_embedded" : {
    "customer" : { … }, <i class="conum" data-value="3"></i><b>(3)</b>
    "additional" : { … } <i class="conum" data-value="4"></i><b>(4)</b>
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>提供 <code>self</code> 链接.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>通过 <code>….preview(…).forLink(…)</code> 添加 <code>customer</code> 链接.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>提供的预览对象.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>通过 <code>….embed(…)</code> 提供其他元素.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在 HAL 中, <code>_embedded</code> 也用于表示顶级集合.  通常将它们归类为根据对象类型得出的链接关系.  即 HAL中的订单清单如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "_embedded" : {
    "orders : [
      … <i class="conum" data-value="1"></i><b>(1)</b>
    ]
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Individual order documents go here.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>创建这样的表示很简单:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Collection&lt;Order&gt; orders = …;

HalModelBuilder.emptyHalDocument()
  .embed(orders);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>也就是说, 如果 Order 为空, 则无法扩展链接关系以显示在 <code>_embedded</code> 内部, 因此, 如果集合为空, 则文档将保持为空.</p>
</div>
<div class="paragraph">
<p>如果您希望显式地传递一个空集合, 则可以将类型传递给采用 <code>Collection</code> 的 <code>….embed(…)</code>  方法的重载.  如果传递给该方法的集合为空, 则将导致使用其链接关系从给定类型扩展的字段呈现.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">HalModelBuilder.emptyHalModel()
  .embed(Collections.emptyList(), Order.class);
  // or
  .embed(Collections.emptyList(), LinkRelation.of("orders"));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>将创建以下更明确的表示形式.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "_embedded" : {
    "orders" : []
  }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mediatypes.hal.configuration"><a class="anchor" href="#mediatypes.hal.configuration"></a>4.1.2. 配置链接渲染</h4>
<div class="paragraph">
<p>在HAL中,<code>_links</code> 是一个 JSON 对象. 属性名称是 <a href="#fundamentals.link-relations">link relations</a>,每个值都是https://tools.ietf.org/html/draft-kelly-json-hal-07#section-4.1.1[链接对象或链接对象数组].</p>
</div>
<div class="paragraph">
<p>对于具有两个或多个链接的给定链接关系,规范在表示形式上很明确:</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. HAL document with two links associated with one relation</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "_links": {
    "item": [
      { "href": "https://myhost/cart/42" },
      { "href": "https://myhost/inventory/12" }
    ]
  },
  "customer": "Dave Matthews"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是,如果给定关系只有一个链接,则说明是不明确的. 您可以将其渲染为单个对象或单个 item 数组.</p>
</div>
<div class="paragraph">
<p>默认情况下,Spring HATEOAS 使用最简洁的方法并呈现如下所示的单链接关系:</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. HAL document with single link rendered as an object</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "_links": {
    "item": { "href": "https://myhost/inventory/12" }
  },
  "customer": "Dave Matthews"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一些用户更喜欢在使用 HAL 时不在数组和对象之间切换.他们更喜欢这种类型的渲染:</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. HAL with single link rendered as an array</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "_links": {
    "item": [{ "href": "https://myhost/inventory/12" }]
  },
  "customer": "Dave Matthews"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您希望自定义此策略,则要做的就是将 <code>HalConfiguration</code> bean注入应用程序配置中. 有多种选择.</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. Global HAL single-link rendering policy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">@Bean
public HalConfiguration globalPolicy() {
    return new HalConfiguration() //
            .withRenderSingleLinks(RenderSingleLinks.AS_ARRAY); <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>通过将所有单链接关系呈现为数组来覆盖 Spring HATEOAS 的默认设置.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您只想重写某些特定的链接关系,则可以创建如下的 <code>HalConfiguration</code> bean:</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. Link relation-based HAL single-link rendering policy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">@Bean
public HalConfiguration linkRelationBasedPolicy() {
    return new HalConfiguration() //
            .withRenderSingleLinksFor( //
                    IanaLinkRelations.ITEM, RenderSingleLinks.AS_ARRAY) <i class="conum" data-value="1"></i><b>(1)</b>
            .withRenderSingleLinksFor( //
                    LinkRelation.of("prev"), RenderSingleLinks.AS_SINGLE); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>始终将 <code>item</code> link 关系呈现为数组.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>当只有一个链接时,将 <code>prev</code> 链接关系呈现为一个对象.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果这些都不符合您的需求,则可以使用 Ant 样式的路径模式:</p>
</div>
<div class="exampleblock">
<div class="title">Example 29. Pattern-based HAL single-link rendering policy</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">@Bean
public HalConfiguration patternBasedPolicy() {
    return new HalConfiguration() //
            .withRenderSingleLinksFor( //
                    "http*", RenderSingleLinks.AS_ARRAY); <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将以 <code>http</code> 开头的所有链接关系呈现为数组.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
基于模式的方法使用 Spring 的 <code>AntPathMatcher</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>所有这些 <code>HalConfiguration</code> 凋零都可以组合形成一项全面的策略. 确保对您的 API 进行广泛测试,以免出现意外情况.</p>
</div>
</div>
<div class="sect3">
<h4 id="mediatypes.hal.i18n"><a class="anchor" href="#mediatypes.hal.i18n"></a>4.1.3. 链接标题国际化</h4>
<div class="paragraph">
<p>HAL为其链接对象定义  <code>title</code> 属性. 可以使用 Spring 的资源包抽象和名为 <code>rest-messages</code> 的资源包来填充这些标题,以便客户端可以在其 UI 中直接使用它们. 该捆绑包将自动设置,并在 HAL 链接序列化期间使用.</p>
</div>
<div class="paragraph">
<p>要定义链接的标题,请使用密钥模板  <code>_links.$relationName.title</code> ,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 30. A sample <code>rest-messages.properties</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>_links.cancel.title=Cancel order
_links.payment.title=Proceed to checkout</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将导致以下 HAL 表示形式:</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. A sample HAL document with link titles defined</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "_links" : {
    "cancel" : {
      "href" : "…"
      "title" : "Cancel order"
    },
    "payment" : {
      "href" : "…"
      "title" : "Proceed to checkout"
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mediatypes.hal.curie-provider"><a class="anchor" href="#mediatypes.hal.curie-provider"></a>4.1.4. <a id="spis.curie-provider"></a> 使用 <code>CurieProvider</code> API</h4>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc8288#section-2.1">Web Linking RFC</a> 描述了注册和扩展链接关系类型. 已注册的 rels 是在 <a href="https://www.iana.org/assignments/link-relations/link-relations.xhtml">IANA registry of link relation types</a>
中注册的众所周知的字符串. 不希望注册关系类型的应用程序可以使用扩展 <code>rel</code>  URI. 每个都是唯一标识关系类型的 URI. <code>rel</code> URI 可以序列化为紧凑URI或 <a href="https://www.w3.org/TR/curie">Curie</a>.
例如,如果 <code>ex</code> 定义为 <code><a href="https://example.com/rels/{rel}" class="bare">example.com/rels/{rel}</a></code>.,则  <code>ex:persons</code>  curie 代表链接关系类型 <code><a href="https://example.com/rels/persons" class="bare">example.com/rels/persons</a></code>. 如果使用 <code>curies</code>,则基本URI必须存在于响应范围中.</p>
</div>
<div class="paragraph">
<p>默认的 <code>RelProvider</code> 创建的 <code>rel</code> 值是扩展关系类型,因此,必须是 URI,这会导致很多开销. <code>CurieProvider</code> API 可以解决此问题:它使您可以将基 本URI 定义为 URI 模板,并定义代表该基本 URI 的前缀. 如果存在 <code>CurieProvider</code>,则 <code>RelProvider</code> 会在所有 <code>rel</code> 值之前添加居里前缀.
此外,还会将 curies 链接自动添加到HAL资源.</p>
</div>
<div class="paragraph">
<p>以下配置定义了默认的 curie 提供程序:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebMvc
@EnableHypermediaSupport(type= {HypermediaType.HAL})
public class Config {

  @Bean
  public CurieProvider curieProvider() {
    return new DefaultCurieProvider("ex", new UriTemplate("https://www.example.com/rels/{rel}"));
  }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>请注意,现在 <code>ex:</code> 前缀会自动出现在所有未向IANA注册的 rel 值之前,例如  <code>ex:orders</code>. 客户可以使用 <code>curies</code> 链接将 Curie 解析为完整表单. 以下示例显示了如何执行此操作:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "_links": {
    "self": {
      "href": "https://myhost/person/1"
    },
    "curies": {
      "name": "ex",
      "href": "https://example.com/rels/{rel}",
      "templated": true
    },
    "ex:orders": {
      "href": "https://myhost/person/1/orders"
    }
  },
  "firstname": "Dave",
  "lastname": "Matthews"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于 <code>CurieProvider</code> API的目的是允许自动创建居里文件,因此每个应用程序范围只能定义一个 <code>CurieProvider</code> bean.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mediatypes.hal-forms"><a class="anchor" href="#mediatypes.hal-forms"></a>4.2. HAL-FORMS</h3>
<div class="paragraph">
<p><a href="https://rwcbook.github.io/hal-forms/" target="_blank" rel="noopener">HAL-FORMS</a> 旨在向 <a href="#mediatypes.hal">HAL media type</a> 添加运行时 form 支持 .</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>HAL-FORMS "looks like HAL." However, it is important to keep in mind that HAL-FORMS is not the same as HAL—the two
should not be thought of as interchangeable in any way.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Mike Amundsen<br>
<cite>HAL-FORMS spec</cite>
</div>
</div>
<div class="paragraph">
<p>要启用此媒体类型,请将以下配置放入代码中:</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. HAL-FORMS enabled application</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableHypermediaSupport(type = HypermediaType.HAL_FORMS)
public class HalFormsApplication {

}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>每当客户端提供带有  <code>application/prs.hal-forms+json</code> 的 <code>Accept</code> 请求头时,您都可以期待这样的事情:</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. HAL-FORMS sample document</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "firstName" : "Frodo",
  "lastName" : "Baggins",
  "role" : "ring bearer",
  "_links" : {
    "self" : {
      "href" : "http://localhost:8080/employees/1"
    }
  },
  "_templates" : {
    "default" : {
      "method" : "put",
      "contentType" : "",
      "properties" : [ {
        "name" : "firstName",
        "required" : true
      }, {
        "name" : "lastName",
        "required" : true
      }, {
        "name" : "role",
        "required" : true
      } ]
    },
    "partiallyUpdateEmployee" : {
      "method" : "patch",
      "contentType" : "",
      "properties" : [ {
        "name" : "firstName",
        "required" : false
      }, {
        "name" : "lastName",
        "required" : false
      }, {
        "name" : "role",
        "required" : false
      } ]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>查看 <a href="https://rwcbook.github.io/hal-forms/">HAL-FORMS 规范</a> 以了解  <strong>_templates</strong>  属性的详细信息. 阅读有关 <a href="#server.affordances">Affordances API</a>  的信息,以通过这些额外的元数据来扩充您的控制器.</p>
</div>
<div class="paragraph">
<p>对于单项(<code>EntityModel</code>)和聚合根集合(<code>CollectionModel</code>),Spring HATEOAS使其呈现与 <a href="#mediatypes.hal">HAL 文档</a>相同.</p>
</div>
<div class="sect3">
<h4 id="mediatypes.hal-forms.metadata"><a class="anchor" href="#mediatypes.hal-forms.metadata"></a>4.2.1. 定义 HAL-FORMS 元数据</h4>
<div class="paragraph">
<p>HAL-FORMS 允许描述每个表单字段的标准. Spring HATEOAS 可以通过调整输入和输出类型的模型类型并在其上使用注解来自定义它们.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;">
<col style="width: 80%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Attribute</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>readOnly</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果该属性没有设置方法,则设置为 <code>true</code>.如果存在,请在访问器或字段上明确使用 Jackson 的 <code>@JsonProperty(Access.READ_ONLY)</code>.默认情况下不呈现,因此默认为 <code>false</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>regex</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以通过在字段或类型上使用 JSR-303 的 <code>@Pattern</code> 注解进行自定义.对于后者,该模式将用于声明为该特定类型的每个属性.默认情况下不呈现.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>required</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可以使用 JSR-303 的 <code>@NotNull</code> 进行自定义.默认情况下不呈现,因此默认为 <code>false</code>.使用 <code>PATCH</code> 作为方法的模板将自动将所有属性设置为不需要.</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>对于无法手动注解的类型,可以通过应用程序上下文中存在的 <code>HalFormsConfiguration</code> bean注册自定义模式.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
class CustomConfiguration {

  @Bean
  HalFormsConfiguration halFormsConfiguration() {

    HalFormsConfiguration configuration = new HalFormsConfiguration();
    configuration.registerPatternFor(CreditCardNumber.class, "[0-9]{16}");
  }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>此设置将使 <code>CreditCardNumber</code> 类型的表示模型属性的 HAL-FORMS 模板属性声明值为  <code>[0-9]{16}</code> 的正则表达式字段.</p>
</div>
</div>
<div class="sect3">
<h4 id="mediatypes.hal-forms.i18n"><a class="anchor" href="#mediatypes.hal-forms.i18n"></a>4.2.2. 表单属性的国际化</h4>
<div class="paragraph">
<p>HAL-FORMS 包含用于人工解释的属性,例如模板的标题或属性提示. 可以使用 Spring 的资源包支持和默认情况下由 Spring HATEOAS 配置的  <code>rest-messages</code> 资源包来定义和国际化它们.</p>
</div>
<div class="sect4">
<h5 id="template-titles"><a class="anchor" href="#template-titles"></a>Template titles</h5>
<div class="paragraph">
<p>要定义模板标题,请使用以下模式: <code>_templates.$affordanceName.title</code>. 请注意,在 HAL-FORMS 中,如果模板名称是唯一的,则它是默认名称. 这意味着您通常必须使用能力描述的本地或完全限定的输入类型名称来限定键.</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. Defining HAL-FORMS template titles</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>_templates.default.title=Some title <i class="conum" data-value="1"></i><b>(1)</b>
_templates.putEmployee.title=Create employee <i class="conum" data-value="2"></i><b>(2)</b>
Employee._templates.default.title=Create employee <i class="conum" data-value="3"></i><b>(3)</b>
com.acme.Employee._templates.default.title=Create employee <i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用默认键作为标题的全局定义.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用实际可得名称作为关键字的标题的全局定义. 除非在创建提供者时明确定义,否则默认为  <code>$httpMethod + $simpleInputTypeName</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>本地定义的标题将应用于名为 <code>Employee</code> 的所有类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用完全限定的类型名称的标题定义.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
使用实际可负担名称的密钥优先于默认密钥.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="属性提示"><a class="anchor" href="#属性提示"></a>属性提示</h5>
<div class="paragraph">
<p>还可以通过 Spring HATEOAS 自动配置的  <code>rest-messages</code> 资源包来解决属性提示. 这些密钥可以全局,本地或完全定义,并且需要一个  <code>._prompt</code>  链接到实际的属性密钥</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. Defining prompts for an <code>email</code> property</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>firstName._prompt=Firstname <i class="conum" data-value="1"></i><b>(1)</b>
Employee.firstName._prompt=Firstname <i class="conum" data-value="2"></i><b>(2)</b>
com.acme.Employee.firstName._prompt=Firstname <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>所有名为 <code>firstName</code> 的属性都将呈现 <code>Firstname</code>,而与声明它们的类型无关.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>类型为 <code>Employee</code> 的 <code>firstName</code> 属性将提示 <code>Firstname</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>com.acme.Employee</code> 的 <code>firstName</code> 属性将获得分配的  <code>Firstname</code> 提示.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>定义了模板标题和属性提示的示例文档将如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. 带有国际化模板标题和属性提示的 HAL-FORMS 文档示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{
  …,
  "_templates" : {
    "default" : {
      "title" : "Create employee",
      "method" : "put",
      "contentType" : "",
      "properties" : [ {
        "name" : "firstName",
        "prompt" : "Firstname",
        "required" : true
      }, {
        "name" : "lastName",
        "prompt" : "Lastname",
        "required" : true
      }, {
        "name" : "role",
        "prompt" : "Role",
        "required" : true
      } ]
    }
  }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mediatypes.http-problem"><a class="anchor" href="#mediatypes.http-problem"></a>4.3. HTTP Problem Details</h3>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc7807">Problem Details for HTTP APIs</a> 是一种媒体类型, 用于在 HTTP 响应中携带机器可读的错误详细信息, 以避免需要为 HTTP API 定义新的错误响应格式.</p>
</div>
<div class="paragraph">
<p>HTTP Problem Details 定义了一组 JSON 属性, 这些属性包含其他信息以向 HTTP 客户端描述错误详细信息.  在 <a href="https://tools.ietf.org/html/rfc7807#section-3.1">RFC document</a> 的相关部分中找到有关这些属性的更多详细信息.</p>
</div>
<div class="paragraph">
<p>您可以通过在 Spring MVC Controller 中使用 <code>Problem</code> 媒体类型 domain 类型来创建这样的 JSON 响应:</p>
</div>
<div class="listingblock">
<div class="title">Reporting problem details using Spring HATEOAS' <code>Problem</code> type</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RestController
class PaymentController {

    @PutMapping
    ResponseEntity&lt;?&gt; issuePayment(@RequestBody PaymentRequest request) {

        PaymentResult result = payments.issuePayment(request.orderId, request.amount);

        if (result.isSuccess()) {
            return ResponseEntity.ok(result);
        }

        String title = messages.getMessage("payment.out-of-credit");
        String detail = messages.getMessage("payment.out-of-credit.details", //
                new Object[] { result.getBalance(), result.getCost() });

        Problem problem = Problem.create() <i class="conum" data-value="1"></i><b>(1)</b>
                .withType(OUT_OF_CREDIT_URI) //
                .withTitle(title) <i class="conum" data-value="2"></i><b>(2)</b>
                .withDetail(detail) //
                .withInstance(PAYMENT_ERROR_INSTANCE.expand(result.getPaymentId())) //
                .withProperties(map -&gt; { <i class="conum" data-value="3"></i><b>(3)</b>
                    map.put("balance", result.getBalance());
                    map.put("accounts", Arrays.asList( //
                            ACCOUNTS.expand(result.getSourceAccountId()), //
                            ACCOUNTS.expand(result.getTargetAccountId()) //
                    ));
                });

        return ResponseEntity.status(HttpStatus.FORBIDDEN) //
                .body(problem);
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>首先, 使用公开的工厂方法创建 <code>Problem</code>  的实例. .</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>您可以定义由媒体类型定义的默认属性的值, 例如 使用 Spring 国际化功能的 URI 类型, 标题和详细信息 (请参见上文) .</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>可以通过 Map 或显式对象添加自定义属性 (请参见下文) .</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要将专用对象用于自定义属性, 请声明一个类型, 创建并填充其实例, 然后通过  <code>….withProperties(…)</code>  或在通过 <code>Problem.create(…)</code> 创建实例时将其移入 <code>Problem</code> 实例.</p>
</div>
<div class="listingblock">
<div class="title">Using a dedicated type to capture extended problem properties</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">class AccountDetails {
    int balance;
    List&lt;URI&gt; accounts;
}

problem.withProperties(result.getDetails());

// or

Problem.create(result.getDetails());
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将导致如下所示的响应:</p>
</div>
<div class="listingblock">
<div class="title">A sample HTTP Problem Details response</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">{
  "type": "https://example.com/probs/out-of-credit",
  "title": "You do not have enough credit.",
  "detail": "Your current balance is 30, but that costs 50.",
  "instance": "/account/12345/msgs/abc",
  "balance": 30,
  "accounts": ["/account/12345",
               "/account/67890"]
}
</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mediatypes.collection-json"><a class="anchor" href="#mediatypes.collection-json"></a>4.4. Collection+JSON</h3>
<div class="paragraph">
<p><a href="http://amundsen.com/media-types/collection/format/" target="_blank" rel="noopener">Collection+JSON</a> 是向IANA批准的媒体类型 <code>application/vnd.collection+json</code> 注册的JSON规范.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><a href="http://amundsen.com/media-types/collection/" target="_blank" rel="noopener">Collection+JSON</a> is a JSON-based read/write hypermedia-type designed to support
management and querying of simple collections.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Mike Amundsen<br>
<cite>Collection+JSON spec</cite>
</div>
</div>
<div class="paragraph">
<p>Collection+JSON 提供了一种统一的方式来表示单个 item 资源和集合.要启用此媒体类型,请将以下配置放入代码中:</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. Collection+JSON enabled application</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableHypermediaSupport(type = HypermediaType.COLLECTION_JSON)
public class CollectionJsonApplication {

}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此配置将使您的应用程序响应具有 <code>application/vnd.collection+json</code> 的 <code>Accept</code> 请求头的请求,如下所示.</p>
</div>
<div class="paragraph">
<p>规格中的以下示例显示了一个 item</p>
</div>
<div class="exampleblock">
<div class="title">Example 38. Collection+JSON single item example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "collection": {
    "version": "1.0",
    "href": "https://example.org/friends/", <i class="conum" data-value="1"></i><b>(1)</b>
    "links": [   <i class="conum" data-value="2"></i><b>(2)</b>
      {
        "rel": "feed",
        "href": "https://example.org/friends/rss"
      },
      {
        "rel": "queries",
        "href": "https://example.org/friends/?queries"
      },
      {
        "rel": "template",
        "href": "https://example.org/friends/?template"
      }
    ],
    "items": [  <i class="conum" data-value="3"></i><b>(3)</b>
      {
        "href": "https://example.org/friends/jdoe",
        "data": [  <i class="conum" data-value="4"></i><b>(4)</b>
          {
            "name": "fullname",
            "value": "J. Doe",
            "prompt": "Full Name"
          },
          {
            "name": "email",
            "value": "jdoe@example.org",
            "prompt": "Email"
          }
        ],
        "links": [ <i class="conum" data-value="5"></i><b>(5)</b>
          {
            "rel": "blog",
            "href": "https://examples.org/blogs/jdoe",
            "prompt": "Blog"
          },
          {
            "rel": "avatar",
            "href": "https://examples.org/images/jdoe",
            "prompt": "Avatar",
            "render": "image"
          }
        ]
      }
    ]
  }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>self</code> 链接存储在文档的 <code>href</code> 属性.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>该文档的顶部  <code>links</code> 部分包含集合级链接(减去 <code>self</code> 链接)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>items</code> 部分包含数据集合,由于这是一个单项文档,因此只有一个条目.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>data</code> 部分包含实际内容. 它由属性组成.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>该 items 的各个 <code>links</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>先前的片段已从规格中删除. 当 Spring HATEOAS 呈现 <code>EntityModel</code> 时,它将:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将 <code>self</code> 链接置于文档的 <code>href</code> 属性和 items 级 <code>href</code> 属性.</p>
</li>
<li>
<p>将模型的其余链接放在顶级 <code>links</code> 和 items 级别  <code>links</code> 中.</p>
</li>
<li>
<p>从EntityModel中提取属性并将其转换为…</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>呈现资源集合时,文档几乎相同,除了在 <code>items</code>  JSON数组项中有多个条目,每个条目一个.</p>
</div>
<div class="paragraph">
<p>Spring HATEOAS 更具体地将:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将整个集合的 <code>self</code> 放入顶级 <code>href</code> 属性.</p>
</li>
<li>
<p><code>CollectionModel</code> 链接(减去 <code>self</code>)将放入顶级 <code>links</code>.</p>
</li>
<li>
<p>每个 items 级别的 <code>href</code> 都将包含 <code>CollectionModel.content</code> 集合中每个条目的相应 <code>self</code> 链接.</p>
</li>
<li>
<p>每个 items 级  <code>links</code>  将包含 <code>CollectionModel.content</code> 每个条目的所有其他链接..</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="mediatypes.uber"><a class="anchor" href="#mediatypes.uber"></a>4.5. UBER - 交换代表的统一依据</h3>
<div class="paragraph">
<p><a href="https://rawgit.com/uber-hypermedia/specification/master/uber-hypermedia.html" target="_blank" rel="noopener">UBER</a> is an experimental JSON spec</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>The UBER document format is a minimal read/write hypermedia type designed to support simple state transfers and ad-hoc
hypermedia-based transitions.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Mike Amundsen<br>
<cite>UBER spec</cite>
</div>
</div>
<div class="paragraph">
<p>UBER 提供了一种统一的方式来表示单个 item 资源和集合.要启用此媒体类型,请将以下配置放入代码中:</p>
</div>
<div class="exampleblock">
<div class="title">Example 39. UBER+JSON enabled application</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableHypermediaSupport(type = HypermediaType.UBER)
public class UberApplication {

}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此配置将使您的应用程序使用 <code>Accept</code> 请求头  <code>application/vnd.amundsen-uber+json</code> 响应请求,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. UBER sample document</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{
  "uber" : {
    "version" : "1.0",
    "data" : [ {
      "rel" : [ "self" ],
      "url" : "/employees/1"
    }, {
      "name" : "employee",
      "data" : [ {
        "name" : "role",
        "value" : "ring bearer"
      }, {
        "name" : "name",
        "value" : "Frodo"
      } ]
    } ]
  }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此媒体类型以及规范本身仍在开发中.如果您在使用票时遇到问题,请随时 <a href="https://github.com/spring-projects/spring-hateoas/issues" target="_blank" rel="noopener">open a ticket</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<strong>UBER media type</strong> 媒体类型与 <strong>Uber Technologies Inc.</strong> 公司没有任何关联.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="mediatypes.alps"><a class="anchor" href="#mediatypes.alps"></a>4.6. ALPS - Application-Level Profile Semantics</h3>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/draft-amundsen-richardson-foster-alps-01" target="_blank" rel="noopener">ALPS</a> 是一种媒体类型,用于提供有关另一个资源的基于配置文件的元数据.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>An ALPS document can be used as a profile to
explain the application semantics of a document with an application-
agnostic media type (such as HTML, HAL, Collection+JSON, Siren,
etc.).  This increases the reusability of profile documents across
media types.</p>
</div>
</blockquote>
<div class="attribution">
&#8212; Mike Amundsen<br>
<cite>ALPS spec</cite>
</div>
</div>
<div class="paragraph">
<p>ALPS 不需要特殊激活.相反,您可以  "build"   <code>Alps</code> 记录,并从 Spring MVC 或 Spring WebFlux Web 方法返回它,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. Building an <code>Alps</code> record</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping(value = "/profile", produces = ALPS_JSON_VALUE)
Alps profile() {

  return Alps.alps() //
      .doc(doc() //
          .href("https://example.org/samples/full/doc.html") //
          .value("value goes here") //
          .format(Format.TEXT) //
          .build()) //
      .descriptor(getExposedProperties(Employee.class).stream() //
          .map(property -&gt; Descriptor.builder() //
              .id("class field [" + property.getName() + "]") //
              .name(property.getName()) //
              .type(Type.SEMANTIC) //
              .ext(Ext.builder() //
                  .id("ext [" + property.getName() + "]") //
                  .href("https://example.org/samples/ext/" + property.getName()) //
                  .value("value goes here") //
                  .build()) //
              .rt("rt for [" + property.getName() + "]") //
              .descriptor(Collections.singletonList(Descriptor.builder().id("embedded").build())) //
              .build()) //
          .collect(Collectors.toList()))
      .build();
}
</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>本示例利用 <code>PropertyUtils.getExposedProperties()</code>  提取有关域对象属性的元数据.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>此片段已插入测试数据.它会生成如下所示的JSON:</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. ALPS JSON</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>{
  "version": "1.0",
  "doc": {
    "format": "TEXT",
    "href": "https://example.org/samples/full/doc.html",
    "value": "value goes here"
  },
  "descriptor": [
    {
      "id": "class field [name]",
      "name": "name",
      "type": "SEMANTIC",
      "descriptor": [
        {
          "id": "embedded"
        }
      ],
      "ext": {
        "id": "ext [name]",
        "href": "https://example.org/samples/ext/name",
        "value": "value goes here"
      },
      "rt": "rt for [name]"
    },
    {
      "id": "class field [role]",
      "name": "role",
      "type": "SEMANTIC",
      "descriptor": [
        {
          "id": "embedded"
        }
      ],
      "ext": {
        "id": "ext [role]",
        "href": "https://example.org/samples/ext/role",
        "value": "value goes here"
      },
      "rt": "rt for [role]"
    }
  ]
}</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以手动编写它们,而不必将每个字段"自动”链接到域对象的字段. 也可以使用 Spring Framework 的消息包和 <code>MessageSource</code> 界面. 这使您能够将这些值委托给特定于区域设置的消息束,甚至可以使元数据国际化.</p>
</div>
</div>
<div class="sect2">
<h3 id="mediatypes.community"><a class="anchor" href="#mediatypes.community"></a>4.7. 基于社区的媒体类型</h3>
<div class="paragraph">
<p>由于能够 <a href="#mediatypes.custom">创建自己的媒体类型</a> , 因此社区做出了许多努力来构建其他媒体类型.</p>
</div>
<div class="sect3">
<h4 id="mediatypes.community.json:api"><a class="anchor" href="#mediatypes.community.json:api"></a>4.7.1. JSON:API</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://jsonapi.org">Specification</a></p>
</li>
<li>
<p>Media type designation: <code>application/vnd.api+json</code></p>
</li>
<li>
<p>Latest Release</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://toedter.github.io/spring-hateoas-jsonapi/release/reference/index.html">Reference documentation</a></p>
</li>
<li>
<p><a href="https://toedter.github.io/spring-hateoas-jsonapi/release/api/index.html">API documentation</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>Current Snapshot</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://toedter.github.io/spring-hateoas-jsonapi/snapshot/reference/index.html">Reference documentation</a></p>
</li>
<li>
<p><a href="https://toedter.github.io/spring-hateoas-jsonapi/snapshot/api/index.html">API documentation</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="https://github.com/toedter/spring-hateoas-jsonapi">Source</a></p>
</li>
<li>
<p>Project Lead: <a href="https://github.com/toedter">Kai Toedter</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Maven coordinates</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.toedter&lt;/groupId&gt;
    &lt;artifactId&gt;spring-hateoas-jsonapi&lt;/artifactId&gt;
    &lt;version&gt;{see project page for current version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle coordinates</div>
<div class="content">
<pre class="highlight"><code>implementation 'com.toedter:spring-hateoas-jsonapi:{see project page for current version}'</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要快照版本, 请访问项目页面以获取更多详细信息.</p>
</div>
</div>
<div class="sect3">
<h4 id="mediatypes.community.siren"><a class="anchor" href="#mediatypes.community.siren"></a>4.7.2. Siren</h4>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/kevinswiber/siren">Specification</a></p>
</li>
<li>
<p>Media type designation: <code>application/vnd.siren+json</code></p>
</li>
<li>
<p><a href="https://spring-hateoas-siren.ingogriebsch.de">Reference documentation</a></p>
</li>
<li>
<p><a href="https://spring-hateoas-siren.ingogriebsch.de/apidocs">javadocs</a></p>
</li>
<li>
<p><a href="https://github.com/ingogriebsch/spring-hateoas-siren">Source</a></p>
</li>
<li>
<p>Project Lead: <a href="https://github.com/ingogriebsch">Ingo Griebsch</a></p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="title">Maven coordinates</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;de.ingogriebsch.hateoas&lt;/groupId&gt;
    &lt;artifactId&gt;spring-hateoas-siren&lt;/artifactId&gt;
    &lt;version&gt;{see project page for current version}&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Gradle coordinates</div>
<div class="content">
<pre class="highlight"><code>implementation 'de.ingogriebsch.hateoas:spring-hateoas-siren:{see project page for current version}'</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mediatypes.custom"><a class="anchor" href="#mediatypes.custom"></a>4.8. 注册自定义媒体类型</h3>
<div class="paragraph">
<p>Spring HATEOAS 允许通过第三方可以实现的一组 SPI 集成对自定义媒体类型的支持. 这样的实现的构造块是:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>某种形式的 Jackson ObjectMapper 定制. 在最简单的情况下,这就是 Jackson 模块的实现.</p>
</li>
<li>
<p><code>LinkDiscoverer</code> 实现,以便客户端支持能够检测生成的表示形式中的链接.</p>
</li>
<li>
<p>一些配置基础结构将允许 Spring HATEOAS 查找自定义实现并选择其配置.</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="mediatypes.custom.configuration"><a class="anchor" href="#mediatypes.custom.configuration"></a>4.8.1. 自定义媒体类型配置</h4>
<div class="paragraph">
<p>Spring HATEOAS 通过扫描应用程序上下文中是否有 <code>HypermediaMappingInformation</code> 接口的任何实现, 来获取自定义媒体类型的实现. 每种媒体类型都必须实现此接口, 以便:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>应用于 <code>WebClient</code>, <code>WebTestClient</code> 或 <code>RestTemplate</code> 实例.</p>
</li>
<li>
<p>支持从 Spring Web MVC 和 Spring WebFlux 控制器提供该媒体类型的服务.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>定义自己的媒体类型看起来像这样简单:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class MyMediaTypeConfiguration implements HypermediaMappingInformation {

  @Override
  public List&lt;MediaType&gt; getMediaTypes() {
    return MediaType.parse("application/vnd-acme-media-type") <i class="conum" data-value="1"></i><b>(1)</b>
  }

  @Override
  public Module getJacksonModule() {
    return new Jackson2MyMediaTypeModule(); <i class="conum" data-value="2"></i><b>(2)</b>
  }

  @Bean
  MyLinkDiscoverer myLinkDiscoverer() {
    return new MyLinkDiscoverer(); <i class="conum" data-value="3"></i><b>(3)</b>
  }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>配置类返回它支持的媒体类型.  这适用于服务器端和客户端方案. .</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>它重写 <code>getJacksonModule()</code> 以提供自定义序列化程序来创建特定于媒体类型的表示形式.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>它还声明了用于客户端支持的自定义 <code>LinkDiscoverer</code> 实现, 以提供进一步的客户端支持.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Jackson 模块通常为表示模型类型 <code>RepresentationModel</code>,<code>EntityModel</code>,<code>CollectionModel</code> 和 <code>PagedModel</code> 声明 <code>Serializer</code> 和 <code>Deserializer</code> 实现. 如果您需要进一步自定义 Jackson 的 ObjectMapper(如自定义的 <code>HandlerInstantiator</code>),
则可以替代重写 <code>configureObjectMapper(…)</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>之前的参考文档提到了实现 <code>MediaTypeConfigurationProvider</code> 接口并将其注册到 <code>spring.factories</code> 中.  这不是必需的.  该 SPI 仅用于 Spring HATEOAS 提供的现成的媒体类型.  只需要实现 <code>HypermediaMappingInformation</code> 接口并将其注册为 Spring bean.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mediatypes.custom.recommendation"><a class="anchor" href="#mediatypes.custom.recommendation"></a>4.8.2. 建议</h4>
<div class="paragraph">
<p>实现媒体类型表示的首选方法是通过提供与预期格式匹配的类型层次结构,并且可以由 Jackson 进行序列化. 在为 <code>RepresentationModel</code> 注册的序列化器和反序列化器实现中,将实例转换为特定于媒体类型的模型类型,然后为这些实例查找 Jackson 序列化器.</p>
</div>
<div class="paragraph">
<p>默认情况下支持的媒体类型使用与第三方实现相同的配置机制.因此,值得研究  <a href="https://github.com/spring-projects/spring-hateoas/tree/master/src/main/java/org/springframework/hateoas/mediatype"> <code>mediatype</code> 包</a> 中的实现.
请注意, 内置媒体类型实现通过 <code>@EnableHypermediaSupport</code> 激活后, 将其配置类包保持私有.  自定义实现可能应该公开这些配置, 以确保用户可以从其应用程序包中导入那些配置类.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="configuration"><a class="anchor" href="#configuration"></a>5. 配置</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节描述了如何配置 Spring HATEOAS.</p>
</div>
<div class="sect2">
<h3 id="configuration.at-enable"><a class="anchor" href="#configuration.at-enable"></a>5.1. 使用 <code>@EnableHypermediaSupport</code></h3>
<div class="paragraph">
<p>要使 <code>RepresentationModel</code> 子类型根据各种超媒体表示类型的规范来呈现,可以通过 <code>@EnableHypermediaSupport</code> 激活对特定超媒体表示格式的支持. 注解将 <code>HypermediaType</code> 枚举作为其参数.
当前,我们支持 HAL 以及默认渲染. 使用注解会触发以下内容:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它注册了必要的 Jackson 模块,以超媒体特定格式呈现 <code>EntityModel</code> 和 <code>CollectionModel</code>.</p>
</li>
<li>
<p>如果 JSONPath 在类路径上,它将自动注册一个 <code>LinkDiscoverer</code> 实例,并在 JSON 查找 <code>rel</code> 链接(请参阅使用 <a href="#client.link-discoverer">使用 <code>LinkDiscoverer</code> 实例</a>).</p>
</li>
<li>
<p>默认情况下,它启用  <a href="#fundamentals.obtaining-links.entity-links">entity links</a>  并自动选择 <code>EntityLinks</code> 实现并将它们捆绑到可以自动装配的 <code>DelegatingEntityLinks</code> 实例中.</p>
</li>
<li>
<p>它会自动拾取 <code>ApplicationContext</code> 中的所有 <code>RelProvider</code> 实现,并将它们捆绑到可以自动装配的 <code>DelegatingRelProvider</code> 中. 它注册提供程序以考虑 domain 以及 Spring MVC 控制器上的 <code>@Relation</code>. 如果 <a href="https://github.com/atteo/evo-inflector">EVO inflector</a> 位于类路径上,则使用库中实现的复数算法继承集合 <code>rel</code> 值(请参见 <a href="#spis.rel-provider">使用 <code>LinkRelationProvider</code> API</a>).</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="configuration.at-enable.stacks"><a class="anchor" href="#configuration.at-enable.stacks"></a>5.1.1. 明确启用对专用 Web 堆栈的支持</h4>
<div class="paragraph">
<p>默认情况下,<code>@EnableHypermediaSupport</code> 将反射性地检测到您正在使用的 Web 应用程序堆栈,并挂接到为这些组件注册的 Spring 组件中,以启用对超媒体表示的支持.
但是,在某些情况下,您只希望明确激活对特定堆栈的支持. 例如. 如果基于 Spring WebMVC 的应用程序使用 WebFlux 的 WebClient 进行传出请求,并且该请求不应该与超媒体元素一起使用,
则可以通过在配置中显式声明 WebMVC 来限制要启用的功能:</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. Explicitly activating hypermedia support for a particular web stack</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableHypermediaSupport(…, stacks = WebStack.WEBMVC)
class MyHypermediaConfiguration { … }
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="client"><a class="anchor" href="#client"></a>6. 客户端支持</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节介绍 Spring HATEOAS 对客户端的支持.</p>
</div>
<div class="sect2">
<h3 id="client.traverson"><a class="anchor" href="#client.traverson"></a>6.1. Traverson</h3>
<div class="paragraph">
<p>Spring HATEOAS 提供了用于客户端服务遍历的 API.它受 <a href="https://blog.codecentric.de/en/2013/11/traverson/">Traverson JavaScript library</a> 的启发.以下示例显示了如何使用它:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Map&lt;String, Object&gt; parameters = new HashMap&lt;&gt;();
parameters.put("user", 27);

Traverson traverson = new Traverson(URI.create("http://localhost:8080/api/"), MediaTypes.HAL_JSON);
String name = traverson
    .follow("movies", "movie", "actor").withTemplateParameters(parameters)
    .toObject("$.name");
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以通过将 <code>Traverson</code> 实例指向 REST 服务器并配置要设置为 <code>Accept</code> 请求头的媒体类型来设置它. 然后,您可以定义要发现和遵循的关系名称. 关系名称可以是简单名称,也可以是 JSONPath 表达式(以 <code>$</code> 开头).</p>
</div>
<div class="paragraph">
<p>然后,示例将参数映射传递给 <code>Traverson</code> 实例. 这些参数用于扩展遍历过程中找到的 URI(已模板化). 通过访问最终遍历的表示来结束遍历. 在前面的示例中,我们评估一个 JSONPath 表达式来访问演员的名字.</p>
</div>
<div class="paragraph">
<p>前面的示例是遍历的最简单版本,其中 <code>rel</code> 值是字符串,并且在每个 hop 处都应用相同的模板参数.</p>
</div>
<div class="paragraph">
<p>在每个级别上,还有更多的选项可以自定义模板参数. 以下示例显示了这些选项.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ParameterizedTypeReference&lt;EntityModel&lt;Item&gt;&gt; resourceParameterizedTypeReference = new ParameterizedTypeReference&lt;EntityModel&lt;Item&gt;&gt;() {};

EntityModel&lt;Item&gt; itemResource = traverson.//
    follow(rel("items").withParameter("projection", "noImages")).//
    follow("$._embedded.items[0]._links.self.href").//
    toObject(resourceParameterizedTypeReference);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>静态 <code>rel(&#8230;&#8203;)</code>  函数是定义 single  <code>Hop</code> 的便捷方法.使用  <code>.withParameter(key, value)</code> 可以简化指定 URI 模板变量的过程.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>.withParameter()</code> 返回可链接的新 <code>Hop</code> 对象. 您可以根据需要将任意多个 <code>.withParameter</code> 串在一起. 结果是单个 hop 定义. 以下示例显示了一种方法:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ParameterizedTypeReference&lt;EntityModel&lt;Item&gt;&gt; resourceParameterizedTypeReference = new ParameterizedTypeReference&lt;EntityModel&lt;Item&gt;&gt;() {};

Map&lt;String, Object&gt; params = Collections.singletonMap("projection", "noImages");

EntityModel&lt;Item&gt; itemResource = traverson.//
    follow(rel("items").withParameters(params)).//
    follow("$._embedded.items[0]._links.self.href").//
    toObject(resourceParameterizedTypeReference);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以使用 <code>.withParameters(Map)</code> 加载整个参数  <code>Map</code> .</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>follow()</code> 是可链接的,这意味着您可以将多个 hop 串在一起,如前面的示例所示. 您可以放置多个基于字符串的 <code>rel</code> 值(<code>follow("items", "item")</code>),也可以放置具有特定参数的单个 hop .
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="entitymodelt-vs-collectionmodelt"><a class="anchor" href="#entitymodelt-vs-collectionmodelt"></a>6.1.1. <code>EntityModel&lt;T&gt;</code> vs. <code>CollectionModel&lt;T&gt;</code></h4>
<div class="paragraph">
<p>到目前为止显示的示例演示了如何避免 Java 的类型擦除,以及如何将单个 JSON 格式的资源转换为 <code>EntityModel&lt;Item&gt;</code>  对象. 但是,如果您得到像 <code>\_embedded</code> HAL 集合这样的集合,该怎么办? 只需稍作调整即可完成此操作,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CollectionModelType&lt;Item&gt; collectionModelType =
    TypeReferences.CollectionModelType&lt;Item&gt;() {};

CollectionModel&lt;Item&gt; itemResource = traverson.//
    follow(rel("items")).//
    toObject(collectionModelType);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该资源没有获取单个资源,而是将一个集合反序列化为 <code>CollectionModel</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="client.link-discoverer"><a class="anchor" href="#client.link-discoverer"></a>6.2. 使用 <code>LinkDiscoverer</code> 实例</h3>
<div class="paragraph">
<p>使用启用了超媒体的表示形式时,常见的任务是在其中找到具有特定关系类型的链接. Spring HATEOAS 为默认表示渲染或 HAL 提供了 <code>LinkDiscoverer</code> 接口的基于 <a href="https://code.google.com/p/json-path">JSONPath</a> 的实现. 使用 <code>@EnableHypermediaSupport</code> 时,我们会自动将支持配置的超媒体类型的实例作为 Spring Bean 暴露.</p>
</div>
<div class="paragraph">
<p>另外,您可以按以下步骤设置和使用实例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String content = "{'_links' :  { 'foo' : { 'href' : '/foo/bar' }}}";
LinkDiscoverer discoverer = new HalLinkDiscoverer();
Link link = discoverer.findLinkWithRel("foo", content);

assertThat(link.getRel(), is("foo"));
assertThat(link.getHref(), is("/foo/bar"));
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="client.web-client"><a class="anchor" href="#client.web-client"></a>6.3. 配置 WebClient 实例</h3>
<div class="paragraph">
<p>如果您需要配置 <code>WebClient</code> 来说明超媒体, 这很容易. 需要 <code>HypermediaWebClientConfigurer</code>, 如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 44. Configuring a <code>WebClient</code> yourself</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
WebClient.Builder hypermediaWebClient(HypermediaWebClientConfigurer configurer) { <i class="conum" data-value="1"></i><b>(1)</b>
 return configurer.registerHypermediaTypes(WebClient.builder()); <i class="conum" data-value="2"></i><b>(2)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在你的 <code>@Configuration</code> 类中, 获取一个 <code>HypermediaWebClientConfigurer</code> bean 副本 Spring HATEOAS registers.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建 <code>WebClient.Builder</code> 后, 使用 configurer 注册 hypermedia types.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>HypermediaWebClientConfigurer</code> 的功能是向 <code>WebClient.Builder</code> 注册所有正确的编码器和解码器.  要使用它, 您需要将构建器注入到应用程序中的某个位置, 然后运行 <code>build()</code> 方法生成 <code>WebClient</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您使用的是 Spring Boot, 则还有另一种方法:  <code>WebClientCustomizer</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 45. Letting Spring Boot configure things</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean <i class="conum" data-value="4"></i><b>(4)</b>
WebClientCustomizer hypermediaWebClientCustomizer(HypermediaWebClientConfigurer configurer) { <i class="conum" data-value="1"></i><b>(1)</b>
    return webClientBuilder -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
        configurer.registerHypermediaTypes(webClientBuilder); <i class="conum" data-value="3"></i><b>(3)</b>
    };
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>当创建一个 Spring bean 时, 请获取一个 Spring HATEOAS <code>HypermediaWebClientConfigurer</code> bean 的副本.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 Java 8 lambda 表达式定义 <code>WebClientCustomizer</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在函数调用内部, 应用 <code>registerHypermediaTypes</code> 方法.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>将整个内容作为 Spring bean 返回,  Spring Boot 可以自动获取并将其应用于其自动配置的 <code>WebClient.Builder</code> bean.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个阶段, 每当需要具体的 <code>WebClient</code> 时, 只需将 <code>WebClient.Builder</code> 注入代码中, 然后使用 <code>build()</code>.  <code>WebClient</code> 实例将能够使用超媒体进行交互.</p>
</div>
</div>
<div class="sect2">
<h3 id="client.web-test-client"><a class="anchor" href="#client.web-test-client"></a>6.4. 配置 <code>WebTestClient</code> 实例</h3>
<div class="paragraph">
<p>使用启用了超媒体的表示形式时, 常见的任务是使用 <code>WebTestClient</code> 执行各种测试.</p>
</div>
<div class="paragraph">
<p>要在测试案例中配置 <code>WebTestClient</code> 的实例, 请查看以下示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 46. Configuring <code>WebTestClient</code> when using Spring HATEOAS</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test // #1225
void webTestClientShouldSupportHypermediaDeserialization() {

  // Configure an application context programmatically.
  AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
  context.register(HalConfig.class); <i class="conum" data-value="1"></i><b>(1)</b>
  context.refresh();

  // Create an instance of a controller for testing
  WebFluxEmployeeController controller = context.getBean(WebFluxEmployeeController.class);
  controller.reset();

  // Extract the WebTestClientConfigurer from the app context.
  HypermediaWebTestClientConfigurer configurer = context.getBean(HypermediaWebTestClientConfigurer.class);

  // Create a WebTestClient by binding to the controller and applying the hypermedia configurer.
  WebTestClient client = WebTestClient.bindToApplicationContext(context).build().mutateWith(configurer); <i class="conum" data-value="2"></i><b>(2)</b>

  // Exercise the controller.
  client.get().uri("http://localhost/employees").accept(HAL_JSON) //
      .exchange() //
      .expectStatus().isOk() //
      .expectBody(new TypeReferences.CollectionModelType&lt;EntityModel&lt;Employee&gt;&gt;() {}) <i class="conum" data-value="3"></i><b>(3)</b>
      .consumeWith(result -&gt; {
        CollectionModel&lt;EntityModel&lt;Employee&gt;&gt; model = result.getResponseBody(); <i class="conum" data-value="4"></i><b>(4)</b>

        // Assert against the hypermedia model.
        assertThat(model.getRequiredLink(IanaLinkRelations.SELF)).isEqualTo(Link.of("http://localhost/employees"));
        assertThat(model.getContent()).hasSize(2);
      });
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注册使用了 <code>@EnableHypermediaSupport</code> 注解的配置类来开启 HAL 支持.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 <code>HypermediaWebTestClientConfigurer</code> 可以应用超媒体支持.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用 Spring HATEOAS 的 <code>TypeReferences.CollectionModelType</code> helper 请求 <code>CollectionModel&lt;EntityModel&lt;Employee&gt;&gt;</code> 响应.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在获得 Spring HATEOAS 格式的 "body" 之后, 对其进行断言！</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>WebTestClient</code> 是不可变的值类型, 因此您不能更改它. . <code>HypermediaWebClientConfigurer</code> 的返回值必须捕获才能使用.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您使用的是 Spring Boot, 则还有其他选项, 例如:</p>
</div>
<div class="exampleblock">
<div class="title">Example 47. Configuring <code>WebTestClient</code> when using Spring Boot</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@SpringBootTest
@AutoConfigureWebTestClient <i class="conum" data-value="1"></i><b>(1)</b>
class WebClientBasedTests {

    @Test
    void exampleTest(@Autowired WebTestClient.Builder builder, @Autowired HypermediaWebTestClientConfigurer configurer) { <i class="conum" data-value="2"></i><b>(2)</b>
        client = builder.apply(configurer).build(); <i class="conum" data-value="3"></i><b>(3)</b>

        client.get().uri("/") //
                .exchange() //
                .expectBody(new TypeReferences.EntityModelType&lt;Employee&gt;() {}) <i class="conum" data-value="4"></i><b>(4)</b>
                .consumeWith(result -&gt; {
                    // assert against this EntityModel&lt;Employee&gt;!
                });
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这是 Spring Boot 的测试注解, 它将为该测试类配置 <code>WebTestClient.Builder</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>自动将 Spring Boot 的 <code>WebTestClient.Builder</code> 插入到 <code>builder</code> 并将 Spring HATEOAS 的 configurer 作为方法参数. .</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用 <code>HypermediaWebTestClientConfigurer</code> 注册对超媒体的支持.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>表示您希望使用 <code>TypeReferences</code> 返回 <code>EntityModel&lt;Employee&gt;</code> .</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>同样, 您可以使用与前面的示例类似的断言.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>还有许多其他方式来测试案例.  <code>WebTestClient</code> 可以绑定到控制器, 函数和 URL.  本部分并不表示所有内容.  相反, 这为您提供了一些入门示例.  重要的是, <code>通过应用HypermediaWebTestClientConfigurer</code>, 可以更改 <code>WebTestClient</code> 的任何实例以处理超媒体.</p>
</div>
</div>
<div class="sect2">
<h3 id="client.rest-template"><a class="anchor" href="#client.rest-template"></a>6.5. 配置 RestTemplate 实例</h3>
<div class="paragraph">
<p>如果要创建自己的 <code>RestTemplate</code> 副本 (配置为使用超媒体) , 则可以使用 <code>HypermediaRestTemplateConfigurer</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 48. Configuring <code>RestTemplate</code> yourself</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">/**
 * Use the {@link HypermediaRestTemplateConfigurer} to configure a {@link RestTemplate}.
 */
@Bean
RestTemplate hypermediaRestTemplate(HypermediaRestTemplateConfigurer configurer) { <i class="conum" data-value="1"></i><b>(1)</b>
	return configurer.registerHypermediaTypes(new RestTemplate()); <i class="conum" data-value="2"></i><b>(2)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>在 <code>@Configuration</code> 类中, 获取 <code>HypermediaRestTemplateConfigurer</code> bean Spring HATEOAS registers 的副本.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建 <code>RestTemplate</code> 之后, 使用配置器应用超媒体类型.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以自由地将此模式应用于所需的任何 <code>RestTemplate</code> 实例, 无论是创建注册的 bean 还是在定义的服务内部.</p>
</div>
<div class="paragraph">
<p>如果您使用的是 Spring Boot, 则还有另一种方法.</p>
</div>
<div class="paragraph">
<p>通常, Spring Boot 摆脱了在应用程序上下文中注册 <code>RestTemplate</code> bean的概念.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当与不同的服务通信时, 您通常需要不同的凭据.</p>
</li>
<li>
<p>当 <code>RestTemplate</code> 使用底层连接池时, 您会遇到其他问题.</p>
</li>
<li>
<p>用户通常需要不同的实例, 而不是单一的 bean.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了弥补这一点, Spring Boot 提供了 <code>RestTemplateBuilder</code>. 这个自动配置的 bean 让您可以定义各种用于构造 <code>RestTemplate</code> 实例的 bean. <code>您请求RestTemplateBuilder</code> bean, 执行其 <code>build()</code> 方法, 然后应用 final 设置(如凭据等).</p>
</div>
<div class="paragraph">
<p>注册基于超媒体的消息转换器, 添加以下代码:</p>
</div>
<div class="exampleblock">
<div class="title">Example 49. Letting Spring Boot configure things</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean <i class="conum" data-value="4"></i><b>(4)</b>
RestTemplateCustomizer hypermediaRestTemplateCustomizer(HypermediaRestTemplateConfigurer configurer) { <i class="conum" data-value="1"></i><b>(1)</b>
    return restTemplate -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
        configurer.registerHypermediaTypes(restTemplate); <i class="conum" data-value="3"></i><b>(3)</b>
    };
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建 Spring Bean 时, 请获取 Spring HATEOAS 的 <code>HypermediaRestTemplateConfigurer</code> Bean的副本.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 Java 8 lambda 表达式定义 <code>RestTemplateCustomizer</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在函数调用内部, 应用 <code>registerHypermediaTypes</code> 方法.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>将整个内容作为 Spring bean 返回, Spring Boot 可以自动获取并将其应用于其自动配置的  <code>RestTemplateBuilder</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个阶段, 只要您需要一个具体的 <code>RestTemplate</code>, 只需将 <code>RestTemplateBuilder</code> 注入到代码中, 并使用 <code>build()</code>. <code>RestTemplate</code> 实例将能够使用超媒体进行交互.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-09-13 15:52:19 +0800
</div>
</div>
</div>
  </div>
</div>
</body>
</html>
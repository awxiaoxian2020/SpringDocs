<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="author" content="Stephane Maldini, Simon Baslé, Jcohy">
<title>Reactor 3 Reference Guide</title>
<link rel="stylesheet" href="css/site.css">
<script src="js/setup.js"></script><script defer src="js/site.js"></script>

</head>
<body class="book toc2 toc-left"><div id="banner-container" class="container" role="banner">
  <div id="banner" class="contained" role="banner">
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </div>
</div>
<div id="tocbar-container" class="container" role="navigation">
  <div id="tocbar" class="contained" role="navigation">
    <button id="toggle-toc"></button>
  </div>
</div>
<div id="main-container" class="container">
  <div id="main" class="contained">
    <div id="doc" class="doc">
<div id="header">
<h1>Reactor 3 Reference Guide</h1>
<div class="details">
<span id="author" class="author">Stephane Maldini</span><br>
<span id="email" class="email"><a href="https://twitter.com/smaldini">@smaldini</a></span><br>
<span id="author2" class="author">Simon Baslé</span><br>
<span id="email2" class="email"><a href="https://twitter.com/simonbasle">@simonbasle</a></span><br>
<span id="author3" class="author">Jcohy</span><br>
<span id="email3" class="email"><a href="https://https://github.com/jiachao23">@Jcohy</a></span><br>
<span id="revdate">2021-09-13</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#about-doc">1. 关于文档</a>
<ul class="sectlevel2">
<li><a href="#最新版本-版权说明">1.1. 最新版本 &amp; 版权说明</a></li>
<li><a href="#贡献本文档">1.2. 贡献本文档</a></li>
<li><a href="#getting-help">1.3. Getting Help</a></li>
<li><a href="#如何开始阅读本文档">1.4. 如何开始阅读本文档</a></li>
</ul>
</li>
<li><a href="#getting-started">2. 入门指南</a>
<ul class="sectlevel2">
<li><a href="#getting-started-introducing-reactor">2.1. 介绍 Reactor</a></li>
<li><a href="#prerequisites">2.2. 前提</a></li>
<li><a href="#getting-started-understanding-bom">2.3. 了解 BOM 和 versioning scheme（版本命名）</a></li>
<li><a href="#getting">2.4. 获取  Reactor</a>
<ul class="sectlevel3">
<li><a href="#maven-安装">2.4.1. Maven 安装</a></li>
<li><a href="#gradle-安装">2.4.2. Gradle 安装</a></li>
<li><a href="#milestones-和-snapshots">2.4.3. Milestones 和 Snapshots</a></li>
</ul>
</li>
<li><a href="#support">2.5. Support and policies</a></li>
</ul>
</li>
<li><a href="#intro-reactive">3. 介绍响应式编程</a>
<ul class="sectlevel2">
<li><a href="#阻塞是对资源的浪费">3.1. 阻塞是对资源的浪费</a></li>
<li><a href="#异步可以解决问题吗">3.2. 异步可以解决问题吗?</a></li>
<li><a href="#从命令式编程到响应式编程">3.3. 从命令式编程到响应式编程</a>
<ul class="sectlevel3">
<li><a href="#可编排性与可读性">3.3.1. 可编排性与可读性</a></li>
<li><a href="#就像装配流水线">3.3.2. 就像装配流水线</a></li>
<li><a href="#operators操作符">3.3.3. Operators(操作符)</a></li>
<li><a href="#reactive.subscribe">3.3.4. <code>subscribe()</code> 之前什么都不会发生</a></li>
<li><a href="#reactive.backpressure">3.3.5. Backpressure(背压)</a></li>
<li><a href="#reactive.hotCold">3.3.6. Hot vs Cold</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#core-features">4. Reactor 核心特性</a>
<ul class="sectlevel2">
<li><a href="#flux">4.1. <code>Flux</code>, 包含 0-N 个元素的异步序列</a></li>
<li><a href="#mono">4.2. <code>Mono</code>, 异步的 0-1 结果</a></li>
<li><a href="#简单的创建和订阅-flux-或-mono-的方法">4.3. 简单的创建和订阅 Flux 或 Mono 的方法</a>
<ul class="sectlevel3">
<li><a href="#subscribe-方法示例">4.3.1. <code>subscribe</code> 方法示例</a></li>
<li><a href="#通过-disposable-取消-subscribe">4.3.2. 通过 <code>Disposable</code> 取消 <code>subscribe()</code></a></li>
<li><a href="#lambda-的替代方案-basesubscriber">4.3.3. Lambda 的替代方案: <code>BaseSubscriber</code></a></li>
<li><a href="#关于背压和重塑请求的方法">4.3.4. 关于背压和重塑请求的方法</a>
<ul class="sectlevel4">
<li><a href="#使用操作符改变下游需求">使用操作符改变下游需求</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#producing">4.4. 可编程式地创建一个序列</a>
<ul class="sectlevel3">
<li><a href="#producing.generate">4.4.1. 同步 <code>generate</code></a></li>
<li><a href="#producing.create">4.4.2. 异步和多线程: <code>create</code></a></li>
<li><a href="#异步但单线程-推送push模式">4.4.3. 异步但单线程: 推送(push)模式</a>
<ul class="sectlevel4">
<li><a href="#推送拉取pushpull混合模式">推送/拉取(push/pull)混合模式</a></li>
<li><a href="#push-或-create-之后清理"><code>push()</code> 或 <code>create()</code> 之后清理</a></li>
</ul>
</li>
<li><a href="#handle">4.4.4. Handle</a></li>
</ul>
</li>
<li><a href="#schedulers">4.5. Threading and Schedulers(线程和调度器)</a>
<ul class="sectlevel3">
<li><a href="#the-publishon-method">4.5.1. The <code>publishOn</code> Method</a></li>
<li><a href="#the-subscribeon-method">4.5.2. The <code>subscribeOn</code> Method</a></li>
</ul>
</li>
<li><a href="#error.handling">4.6. 处理错误</a>
<ul class="sectlevel3">
<li><a href="#错误处理方法">4.6.1. “错误处理”方法</a>
<ul class="sectlevel4">
<li><a href="#静态默认值">静态默认值</a></li>
<li><a href="#异常处理方法">异常处理方法</a></li>
<li><a href="#动态候补值">动态候补值</a></li>
<li><a href="#捕获并重新抛出">捕获并重新抛出</a></li>
<li><a href="#记录错误日志">记录错误日志</a></li>
<li><a href="#使用资源和-try-catch-代码块">使用资源和 try-catch 代码块</a></li>
<li><a href="#演示终止方法-onerror">演示终止方法 <code>onError</code></a></li>
<li><a href="#重试">重试</a></li>
</ul>
</li>
<li><a href="#在操作符或函数式中处理异常">4.6.2. 在操作符或函数式中处理异常</a></li>
</ul>
</li>
<li><a href="#processors">4.7. Processors 和 Sinks</a></li>
</ul>
</li>
<li><a href="#sinks">5. 使用 <code>Sinks.One</code> 和 <code>Sinks.Many</code> 从多个线程生成</a></li>
<li><a href="#processor-overview">6. 可用的 Sinks 的概述</a>
<ul class="sectlevel2">
<li><a href="#sinks-many-unicast-onbackpressurebufferargs">6.1. Sinks.many().unicast().onBackpressureBuffer(args?)</a></li>
<li><a href="#sinks-many-multicast-onbackpressurebufferargs">6.2. Sinks.many().multicast().onBackpressureBuffer(args?)</a></li>
<li><a href="#sinks-many-multicast-directallornothing">6.3. Sinks.many().multicast().directAllOrNothing()</a></li>
<li><a href="#sinks-many-multicast-directbesteffort">6.4. Sinks.many().multicast().directBestEffort()</a></li>
<li><a href="#sinks-many-replay">6.5. Sinks.many().replay()</a></li>
<li><a href="#sinks-unsafe-many">6.6. Sinks.unsafe().many()</a></li>
<li><a href="#sinks-one">6.7. Sinks.one()</a></li>
<li><a href="#sinks-empty">6.8. Sinks.empty()</a></li>
</ul>
</li>
<li><a href="#kotlin">7. Kotlin 支持</a>
<ul class="sectlevel2">
<li><a href="#kotlin-requirements">7.1. 前提</a></li>
<li><a href="#kotlin-extensions">7.2. 扩展</a></li>
<li><a href="#kotlin-null-safety">7.3. Null 值安全</a></li>
</ul>
</li>
<li><a href="#testing">8. 测试</a>
<ul class="sectlevel2">
<li><a href="#使用-stepverifier-来测试">8.1. 使用 <code>StepVerifier</code> 来测试</a>
<ul class="sectlevel3">
<li><a href="#识别测试失败">8.1.1. 识别测试失败</a></li>
</ul>
</li>
<li><a href="#操控时间">8.2. 操控时间</a></li>
<li><a href="#使用-stepverifier-进行-后校验">8.3. 使用 <code>StepVerifier</code> 进行 "后校验"</a></li>
<li><a href="#测试-context">8.4. 测试 <code>Context</code></a></li>
<li><a href="#用-testpublisher-手动发出元素">8.5. 用 <code>TestPublisher</code> 手动发出元素</a></li>
<li><a href="#用-publisherprobe-检查执行路径">8.6. 用 <code>PublisherProbe</code> 检查执行路径</a></li>
</ul>
</li>
<li><a href="#debugging">9. 调试 Reactor</a>
<ul class="sectlevel2">
<li><a href="#典型的-reactor-stack-trace">9.1. 典型的 Reactor Stack Trace</a></li>
<li><a href="#debug-activate">9.2. 开启调试模式 - aka tracebacks</a></li>
<li><a href="#阅读调试模式的-stack-trace">9.3. 阅读调试模式的 Stack Trace</a>
<ul class="sectlevel3">
<li><a href="#checkpoint-alternative">9.3.1. 用 <code>checkpoint()</code> 方式替代</a></li>
</ul>
</li>
<li><a href="#reactor-tools-debug">9.4. 用于生产环境的全局调试</a>
<ul class="sectlevel3">
<li><a href="#局限性">9.4.1. 局限性</a></li>
<li><a href="#将-reactordebugagent-作为-java代-理运行">9.4.2. 将 ReactorDebugAgent 作为 Java代 理运行</a></li>
<li><a href="#在构建时运行-reactordebugagent">9.4.3. 在构建时运行 ReactorDebugAgent</a></li>
</ul>
</li>
<li><a href="#记录流的日志">9.5. 记录流的日志</a></li>
</ul>
</li>
<li><a href="#metrics">10. 暴漏 Reactor 指标</a>
<ul class="sectlevel2">
<li><a href="#scheduler-metrics">10.1. Scheduler metrics</a></li>
<li><a href="#publisher-metrics">10.2. Publisher metrics</a>
<ul class="sectlevel3">
<li><a href="#tags">10.2.1. Tags</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#advanced">11. 高级特性与概念</a>
<ul class="sectlevel2">
<li><a href="#advanced-mutualizing-operator-usage">11.1. 打包重用操作符</a>
<ul class="sectlevel3">
<li><a href="#使用-transform-操作符">11.1.1. 使用 <code>transform</code> 操作符</a></li>
<li><a href="#使用-transformdeferred-操作符">11.1.2. 使用 <code>transformDeferred</code> 操作符</a></li>
</ul>
</li>
<li><a href="#reactor.hotCold">11.2. Hot vs Cold</a></li>
<li><a href="#advanced-broadcast-multiple-subscribers-connectableflux">11.3. 使用 <code>ConnectableFlux</code> 对多个订阅者进行广播</a></li>
<li><a href="#advanced-three-sorts-batching">11.4. 三种分批处理方式</a>
<ul class="sectlevel3">
<li><a href="#用-fluxgroupedfluxt-进行分组">11.4.1. 用 <code>Flux&lt;GroupedFlux&lt;T&gt;&gt;</code> 进行分组</a></li>
<li><a href="#使用-fluxfluxt-进行-window-操作">11.4.2. 使用 <code>Flux&lt;Flux&lt;T&gt;&gt;</code> 进行 window 操作</a></li>
<li><a href="#使用-fluxlistt-进行缓存">11.4.3. 使用 <code>Flux&lt;List&lt;T&gt;&gt;</code> 进行缓存</a></li>
</ul>
</li>
<li><a href="#advanced-parallelizing-parralelflux">11.5. 使用 <code>ParallelFlux</code> 进行并行处理</a></li>
<li><a href="#scheduler-factory">11.6. 替换默认的 <code>Schedulers</code></a></li>
<li><a href="#hooks">11.7. 使用全局的 Hooks</a>
<ul class="sectlevel3">
<li><a href="#hooks-dropping">11.7.1. 丢弃事件的 Hooks</a></li>
<li><a href="#hooks-internal">11.7.2. 内部错误 Hook</a></li>
<li><a href="#hooks-assembly">11.7.3. 组装 Hooks</a></li>
<li><a href="#预置-hook">11.7.4. 预置 Hook</a></li>
</ul>
</li>
<li><a href="#context">11.8. 增加一个 Context 到响应式序列</a>
<ul class="sectlevel3">
<li><a href="#context.api">11.8.1. <code>Context</code> API</a></li>
<li><a href="#context.write">11.8.2. 把 <code>Context</code> 绑定到 <code>Flux</code> and Writing</a></li>
<li><a href="#context.read">11.8.3. 通过  <code>ContextView</code> 读取 <code>Context</code></a></li>
<li><a href="#简单的-context-例子">11.8.4. 简单的 <code>Context</code> 例子</a></li>
<li><a href="#完整示例">11.8.5. 完整示例</a></li>
</ul>
</li>
<li><a href="#cleanup">11.9. 处理需要清理的对象</a>
<ul class="sectlevel3">
<li><a href="#doondiscard-操作符或本地-hook">11.9.1. <code>doOnDiscard</code> 操作符或本地 Hook</a></li>
<li><a href="#onoperatorerror-hook">11.9.2. <code>onOperatorError</code> hook</a></li>
<li><a href="#onnextdropped-hook">11.9.3. <code>onNextDropped</code> Hook</a></li>
<li><a href="#operator-specific-handlers">11.9.4. Operator-specific Handlers</a></li>
</ul>
</li>
<li><a href="#null-safety">11.10. 空值安全</a></li>
</ul>
</li>
<li><a href="#which-operator">Appendix A: 我需要哪个操作符?</a>
<ul class="sectlevel2">
<li><a href="#which.create">A.1. 创建一个新序列,它&#8230;&#8203;</a></li>
<li><a href="#which.values">A.2. 对序列进行转化</a></li>
<li><a href="#which.peeking">A.3. "窥视"(只读)序列</a></li>
<li><a href="#which.filtering">A.4. 过滤序列</a></li>
<li><a href="#which.errors">A.5. 错误处理</a></li>
<li><a href="#which.time">A.6. 基于时间的操作</a></li>
<li><a href="#which.window">A.7. 拆分 Flux</a></li>
<li><a href="#which.blocking">A.8. 回到同步的世界</a></li>
<li><a href="#which.multicasting">A.9. 将 Flux 传播给多个 to several Subscribers</a></li>
</ul>
</li>
<li><a href="#howtoReadMarbles">Appendix B: 如何阅读 marble diagrams(弹珠图)?</a></li>
<li><a href="#faq">Appendix C: FAQ,最佳实践,以及 "我如何&#8230;&#8203;?"</a>
<ul class="sectlevel2">
<li><a href="#faq.wrap-blocking">C.1. 如何包装一个同步阻塞的调用?</a></li>
<li><a href="#faq.chain">C.2. 用在 <code>Flux</code> 上的操作符好像没起作用,为啥?</a></li>
<li><a href="#faq.monoThen">C.3. <code>Mono</code> <code>zipWith/zipWhen</code> 没有被调用</a></li>
<li><a href="#faq.retryWhen">C.4. 如何用 <code>retryWhen</code> 来实现 <code>retry(3)</code> 的效果?</a></li>
<li><a href="#faq.exponentialBackoff">C.5. 如何使用 <code>retryWhen</code> 进行 exponential backoff?</a></li>
<li><a href="#faq.thread-affinity-publishon">C.6. 如何使用 <code>publishOn()</code> 确保线程 Affinity ?</a></li>
<li><a href="#faq.mdc">C.7. 是你是上下文日志记录的最好模式? (MDC)</a></li>
</ul>
</li>
<li><a href="#reactor-extra">Appendix D: Reactor-Extra</a>
<ul class="sectlevel2">
<li><a href="#extra-tuples">D.1. <code>TupleUtils</code> 以及函数式接口</a></li>
<li><a href="#extra-math">D.2. <code>MathFlux</code> 的数学操作符</a></li>
<li><a href="#extra-schedulers">D.3. 调度器</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="about-doc"><a class="anchor" href="#about-doc"></a>1. 关于文档</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节是对 Reactor 参考文档的简要概述.你并不需要从头到尾阅读该文档.每一节的内容都是独立的,不过会有其他章节的链接.</p>
</div>
<div class="sect2">
<h3 id="最新版本-版权说明"><a class="anchor" href="#最新版本-版权说明"></a>1.1. 最新版本 &amp; 版权说明</h3>
<div class="paragraph">
<p>本 Reactor 参考文档也提供 HTML 形式.最新版本见 <code><a href="http://projectreactor.io/docs/core/release/reference/docs/index.html" class="bare">projectreactor.io/docs/core/release/reference/docs/index.html</a></code>.</p>
</div>
<div class="paragraph">
<p>本文档的副本你可以自用,亦可分发给他人.不过无论是打印版还是电子版,请免费提供.</p>
</div>
<div class="paragraph">
<p>本文档的大多数翻译来源于 <a href="https://github.com/get-set/reactor-core/tree/master-zh/src/docs">https://github.com/get-set/reactor-core/tree/master-zh/src/docs</a></p>
</div>
</div>
<div class="sect2">
<h3 id="贡献本文档"><a class="anchor" href="#贡献本文档"></a>1.2. 贡献本文档</h3>
<div class="paragraph">
<p>本参考文档用 <a href="https://asciidoctor.org/docs/asciidoc-writers-guide/">Asciidoc</a> 编写, 其源码见 <a href="https://github.com/reactor/reactor-core/tree/main/docs/asciidoc" class="bare">github.com/reactor/reactor-core/tree/main/docs/asciidoc</a></p>
</div>
<div class="paragraph">
<p>如有任何补充,欢迎你提交 pull request.</p>
</div>
<div class="paragraph">
<p>我们建议你将源码 checkout 到本地,这样可以使用 gradle 的 <code>asciidoctor</code> 任务检查文档渲染效果. 有些章节会包含其他文件,Github 并不一定能够渲染出来.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
为了方便读者的反馈,多数章节在结尾都提供一个链接,这个链接可以打开一个 Github 上的 编辑界面,从而可以编辑相应章节的源码.这些链接在 HTML5 的版本中能够看到,就像这样:  <a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/aboutDoc.adoc" class="fa fa-edit" target="_blank" rel="noopener">Suggest Edit</a> - <a href="#about-doc">关于文档</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="getting-help"><a class="anchor" href="#getting-help"></a>1.3. Getting Help</h3>
<div class="paragraph">
<p>Reactor 项目有多种方式希望能帮助到你:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与社区沟通:  <a href="https://gitter.im/reactor/reactor">Gitter</a>.</p>
</li>
<li>
<p>在 stackoverflow.com 的 <a href="https://stackoverflow.com/tags/project-reactor"><code>project-reactor</code></a> 进行提问.</p>
</li>
<li>
<p>在 Github issues 提交 bug .下边这几个库我们会一直关注: <a href="https://github.com/reactor/reactor-core/issues">reactor-core</a> (涉及 Reactor 的核心功能) 以及 <a href="https://github.com/reactor/reactor-addons/issues">reactor-addons</a> (涉及 reactor-test 和 adapters issues).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
所有 Reactor 项目都是开源的, 包括 <a href="https://github.com/reactor/reactor-core/tree/main/docs/asciidoc">本文档</a>. 如果你发现本文档有问题,或希望补充一些内容,请参考 <a href="https://github.com/reactor/.github/blob/main/CONTRIBUTING.md">这里</a> 进行了解.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="如何开始阅读本文档"><a class="anchor" href="#如何开始阅读本文档"></a>1.4. 如何开始阅读本文档</h3>
<div class="ulist">
<ul>
<li>
<p>如果你想直接写代码请参考 <a href="#getting-started">入门指南</a></p>
</li>
<li>
<p>如果你对 响应式编程(Reactive Programming) 比较陌生,最好从 <a href="#intro-reactive">响应式编程</a> 开始.</p>
</li>
<li>
<p>如果你对 Reactor 的理念比较熟悉,只是在编写程序时查找合适的操作符, 请参考附录 <a href="#which-operator">我需要哪个操作符 ? </a> .</p>
</li>
<li>
<p>如果你想深入了解 Reactor 的核心功能,请参考 <a href="#core-features">Reactor 核心特性</a>,以便了解:</p>
<div class="ulist">
<ul>
<li>
<p>关于 Reactor 的响应式类型 <a href="#flux"><code>Flux</code>, 包含 0-N 个元素的异步序列</a> 和 <a href="#mono"><code>Mono</code>, 异步的 0-1 结果</a> 章节.</p>
</li>
<li>
<p>如何调整执行的线程环境 <a href="#schedulers">scheduler</a>.</p>
</li>
<li>
<p>如何处理问题 <a href="#error.handling">处理错误</a> .</p>
</li>
</ul>
</div>
</li>
<li>
<p>单测的内容主要来自  <code>reactor-test</code> 项目,参考 <a href="#testing">测试</a>.</p>
</li>
<li>
<p><a href="#producing">可编程式地创建一个序列</a> 提供了更加丰富的创建响应式源(reactive source)的方式.</p>
</li>
<li>
<p>其他高级主题请看参考 <a href="#advanced">高级特性与概念</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/aboutDoc.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#about-doc">关于文档</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting-started"><a class="anchor" href="#getting-started"></a>2. 入门指南</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这一节的内容能够帮助你上手使用 Reactor.包括如下内容:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#getting-started-introducing-reactor">介绍 Reactor</a></p>
</li>
<li>
<p><a href="#prerequisites">前提</a></p>
</li>
<li>
<p><a href="#getting-started-understanding-bom">了解 BOM 和 versioning scheme（版本命名）</a></p>
</li>
<li>
<p><a href="#getting">获取  Reactor</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="getting-started-introducing-reactor"><a class="anchor" href="#getting-started-introducing-reactor"></a>2.1. 介绍 Reactor</h3>
<div class="paragraph">
<p>Reactor 是一个用于 JVM 的完全非阻塞的响应式编程框架,具备高效的需求管理(即对 背压(&#8220;backpressure&#8221;) 的控制)能力.它与 Java 8 函数式 API 直接集成,比如 <code>CompletableFuture</code>, <code>Stream</code>, 以及 <code>Duration</code>.
它提供了异步序列 API <code>Flux</code>(用于[N]个元素)和 <code>Mono</code>(用于 [0|1]个元素),并完全遵循和实现了 <a href="https://www.reactive-streams.org/">Reactive Streams</a> 规范.</p>
</div>
<div class="paragraph">
<p>Reactor 还支持与 <code>Reactor-Netty</code> 项目的非阻塞的进程间通信. 适用于微服务架构,<code>Reactor Netty</code> 为 HTTP(包括 <code>Websockets</code>),TCP 和 UDP 提供了支持背压的网络引擎. 完全支持响应式编码和解码.</p>
</div>
</div>
<div class="sect2">
<h3 id="prerequisites"><a class="anchor" href="#prerequisites"></a>2.2. 前提</h3>
<div class="paragraph">
<p>Reactor Core 运行于 <code>Java 8</code> 及以上版本.</p>
</div>
<div class="paragraph">
<p>依赖 <code>org.reactivestreams:reactive-streams:1.0.3</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">Android 支持</div>
<div class="ulist">
<ul>
<li>
<p>Reactor 3 并不正式支持 Andorid(如果需要可以考虑使用 RxJava 2).</p>
</li>
<li>
<p>但是,在 Android SDK 26(Android 0)及以上版本应该没问题.</p>
</li>
<li>
<p>It will likely work fine with Android SDK 21 (Android 5.0) and above when desugaring
is enabled. See <a href="https://developer.android.com/studio/write/java8-support#library-desugaring" class="bare">developer.android.com/studio/write/java8-support#library-desugaring</a></p>
</li>
<li>
<p>我们希望能够最大程度兼顾对 Android 的支持,但是我们并不能作出保证,具体情况具体分析.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="getting-started-understanding-bom"><a class="anchor" href="#getting-started-understanding-bom"></a>2.3. 了解 BOM 和 versioning scheme（版本命名）</h3>
<div class="paragraph">
<p>自从 <code>reactor-core 3.0.4</code>,随着 <code>Aluminium</code> 版本发布上车(release train)以来,Reactor 3 使用了 BOM(Bill of Materials,一种标准的 Maven artifact).</p>
</div>
<div class="paragraph">
<p>请注意 版本命名在 3.3.x 和 3.4.x 之间有变动(Dysprosium 和 Europium).</p>
</div>
<div class="paragraph">
<p>组件使用 <code>MAJOR.MINOR.PATCH-QUALIFIER</code> 的版本命名，而 BOM 使用 <code>YYYY.MINOR.PATCH-QUALIFIER</code> 的命名, 其中:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MAJOR</code> 是 Reactor 的第几次大迭代, 每一次大的迭代都会给项目结构带来根本性的变化（这可能意味着更重要的迁移工作）</p>
</li>
<li>
<p><code>YYYY</code> 是给定发布周期中第一个 GA 版本发布年份 (例如 3.4.0 for 3.4.x)</p>
</li>
<li>
<p><code>.MINOR</code> 是一个从 0 开始的数字，随着每个新的发布周期递增</p>
<div class="ulist">
<ul>
<li>
<p>它通常反映更广泛的变化，可以表明适度的迁移工作</p>
</li>
<li>
<p>在 BOM 的情况下，它允许区分发布周期，以防两个在同一年首次发布</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>.PATCH</code> 是一个从 0 开始的数字，随着每个服务版本递增</p>
</li>
<li>
<p><code>-QUALIFIER</code> 是一个文本限定符，在 GA 版本的情况下被省略（见下文）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，遵循该约定的第一个发布周期是 <code>2020.0.x</code>，代号 <code>Europium</code>。该方案按顺序使用以下限定符（注意使用破折号分隔符）：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-M1</code>..<code>-M9</code>: 里程碑（我们预计每个服务版本不会超过 9 个）</p>
</li>
<li>
<p><code>-RC1</code>..<code>-RC9</code>: 候选版本（我们预计每个服务版本不会超过 9 个）</p>
</li>
<li>
<p><code>-SNAPSHOT</code>: 快照</p>
</li>
<li>
<p><em>no qualifier</em> for GA releases</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
快照按上述顺序出现在更高的位置，因为从概念上讲，它们始终是任何给定 PATCH 的“最新鲜的预发布”。即使 PATCH 周期的第一个部署工件将始终是一个 -SNAPSHOT，一个类似命名但更新的快照也将在例如之后发布。里程碑或发布候选者之间。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>每个发布周期也有一个代号，与之前基于代号的方案保持连续性，可用于更非正式地引用它（如在讨论、博客文章等中）。代号替代了传统的 MAJOR.MINOR 的数字形式.这些代号主要来自 <a href="https://en.wikipedia.org/wiki/Periodic_table#Overview">Periodic Table of
Elements</a>, 按首字母顺序依次选取.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
在 Dysprosium 之前，BOM 是使用代号后跟限定符的版本序列方案进行版本控制的，并且限定符略有不同。例如：Aluminium-RELEASE（第一个 GA 版本，现在类似于 YYYY.0.0）、Bismuth-M1、Californium-SR1（服务版本现在类似于 YYYY.0.1）、Dysprosium-RC1、Dysprosium-BUILD-SNAPSHOT （在每个补丁之后，我们会回到相同的快照版本。现在类似于 YYYY.0.X-SNAPSHOT 所以我们每个补丁获得 1 个快照）。
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="getting"><a class="anchor" href="#getting"></a>2.4. 获取  Reactor</h3>
<div class="paragraph">
<p><a href="#getting-started-understanding-bom">前边提到</a>,使用 Reactor 的最简单方式是在你的项目中配置 BOM 以及相关依赖. 注意,当你这样添加依赖的时候,要省略版本(&lt;version&gt;)配置,从而自动使用 BOM 中指定的版本.</p>
</div>
<div class="paragraph">
<p>当然,如果你希望使用某个版本的 artifact,仍然可以指定.甚至完全不使用 BOM,逐个配置 artifact 的版本也是可以的.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
对于当前版本 (reactor-core 3.4.8), 最新的稳定的 BOM 版本为 <code>2020.0.9</code>, 如下面的代码所示.
此后可能会有更新的版本 (包括 snapshots, milestones 和 new release train lines),
请查看 <a href="https://projectreactor.io/docs" class="bare">projectreactor.io/docs</a> 获取最新的 artifacts 和 BOMs.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="maven-安装"><a class="anchor" href="#maven-安装"></a>2.4.1. Maven 安装</h4>
<div class="paragraph">
<p>Maven 原本就支持 BOM.首先,你需要在 <code>pom.xml</code> 内通过添加下边的代码引入 BOM.如果 (<code>dependencyManagement</code>) 已经存在,只需要添加其内容即可</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
            &lt;artifactId&gt;reactor-bom&lt;/artifactId&gt;
            &lt;version&gt;{reactorReleaseTrain}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注意 <code>dependencyManagement</code> 标签用来补充通常使用的 <code>dependencies</code> 配置.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果 <code>pom</code> 中已经存在 <code>dependencyManagement</code> 标签,则仅添加内容.</p>
</div>
<div class="paragraph">
<p>然后,在 <code>dependencies</code> 中添加相关的 reactor 项目,省略 <code>&lt;version&gt;</code>,如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-test&lt;/artifactId&gt; <i class="conum" data-value="3"></i><b>(3)</b>
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>依赖 Core 库</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>没有 version 标签</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>reactor-test</code> 提供了对 reactive streams 的单元测试</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gradle-安装"><a class="anchor" href="#gradle-安装"></a>2.4.2. Gradle 安装</h4>
<div class="paragraph">
<p>Gradle 5.0 之前的版本,没有对 Maven BOM 的支持,但是你可以使用 Spring 的 <a href="https://github.com/spring-gradle-plugins/dependency-management-plugin">gradle-dependency-management</a> 插件.</p>
</div>
<div class="paragraph">
<p>首先,apply 插件</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id "io.spring.dependency-management" version "1.0.7.RELEASE" <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>编写本文档时,插件最新版本为 1.0.7.RELEASE,请自行使用合适的版本.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>然后用它引入 BOM:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencyManagement {
     imports {
          mavenBom "io.projectreactor:reactor-bom:{reactorReleaseTrain}"
     }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后,向您的项目添加一个不带版本号的依赖:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
     implementation 'io.projectreactor:reactor-core' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>无需第三个 <code>:</code> 添加版本号</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>从 Gradle 5.0 开始,您可以使用本地 Gradle 支持对 BOM 的支持:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
     implementation platform('io.projectreactor:reactor-bom:{reactorReleaseTrain}')
     implementation 'io.projectreactor:reactor-core' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>无需第三个 <code>:</code> 添加版本号</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="milestones-和-snapshots"><a class="anchor" href="#milestones-和-snapshots"></a>2.4.3. Milestones 和 Snapshots</h4>
<div class="paragraph">
<p>里程碑版(Milestones)和开发预览版(developer previews)通过 Spring Milestones repository 而不是 Maven Central 来发布. 需要添加到构建配置文件中,如:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. Milestones in Maven</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;spring-milestones&lt;/id&gt;
        &lt;name&gt;Spring Milestones Repository&lt;/name&gt;
        &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>gradle 使用下边的配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. Milestones in Gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
  maven { url 'https://repo.spring.io/milestone' }
  mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>类似的,snapshot 版也需要配置专门的库:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. BUILD-SNAPSHOTs in Maven</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;spring-snapshots&lt;/id&gt;
        &lt;name&gt;Spring Snapshot Repository&lt;/name&gt;
        &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 4. BUILD-SNAPSHOTs in Gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
  maven { url 'https://repo.spring.io/snapshot' }
  mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="support"><a class="anchor" href="#support"></a>2.5. Support and policies</h3>
<div class="paragraph">
<p>The entries below are mirroring <a href="https://github.com/reactor/.github/blob/main/SUPPORT.adoc" class="bare">github.com/reactor/.github/blob/main/SUPPORT.adoc</a></p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/gettingStarted.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#getting-started">入门指南</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="intro-reactive"><a class="anchor" href="#intro-reactive"></a>3. 介绍响应式编程</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reactor 是响应式编程范式的实现,总结起来有如下几点:</p>
</div>
<div class="quoteblock">
<blockquote>
响应式编程是一种关注于数据流(data streams)和变化传递(propagation of change)的异步编程方式. 这意味着它可以用既有的编程语言表达静态(如数组)或动态(如事件源)的数据流.
</blockquote>
<div class="attribution">
&#8212; https://en.wikipedia.org/wiki/Reactive_programming
</div>
</div>
<div class="paragraph">
<p>在响应式编程方面,微软跨出了第一步,它在 .NET 生态中创建了响应式扩展库(Reactive Extensions library, Rx).接着 RxJava 在 JVM 上实现了响应式编程.后来,在 JVM 平台出现了一套标准的响应式 编程规范,它定义了一系列标准接口和交互规范.并整合到 Java 9 中(使用 <code>Flow</code> 类).</p>
</div>
<div class="paragraph">
<p>响应式编程通常作为面向对象编程中的“观察者模式”(Observer design pattern)的一种扩展. 响应式流(reactive streams)与“迭代子模式”(Iterator design pattern)也有相通之处, 因为其中也有 <code>Iterable</code>-<code>Iterator</code> 这样的对应关系.主要的区别在于,Iterator 是基于 “拉取”(pull)方式的,而响应式流是基于“推送”(push)方式的.</p>
</div>
<div class="paragraph">
<p>使用 iterator 是一种“命令式”(imperative)编程范式,即使访问元素的方法是 <code>Iterable</code> 的唯一职责.关键在于,什么时候执行 <code>next()</code> 获取元素取决于开发者.在响应式流中,相对应的 角色是 <code>Publisher-Subscriber</code>,但是 当有新的值到来的时候 ,
却反过来由发布者(<code>Publisher</code>) 通知订阅者(<code>Subscriber</code>),这种“推送”模式是响应式的关键.此外,对推送来的数据的操作 是通过一种声明式(declaratively)而不是命令式(imperatively)的方式表达的: 开发者通过 描述“控制流程”来定义对数据流的处理逻辑.</p>
</div>
<div class="paragraph">
<p>除了数据推送,对错误处理(error handling)和完成(completion)信号的定义也很完善. 一个 <code>Publisher</code> 可以推送新的值到它的 <code>Subscriber</code>(调用 <code>onNext</code> 方法), 同样也可以推送错误(调用 <code>onError</code> 方法)和完成(调用 <code>onComplete</code> 方法)信号. 错误和完成信号都可以终止响应式流.可以用下边的表达式描述:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>onNext x 0..N [onError | onComplete]</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这种方式非常灵活,无论是有/没有值,还是 n 个值(包括有无限个值的流,比如时钟的持续读秒),都可处理.</p>
</div>
<div class="paragraph">
<p>那么我们为什么需要这样的异步响应式开发库呢?</p>
</div>
<div class="sect2">
<h3 id="阻塞是对资源的浪费"><a class="anchor" href="#阻塞是对资源的浪费"></a>3.1. 阻塞是对资源的浪费</h3>
<div class="paragraph">
<p>现代应用需要应对大量的并发用户,而且即使现代硬件的处理能力飞速发展,软件性能仍然是关键因素.</p>
</div>
<div class="paragraph">
<p>广义来说我们有两种思路来提升程序性能:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>parallelize</strong> 使用更多的线程和硬件资源.</p>
</li>
<li>
<p>基于现有的资源来 <strong>提高执行效率</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常,Java开发者使用阻塞式(blocking)编写代码.这没有问题,在出现性能瓶颈后, 我们可以增加处理线程,线程中同样是阻塞的代码.但是这种使用资源的方式会迅速面临 资源竞争和并发问题.</p>
</div>
<div class="paragraph">
<p>更糟糕的是,阻塞会浪费资源.具体来说,比如当一个程序面临延迟(通常是I/O方面, 比如数据库读写请求或网络调用),所在线程需要进入 idle 状态等待数据,从而浪费资源.</p>
</div>
<div class="paragraph">
<p>所以,并行化方式并非银弹.这是挖掘硬件潜力的方式,但是却带来了复杂性,而且容易造成浪费.</p>
</div>
</div>
<div class="sect2">
<h3 id="异步可以解决问题吗"><a class="anchor" href="#异步可以解决问题吗"></a>3.2. 异步可以解决问题吗?</h3>
<div class="paragraph">
<p>第二种思路——提高执行效率——可以解决资源浪费问题.通过编写 异步非阻塞 的代码, (任务发起异步调用后)执行过程会切换到另一个 使用同样底层资源 的活跃任务,然后等 异步调用返回结果再去处理.</p>
</div>
<div class="paragraph">
<p>但是在 JVM 上如何编写异步代码呢? Java 提供了两种异步编程方式:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Callbacks</strong>: 异步方法没有返回值,而是采用一个 <code>callback</code> 作为参数(lambda 或匿名类),当结果出来后回调这个 <code>callback</code>.常见的例子比如 Swings 的 <code>EventListener</code>.</p>
</li>
<li>
<p><strong>Futures</strong>: 异步方法 立即 返回一个 <code>Future&lt;T&gt;</code>,该异步方法要返回结果的是 <code>T</code> 类型,通过 <code>Future</code> 封装.这个结果并不是 <strong>立刻</strong> 可以拿到,而是等实际处理结束才可用.比如, <code>ExecutorService</code> 执行 <code>Callable&lt;T&gt;</code> 任务时会返回 <code>Future</code> 对象.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些技术够用吗? 并非对于每个用例都是如此,两种方式都有局限性.</p>
</div>
<div class="paragraph">
<p>回调很难组合起来,因为很快就会导致代码难以理解和维护(即所谓的“回调地狱(callback hell)”).</p>
</div>
<div class="paragraph">
<p>考虑这样一种情景: 在用户界面上显示用户的5个收藏,或者如果没有任何收藏提供5个建议.这需要3个 服务(一个提供收藏的ID列表,第二个服务获取收藏内容,第三个提供建议内容):</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. 回调地狱(Callback Hell)的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">userService.getFavorites(userId, new Callback&lt;List&lt;String&gt;&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>
  public void onSuccess(List&lt;String&gt; list) { <i class="conum" data-value="2"></i><b>(2)</b>
    if (list.isEmpty()) { <i class="conum" data-value="3"></i><b>(3)</b>
      suggestionService.getSuggestions(new Callback&lt;List&lt;Favorite&gt;&gt;() {
        public void onSuccess(List&lt;Favorite&gt; list) { <i class="conum" data-value="4"></i><b>(4)</b>
          UiUtils.submitOnUiThread(() -&gt; { <i class="conum" data-value="5"></i><b>(5)</b>
            list.stream()
                .limit(5)
                .forEach(uiList::show); <i class="conum" data-value="6"></i><b>(6)</b>
            });
        }

        public void onError(Throwable error) { <i class="conum" data-value="7"></i><b>(7)</b>
          UiUtils.errorPopup(error);
        }
      });
    } else {
      list.stream() <i class="conum" data-value="8"></i><b>(8)</b>
          .limit(5)
          .forEach(favId -&gt; favoriteService.getDetails(favId, <i class="conum" data-value="9"></i><b>(9)</b>
            new Callback&lt;Favorite&gt;() {
              public void onSuccess(Favorite details) {
                UiUtils.submitOnUiThread(() -&gt; uiList.show(details));
              }

              public void onError(Throwable error) {
                UiUtils.errorPopup(error);
              }
            }
          ));
    }
  }

  public void onError(Throwable error) {
    UiUtils.errorPopup(error);
  }
});
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>基于回调的服务使用一个匿名 <code>Callback</code> 作为参数.后者的两个方法分别在异步执行成功 或异常时被调用.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>获取到收藏 ID 的 list 后调用第一个服务的回调方法 <code>onSuccess</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果 list 为空, 调用 <code>suggestionService</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>服务 <code>suggestionService</code> 传递 <code>List&lt;Favorite&gt;</code> 给第二个回调.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>既然是处理 UI,我们需要确保消费代码运行在 UI 线程.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>使用 Java 8 <code>Stream</code> 来限制建议数量为 5,然后在 UI 中显示.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>在每一层,我们都以同样的方式处理错误: 在一个 popup 中显示错误信息.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>B回到收藏 ID 这一层,如果返回 list,我们需要使用 <code>favoriteService</code> 来获取 <code>Favorite</code> 对象.由于只想要 5 个,因此使用 stream .</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>再一次回调.这次对每个 ID,获取 <code>Favorite</code> 对象在 UI 线程中推送到前端显示.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>这里有不少代码,稍微有些难以阅读,并且还有重复代码,我们再来看一下用 Reactor 实现同样功能:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. 使用 Reactor 实现以上回调方式同样功能的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">userService.getFavorites(userId) <i class="conum" data-value="1"></i><b>(1)</b>
           .flatMap(favoriteService::getDetails) <i class="conum" data-value="2"></i><b>(2)</b>
           .switchIfEmpty(suggestionService.getSuggestions()) <i class="conum" data-value="3"></i><b>(3)</b>
           .take(5) <i class="conum" data-value="4"></i><b>(4)</b>
           .publishOn(UiUtils.uiThreadScheduler()) <i class="conum" data-value="5"></i><b>(5)</b>
           .subscribe(uiList::show, UiUtils::errorPopup); <i class="conum" data-value="6"></i><b>(6)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们获取到收藏 ID 的流</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们 <em>异步地转换</em> 它们(ID) 为 <code>Favorite</code> 对象(使用 <code>flatMap</code>),现在我们有了 <code>Favorite</code> 流.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>一旦 <code>Favorite</code> 为空,切换到 <code>suggestionService</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们只关注流中的最多5个元素.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>最后,我们希望在 UI 线程中进行处理.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>通过描述对数据的最终处理(在 UI 中显示)和对错误的处理(显示在 popup 中)来触发(subscribe).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果你想确保 “收藏的ID” 的数据在 800ms 内获得(如果超时,从缓存中获取)呢? 在基于回调的代码中, 会比较复杂.但 Reactor 中就很简单,在处理链中增加一个 <code>timeout</code> 的操作符即可.</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. Reactor 中增加超时控制的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">userService.getFavorites(userId)
           .timeout(Duration.ofMillis(800)) <i class="conum" data-value="1"></i><b>(1)</b>
           .onErrorResume(cacheService.cachedFavoritesFor(userId)) <i class="conum" data-value="2"></i><b>(2)</b>
           .flatMap(favoriteService::getDetails) <i class="conum" data-value="3"></i><b>(3)</b>
           .switchIfEmpty(suggestionService.getSuggestions())
           .take(5)
           .publishOn(UiUtils.uiThreadScheduler())
           .subscribe(uiList::show, UiUtils::errorPopup);
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果在 800ms 内没有发出(emit)任何值,则发出错误(error).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>一旦收到错误,交由 <code>cacheService</code> 处理.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>处理链后边的内容与上例类似.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><code>Futures</code> 比回调要好一点,但即使在 Java 8 引入了 <code>CompletableFuture</code>,它对于多个处理的组合仍不够好用. 编排多个 <code>Futures</code> 是可行的,但却不易.此外,<code>Future</code> 还有一个问题:</p>
</div>
<div class="paragraph">
<p><code>Future</code> 对象相比较 callbacks 也许更好一点, 但他们在组合使用仍然做的还不是很好。尽管在 Java 8 中提供了 <code>CompletableFuture</code> 来将多个 <code>Future</code> 对象组合在一起使用，但想要实现并不容易，此外 <code>Future</code> 还有其他问题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当对 <code>Future</code> 对象最终调用 <code>get()</code> 方法时,仍然会导致阻塞</p>
</li>
<li>
<p>它们不支持惰性计算.</p>
</li>
<li>
<p>并且缺乏对多个值以及更进一步对错误的处理</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>再看一个例子: 我们得到一个 ID 列表,然后通过它进一步获取到 对应的 name 和 statistics  为元素的列表,整个过程用异步方式来实现.下面的示例使用 <code>CompletableFuture</code> 类型的列表执行此操作:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. <code>CompletableFuture</code> 处理组合的例子</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">CompletableFuture&lt;List&lt;String&gt;&gt; ids = ifhIds(); <i class="conum" data-value="1"></i><b>(1)</b>

CompletableFuture&lt;List&lt;String&gt;&gt; result = ids.thenComposeAsync(l -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
    Stream&lt;CompletableFuture&lt;String&gt;&gt; zip =
            l.stream().map(i -&gt; { <i class="conum" data-value="3"></i><b>(3)</b>
                CompletableFuture&lt;String&gt; nameTask = ifhName(i); <i class="conum" data-value="4"></i><b>(4)</b>
                CompletableFuture&lt;Integer&gt; statTask = ifhStat(i); <i class="conum" data-value="5"></i><b>(5)</b>

                return nameTask.thenCombineAsync(statTask, (name, stat) -&gt; "Name " + name + " has stats " + stat); <i class="conum" data-value="6"></i><b>(6)</b>
            });
    List&lt;CompletableFuture&lt;String&gt;&gt; combinationList = zip.collect(Collectors.toList()); <i class="conum" data-value="7"></i><b>(7)</b>
    CompletableFuture&lt;String&gt;[] combinationArray = combinationList.toArray(new CompletableFuture[combinationList.size()]);

    CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(combinationArray); <i class="conum" data-value="8"></i><b>(8)</b>
    return allDone.thenApply(v -&gt; combinationList.stream()
            .map(CompletableFuture::join) <i class="conum" data-value="9"></i><b>(9)</b>
            .collect(Collectors.toList()));
});

List&lt;String&gt; results = result.join(); <i class="conum" data-value="10"></i><b>(10)</b>
assertThat(results).contains(
        "Name NameJoe has stats 103",
        "Name NameBart has stats 104",
        "Name NameHenry has stats 105",
        "Name NameNicole has stats 106",
        "Name NameABSLAJNFOAJNFOANFANSF has stats 121");
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>以一个 Future 开始,其中封装了后续将获取和处理的 <code>id</code> 的 list.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>获取到 list 后边进一步对其启动异步处理任务.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>对于 list 中的每一个元素:</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>异步地得到相应的 name.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>异步地得到相应的 statistics.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>将两个结果一一组合.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>我们现在有了一个 list,元素是 Future(表示组合的任务,类型是 <code>CompletableFuture</code>),为了执行这些任务, 我们需要将这个 list(元素构成的流) 转换为数组(List).</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>将这个数组传递给 <code>CompletableFuture.allOf</code>,返回一个 <code>Future</code> ,当所以任务都完成了,那么这个 <code>Future</code> 也就完成了. ,</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>有点麻烦的地方在于 <code>allOf</code> 返回的是 <code>CompletableFuture&lt;Void&gt;</code>,所以我们遍历这个 <code>Future</code> 的 <code>List</code>, ,然后使用 <code>join()</code> 来收集它们的结果(不会导致阻塞,因为 <code>allOf</code> 确保这些 <code>Future</code> 全部完成)</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>一旦整个异步流水线被触发,我们等它完成处理,然后返回结果列表.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>由于 Reactor 内置许多组合操作,因此以上例子可以简单地实现:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. Reactor 实现与 Future 同样功能的代码</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; ids = ifhrIds(); <i class="conum" data-value="1"></i><b>(1)</b>

Flux&lt;String&gt; combinations =
        ids.flatMap(id -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
            Mono&lt;String&gt; nameTask = ifhrName(id); <i class="conum" data-value="3"></i><b>(3)</b>
            Mono&lt;Integer&gt; statTask = ifhrStat(id); <i class="conum" data-value="4"></i><b>(4)</b>

            return nameTask.zipWith(statTask, <i class="conum" data-value="5"></i><b>(5)</b>
                    (name, stat) -&gt; "Name " + name + " has stats " + stat);
        });

Mono&lt;List&lt;String&gt;&gt; result = combinations.collectList(); <i class="conum" data-value="6"></i><b>(6)</b>

List&lt;String&gt; results = result.block(); <i class="conum" data-value="7"></i><b>(7)</b>
assertThat(results).containsExactly( <i class="conum" data-value="8"></i><b>(8)</b>
        "Name NameJoe has stats 103",
        "Name NameBart has stats 104",
        "Name NameHenry has stats 105",
        "Name NameNicole has stats 106",
        "Name NameABSLAJNFOAJNFOANFANSF has stats 121"
);
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这一次,我们从一个异步方式提供的 <code>ids</code> 序列(<code>Flux&lt;String&gt;</code>)开始.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>对于序列中的每一个元素,我们异步地处理它(<code>flatMap</code> 方法内)两次.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>获取相应的 name.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>获取相应的 statistic.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>异步地组合两个值</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>随着序列中的元素值“到位”,它们收集一个 <code>List</code> 中.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>在生成流的环节,我们可以继续异步地操作 <code>Flux</code> 流,对其进行组合和订阅(<code>subscribe</code>). 最终我们很可能得到一个 <code>Mono</code> .由于是测试,我们阻塞住(block()),等待流处理过程结束, 然后直接返回集合.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>对结果进行断言.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>回调或 <code>Future</code> 遇到的窘境是类似的,这也是响应式编程要通过 <code>Publisher-Suscriber</code> 方式来解决的.</p>
</div>
</div>
<div class="sect2">
<h3 id="从命令式编程到响应式编程"><a class="anchor" href="#从命令式编程到响应式编程"></a>3.3. 从命令式编程到响应式编程</h3>
<div class="paragraph">
<p>类似 Reactor 这样的响应式库的目标就是要弥补上述 &#8220;classic&#8221; (经典) 的 JVM 异步方式所带来的不足, 此外还会关注一下几个方面:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Composability(可编排性)</strong> 和 <strong>readability(可读性)</strong></p>
</li>
<li>
<p>使用丰富的  <strong>操作符</strong> 来处理形如 <strong>流</strong> 的数据</p>
</li>
<li>
<p>在 <strong>subscribe(订阅)</strong> 之前什么都不会发生</p>
</li>
<li>
<p><strong>Backpressure(被压)</strong> 具体来说即 <em>消费者能够反向告知生产者生产内容的速度的能力</em></p>
</li>
<li>
<p><strong>高层次</strong> (同时也是有 <strong>高价值的</strong>)的抽象,从而达到 并发无关 的效果</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="可编排性与可读性"><a class="anchor" href="#可编排性与可读性"></a>3.3.1. 可编排性与可读性</h4>
<div class="paragraph">
<p>可编排性,指的是编排多个异步任务的能力.比如我们将前一个任务的结果传递给后一个任务作为输入, 或者将多个任务以分解再汇总(fork-join)的形式执行,或者将异步的任务作为离散的组件在系统中 进行重用.</p>
</div>
<div class="paragraph">
<p>这种编排任务的能力与代码的可读性和可维护性是紧密相关的.随着异步处理任务数量和复杂度 的提高,编写和阅读代码都变得越来越困难.就像我们刚才看到的,回调模式是简单的,但是缺点 是在复杂的处理逻辑中,回调中会层层嵌入回调,导致 回调地狱(Callback Hell) .你能猜到 (或有过这种痛苦经历),这样的代码是难以阅读和分析的.</p>
</div>
<div class="paragraph">
<p>Reactor 提供了丰富的编排操作,从而代码直观反映了处理流程,并且所有的操作保持在同一层次 (尽量避免了嵌套).</p>
</div>
</div>
<div class="sect3">
<h4 id="就像装配流水线"><a class="anchor" href="#就像装配流水线"></a>3.3.2. 就像装配流水线</h4>
<div class="paragraph">
<p>你可以想象数据在响应式应用中的处理,就像流过一条装配流水线.Reactor 既是传送带, 又是一个个的装配工或机器人.原材料从源头(最初的 <code>Publisher</code>)流出,最终被加工为成品, 等待被推送到消费者(或者说 <code>Subscriber</code>).</p>
</div>
<div class="paragraph">
<p>原材料会经过不同的中间处理过程,或者作为半成品与其他半成品进行组装.如果某处有齿轮卡住, 或者某件产品的包装过程花费了太久时间,相应的工位就可以向上游发出信号来限制或停止发出原材料.</p>
</div>
</div>
<div class="sect3">
<h4 id="operators操作符"><a class="anchor" href="#operators操作符"></a>3.3.3. Operators(操作符)</h4>
<div class="paragraph">
<p>在 Reactor 中,操作符(operator)就像装配线中的工位(操作员或装配机器人).每一个操作符 对 <code>Publisher</code> 进行相应的处理,然后将 <code>Publisher</code> 包装为一个新的 <code>Publisher</code>.就像一个链条,
数据源自第一个 <code>Publisher</code>,然后顺链条而下,在每个环节进行相应的处理.最终,一个订阅者 (<code>Subscriber</code>)终结这个过程.请记住,在订阅者(<code>Subscriber</code>)订阅(<code>subscribe</code>)到一个 发布者(<code>Publisher</code>)之前,什么都不会发生.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
理解了操作符会创建新的 Publisher 实例这一点,能够帮助你避免一个常见的问题, 这种问题会让你觉得处理链上的某个操作符没有起作用.相关内容请参考 <a href="#faq.chain">item</a> .
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>虽然响应式流规范(Reactive Streams specification)没有规定任何操作符, 类似 Reactor 这样的响应式库所带来的最大附加价值之一就是提供丰富的操作符.包括基础的转换操作, 到过滤操作,甚至复杂的编排和错误处理操作.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.subscribe"><a class="anchor" href="#reactive.subscribe"></a>3.3.4. <code>subscribe()</code> 之前什么都不会发生</h4>
<div class="paragraph">
<p>在 Reactor 中,当你创建了一条 <code>Publisher</code> 处理链,数据还不会开始生成.事实上,你是创建了 一种抽象的对于异步处理流程的描述(从而方便重用和组装).</p>
</div>
<div class="paragraph">
<p>当真正 <strong>subscribing</strong> 的时候,你需要将 <code>Publisher</code> 关联到一个 <code>Subscriber</code> 上,然后 才会触发整个链的流动.这时候,<code>Subscriber</code> 会向上游发送一个 <code>request</code> 信号,一直到达源头 的 <code>Publisher</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.backpressure"><a class="anchor" href="#reactive.backpressure"></a>3.3.5. Backpressure(背压)</h4>
<div class="paragraph">
<p>向上游传递信号这一点也被用于实现 背压 ,就像在装配线上,某个工位的处理速度如果慢于流水线 速度,会对上游发送反馈信号一样.</p>
</div>
<div class="paragraph">
<p>在响应式流规范中实际定义的机制同刚才的类比非常接近: 订阅者可以无限接受数据并让它的源头 “满负荷”推送所有的数据,也可以通过使用 <code>request</code> 机制来告知源头它一次最多能够处理 <code>n</code> 个元素.</p>
</div>
<div class="paragraph">
<p>中间环节的操作也可以影响 request.想象一个能够将每10个元素分批打包的缓存(<code>buffer</code>)操作. 如果订阅者请求一个元素,那么对于源头来说可以生成10个元素.此外预取策略也可以使用了, 比如在订阅前预先生成元素.
避免了 <code>request(1)</code>  往返,如果在请求之前生成元素的成本不太高的话,这将是有益的.</p>
</div>
<div class="paragraph">
<p>这样能够将“推送”模式转换为“推送+拉取”混合的模式,如果下游准备好了,可以从上游拉取 n 个元素; 但是如果上游元素还没有准备好,下游还是要等待上游的推送.</p>
</div>
</div>
<div class="sect3">
<h4 id="reactive.hotCold"><a class="anchor" href="#reactive.hotCold"></a>3.3.6. Hot vs Cold</h4>
<div class="paragraph">
<p>在 Rx 家族的响应式库中,响应式流分为 <strong>Cold</strong> 和 <strong>Hot</strong> 两种类型,区别主要在于响应式流如何 对订阅者进行响应:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Cold</strong> 指对于每一个 <code>Subscriber</code>,都会收到从头开始所有的数据.如果源头 生成了一个 HTTP 请求,对于每一个订阅都会创建一个新的 HTTP 请求.</p>
</li>
<li>
<p><strong>Hot</strong> 指对于一个 <code>Subscriber</code>,只能获取从它开始 订阅 之后 发出的数据.不过注意,有些 "hot" 的响应式流可以缓存部分或全部历史数据. 通常意义上来说,
一个 "hot" 的响应式流,甚至在即使没有订阅者接收数据的情况下,也可以 发出数据(这一点同 "Subscribe() 之前什么都不会发生" 的规则有冲突).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>更多关于 Reactor 中 Hot vs Cold 的内容,请参考 <a href="#reactor.hotCold">reactor-specific 章节</a>.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/reactiveProgramming.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#intro-reactive">介绍响应式编程</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="core-features"><a class="anchor" href="#core-features"></a>4. Reactor 核心特性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reactor 项目的主要 artifact 是 <code>reactor-core</code>,这是一个基于 Java 8 的实现了响应式流规范 (Reactive Streams specification)的响应式库.</p>
</div>
<div class="paragraph">
<p>Reactor 引入了实现 <code>Publisher</code> 的响应式类 <code>Flux</code> 和 <code>Mono</code>,以及丰富的操作方式. 一个 <code>Flux</code> 对象代表一个包含 0..N 个元素的响应式序列,而一个 <code>Mono</code> 对象代表一个包含 零/一个(0..1)元素的结果.</p>
</div>
<div class="paragraph">
<p>这种区别为这俩类型带来了语义上的信息——表明了异步处理逻辑所面对的元素基数.比如, 一个 HTTP 请求产生一个响应,所以对其进行 <code>count</code> 操作是没有多大意义的.表示这样一个 结果的话,应该用 <code>Mono&lt;HttpResponse&gt;</code> 而不是 <code>Flux&lt;HttpResponse&gt;</code>,因为要置于其上的 操作通常只用于处理 0/1 个元素.</p>
</div>
<div class="paragraph">
<p>有些操作可以改变基数,从而需要切换类型.比如,<code>count</code> 操作用于 <code>Flux</code>,但是操作 返回的结果是 <code>Mono&lt;Long&gt;</code>.</p>
</div>
<div class="sect2">
<h3 id="flux"><a class="anchor" href="#flux"></a>4.1. <code>Flux</code>, 包含 0-N 个元素的异步序列</h3>
<div class="paragraph">
<p>下图显示了 <code>Flux</code> 如何传输元素:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/marbles/flux.svg" alt="Flux">
</div>
</div>
<div class="paragraph">
<p><code>Flux&lt;T&gt;</code> 是一个能够发出 0 到 N 个元素的标准的 <code>Publisher&lt;T&gt;</code>,它会被一个 "错误(error)"  或 "完成(completion)" 信号终止.
就像在响应式流规范中规定的那样,这三种类型的信号被翻译为面向下游的 <code>onNext</code>,<code>onComplete</code> 和 <code>onError</code> 方法.</p>
</div>
<div class="paragraph">
<p>由于多种不同的信号可能性,<code>Flux</code> 可以作为一种通用的响应式类型.注意,所有的信号事件, 包括代表终止的信号事件都是可选的: 如果没有 <code>onNext</code> 事件但是有一个 <code>onComplete</code> 事件,
那么发出的就是 空的 有限序列,但是去掉 <code>onComplete</code> 那么得到的就是一个 无限的 空序列. 当然,无限序列也可以不是空序列,比如,<code>Flux.interval(Duration)</code> 生成的是一个 <code>Flux&lt;Long&gt;</code>, 这就是一个无限地周期性发出规律 ticks 的时钟序列.</p>
</div>
</div>
<div class="sect2">
<h3 id="mono"><a class="anchor" href="#mono"></a>4.2. <code>Mono</code>, 异步的 0-1 结果</h3>
<div class="paragraph">
<p>下图显示了 <code>Mono</code> 如何传输元素:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/marbles/mono.svg" alt="Mono">
</div>
</div>
<div class="paragraph">
<p><code>Mono&lt;T&gt;</code> 是一种特殊的 <code>Publisher&lt;T&gt;</code>, 它通过 <code>onNext</code>  信号最多发出一个元素,然后终止于一个 <code>onComplete</code> 信号 (成功的 <code>Mono</code>,值可有可无 ) 或一个 <code>onError</code> 信号 (失败的 <code>Mono</code>).</p>
</div>
<div class="paragraph">
<p>大多数  <code>Mono</code> 的实现都希望在调用 <code>onNext</code> 之后立即在 <code>Subscriber</code> 上调用 <code>onComplete</code>。<code>Mono.never()</code> 是一个异常值:它不发出任何信号，这在技术上不是禁止的，尽管在测试之外不是非常有用。另一方面，<code>onNext</code> 和 <code>onError</code> 的组合是显式禁止的。</p>
</div>
<div class="paragraph">
<p><code>Mono</code> 只适用其中一部分可用于 <code>Flux</code> 的操作.比如,(两个 <code>Mono</code> 的)结合类操作可以忽略其中之一 而发出另一个 <code>Mono</code>,也可以将两个都发出,对于后一种情况会切换为一个 <code>Flux</code>.</p>
</div>
<div class="paragraph">
<p>例如,<code>Mono#concatWith(Publisher)</code> 返回一个 <code>Flux</code>,而 <code>Mono#then(Mono)</code> 返回另一个 <code>Mono</code>.</p>
</div>
<div class="paragraph">
<p>注意,<code>Mono</code> 可以用于表示“空”的只有完成概念的异步处理(比如 <code>Runnable</code>).这种用 <code>Mono&lt;Void&gt;</code> 来创建.</p>
</div>
</div>
<div class="sect2">
<h3 id="简单的创建和订阅-flux-或-mono-的方法"><a class="anchor" href="#简单的创建和订阅-flux-或-mono-的方法"></a>4.3. 简单的创建和订阅 Flux 或 Mono 的方法</h3>
<div class="paragraph">
<p>最简单的上手 <code>Flux</code> 和 <code>Mono</code> 的方式就是使用相应类提供的多种工厂方法之一.</p>
</div>
<div class="paragraph">
<p>比如,如果要创建一个 <code>String</code> 的序列,你可以直接列举它们,或者将它们放到一个集合里然后用来创建 Flux,如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; seq1 = Flux.just("foo", "bar", "foobar");

List&lt;String&gt; iterable = Arrays.asList("foo", "bar", "foobar");
Flux&lt;String&gt; seq2 = Flux.fromIterable(iterable);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>工厂方法的其他例子如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Mono&lt;String&gt; noData = Mono.empty(); <i class="conum" data-value="1"></i><b>(1)</b>

Mono&lt;String&gt; data = Mono.just("foo");

Flux&lt;Integer&gt; numbersFromFiveToSeven = Flux.range(5, 3); <i class="conum" data-value="2"></i><b>(2)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注意,即使没有值,工厂方法仍然采用通用的返回类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个参数是 range 的开始,第二个参数是要生成的元素个数.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在订阅(subscribe)的时候,<code>Flux</code> 和 <code>Mono</code> 使用 Java 8 lambda 表达式. <code>.subscribe()</code> 方法有多种不同的方法签名,你可以传入各种不同的 lambda 形式的参数来定义回调.如下所示:</p>
</div>
<div id="subscribeMethods" class="exampleblock">
<div class="title">Example 10. 基于 lambda 的对 <code>Flux</code> 的订阅(subscribe)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">subscribe(); <i class="conum" data-value="1"></i><b>(1)</b>

subscribe(Consumer&lt;? super T&gt; consumer); <i class="conum" data-value="2"></i><b>(2)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer); <i class="conum" data-value="3"></i><b>(3)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer); <i class="conum" data-value="4"></i><b>(4)</b>

subscribe(Consumer&lt;? super T&gt; consumer,
          Consumer&lt;? super Throwable&gt; errorConsumer,
          Runnable completeConsumer,
          Consumer&lt;? super Subscription&gt; subscriptionConsumer); <i class="conum" data-value="5"></i><b>(5)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>订阅并触发序列.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>对每一个生成的元素进行消费.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>对正常元素进行消费,也对错误进行响应.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>对正常元素和错误均有响应,还定义了序列正常完成后的回调.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>对正常元素、错误和完成信号均有响应, 同时也定义了对该 <code>subscribe</code> 方法返回的 <code>Subscription</code> 执行的回调.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
以上方法会返回一个 <code>Subscription</code> 的引用,如果不再需要更多元素你可以通过它来取消订阅. 取消订阅时, 源头会停止生成新的数据,并清理相关资源.取消和清理的操作在 Reactor 中是在 接口 <code>Disposable</code> 中定义的.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="subscribe-方法示例"><a class="anchor" href="#subscribe-方法示例"></a>4.3.1. <code>subscribe</code> 方法示例</h4>
<div class="paragraph">
<p>这一小节包含了对 <code>subscribe</code> 的 5 个不同签名的方法的示例,如下是一个无参的基本方法的使用:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 3); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(); <i class="conum" data-value="2"></i><b>(2)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>配置一个在订阅时会产生3个值的 <code>Flux</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>最简单的订阅方式</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>第二行代码没有任何输出,但是它确实执行了.<code>Flux</code> 产生了 3 个值.如果我们传入一个 lambda, 我们就可以看到这几个值,如下一个列子:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 3); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(i -&gt; System.out.println(i)); <i class="conum" data-value="2"></i><b>(2)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>配置一个在订阅时会产生3个值的 <code>Flux</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>订阅它并输出值</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>第二行代码会输入如下内容:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>1
2
3</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了演示下一个方法签名,我们故意引入一个错误,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4) <i class="conum" data-value="1"></i><b>(1)</b>
      .map(i -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
        if (i &lt;= 3) return i; <i class="conum" data-value="3"></i><b>(3)</b>
        throw new RuntimeException("Got to 4"); <i class="conum" data-value="4"></i><b>(4)</b>
      });
ints.subscribe(i -&gt; System.out.println(i), <i class="conum" data-value="5"></i><b>(5)</b>
      error -&gt; System.err.println("Error: " + error));
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>配置一个在订阅时会产生4个值的 Flux.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>为了对元素进行处理,我们需要一个 map 操作</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>对于多数元素,返回值本身.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>对其中一个元素抛出错误.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>订阅的时候定义如何进行错误处理</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>现在我们有两个 lambda 表达式: 一个是用来处理正常数据,一个用来处理错误. 刚才的代码输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>1
2
3
Error: java.lang.RuntimeException: Got to 4</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下一个 <code>subscribe</code> 方法的签名既有错误处理,还有一个完成后的处理,如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4); <i class="conum" data-value="1"></i><b>(1)</b>
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; System.out.println("Done")); <i class="conum" data-value="2"></i><b>(2)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>配置一个在订阅时会产生 4 个值的 Flux</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>订阅时定义错误和完成信号的处理.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>错误和完成信号都是终止信号,并且二者只会出现其中之一.为了能够最终全部正常完成,你必须处理错误信号.</p>
</div>
<div class="paragraph">
<p>用于处理完成信号的 lambda 是一对空的括号,因为它实际上匹配的是 <code>Runnalbe</code> 接口中的 <code>run</code> 方法, 不接受参数.刚才的代码输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>1
2
3
4
Done</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>subscribe</code> 方法的最后一个签名包括 <code>Consumer&lt;Subscription&gt;</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
该变体需要您对 <code>Subscription</code> 进行操作(对它执行一个 <code>request(long)</code>  或 <code>cancel()</code> ).否则,<code>Flux</code> 会挂起.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示了 <code>subscription</code> 方法的最后一个签名:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(i -&gt; System.out.println(i),
    error -&gt; System.err.println("Error " + error),
    () -&gt; System.out.println("Done"),
    sub -&gt; sub.request(10)); <i class="conum" data-value="1"></i><b>(1)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>当我们订阅时,我们会收到一个  <code>Subscription</code>.表示我们要从源中获取最多 <code>10</code> 个元素(实际上将发出 <code>4</code> 个元素并完成).</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="通过-disposable-取消-subscribe"><a class="anchor" href="#通过-disposable-取消-subscribe"></a>4.3.2. 通过 <code>Disposable</code> 取消 <code>subscribe()</code></h4>
<div class="paragraph">
<p>所有这些基于 lambda 的 <code>subscribe()</code> 都有 <code>Disposable</code> 的返回类型. <code>Disposable</code> 接口代表我们可以通过其  <code>dispose()</code> 方法来取消订阅.</p>
</div>
<div class="paragraph">
<p>对于 <code>Flux</code> 或 <code>Mono</code>, 取消意味着源应该停止生成元素，但是，它不能保证是即时的:有些源可能会快速地生成元素，以至于在收到取消指令之前就完成了。</p>
</div>
<div class="paragraph">
<p>一些关于 <code>Disposable</code> 的工具类可以在 <code>Disposables</code> 类中找到。其中，<code>Disposables.swap()</code> 创建了一个 <code>Disposable</code> 包装器，允许您自动取消和替换一个具体的 <code>Disposable</code>。这可能很有用，例如，在 UI 场景中，当用户单击按钮时，您希望取消一个请求并用一个新的请求替换它。处理包装本身将关闭它。这样做将处理当前的具体值和所有未来尝试的替换.</p>
</div>
<div class="paragraph">
<p>另一个有趣的是 <code>Disposables.composite(&#8230;&#8203;)</code>. 他可以允许您收集多个 <code>Disposable</code>&#8201;&#8212;&#8201;例如，多个与服务调用关联的正在处理的请求&#8201;&#8212;&#8201;并在稍后一次性处理所有这些请求.
一旦组合的 <code>dispose()</code> 方法被调用，任何添加另一个 <code>Disposable</code>  的尝试都会立即处理.</p>
</div>
</div>
<div class="sect3">
<h4 id="lambda-的替代方案-basesubscriber"><a class="anchor" href="#lambda-的替代方案-basesubscriber"></a>4.3.3. Lambda 的替代方案: <code>BaseSubscriber</code></h4>
<div class="paragraph">
<p>还有另一种更通用的  <code>subscribe</code> 方法,它采用了成熟的 <code>Subscriber</code> ,而不是由一个 lambda 组成一个.为了帮助编写这样的  <code>Subscriber</code>,我们提供了一个称为 <code>BaseSubscriber</code> 的可扩展类.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
BaseSubscriber(或其子类)的实例都只能使用一次,这意味着如果 <code>BaseSubscriber</code> 订阅了第二个 <code>Publisher</code>,则取消其对第一个 <code>Publisher</code> 的订阅.
那是因为两次使用一个实例将违反响应式流规则,即不能并行调用 <code>Subscriber</code> 的 <code>onNext</code> 方法. 因此,只有在对 <code>Publisher#subscribe(Subscriber)</code> 的调用中直接声明匿名实现时,匿名实现才可以.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在我们可以实现其中之一.我们称它为 <code>SampleSubscriber</code>.以下示例显示了如何将其连接到 <code>Flux</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SampleSubscriber&lt;Integer&gt; ss = new SampleSubscriber&lt;Integer&gt;();
Flux&lt;Integer&gt; ints = Flux.range(1, 4);
ints.subscribe(ss);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的示例显示了 <code>SampleSubscriber</code> ,它是 <code>BaseSubscriber</code> 的简约实现:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block">package io.projectreactor.samples;

</span><span class="fold-block hide-when-folded">import org.reactivestreams.Subscription;

import reactor.core.publisher.BaseSubscriber;

</span><span class="fold-block">public class SampleSubscriber&lt;T&gt; extends BaseSubscriber&lt;T&gt; {

    public void hookOnSubscribe(Subscription subscription) {
        System.out.println("Subscribed");
        request(1);
    }

    public void hookOnNext(T value) {
        System.out.println(value);
        request(1);
    }
}
</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>SampleSubscriber</code> 类继承自 <code>BaseSubscriber</code>,在 Reactor 中, 推荐用户扩展它来实现自定义的 <code>Subscriber</code>.这个类提供了一些 hook 方法,我们可以通过重写它们来调整 subscriber 的行为.
默认情况下,它会触发一个无限个数的请求,但是当你想自定义请求元素的个数的时候,扩展 <code>BaseSubscriber</code> 就很方便了.</p>
</div>
<div class="paragraph">
<p>扩展的时候通常至少要覆盖 <code>hookOnSubscribe(Subscription subscription)</code> 和 <code>hookOnNext(T value)</code> 这两个方法.这个例子中, <code>hookOnSubscribe</code> 方法打印一段话到标准输出,然后进行第一次请求.
然后 <code>hookOnNext</code> 同样进行了打印,同时逐个处理剩余请求.</p>
</div>
<div class="paragraph">
<p><code>SampleSubscriber</code> 输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Subscribed
1
2
3
4</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>BaseSubscriber</code> 还提供了 <code>requestUnbounded()</code> 方法以切换到"无限”模式(等效于 <code>request(Long.MAX_VALUE)</code>),还提供了  <code>cancel()</code>  方法.</p>
</div>
<div class="paragraph">
<p>它还具有其他钩子: <code>hookOnComplete</code>, <code>hookOnError</code>, <code>hookOnCancel</code>, 和 <code>hookFinally</code>(在序列终止时始终调用,并将终止类型作为 <code>SignalType</code> 参数传入)</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
建议你同时重写 <code>hookOnError</code>、<code>hookOnCancel</code>,以及 <code>hookOnComplete</code> 方法. 你最好也重写 <code>hookFinally</code> 方法.<code>SampleSubscriber</code> 确实是一个最简单的实现了 请求有限个数元素的 Subscriber.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="关于背压和重塑请求的方法"><a class="anchor" href="#关于背压和重塑请求的方法"></a>4.3.4. 关于背压和重塑请求的方法</h4>
<div class="paragraph">
<p>在 Reactor 中实现背压时,通过向上游发送请求,将消费者压力传播回源. 当前请求的总和有时被称为当前 &#8220;demand&#8221; 或 &#8220;pending request&#8221;. 需求的上限为 <code>Long.MAX_VALUE</code>,表示无限制的请求(意思是 "尽可能快地生成"-基本禁用背压).</p>
</div>
<div class="paragraph">
<p>在订阅时,当第一个请求来自 final subscriber ,但是以下最直接的订阅方式立即触发 <code>了Long.MAX_VALUE</code> 的无限制请求:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subscribe()</code> 大多数基于 lambda 的变体(具有 <code>Consumer&lt;Subscription&gt;</code> 的变体除外)</p>
</li>
<li>
<p><code>block()</code>, <code>blockFirst()</code> 和 <code>blockLast()</code></p>
</li>
<li>
<p>遍历一个 <code>toIterable()</code> 或 <code>toStream()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>自定义原始请求的最简单方法是使用 <code>BaseSubscriber</code> 进行预订,并覆盖 <code>hookOnSubscribe</code> 方法,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.range(1, 10)
    .doOnRequest(r -&gt; System.out.println("request of " + r))
    .subscribe(new BaseSubscriber&lt;Integer&gt;() {

      @Override
      public void hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      public void hookOnNext(Integer integer) {
        System.out.println("Cancelling after having received " + integer);
        cancel();
      }
    });
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的代码段打印出以下内容:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>request of 1
Cancelling after having received 1</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
当你修改请求操作的时候,你必须注意让 <code>subscriber</code> 向上提出足够的需求, 否则上游的 <code>Flux</code> 可能会被“卡住”.所以 <code>BaseSubscriber</code> 在进行扩展的时候要覆盖 <code>hookOnSubscribe</code> 和 <code>onNext</code>,这样你至少会调用 <code>request</code> 一次.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="使用操作符改变下游需求"><a class="anchor" href="#使用操作符改变下游需求"></a>使用操作符改变下游需求</h5>
<div class="paragraph">
<p>要记住的一件事是,上游链中的每个操作符都可以调整在订阅表达的需求. 一个典型的情况是 <code>buffer(N)</code> 运算符: 如果接收到一个  <code>request(2)</code>,则解释为对两个完整缓冲区的需求.
结果,由于缓冲区需要将 <code>N</code> 个元素视为已满,因此缓冲区运算符会将请求重塑为 <code>2 x N</code>.</p>
</div>
<div class="paragraph">
<p>您可能还已经注意到,某些运算符的变体采用了  <code>prefetch</code> 的 <code>int</code> 输入参数. 这是另一类修改下游请求的运算符. 这些通常是处理内部序列的运算符,是从每个传入元素(例如 <code>flatMap</code>)扩展 出 <code>Publisher</code> 的.</p>
</div>
<div class="paragraph">
<p><strong>Prefetch</strong> 是一种调整对这些内部序列发出的初始请求的方法.如果未指定,则大多数这些运算符的开头为 <code>32</code>.</p>
</div>
<div class="paragraph">
<p>这些操作符通常还会实现  <strong>replenishing optimization</strong>: 一旦操作符看到预请求的 <code>75%</code> 得到满足,它就会从上游重新请求 <code>75%</code>. 进行启发式优化,以便这些操作能够主动预测即将到来的请求.</p>
</div>
<div class="paragraph">
<p>最后,几个运算符可让您直接调整请求: <code>limitRate</code> and <code>limitRequest</code>.</p>
</div>
<div class="paragraph">
<p><code>limitRate(N)</code> 拆分下游请求,以便将它们以较小的速度传到上游. 例如,对 <code>limitRate(10)</code> 发出的 <code>100</code> 个请求最多将导致 <code>10</code> 个 <code>10</code> 个请求传到上游.
注意,以这种形式,<code>limitRate</code> 实际上实现了前面讨论的补充优化.</p>
</div>
<div class="paragraph">
<p>运算符还有一个变体,还可以让您调整数量(在变体中称为 <code>lowTide</code>): <code>limitRate(highTide, lowTide)</code>. 选择 <code>lowTide</code> 0 会导致严格的  <code>highTide</code> 请求批次,
而不是通过 replenishing 策略进一步重做的批次.</p>
</div>
<div class="paragraph">
<p><code>limitRequest(N)</code>, 另一方面,将下游请求限制为最大总需求. 它将总计达 <code>N</code> 个请求.如果单个请求未使总需求超过 <code>N</code>,则该特定请求将完全传到上游. 源地址发出该 amount 后,<code>limitRequest</code> 认为序列已完成,向下游发送 <code>onComplete</code> 信号, 然后取消源.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="producing"><a class="anchor" href="#producing"></a>4.4. 可编程式地创建一个序列</h3>
<div class="paragraph">
<p>在这一小节,我们介绍如何通过定义相对应的事件(<code>onNext</code>、<code>onError</code> 和 <code>onComplete</code>) 创建一个 <code>Flux</code> 或 <code>Mono</code>.所有这些方法都通过
API 来触发我们叫做 <strong>sink</strong>(池) 的事件. sink 的类型不多,我们快速过一下.</p>
</div>
<div class="sect3">
<h4 id="producing.generate"><a class="anchor" href="#producing.generate"></a>4.4.1. 同步 <code>generate</code></h4>
<div class="paragraph">
<p>最简单的创建 <code>Flux</code> 的方式就是使用 <code>generate</code> 方法.</p>
</div>
<div class="paragraph">
<p>这是一种 <strong>同步地</strong>, <strong>逐个地</strong> 产生值的方法,意味着 sink 是一个 <code>SynchronousSink</code> 而且其 <code>next()</code> 方法在每次回调的时候最多只能被调用一次.你也可以调用 <code>error(Throwable)</code> 或者 <code>complete()</code>,不过是可选的.</p>
</div>
<div class="paragraph">
<p>最有用的一种方式就是同时能够记录一个状态值(state),从而在使用 sink 发出下一个元素的时候能够 基于这个状态值去产生元素.此时生成器(generator)方法就是一个 <code>BiFunction&lt;S, SynchronousSink&lt;T&gt;, S&gt;</code>, 其中  <code>&lt;S&gt;</code>  是状态对象的类型.你需要提供一个 <code>Supplier&lt;S&gt;</code> 来初始化状态值,而生成器需要 在每一“回合”生成元素后返回新的状态值(供下一回合使用).</p>
</div>
<div class="paragraph">
<p>例如我们使用一个 <code>int</code> 作为状态值.</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. 基于状态值的 generate 示例</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    () -&gt; 0, <i class="conum" data-value="1"></i><b>(1)</b>
    (state, sink) -&gt; {
      sink.next("3 x " + state + " = " + 3*state); <i class="conum" data-value="2"></i><b>(2)</b>
      if (state == 10) sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
      return state + 1; <i class="conum" data-value="4"></i><b>(4)</b>
    });
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>初始化状态值(state)为0.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们基于状态值 state 来生成下一个值(state 乘以 3)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们也可以用状态值来决定什么时候终止序列.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>返回一个新的状态值 state,用于下一次调用.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的代码生成了“3 x”的乘法表:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>3 x 0 = 0
3 x 1 = 3
3 x 2 = 6
3 x 3 = 9
3 x 4 = 12
3 x 5 = 15
3 x 6 = 18
3 x 7 = 21
3 x 8 = 24
3 x 9 = 27
3 x 10 = 30</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们也可以使用可变(mutable)类型(译者注: 如上例,原生类型及其包装类,以及 String 等属于不可变类型) 的 <code>&lt;S&gt;</code>.上边的例子也可以用 <code>AtomicLong</code> 作为状态值,在每次生成后改变它的值.</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. 可变类型的状态变量</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::new, <i class="conum" data-value="1"></i><b>(1)</b>
    (state, sink) -&gt; {
      long i = state.getAndIncrement(); <i class="conum" data-value="2"></i><b>(2)</b>
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state; <i class="conum" data-value="3"></i><b>(3)</b>
    });
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这次我们初始化一个可变类型的状态值.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>改变状态值.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>返回 <strong>同一个</strong> 实例作为新的状态值.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果状态对象需要清理资源,可以使用 <code>generate(Supplier&lt;S&gt;, BiFunction, Consumer&lt;S&gt;)</code> 这个签名方法来清理状态对象.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>下面是一个在 <code>generate</code> 方法中增加 <code>Consumer</code> 的例子:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux.generate(
    AtomicLong::new,
      (state, sink) -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
      long i = state.getAndIncrement(); <i class="conum" data-value="2"></i><b>(2)</b>
      sink.next("3 x " + i + " = " + 3*i);
      if (i == 10) sink.complete();
      return state; <i class="conum" data-value="3"></i><b>(3)</b>
    }, (state) -&gt; System.out.println("state: " + state)); <i class="conum" data-value="4"></i><b>(4)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>同样,初始化一个可变对象作为状态变量.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>改变状态.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>返回 <strong>同一个</strong> 实例作为新的状态</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>我们会看到最后一个状态值(11)会被这个 <code>Consumer</code> lambda 输出.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果 state 使用了数据库连接或者其他需要最终进行清理的资源,这个 <code>Consumer</code> lambda 可以用来在最后关闭连接或完成相关的其他清理任务.</p>
</div>
</div>
<div class="sect3">
<h4 id="producing.create"><a class="anchor" href="#producing.create"></a>4.4.2. 异步和多线程: <code>create</code></h4>
<div class="paragraph">
<p>作为一个更高级的创建 <code>Flux</code> 的方式, <code>create</code> 方法的生成方式既可以是同步, 也可以是异步的,并且还可以每次发出多个元素.</p>
</div>
<div class="paragraph">
<p>该方法用到了 <code>FluxSink</code>,后者同样提供 <code>next</code>,<code>error</code> 和 <code>complete</code> 等方法. 与 <code>generate</code> 不同的是,<code>create</code> 不需要状态值,另一方面,它可以在回调中触发 多个事件(即使是在未来的某个时间).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>create</code> 有个好处就是可以将现有的 API 转为响应式,比如监听器的异步方法.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
即使它可以与异步 API 一起使用,但 <code>create</code> 不会并行异步执行您的代码. 如果在创建 lambda 中阻塞了,则会使自己陷入死锁和类似的副作用.
即使使用了 <code>SubscribeOn</code>,也需要注意的是,长时间阻塞的创建 lambda(例如,调用 <code>sink.next(t)</code> 的无限循环)可以锁定管道: 由于循环使同一线程处于饥饿状态,
因此将永远不会执行请求. 使用 <code>subscribeOn(Scheduler, false)</code> 变体: <code>requestOnSeparateThread = false</code> 将使用 <code>Scheduler</code> 线程进行创建,并且仍然可以通过在原始线程中执行请求来让数据传输.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>假设你有一个监听器 API,它按 chunk 处理数据,有两种事件: (1)一个 chunk 数据准备好的事件; (2)处理结束的事件.如 <code>MyEventListener</code> 接口所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">interface MyEventListener&lt;T&gt; {
    void onDataChunk(List&lt;T&gt; chunk);
    void processComplete();
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>你可以使用 <code>create</code> 方法将其转化为响应式类型 <code>Flux&lt;T&gt;</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myEventProcessor.register( <i class="conum" data-value="4"></i><b>(4)</b>
      new MyEventListener&lt;String&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
          }
        }

        public void processComplete() {
            sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
        }
    });
});
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>桥接  <code>MyEventListener</code> API</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>每一个 chunk 的数据转化为 <code>Flux</code> 中的一个元素.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>processComplete</code> 事件转换为 <code>onComplete</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>所有这些都是在 <code>myEventProcessor</code> 执行时异步执行的.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>此外,既然 <code>create</code> 可以是异步地,并且能够控制背压,你可以通过提供一个 <code>OverflowStrategy</code> 来定义背压行为.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IGNORE</code> 完全忽略下游背压请求,这可能会在下游队列积满的时候导致 <code>IllegalStateException</code>.</p>
</li>
<li>
<p><code>ERROR</code> 当下游跟不上节奏的时候发出一个 <code>IllegalStateException</code> 的错误信号.</p>
</li>
<li>
<p><code>DROP</code> 当下游没有准备好接收新的元素的时候抛弃这个元素.</p>
</li>
<li>
<p><code>LATEST</code> 让下游只得到上游最新的元素.</p>
</li>
<li>
<p><code>BUFFER</code> (默认的)缓存所有下游没有来得及处理的元素(这个不限大小的缓存可能导致 <code>OutOfMemoryError</code>).</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>Mono</code> 也有一个用于 <code>create</code> 的生成器(generator)—— <code>MonoSink</code>,它不能生成多个元素, 因此会抛弃第一个元素之后的所有元素.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="异步但单线程-推送push模式"><a class="anchor" href="#异步但单线程-推送push模式"></a>4.4.3. 异步但单线程: 推送(push)模式</h4>
<div class="paragraph">
<p><code>create</code> 的一个变体是 <code>push</code>,适合生成事件流.与 <code>create</code> 类似,<code>push</code> 也可以是异步地, 并且能够使用以上各种溢出策略(overflow strategies)管理背压.
每次只有一个生成线程可以调用 <code>next</code>,<code>complete</code> 或 <code>error</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; bridge = Flux.push(sink -&gt; {
    myEventProcessor.register(
      new SingleThreadEventListener&lt;String&gt;() { <i class="conum" data-value="1"></i><b>(1)</b>

        public void onDataChunk(List&lt;String&gt; chunk) {
          for(String s : chunk) {
            sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
          }
        }

        public void processComplete() {
            sink.complete(); <i class="conum" data-value="3"></i><b>(3)</b>
        }

        public void processError(Throwable e) {
            sink.error(e); <i class="conum" data-value="4"></i><b>(4)</b>
        }
    });
});
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>桥接  <code>SingleThreadEventListener</code> API.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在监听器所在线程中,事件通过调用 <code>next</code> 被推送到 sink</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>complete</code> 事件也在同一个线程中.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>error</code> 事件也在同一个线程中.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="推送拉取pushpull混合模式"><a class="anchor" href="#推送拉取pushpull混合模式"></a>推送/拉取(push/pull)混合模式</h5>
<div class="paragraph">
<p>大多数响应式的操作,如 <code>create</code>,采用混合推/拉模型.我们的意思是,尽管大多数处理是异步的(建议使用推方法),但其中有一个小的拉取组件:request.</p>
</div>
<div class="paragraph">
<p>使用者从源头中提取数据,因为在第一次请求之前它不会发出任何数据.只要数据可用,源头就会将其推送给使用者,但要在请求的数量范围内.</p>
</div>
<div class="paragraph">
<p>注意,<code>push()</code> 和 <code>create()</code> 都允许设置一个 <code>onRequest</code> 消费者,以便管理请求数量,并确保只有在存在挂起的请求时才通过接收器推送数据.</p>
</div>
<div class="paragraph">
<p>不像 <code>push</code>,<code>create</code> 可以用于 <strong>push/pull</strong> 模式,因此适合桥接监听器的 的 API,因为事件消息会随时异步地到来.
回调方法 onRequest 可以被注册到 FluxSink 以便跟踪请求.这个回调可以被用于从源头请求更多数据,或者通过在下游请求到来 的时候传递数据给 sink 以实现背压管理.
这是一种推送/拉取混合的模式, 因为下游可以从上游拉取已经就绪的数据,上游也可以在数据就绪的时候将其推送到下游.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    myMessageProcessor.register(
      new MyMessageListener&lt;String&gt;() {

        public void onMessage(List&lt;String&gt; messages) {
          for(String s : messages) {
            sink.next(s); <i class="conum" data-value="3"></i><b>(3)</b>
          }
        }
    });
    sink.onRequest(n -&gt; {
        List&lt;String&gt; messages = myMessageProcessor.getHistory(n); <i class="conum" data-value="1"></i><b>(1)</b>
        for(String s : messages) {
           sink.next(s); <i class="conum" data-value="2"></i><b>(2)</b>
        }
    });
});
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>当有请求的时候取出一个 message.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果有就绪的 message,就发送到 sink.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>后续异步到达的 message 也会被发送给 sink</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="push-或-create-之后清理"><a class="anchor" href="#push-或-create-之后清理"></a><code>push()</code> 或 <code>create()</code> 之后清理</h5>
<div class="paragraph">
<p><code>onDispose</code> 和 <code>onCancel</code> 这两个回调用于在被取消和终止后进行清理工作. <code>onDispose</code> 可用于在 <code>Flux</code> 完成,有错误出现或被取消的时候执行清理. <code>onCancel</code> 只用于针对“取消”信号执行相关操作,会先于 <code>onDispose</code> 执行.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; {
    sink.onRequest(n -&gt; channel.poll(n))
        .onCancel(() -&gt; channel.cancel()) <i class="conum" data-value="1"></i><b>(1)</b>
        .onDispose(() -&gt; channel.close())  <i class="conum" data-value="2"></i><b>(2)</b>
    });
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>onCancel</code> 在取消时被调用</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>onDispose</code> 在有完成、错误和取消时被调用.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handle"><a class="anchor" href="#handle"></a>4.4.4. Handle</h4>
<div class="paragraph">
<p><code>handle</code> 方法有些不同,它在 <code>Mono</code> 和 <code>Flux</code> 中都有.然而,它是一个实例方法 (instance method),意思就是它要链接在一个现有的源后使用(与其他操作符一样).</p>
</div>
<div class="paragraph">
<p>它与 <code>generate</code> 比较类似,因为它也使用 <code>SynchronousSink</code>,并且只允许元素逐个发出. 然而,<code>handle</code> 可被用于基于现有数据源中的元素生成任意值,有可能还会跳过一些元素. 这样,可以把它当做 <code>map</code> 与 <code>filter</code> 的组合.handle 方法签名如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;R&gt; handle(BiConsumer&lt;T, SynchronousSink&lt;R&gt;&gt;);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>举个例子,响应式流规范允许 <code>null</code> 这样的值出现在序列中.假如你想执行一个类似 <code>map</code> 的操作,你想利用一个现有的具有映射功能的方法,但是它会返回 null,这时候怎么办呢?</p>
</div>
<div class="paragraph">
<p>例如,下边的方法可以用于 Integer 序列,映射为字母或 null .</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public String alphabet(int letterNumber) {
    if (letterNumber &lt; 1 || letterNumber &gt; 26) {
        return null;
    }
    int letterIndexAscii = 'A' + letterNumber - 1;
    return "" + (char) letterIndexAscii;
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们可以使用 <code>handle</code> 来去掉其中的 <code>null</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. 将 <code>handle</code> 用于一个 "映射 + 过滤 null" 的场景</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; alphabet = Flux.just(-1, 30, 13, 9, 20)
    .handle((i, sink) -&gt; {
        String letter = alphabet(i); <i class="conum" data-value="1"></i><b>(1)</b>
        if (letter != null) <i class="conum" data-value="2"></i><b>(2)</b>
            sink.next(letter); <i class="conum" data-value="3"></i><b>(3)</b>
    });

alphabet.subscribe(System.out::println);
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>映射到字母</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果返回的是 null &#8230;&#8203;.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>就不会调用 <code>sink.next</code> 从而过滤掉.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>M
I
T</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="schedulers"><a class="anchor" href="#schedulers"></a>4.5. Threading and Schedulers(线程和调度器)</h3>
<div class="paragraph">
<p>Reactor, 就像 RxJava,也可以被认为是 并发无关(concurrency agnostic) 的.意思就是, 它并不强制要求任何并发模型.更进一步,它将选择权交给开发者.不过,它还是提供了一些方便 进行并发执行的库.</p>
</div>
<div class="paragraph">
<p>在 Reactor 中,执行模式以及执行过程取决于所使用的 Scheduler. Scheduler 是一个拥有广泛实现类的抽象接口. Schedulers 类提供的静态方法用于达成如下的执行环境:</p>
</div>
<div class="paragraph">
<p><code>Flux</code> 和 <code>Mono</code> 不会创建线程.取而代之的是,大多数操作符会继续在前一个操作符的线程中工作. 除非指定,否则 topmost 运算符(source)本身运行在进行  <code>subscribe()</code>  调用的线程上. 以下示例在新线程中运行 <code>Mono</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static void main(String[] args) throws InterruptedException {
  final Mono&lt;String&gt; mono = Mono.just("hello "); <i class="conum" data-value="1"></i><b>(1)</b>

  Thread t = new Thread(() -&gt; mono
      .map(msg -&gt; msg + "thread ")
      .subscribe(v -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
          System.out.println(v + Thread.currentThread().getName()) <i class="conum" data-value="3"></i><b>(3)</b>
      )
  )
  t.start();
  t.join();

}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>Mono&lt;String&gt;</code> 在 <code>main</code> 线程中运行.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>但是,它是在线程 <code>Thread-0</code> 中订阅的. .</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>结果, <code>map</code> 和 <code>onNext</code> 回调实际上都在 <code>Thread-0</code> 中运行</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的代码产生以下输出:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>hello thread Thread-0</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在 Reactor 中,执行模式以及执行过程取决于所使用的 <code>Scheduler</code>. <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html"><code>Scheduler</code></a> 是一个拥有广泛实现类类似 <code>ExecutorService</code> 的调度职责 的抽象接口.
尤其是充当时钟并启用更广泛的实现方式(测试的虚拟时间,trampolining 或 即时调度 等)</p>
</div>
<div class="paragraph">
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html"><code>Schedulers</code></a> 类提供的静态方法用于达成如下的执行环境:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>没有执行上下文 (<code>Schedulers.immediate()</code>): 在处理时,提交的 <code>Runnable</code> 将被直接在当前线程中执行(可以视为“空对象”或无操作 <code>Scheduler</code>).</p>
</li>
<li>
<p>可重用的单线程 (<code>Schedulers.single()</code>). 注意,这个方法对所有调用者都提供同一个线程来使用, 直到该调度器(Scheduler)被废弃.如果你想使用专一的线程,就对每一个调用使用 <code>Schedulers.newSingle()</code> .</p>
</li>
<li>
<p>无限弹性线程池 (<code>Schedulers.elastic()</code>): 此选项不再是首选,因为它倾向于隐藏背压问题并导致线程过多(请参见下文)使用  <code>Schedulers.boundedElastic()</code>.</p>
</li>
<li>
<p>有限弹性线程池 (<code>Schedulers.boundedElastic()</code>). 像其前身 <code>elastic()</code> 一样 ,它根据需要创建一个线程池,重用空闲线程.线程池如果空闲时间过长 (默认为 60s)就会被废弃.与  <code>elastic()</code> 不同的是,它可以支持
你创建线程的个数(默认为 CPU 核数*10),达到上限后,最多可提交 <code>10</code> 万个任务,并在线程可用时重新调度(当延迟调度时,延迟在线程可用时开始),对于 I/O 阻塞的场景比较适用. <code>Schedulers.boundedElastic()</code> 能够方便地给一个阻塞 的任务分配它自己的线程,
从而不会妨碍其他任务和资源,见 <a href="#faq.wrap-blocking">如何包装一个同步阻塞的调用 ?</a>.使用新线程不会给系统带来太大压力.</p>
</li>
<li>
<p>固定大小线程池 (<code>Schedulers.parallel()</code>). 所创建线程池的大小与 CPU 个数等同.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外,你还可以使用 <code>Schedulers.fromExecutorService(ExecutorService)</code> 基于现有的 <code>ExecutorService</code> 创建 <code>Scheduler</code>.(虽然不太建议,不过你也可以使用 <code>Executor</code> 来创建).</p>
</div>
<div class="paragraph">
<p>你也可以使用 <code>newXXX</code> 方法来创建不同的调度器.比如 <code>Schedulers.newElastic(yourScheduleName)</code> 创建一个新的名为 <code>yourScheduleName</code> 的弹性调度器.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然 <code>boundedElastic</code> 可以帮助避免传统阻塞代码,但 <code>single</code> 和 <code>parallel</code> 则不行. 结果,使用 Reactor 阻塞的 API(<code>block()</code>, <code>blockFirst()</code>, <code>blockLast()</code> (以及在默认的  <code>single</code> 和 <code>parallel</code>  调度程序中迭代到 <code>toIterable()</code> 或 <code>toStream()</code> ))会抛出 <code>IllegalStateException</code> 异常.</p>
</div>
<div class="paragraph">
<p>通过创建实现 <code>NonBlocking</code> 接口的 <code>Thread</code> 实例,还可以将自定义调度程序标记为 "non blocking only".</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一些操作符默认会使用一个指定的调度器(通常也允许开发者调整为其他调度器)例如, 通过工厂方法 <code>Flux.interval(Duration.ofMillis(300))</code>  生成的每 300ms 打点一次的 <code>Flux&lt;Long&gt;</code>, 默认情况下使用的是 <code>Schedulers.parallel()</code>,下边的代码演示了如何将其装换为 <code>Schedulers.single()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.interval(Duration.ofMillis(300), Schedulers.newSingle("test"))
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Reactor 提供了两种在响应式链中调整调度器 <code>Scheduler</code> 的方法: <code>publishOn</code> 和 <code>subscribeOn</code>. 它们都接受一个 <code>Scheduler</code> 作为参数,从而可以改变调度器.但是 <code>publishOn</code> 在链中出现的位置 是有讲究的,而 <code>subscribeOn</code> 则无所谓.要理解它们的不同,你首先要理解 <a href="#reactive.subscribe">nothing happens until you subscribe</a>.</p>
</div>
<div class="paragraph">
<p>在 Reactor 中,当你在操作链上添加操作符的时候,你可以根据需要在 <code>Flux</code> 和 <code>Mono</code> 的实现中包装其他的 <code>Flux</code> 和 <code>Mono</code>.一旦你订阅(subscribe)了它,一个 <code>Subscriber</code> 的链 就被创建了,一直向上到第一个 <code>publisher</code> .这些对开发者是不可见的,开发者所能看到的是最外一层的 <code>Flux</code> (或 <code>Mono</code>)和 <code>Subscription</code>,但是具体的任务是在中间这些跟操作符相关的 <code>subscriber</code> 上处理的.</p>
</div>
<div class="paragraph">
<p>基于此,我们仔细研究一下 <code>publishOn</code> 和 <code>subscribeOn</code> 这两个操作符:</p>
</div>
<div class="sect3">
<h4 id="the-publishon-method"><a class="anchor" href="#the-publishon-method"></a>4.5.1. The <code>publishOn</code> Method</h4>
<div class="paragraph">
<p><code>publishOn</code> 的用法和处于订阅链(subscriber chain)中的其他操作符一样.它将上游 信号传给下游,同时执行指定的调度器 <code>Scheduler</code> 的某个工作线程上的回调.
它会 改变后续的操作符的执行所在线程 (直到下一个 <code>publishOn</code> 出现在这个链上).如下所示:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Scheduler</code> 选择的一个线程更改执行上下文</p>
</li>
<li>
<p>根据规范,onNext调用是按顺序发生的,因此这会占用一个线程</p>
</li>
<li>
<p>除非他们在特定的 <code>Scheduler</code> 上工作,否则 <code>publishOn</code> 之后的操作符将继续在同一线程上执行</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下示例使用 <code>publishOn</code> 方法:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); <i class="conum" data-value="1"></i><b>(1)</b>

final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    .map(i -&gt; 10 + i)  <i class="conum" data-value="2"></i><b>(2)</b>
    .publishOn(s)  <i class="conum" data-value="3"></i><b>(3)</b>
    .map(i -&gt; "value " + i);  <i class="conum" data-value="4"></i><b>(4)</b>

new Thread(() -&gt; flux.subscribe(System.out::println));  <i class="conum" data-value="5"></i><b>(5)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建一个有 4 个线程的 <code>Scheduler</code> 实例</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个 <code>map</code> 操作在  &lt;5&gt; 中匿名线程上执行.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>publishOn</code> 将整个列表切换到从 &lt;1&gt; 选取的 线程 上.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>第二个 <code>map</code> 在&lt;1&gt;的线程上运行.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>此匿名线程是在 <em>subscription</em> 时产生的线程.输出在最新的执行上下文中,输出 <code>publishOn</code> 中的内容.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="the-subscribeon-method"><a class="anchor" href="#the-subscribeon-method"></a>4.5.2. The <code>subscribeOn</code> Method</h4>
<div class="paragraph">
<p><code>subscribeOn</code> 用于订阅(subscription)过程,作用于那个向上的订阅链(发布者在被订阅 时才激活,订阅的传递方向是向上游的).所以,无论你把 <code>subscribeOn</code> 至于操作链的什么位置,
它都会影响到源头的线程执行环境(context). 但是,它不会影响到后续的 <code>publishOn</code>,后者仍能够切换其后操作符的线程执行环境.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>更改整个操作链所订阅的线程</p>
</li>
<li>
<p>从 <code>Scheduler</code> 中选择一个线程</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
实际上仅考虑链中最早的 <code>SubscribeOn</code> 调用.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例使用 <code>subscribeOn</code> 方法:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Scheduler s = Schedulers.newParallel("parallel-scheduler", 4); <i class="conum" data-value="1"></i><b>(1)</b>

final Flux&lt;String&gt; flux = Flux
    .range(1, 2)
    .map(i -&gt; 10 + i)  <i class="conum" data-value="2"></i><b>(2)</b>
    .subscribeOn(s)  <i class="conum" data-value="3"></i><b>(3)</b>
    .map(i -&gt; "value " + i);  <i class="conum" data-value="4"></i><b>(4)</b>

new Thread(() -&gt; flux.subscribe(System.out::println));  <i class="conum" data-value="5"></i><b>(5)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建一个有 4 个线程的 <code>Scheduler</code> 实例</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一个 <code>map</code> 操作在这四个线程之一上执行.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;因为 <code>subscriptionOn</code> 会从订阅时间(&lt;5&gt;)开始切换整个序列.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>第二个 <code>map</code> 也运行在同一线程上.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>这个匿名线程是最初进行  <em>subscription</em> 的那个线程,但是 <code>subscribeOn</code> 立即将其转移到 scheduler 四个之一的线程.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="error.handling"><a class="anchor" href="#error.handling"></a>4.6. 处理错误</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果想了解有哪些可用于错误处理的操作符,请参考 <a href="#which.errors">the relevant operator decision tree</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>在响应式流中,错误(error)是终止(terminal)事件.当有错误发生时,它会导致流序列停止, 并且错误信号会沿着操作链条向下传递,直至遇到你定义的 <code>Subscriber</code> 及其 <code>onError</code> 方法.</p>
</div>
<div class="paragraph">
<p>这样的错误还是应该在应用层面解决的.比如,你可能会将错误信息显示在用户界面,或者通过某个 REST 端点(endpoint)发出.因此,订阅者(subscriber)的 <code>onError</code> 方法是应该定义的.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
如果没有定义,<code>onError</code> 会抛出 <code>UnsupportedOperationException</code>.你可以接下来再 检测错误,并通过 <code>Exceptions.isErrorCallbackNotImplemented</code> 方法捕获和处理它.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reactor 还提供了其他的用于在链中处理错误的方法,即错误处理操作(error-handling operators).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just(1, 2, 0)
    .map(i -&gt; "100 / " + i + " = " + (100 / i)) //this triggers an error with 0
    .onErrorReturn("Divided by zero :("); // error handling example
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
在你了解错误处理操作符之前,你必须牢记 响应式流中的任何错误都是一个终止事件. 即使用了错误处理操作符,也不会让源头流序列继续.
而是将 <code>onError</code> 信号转化为一个 新的 序列 的开始.换句话说,它代替了被终结的 上游 流序列.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>现在我们来逐个看看错误处理的方法.需要的时候我们会同时用到命令式编程风格的 <code>try</code> 代码块来作比较.</p>
</div>
<div class="sect3">
<h4 id="错误处理方法"><a class="anchor" href="#错误处理方法"></a>4.6.1. “错误处理”方法</h4>
<div class="paragraph">
<p>你也许熟悉在 try-catch 代码块中处理异常的几种方法.常见的包括如下几种:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>捕获并返回一个静态的默认值.</p>
</li>
<li>
<p>捕获并执行一个异常处理方法.</p>
</li>
<li>
<p>捕获并动态计算一个候补值来顶替.</p>
</li>
<li>
<p>捕获,并再包装为某一个 业务相关的异常,然后再抛出 <code>BusinessException</code>.</p>
</li>
<li>
<p>捕获,记录错误日志,然后继续抛出.</p>
</li>
<li>
<p>使用 <code>finally</code> 来清理资源,或使用 Java 7 引入的 <code>"try-with-resource"</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以上所有这些在 Reactor 都有相应的基于 error-handling 操作符处理方式.</p>
</div>
<div class="paragraph">
<p>在开始研究这些操作符之前,我们先准备好响应式链(reactive chain)方式和 try-catch 代码块方式(以便对比).</p>
</div>
<div class="paragraph">
<p>当订阅的时候,位于链结尾的 <code>onError</code> 回调方法和 <code>catch</code> 块类似,一旦有  <code>Exception</code> ,执行过程会跳入到 catch:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; s = Flux.range(1, 10)
    .map(v -&gt; doSomethingDangerous(v)) <i class="conum" data-value="1"></i><b>(1)</b>
    .map(v -&gt; doSecondTransform(v)); <i class="conum" data-value="2"></i><b>(2)</b>
s.subscribe(value -&gt; System.out.println("RECEIVED " + value), <i class="conum" data-value="3"></i><b>(3)</b>
            error -&gt; System.err.println("CAUGHT " + error) <i class="conum" data-value="4"></i><b>(4)</b>
);
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>执行 map 转换,有可能抛出异常.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果没问题,执行第二个 map 转换操作.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>所有转换成功的值都打印出来.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>一旦有错误,序列(sequence)终止,并打印错误信息.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>这与 try/catch 代码块是类似的:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    for (int i = 1; i &lt; 11; i++) {
        String v1 = doSomethingDangerous(i); <i class="conum" data-value="1"></i><b>(1)</b>
        String v2 = doSecondTransform(v1); <i class="conum" data-value="2"></i><b>(2)</b>
        System.out.println("RECEIVED " + v2);
    }
} catch (Throwable t) {
    System.err.println("CAUGHT " + t); <i class="conum" data-value="3"></i><b>(3)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果这里抛出异常&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;后续的代码跳过&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203; 执行过程直接到这</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>既然我们准备了两种方式做对比,我们就来看一下不同的错误处理场景,以及相应的操作符.</p>
</div>
<div class="sect4">
<h5 id="静态默认值"><a class="anchor" href="#静态默认值"></a>静态默认值</h5>
<div class="paragraph">
<p>与第 (1) 条(捕获并返回一个静态的默认值)对应的是 <code>onErrorReturn</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
  return doSomethingDangerous(10);
}
catch (Throwable error) {
  return "RECOVERED";
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了 Reactor 的如何操作:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn("RECOVERED");
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以选择对异常进行 <code>Predicate</code> ,以决定是否要恢复,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just(10)
    .map(this::doSomethingDangerous)
    .onErrorReturn(e -&gt; e.getMessage().equals("boom10"), "recovered10"); <i class="conum" data-value="1"></i><b>(1)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>仅在异常消息为 <code>"boom10"</code> 时恢复</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="异常处理方法"><a class="anchor" href="#异常处理方法"></a>异常处理方法</h5>
<div class="paragraph">
<p>如果你不只是想要在发生错误的时候给出默认值,而是希望提供一种更安全的处理数据的方式, 可以使用 <code>onErrorResume</code>.这与第 (2) 条(捕获并执行一个异常处理方法)类似.</p>
</div>
<div class="paragraph">
<p>假设,你会尝试从一个外部的不稳定服务获取数据,但仍然会在本地缓存一份 可能 有些过期的数据, 因为缓存的读取更加可靠.可以这样来做:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String v1;
try {
  v1 = callExternalService("key1");
}
catch (Throwable error) {
  v1 = getFromCache("key1");
}

String v2;
try {
  v2 = callExternalService("key2");
}
catch (Throwable error) {
  v2 = getFromCache("key2");
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例显示了 Reactor 的实现方式:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just("key1", "key2")
    .flatMap(k -&gt; callExternalService(k) <i class="conum" data-value="1"></i><b>(1)</b>
        .onErrorResume(e -&gt; getFromCache(k)) <i class="conum" data-value="2"></i><b>(2)</b>
    );
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>对于每个 key,异步调用  external service.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果对外部服务的调用失败,则再去缓存中查找该 key.注意,这里无论 <code>e</code> 是什么,都会执行异常处理方法.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>就像 <code>onErrorReturn</code>,<code>onErrorResume</code> 也有可以用于预先过滤错误内容的方法变体,可以基于异常类或 <code>Predicate</code> 进行过滤.它实际上是用一个 <code>Function</code> 来作为参数,还可以返回一个新的流序列.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just("timeout1", "unknown", "key2")
    .flatMap(k -&gt; callExternalService(k)
        .onErrorResume(error -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
            if (error instanceof TimeoutException) <i class="conum" data-value="2"></i><b>(2)</b>
                return getFromCache(k);
            else if (error instanceof UnknownKeyException)  <i class="conum" data-value="3"></i><b>(3)</b>
                return registerNewEntry(k, "DEFAULT");
            else
                return Flux.error(error); <i class="conum" data-value="4"></i><b>(4)</b>
        })
    );
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个函数式允许开发者自行决定如何处理</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果源超时,使用本地缓存</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果源找不到对应的 key,创建一个新的实体.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>否则, 将问题 <code>"重新抛出"</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="动态候补值"><a class="anchor" href="#动态候补值"></a>动态候补值</h5>
<div class="paragraph">
<p>有时候并不想提供一个错误处理方法,而是想在接收到错误的时候计算一个候补的值.这类似于第 (3) 条(捕获并动态计算一个候补值).</p>
</div>
<div class="paragraph">
<p>例如,如果你的返回类型本身就有可能包装有异常(比如 <code>Future.complete(T success)</code> vs <code>Future.completeExceptionally(Throwable error)</code> ),你有可能使用流中的错误包装起来实例化 返回值.</p>
</div>
<div class="paragraph">
<p>示例代码如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
  Value v = erroringMethod();
  return MyWrapper.fromValue(v);
}
catch (Throwable error) {
  return MyWrapper.fromError(error);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这也可以使用上一种错误处理方法的方式(使用 <code>onErrorResume</code>)解决,代码如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">erroringFlux.onErrorResume(error -&gt; Mono.just( <i class="conum" data-value="1"></i><b>(1)</b>
        MyWrapper.fromError(error) <i class="conum" data-value="2"></i><b>(2)</b>
));
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>由于我们希望使用 <code>MyWrapper</code> 表示错误,,在 <code>onErrorResume</code> 中,使用 <code>Mono.just</code> 创建一个 <code>Mono&lt;MyWrapper&gt;</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们需要计算异常值.在这里,我们通过使用相关的 <code>MyWrapper</code> 工厂方法包装异常来实现这一点.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="捕获并重新抛出"><a class="anchor" href="#捕获并重新抛出"></a>捕获并重新抛出</h5>
<div class="paragraph">
<p>捕获,包装到 <code>BusinessException</code> 并重新抛出.如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
  return callExternalService(k);
}
catch (Throwable error) {
  throw new BusinessException("oops, SLA exceeded", error);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在 &#8220;错误处理方法&#8221; 的例子中,基于 <code>flatMap</code> 方法的最后一行,我们可以猜到如何做到第 (4) 条(捕获,包装到一个业务相关的异常,然后抛出 <code>BusinessException</code>):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just("timeout1")
    .flatMap(k -&gt; callExternalService(k))
    .onErrorResume(original -&gt; Flux.error(
            new BusinessException("oops, SLA exceeded", original))
    );
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然而还有一个更加直接的方法 —— <code>onErrorMap</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just("timeout1")
    .flatMap(k -&gt; callExternalService(k))
    .onErrorMap(original -&gt; new BusinessException("oops, SLA exceeded", original));
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="记录错误日志"><a class="anchor" href="#记录错误日志"></a>记录错误日志</h5>
<div class="paragraph">
<p>对于希望错误继续传播但仍希望对它作出反应而又不修改顺序(例如记录错误)的情况,可以使用doOnError运算符. 这等效于“捕获,记录特定于错误的消息并重新抛出”模式,如以下示例所示:</p>
</div>
<div class="paragraph">
<p>如果对于错误你只是想在不改变它的情况下做出响应(如记录日志),并让错误继续传递下去, 那么可以用 <code>doOnError</code> 方法.这对应第 (5) 条(捕获,记录错误日志,并继续抛出).如以下示例所示</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
  return callExternalService(k);
}
catch (RuntimeException error) {
  //make a record of the error
  log("uh oh, falling back, service failed for key " + k);
  throw error;
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个方法与其他以 <code>doOn</code> 开头的方法一样,只起副作用("side-effect").它们对序列都是只读, 而不会带来任何改动.</p>
</div>
<div class="paragraph">
<p>如下边的例子所示,我们会记录错误日志</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">LongAdder failureStat = new LongAdder();
Flux&lt;String&gt; flux =
Flux.just("unknown")
    .flatMap(k -&gt; callExternalService(k) <i class="conum" data-value="1"></i><b>(1)</b>
        .doOnError(e -&gt; {
            failureStat.increment();
            log("uh oh, falling back, service failed for key " + k); <i class="conum" data-value="2"></i><b>(2)</b>
        })
        <i class="conum" data-value="3"></i><b>(3)</b>
    );
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>对外部服务的调用失败&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>&#8230;&#8203;记录错误日志&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203;然后回调错误处理方法.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>并且还通过变量自增统计错误发生个数.</p>
</div>
</div>
<div class="sect4">
<h5 id="使用资源和-try-catch-代码块"><a class="anchor" href="#使用资源和-try-catch-代码块"></a>使用资源和 try-catch 代码块</h5>
<div class="paragraph">
<p>最后一个要与命令式编程对应的对比就是使用 Java 7 "try-with-resources" 或 <code>finally</code> 代码块清理资源.这是第 (6) 条(使用 <code>finally</code> 代码块清理资源或使用 Java 7 引入的 "try-with-resource").</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. Imperative use of finally</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Stats stats = new Stats();
stats.startTimer();
try {
  doSomethingDangerous();
}
finally {
  stats.stopTimerAndRecordTiming();
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 15. Imperative use of try-with-resource</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try (SomeAutoCloseable disposableInstance = new SomeAutoCloseable()) {
  return disposableInstance.toString();
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在 Reactor 中都有对应的方法:  <code>using</code> 和 <code>doFinally</code>:</p>
</div>
<div class="paragraph">
<p>另一方面, <code>doFinally</code> 在序列终止(无论是 <code>onComplete</code>、<code>onError</code> 还是取消)的时候被执行, 并且能够判断是什么类型的终止事件(完成、错误还是取消? ).</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="title">Reactive finally: <code>doFinally()</code></div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Stats stats = new Stats();
LongAdder statsCancel = new LongAdder();

Flux&lt;String&gt; flux =
Flux.just("foo", "bar")
    .doOnSubscribe(s -&gt; stats.startTimer())
    .doFinally(type -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
        stats.stopTimerAndRecordTiming();<i class="conum" data-value="2"></i><b>(2)</b>
        if (type == SignalType.CANCEL) <i class="conum" data-value="3"></i><b>(3)</b>
          statsCancel.increment();
    })
    .take(1); <i class="conum" data-value="4"></i><b>(4)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>doFinally</code> 用 <code>SignalType</code> 检查了终止信号的类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>与 <code>finally</code> 块类似,我们总是记录时间.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果只是取消,那么统计数据自增.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>take(1)</code> 能够在发出 1 个元素后取消流.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>另一方面,<code>using</code> 能处理从 <code>Flux</code> 产生的资源,并且每当处理完成时都必须对资源进行操作. 在以下示例中,我们用 <code>Disposable</code> 替换了  &#8220;try-with-resource&#8221;  的 <code>AutoCloseable</code> 接口:</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. The Disposable resource</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AtomicBoolean isDisposed = new AtomicBoolean();
Disposable disposableInstance = new Disposable() {
    @Override
    public void dispose() {
        isDisposed.set(true); <i class="conum" data-value="4"></i><b>(4)</b>
    }

    @Override
    public String toString() {
        return "DISPOSABLE";
    }
};
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在,我们可以在上面进行等效的  &#8220;try-with-resource&#8221;  尝试,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. Reactive try-with-resource: <code>using()</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux =
Flux.using(
        () -&gt; disposableInstance, <i class="conum" data-value="1"></i><b>(1)</b>
        disposable -&gt; Flux.just(disposable.toString()), <i class="conum" data-value="2"></i><b>(2)</b>
        Disposable::dispose <i class="conum" data-value="3"></i><b>(3)</b>
);
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>第一个 lambda 生成资源,这里我们返回模拟的(mock) <code>Disposable</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第二个 lambda 处理资源,返回一个 <code>Flux&lt;T&gt;</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>第三个 lambda 在 2) 中的资源 <code>Flux</code> 终止或取消的时候,用于清理资源</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在订阅或执行流序列之后, isDisposed 会置为 <code>true</code>.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="演示终止方法-onerror"><a class="anchor" href="#演示终止方法-onerror"></a>演示终止方法 <code>onError</code></h5>
<div class="paragraph">
<p>为了演示当错误出现的时候如何导致上游序列终止,我们使用 <code>Flux.interval</code> 构造一个更加直观的例子. 这个 <code>interval</code> 操作符会在每 <code>x</code> 单位的时间发出一个自增的 <code>Long</code> 值.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux =
Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .onErrorReturn("Uh oh");

flux.subscribe(System.out::println);
Thread.sleep(2100); <i class="conum" data-value="1"></i><b>(1)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>注意 interval 默认基于一个  <strong>timer</strong> <code>Scheduler</code> 来执行. 如果我们想在 main 方法中运行, 我们需要调用 <code>sleep</code>,这样程序就可以在还没有产生任何值的时候就退出了.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>每 250ms 打印出一行信息,如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>tick 0
tick 1
tick 2
Uh oh</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>即使多给了 1 秒钟时间,也没有更多的 tick 信号由 <code>interval</code> 产生了,所以序列确实被错误信号终止了.</p>
</div>
</div>
<div class="sect4">
<h5 id="重试"><a class="anchor" href="#重试"></a>重试</h5>
<div class="paragraph">
<p>还有一个用于错误处理的操作符你可能会用到,就是 <code>retry</code>,见文知意,用它可以对出现错误的序列进行重试.</p>
</div>
<div class="paragraph">
<p>问题是它对于上游 <code>Flux</code> 是基于重订阅(<strong>re-subscribing</strong>)的方式.这实际上已经一个不同的序列了, 发出错误信号的序列仍然是终止了的.为了验证这一点,我们可以在继续用上边的例子,增加一个 <code>retry(1)</code> 代替 <code>onErrorReturn</code> 来重试一次.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.interval(Duration.ofMillis(250))
    .map(input -&gt; {
        if (input &lt; 3) return "tick " + input;
        throw new RuntimeException("boom");
    })
    .retry(1)
    .elapsed() <i class="conum" data-value="1"></i><b>(1)</b>
    .subscribe(System.out::println, System.err::println); <i class="conum" data-value="2"></i><b>(2)</b>

Thread.sleep(2100); <i class="conum" data-value="3"></i><b>(3)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>elapsed</code> 会关联从当前值与上个值发出的时间间隔(译者加: 如下边输出的内容中的 259/249/251…)</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们还是要看一下 <code>onError</code> 时的内容.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>确保我们有足够的时间可以进行 4x2 次 tick.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>输出如下</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>259,tick 0
249,tick 1
251,tick 2
506,tick 0 <i class="conum" data-value="1"></i><b>(1)</b>
248,tick 1
253,tick 2
java.lang.RuntimeException: boom</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>一个新的 <code>interval</code> 从 tick 0 开始.多出来的 250ms 间隔来自于第 4 次 tick, 就是导致出现异常并执行 <code>retry</code> 的那次.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>可见, <code>retry(1)</code> 不过是再一次从新订阅了原始的 <code>interval</code>,从 tick 0 开始.第二次, 由于异常再次出现,便将异常传递到下游了.</p>
</div>
<div class="paragraph">
<p>还有一个 &#8220;高配版&#8221; 的 <code>retry</code> (<code>retryWhen</code>),它使用一个伴随(&#8220;companion&#8221;) <code>Flux</code> 来判断对某次错误是否要重试.这个伴随 <code>Flux</code> 是由操作符创建的,但是由开发者包装它, 从而实现对重试操作的配置.</p>
</div>
<div class="paragraph">
<p>这个伴随 <code>Flux</code> 是一个 <code>Flux&lt;RetrySignal&gt;</code>,它作为 <code>retryWhen</code> 的唯一参数被传递给一个 <code>Retry</code> strategy/function,你可以定义这个函数并让它返回一个新的 <code>Publisher&lt;?&gt;</code>.
<code>Retry</code> 类是一个抽象类,但是如果您想用一个简单的 lambda (<code>Retry.from(Function)</code>) 转换,它提供了一个工厂方法.</p>
</div>
<div class="paragraph">
<p>重试周期如下:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>每次出现错误,都会将 <code>RetrySignal</code> 信号会发送给伴随 <code>Flux</code>,后者已经被你的方法包装.在 <code>Flux</code> 可以看到目前为止所有的尝试,<code>RetrySignal</code> 允许访问错误以及错误周围的元数据.</p>
</li>
<li>
<p>如果伴随 <code>Flux</code> 发出元素,就会触发重试.</p>
</li>
<li>
<p>如果伴随 <code>Flux</code> 完成(complete),重试循环也会停止,并且原始序列也会 完成(complete)</p>
</li>
<li>
<p>如果伴随 Flux 产生一个错误( <code>e</code> ),则重试周期停止,结果序列错误为 <code>e</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>了解前两个场景的区别是很重要的.如果让伴随 Flux 完成(complete)等于吞掉了错误.如下代码用 <code>retryWhen</code> 模仿了 <code>retry(3)</code> 的效果:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux
    .&lt;String&gt;error(new IllegalArgumentException()) <i class="conum" data-value="1"></i><b>(1)</b>
    .doOnError(System.out::println) <i class="conum" data-value="2"></i><b>(2)</b>
    .retryWhen(Retry.from(companion -&gt; <i class="conum" data-value="3"></i><b>(3)</b>
        companion.take(3))); <i class="conum" data-value="4"></i><b>(4)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>持续产生错误.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在 retry 之前 的 <code>doOnError</code> 可以让我们看到错误.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>Retry</code> 适配自一个非常简单的lambda <code>Function</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>这里,我们认为前 3 个错误是可以重试的(<code>take(3)</code>),再有错误就放弃.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>事实上,上边例子最终得到的是一个 空的 <code>Flux</code>,但是却 成功 完成了.反观对同一个 <code>Flux</code> 调用 <code>retry(3)</code> 的话,最终是以最后一个 error 终止 Flux,故而 <code>retryWhen</code> 与之不同.</p>
</div>
<div class="paragraph">
<p>实现同样的效果需要一些额外的技巧:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AtomicInteger errorCount = new AtomicInteger();
Flux&lt;String&gt; flux =
        Flux.&lt;String&gt;error(new IllegalArgumentException())
                .doOnError(e -&gt; errorCount.incrementAndGet())
                .retryWhen(Retry.from(companion -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
                        companion.map(rs -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
                            if (rs.totalRetries() &lt; 3) return rs.totalRetries(); <i class="conum" data-value="3"></i><b>(3)</b>
                            else throw Exceptions.propagate(rs.failure()); <i class="conum" data-value="4"></i><b>(4)</b>
                        })
                ));
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们通过改写 lambda <code>Function</code> 而不是提供具体的类来自定义 <code>Retry</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>伴随 <code>RetrySignal</code> 对象,该对象包含重试次数以及上一次失败</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>为了允许进行三次重试,我们考虑让 indexes&lt;3,然后返回要发出的值(这里我们只是返回索引).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>为了终止错误的序列,我们在这三个重试之后抛出了原始异常.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
可以使用  <code>Retry</code> 中暴露的构建器以更流畅的方式以及更精细的重试策略来实现相同目标.例如: <code>errorFlux.retryWhen(Retry.max(3));</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
类似的代码也可以被用于实现 &#8220;exponential backoff and retry&#8221; 模式 (译者加: 重试指定的次数, 且每一次重试之间停顿的时间逐渐增加),参考 <a href="#faq.exponentialBackoff">FAQ</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>core 包中提供的 <code>Retry</code> helpers , <code>RetrySpec</code> 和 <code>RetryBackoffSpec</code> 都允许高级自定义,例如:
- 为可能触发重试的异常设置 <code>filter(Predicate)</code>
- 通过 <code>modifyErrorFilter(Function)</code> 修改类似上一条中设置的过滤器
- 触发副作用,例如在重试触发器周围记录日志(即在延迟之前和之后进行回退),前提是重试已通过验证(<code>doBeforeRetry()</code> 和 <code>doAfterRetry()</code> 都符合)
- 在重试触发器周围触发异步 <code>Mono&lt;Void&gt;</code>,这允许在基本延迟之上添加异步行为,但因此进一步延迟了触发器( <code>doBeforeRetryAsync</code> 和 <code>doAfterRetryAsync</code> 是符合)
- 通过 <code>onRetryExhaustedThrow(BiFunction)</code> 自定义异常(如果已达到最大尝试次数).默认情况下,使用  <code>Exceptions.retryExhausted(&#8230;&#8203;)</code>,可以通过 <code>Exceptions.isRetryExhausted(Throwable)</code> 进行区分
- 激活  <em>transient errors</em>  的处理(请参见下文)(see below)</p>
</div>
<div class="paragraph">
<p><code>Retry</code> 规范中的瞬态错误处理利用 <code>RetrySignal#totalRetriesInARow()</code>: 检查是否重试并计算重试延迟,使用的索引是一种替代索引,每次发出 <code>onNext</code> 时,该索引都会重置为0.
结果是,如果重新订阅源在再次失败之前生成了一些数据,则先前的失败将不会计入最大重试次数. 在采用指数退避策略的情况下,这还意味着下一次尝试将回到使用最小的 <code>Duration</code> ,而不是更长的 <code>Duration</code>.
这对于发现零星突发错误(或瞬态错误)的长寿命源尤其有用,在这种情况下,应使用自己的退避重试每个突发.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AtomicInteger errorCount = new AtomicInteger(); <i class="conum" data-value="1"></i><b>(1)</b>
AtomicInteger transientHelper = new AtomicInteger();
Flux&lt;Integer&gt; transientFlux = Flux.&lt;Integer&gt;generate(sink -&gt; {
    int i = transientHelper.getAndIncrement();
    if (i == 10) { <i class="conum" data-value="2"></i><b>(2)</b>
        sink.next(i);
        sink.complete();
    }
    else if (i % 3 == 0) { <i class="conum" data-value="3"></i><b>(3)</b>
        sink.next(i);
    }
    else {
        sink.error(new IllegalStateException("Transient error at " + i)); <i class="conum" data-value="4"></i><b>(4)</b>
    }
})
        .doOnError(e -&gt; errorCount.incrementAndGet());

transientFlux.retryWhen(Retry.max(2).transientErrors(true))  <i class="conum" data-value="5"></i><b>(5)</b>
             .blockLast();
assertThat(errorCount).hasValue(6); <i class="conum" data-value="6"></i><b>(6)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们将计算重试序列中的错误数.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们 <code>generate</code>  的源中包含大量错误.当计数器达到 10 时,它将成功完成.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果 <code>transientHelper</code> atomic 是 3 的倍数,则我们发出 <code>onNext</code> 并因此结束当前突发.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>在其他情况下,我们发出一个 <code>onError</code>.因为 2 不是 3 的倍数,因此 2 个 <code>onError</code> 突发被 1 个 <code>onNext</code> 中断.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>我们在该源上使用 <code>retryWhen</code>,最多配置2次重试尝试,但处于 <code>transientErrors</code> 模式.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>最后,在 <code>errorCount</code> 中注册了 <code>6</code> 个错误之后,序列到达 <code>onNext(10)</code> 并完成.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>如果没有 <code>transientErrors(true)</code>,则第二个突发将达到配置的最大尝试次数 <code>2</code>,并且在发出 <code>onNext(3)</code> 之后序列将失败.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="在操作符或函数式中处理异常"><a class="anchor" href="#在操作符或函数式中处理异常"></a>4.6.2. 在操作符或函数式中处理异常</h4>
<div class="paragraph">
<p>总体来说,所有的操作符自身都可能包含触发异常的代码,或自定义的可能导致失败的代码, 所以它们都自带一些错误处理方式.</p>
</div>
<div class="paragraph">
<p>一般来说,一个 不受检异常(Unchecked Exception) 总是由 <code>onError</code> 传递.例如, 在一个 <code>map</code> 方法中抛出 <code>RuntimeException</code> 会被翻译为一个 <code>onError</code> 事件,如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.just("foo")
    .map(s -&gt; { throw new IllegalArgumentException(s); })
    .subscribe(v -&gt; System.out.println("GOT VALUE"),
               e -&gt; System.out.println("ERROR: " + e));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上边代码输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ERROR: java.lang.IllegalArgumentException: foo</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>Exception</code> 可以在其被传递给 <code>onError</code> 之前,使用 <a href="#hooks-internal">hook</a> 进行调整.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Reactor,定义了一系列的能够导致“严重失败”的错误(比如 <code>OutOfMemoryError</code>),也可参考 <code>Exceptions.throwIfFatal</code> 方法.这些错误意味着 Reactor 无力处理只能抛出,无法传递下去.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
还有些情况下不受检异常仍然无法传递下去(多数处于 subscribe 和 request 阶段), 因为可能由于多线程竞争导致两次 <code>onError</code> 或 <code>onComplete</code> 的情况.当这种竞争发生的时候, 无法传递下去的错误信号就被 &#8220;dropped&#8221; 了.
这些情况仍然可以通过自定义的 hook 来搞定,见 丢弃事件的 <a href="#hooks-dropping">丢弃事件的 Hooks</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>你可能会问: “那么 受检查异常(Checked Exceptions)? ”</p>
</div>
<div class="paragraph">
<p>如果你需要调用一个声明为 <code>throws</code> 异常的方法,你仍然需要使用 <code>try-catch</code> 代码块处理异常. 有几种方式:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>捕获异常,并修复它,流序列正常继续.</p>
</li>
<li>
<p>捕获异常,并把它包装(wrap)到一个 不受检异常 中,然后抛出(中断序列).工具类 <code>Exceptions</code> 可用于这种方式(我们马上会讲到).</p>
</li>
<li>
<p>如果你需要我返回一个 <code>Flux</code> (例如在 <code>flatMap</code> 中),将异常包装在一个产生错误的 <code>Flux``中:  `return Flux.error(checkedException)</code>(流序列也会终止).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Reactor 有一个工具类 <code>Exceptions</code>,可以确保在收到受检异常的时候将其包装(wrap)起来.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果需要,可以使用 <code>Exceptions.propagate</code> 方法来包装异常,它同样会首先调用 <code>throwIfFatal</code>, 并且不会包装 <code>RuntimeException</code>.</p>
</li>
<li>
<p>使用 <code>Exceptions.unwrap</code> 方法来得到原始的未包装的异常(追溯最初的异常).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下面是一个 <code>map</code> 的例子,它使用的 <code>convert</code> 方法会抛出 <code>IOException</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public String convert(int i) throws IOException {
    if (i &gt; 3) {
        throw new IOException("boom " + i);
    }
    return "OK " + i;
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在想象你将这个方法用于一个 <code>map</code> 中,你必须明确捕获这个异常,并且你的 <code>map</code> 方法不能再次抛出它. 所以你可以将其以 <code>RuntimeException</code> 的形式传递给 <code>onError</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; converted = Flux
    .range(1, 10)
    .map(i -&gt; {
        try { return convert(i); }
        catch (IOException e) { throw Exceptions.propagate(e); }
    });
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当后边订阅上边的这个 <code>Flux</code> 并响应错误(比如在用户界面)的时候,如果你想处理 IOException, 你还可以再将其转换为原始的异常.如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">converted.subscribe(
    v -&gt; System.out.println("RECEIVED: " + v),
    e -&gt; {
        if (Exceptions.unwrap(e) instanceof IOException) {
            System.out.println("Something bad happened with I/O");
        } else {
            System.out.println("Something bad happened");
        }
    }
);
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="processors"><a class="anchor" href="#processors"></a>4.7. Processors 和 Sinks</h3>
<div class="paragraph">
<p>Processors 既是一种特别的发布者(<code>Publisher</code>)又是一种订阅者(<code>Subscriber</code>).
它们最初的目的是作为一个中间步骤的可能表示，然后可以在 Reactive Streams 实现之间共享。然而，在 Reactor 中，这些步骤是由 <code>Publisher</code> 之类的操作符表示的。</p>
</div>
<div class="paragraph">
<p>第一次遇到 <code>Processor</code> 时，一个常见的错误是试图直接从 <code>Subscriber</code> 接口调用公开的 <code>onNext</code>, <code>onComplete</code> 和 <code>onError</code>  方法。</p>
</div>
<div class="paragraph">
<p>这样的手动调用应该小心进行，特别是在 Reactive Streams 规范之外的同步调用。Processors 实际上可能略微有用，除非遇到需要传递基于 Reactive Streams 的 API 的 <code>Subscriber</code> 而不是公开 <code>Publisher</code> 的.</p>
</div>
<div class="paragraph">
<p>Sinks 通常是更好的选择。在 Reactor 中，sink 是一个允许安全手动触发信号的类。它可以与订阅关联(从操作符内部)，也可以完全独立.</p>
</div>
<div class="paragraph">
<p>从 <code>3.4.0</code> 开始, sinks 逐渐成为一等公民, 并且 <code>Processor</code> 正被逐渐淘汰:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>抽象和具体的 <code>FluxProcessor</code> 和 <code>MonoProcessor</code> 都将被淘汰，并在 3.5.0 移除</p>
</li>
<li>
<p>sinks 是通过 <code>Sinks</code> 类中的工厂生成的，而不是通过操作符产生的.</p>
</li>
<li>
<p>我们希望所有的 processor 用法都可以通过现有的操作符或者 <code>Sinks</code> 来替代。在 3.5 发布之前，用户有时间去发现那些不是这样的情况，同时退回到使用废弃的 api.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sinks"><a class="anchor" href="#sinks"></a>5. 使用 <code>Sinks.One</code> 和 <code>Sinks.Many</code> 从多个线程生成</h2>
<div class="sectionbody">
<div class="paragraph">
<p>从下游订阅者的角度来看，由 reactor-core 暴露的 <code>Sinks</code> 需要确保多线程使用被检测到，并且不会导致违反规范或未定义的行为。当使用 <code>tryEmit*</code>  API 时，并行调用会快速失败。当使用 <code>emit*</code>  API 时，提供的 <code>EmissionFailureHandler</code> 可能允许重试连接(例如。busy looping)，否则 sink 将以一个错误终止.</p>
</div>
<div class="paragraph">
<p>这是对 <code>Processor.onNext</code> 的改进。它必须从外部同步，否则从下游订阅者的角度来看会导致未定义的行为.</p>
</div>
<div class="paragraph">
<p><code>Sinks</code> 建造者对象(builder) 为主要支持的 producer 类型提供了一个指导性 API to the main supported producer types.
您可以字 <code>Flux</code> 中识别一些行为,例如 <code>onBackpressureBuffer</code>.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Sinks.Many&lt;Integer&gt; replaySink = Sinks.many().replay().all();
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>多个生产者线程可以通过执行以下操作在接收器上并发生成数据：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">//thread1
sink.emitNext(1, FAIL_FAST);

//thread2, later
sink.emitNext(2, FAIL_FAST);

//thread3, concurrently with thread 2
EmitResult result = sink.tryEmitNext(3); //would return FAIL_NON_SERIALIZED
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>Sinks.Many</code> 可以作为 <code>Flux</code> 展现给下游消费者, 如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; fluxView = replaySink.asFlux();
fluxView
    .takeWhile(i -&gt; i &lt; 10)
    .log()
    .blockLast();
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>相似的, <code>Sinks.Empty</code> 和 <code>Sinks.One</code> 可以使用 <code>asMono()</code> 方法 将其视为 <code>Mono</code>.</p>
</div>
<div class="paragraph">
<p><code>Sinks</code> 分类:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>many().multicast()</code>: a sink that will transmit only newly pushed data to its subscribers, honoring their backpressure (newly pushed as in "after the subscriber&#8217;s subscription").</p>
</li>
<li>
<p><code>many().unicast()</code>: same as above, with the twist that data pushed before the first subscriber registers is buffered.</p>
</li>
<li>
<p><code>many().replay()</code>: a sink that will replay a specified history size of pushed data to new subscribers then continue pushing new data live.</p>
</li>
<li>
<p><code>one()</code>: a sink that will play a single element to its subscribers</p>
</li>
<li>
<p><code>empty()</code>: a sink that will play a terminal signal only to its subscribers (error or complete), but can still be viewed as a <code>Mono&lt;T&gt;</code> (notice the generic type <code>&lt;T&gt;</code>).</p>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="processor-overview"><a class="anchor" href="#processor-overview"></a>6. 可用的 Sinks 的概述</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="sinks-many-unicast-onbackpressurebufferargs"><a class="anchor" href="#sinks-many-unicast-onbackpressurebufferargs"></a>6.1. Sinks.many().unicast().onBackpressureBuffer(args?)</h3>
<div class="paragraph">
<p>A unicast <code>Sinks.Many</code> can deal with backpressure by using an internal buffer.
The trade-off is that it can have <em>at most one</em> <code>Subscriber</code>.</p>
</div>
<div class="paragraph">
<p>The basic unicast sink is created via <code>Sinks.many().unicast().onBackpressureBuffer()</code>.
But there are a few additional <code>unicast</code> static factory methods in <code>Sinks.many().unicast()</code> allowing finer tuning.</p>
</div>
<div class="paragraph">
<p>For instance, by default, it is unbounded: if you push any amount of data through it while
its <code>Subscriber</code> has not yet requested data, it buffers all of the data.
You can change this by providing a custom <code>Queue</code> implementation for the internal
buffering in the <code>Sinks.many().unicast().onBackpressureBuffer(Queue)</code> factory m</p>
</div>
<div class="paragraph">
<p>ethod.
If that queue is bounded, the sink could reject the push of a value when the buffer
is full and not enough requests from downstream have been received.</p>
</div>
</div>
<div class="sect2">
<h3 id="sinks-many-multicast-onbackpressurebufferargs"><a class="anchor" href="#sinks-many-multicast-onbackpressurebufferargs"></a>6.2. Sinks.many().multicast().onBackpressureBuffer(args?)</h3>
<div class="paragraph">
<p>A multicast <code>Sinks.Many</code> can emit to several subscribers while honoring backpressure for each of its subscribers.
Subscribers receive only the signals pushed through the sink after they have subscribed.</p>
</div>
<div class="paragraph">
<p>The basic multicast sink is created via <code>Sinks.many().multicast().onBackpressureBuffer()</code>.</p>
</div>
<div class="paragraph">
<p>By default, if all of its subscribers are cancelled (which basically means they have all
un-subscribed), it clears its internal buffer and stops accepting new subscribers.
You can tune this by using the <code>autoCancel</code> parameter in the <code>multicast</code> static factory methods
under <code>Sinks.many().multicast()</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="sinks-many-multicast-directallornothing"><a class="anchor" href="#sinks-many-multicast-directallornothing"></a>6.3. Sinks.many().multicast().directAllOrNothing()</h3>
<div class="paragraph">
<p>A multicast <code>Sinks.Many</code> with a simplistic handling of backpressure: if <strong>any</strong> of the subscribers
is too slow (has zero demand), the <code>onNext</code> is dropped for <strong>all</strong> subscribers.</p>
</div>
<div class="paragraph">
<p>However, the slow subscribers are not terminated and once the slow subscribers have started
requesting again, all will resume receiving elements pushed from there on.</p>
</div>
<div class="paragraph">
<p>Once the <code>Sinks.Many</code> has terminated (usually through its <code>emitError(Throwable)</code> or
<code>emitComplete()</code> methods being called), it lets more subscribers subscribe but replays the
termination signal to them immediately.</p>
</div>
</div>
<div class="sect2">
<h3 id="sinks-many-multicast-directbesteffort"><a class="anchor" href="#sinks-many-multicast-directbesteffort"></a>6.4. Sinks.many().multicast().directBestEffort()</h3>
<div class="paragraph">
<p>A multicast <code>Sinks.Many</code> with a best effort handling of backpressure: if a subscriber
is too slow (has zero demand), the <code>onNext</code> is dropped for <strong>this slow subscriber only</strong>.</p>
</div>
<div class="paragraph">
<p>However, the slow subscribers are not terminated and once they have started requesting again
they will resume receiving newly pushed elements.</p>
</div>
<div class="paragraph">
<p>Once the <code>Sinks.Many</code> has terminated (usually through its <code>emitError(Throwable)</code> or
<code>emitComplete()</code> methods being called), it lets more subscribers subscribe but replays the
termination signal to them immediately.</p>
</div>
</div>
<div class="sect2">
<h3 id="sinks-many-replay"><a class="anchor" href="#sinks-many-replay"></a>6.5. Sinks.many().replay()</h3>
<div class="paragraph">
<p>A replay <code>Sinks.Many</code> caches emitted elements and replays them to late subscribers.</p>
</div>
<div class="paragraph">
<p>It can be created in multiple configurations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Caching a limited history (<code>Sinks.many().replay().limit(int)</code>) or an unbounded history (<code>Sinks.many().replay().all()</code>).</p>
</li>
<li>
<p>Caching a time-based replay window (<code>Sinks.many().replay().limit(Duration)</code>).</p>
</li>
<li>
<p>Caching a combination of history size and time window (<code>Sinks.many().replay().limit(int, Duration)</code>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Additional overloads for fine tuning of the above can also be found under <code>Sinks.many().replay()</code>, as well
as a variant that allows caching of a single element (<code>latest()</code> and <code>latestOrDefault(T)</code>).</p>
</div>
</div>
<div class="sect2">
<h3 id="sinks-unsafe-many"><a class="anchor" href="#sinks-unsafe-many"></a>6.6. Sinks.unsafe().many()</h3>
<div class="paragraph">
<p>Advanced users and operators builders might want to consider using <code>Sinks.unsafe().many()</code>
which will provide the same <code>Sinks.Many</code> factories <em>without</em> the extra producer thread safety.
As a result there will be less overhead per sink, since thread-safe sinks have to detect multi-threaded access.</p>
</div>
<div class="paragraph">
<p>Library developers should not expose unsafe sinks but can use them internally in a controlled
calling environment where they can ensure external synchronization of the calls that lead to
<code>onNext</code>, <code>onComplete</code> and <code>onError</code> signals, in respect of the Reactive Streams specification.</p>
</div>
</div>
<div class="sect2">
<h3 id="sinks-one"><a class="anchor" href="#sinks-one"></a>6.7. Sinks.one()</h3>
<div class="paragraph">
<p>This method directly construct a simple instance of <code>Sinks.One&lt;T&gt;</code>.
This flavor of <code>Sinks</code> is viewable as a <code>Mono</code> (through its <code>asMono()</code> view method), and
has slightly different <code>emit</code> methods to better convey this Mono-like semantics:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>emitValue(T value)</code> generates an <code>onNext(value)</code> signal and - in most implementations - will also trigger an implicit <code>onComplete()</code></p>
</li>
<li>
<p><code>emitEmpty()</code> generates an isolated <code>onComplete()</code> signal, intended as generating the equivalent of an empty <code>Mono</code></p>
</li>
<li>
<p><code>emitError(Throwable t)</code> generates an <code>onError(t)</code> signal</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Sinks.one()</code> accepts <em>one</em> call of any of these methods, effectively generating a <code>Mono</code>
that either completed with a value, completed empty or failed.</p>
</div>
</div>
<div class="sect2">
<h3 id="sinks-empty"><a class="anchor" href="#sinks-empty"></a>6.8. Sinks.empty()</h3>
<div class="paragraph">
<p>This method directly constructs a simple instance of <code>Sinks.Empty&lt;T&gt;</code>.
This flavor of <code>Sinks</code> is like <code>Sinks.One&lt;T&gt;</code>, except it doesn&#8217;t offer the <code>emitValue</code> method.</p>
</div>
<div class="paragraph">
<p>As a result, it can only generates a <code>Mono</code> that completes empty or fails.</p>
</div>
<div class="paragraph">
<p>The sink is still typed with a generic <code>&lt;T&gt;</code> despite being unable to trigger an <code>onNext</code>,
because it allows easy composition and inclusion in chains of operators that require a specific type.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/coreFeatures.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#core-features">Reactor 核心特性</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kotlin"><a class="anchor" href="#kotlin"></a>7. Kotlin 支持</h2>
<div class="sectionbody">
<div id="kotlin-introduction" class="paragraph">
<p><a href="https://kotlinlang.org">Kotlin</a> 是一种运行于 JVM(及其他平台)上的静态(statically-typed)语言. 使用它可以在拥有与现有 Java 库良好 <a href="https://kotlinlang.org/docs/reference/java-interop.html">互操作性</a> 的同时编写简介优雅的代码.</p>
</div>
<div class="paragraph">
<p>本小节介绍了 Reactor 如何能够完美支持 Kotlin.</p>
</div>
<div class="sect2">
<h3 id="kotlin-requirements"><a class="anchor" href="#kotlin-requirements"></a>7.1. 前提</h3>
<div class="paragraph">
<p>Kotlin 支持 Kotlin 1.1+ 及依赖 <a href="https://search.maven.org/artifact/org.jetbrains.kotlin/kotlin-stdlib"><code>kotlin-stdlib</code></a> (或 <a href="https://search.maven.org/artifact/org.jetbrains.kotlin/kotlin-stdlib-jdk7"><code>kotlin-stdlib-jdk7</code></a> 或 <a href="https://search.maven.org/artifact/org.jetbrains.kotlin/kotlin-stdlib-jdk8"><code>kotlin-stdlib-jdk8</code></a> 之一)</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-extensions"><a class="anchor" href="#kotlin-extensions"></a>7.2. 扩展</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从 <code>Dysprosium-M1</code> (ie. <code>reactor-core 3.3.0.M1</code>) 开始,将 Kotlin 扩展移至专门的 <a href="https://github.com/reactor/reactor-kotlin-extensions"><code>reactor-kotlin-extensions</code></a> 模块,
该模块的包名称以 <code>reactor.kotlin</code> 开头,而不是简单的 <code>reactor</code>.</p>
</div>
<div class="paragraph">
<p>结果,在 <code>reactor-core</code> 中已经废弃了 Kotlin 扩展.新依赖的 <code>groupId</code> 和 <code>artifactId</code> 为:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-gradle" data-lang="gradle">io.projectreactor.kotlin:reactor-kotlin-extensions</code></pre>
</div>
</div>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>多亏了其良好的 <a href="https://kotlinlang.org/docs/reference/java-interop.html">Java 互操作性</a> 以及 <a href="https://kotlinlang.org/docs/reference/extensions.html">Kotlin 扩展</a>(extensions),
Reactor Kotlin APIs 既可使用 Java APIs,还能够收益于一些 Reactor 内置的专门支持 Kotlin 的 APIs.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
注意 Kotlin 的扩展需要 <code>import</code> 才能够使用.所以比如 <code>Throwable.toFlux</code> 的 Kotlin 扩展必须在 <code>import reactor.core.publisher.toFlux</code> 后才可使用.
多数场景下 IDE 应该能够自动给出这种类似 static import 的建议.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如, <a href="https://kotlinlang.org/docs/reference/inline-functions.html#reified-type-parameters">Kotlin 参数类型推导(reified type parameters)</a> 对于 JVM 的 <a href="https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">通用类型擦除(generics type erasure)</a>提供了一种变通解决方案,
Reactor 就可以通过扩展(extension)来应用到这种特性.</p>
</div>
<div class="paragraph">
<p>下面是对 "Reactor with Java" 和 "Reactor with Kotlin + extensions" 的比较:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Java</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>Kotlin with extensions</strong></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono.just("foo")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"foo".toMono()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux.fromIterable(list)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>list.toFlux()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Mono.error(new RuntimeException())</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RuntimeException().toMono()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Flux.error(new RuntimeException())</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RuntimeException().toFlux()</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.ofType(Foo.class)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.ofType&lt;Foo&gt;()</code> or <code>flux.ofType(Foo::class)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>StepVerifier.create(flux).verifyComplete()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>flux.test().verifyComplete()</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可参考 <a href="https://projectreactor.io/docs/kotlin/release/kdoc-api/">Reactor KDoc API</a> 中详细的关于 Kotlin 扩展的文档.</p>
</div>
</div>
<div class="sect2">
<h3 id="kotlin-null-safety"><a class="anchor" href="#kotlin-null-safety"></a>7.3. Null 值安全</h3>
<div class="paragraph">
<p>Kotlin的一个关键特性就是 <a href="https://kotlinlang.org/docs/reference/null-safety.html">null safety</a> —— 从而可以在编译时处理 <code>null</code> 值,而不是在运行时抛出著名的 <code>NullPointerException</code>.
这样,通过“可能为空 "(nullability)" 的声明,以及能够表明“有值或空值”的语法(避免使用类似 <code>Optional</code> 来进行包装),使得应用程序更加安全.(Kotlin 允许在函数参数中使用可能为空的值,
请参考 <a href="https://www.baeldung.com/kotlin-null-safety">comprehensive guide to Kotlin null-safety</a>)</p>
</div>
<div class="paragraph">
<p>尽管 Java 的类型系统不允许这样的 <code>null</code> 值安全的表达方式, <a href="#null-safety">now provides null safety</a> 对所有 Reactor API 通过工具友好的(tooling-friendly)注解(在 <code>reactor.util.annotation</code> 包中定义)来支持.
默认情况下,Java APIs 用于 Kotlin 的话会被作为 平台类型(<a href="https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types">platform types</a>) 而放松对 <code>null</code> 的检查.
Kotlin 对 <a href="https://github.com/Kotlin/KEEP/blob/jsr-305/proposals/jsr-305-custom-nullability-qualifiers.md">JSR 305 注解的支持</a> + Reactor 可为空(nullability)的注解,为所有 Reactor API 和 Kotlin 开发者确保 "null 值安全" 的特性 (在编译期处理 <code>null</code> 值).</p>
</div>
<div class="paragraph">
<p>JSR 305 的检查可以通过增加 <code>-Xjsr305</code> 编译参数进行配置:  <code>-Xjsr305={strict|warn|ignore}</code>.</p>
</div>
<div class="paragraph">
<p>对于 kotlin 1.1.50+,默认的配置为 <code>-Xjsr305=warn</code>.如果希望 Reactor API 能够全面支持 null 值安全 则需要配置为 <code>strict</code>.不过你可以认为这是实验性的(experimental),因为 Reactor API "可能为空" 的声明可能甚至在小版本的发布中都会不断改进,而且将来也可能增加新的检查.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
目前尚不支持通用类型参数、可变类型以及数组元素的 "可为空".不过应该包含在接下来的发布中,最新信息请看 这个 <a href="https://github.com/Kotlin/KEEP/issues/79">issues</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/kotlin.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#kotlin">Kotlin 支持</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="testing"><a class="anchor" href="#testing"></a>8. 测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>无论你是编写了一个简单的 Reactor 操作链,还是开发了自定义的操作符,对它进行 自动化的测试总是一个好主意.</p>
</div>
<div class="paragraph">
<p>Reactor 内置一些专门用于测试的元素,放在一个专门的 artifact 里:  <code>reactor-test</code>. 你可以在 <a href="https://github.com/reactor/reactor-core/tree/main/reactor-test/src">on Github</a> 的 <code>reactor-core</code> 库里找到这个项目.</p>
</div>
<div class="paragraph">
<p>如果要用它来进行测试,添加 <code>scope</code> 为 <code>test</code> 的依赖.</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. reactor-test 用 Maven 配置 <code>&lt;dependencies&gt;</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果你使用了 <a href="#getting">BOM</a> ,你不需要指定 <code>&lt;version&gt;</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 Gradle 配置 <code>reactor-test</code> 依赖:</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. reactor-test 用 Gradle 配置 <code>dependencies</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
   testCompile 'io.projectreactor:reactor-test'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>reactor-test 的三个主要用途:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 <code>StepVerifier</code> 一步一步地测试一个给定场景的序列.</p>
</li>
<li>
<p>使用 <code>TestPublisher</code> 生成数据来测试下游的操作符(包括你自己的 operator).</p>
</li>
<li>
<p>在可以通过多个候选发布者的序列中(例如,使用 <code>switchIfEmpty</code> 的链),探测此类 <code>Publisher</code> 以确保已使用(即已订阅)它.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="使用-stepverifier-来测试"><a class="anchor" href="#使用-stepverifier-来测试"></a>8.1. 使用 <code>StepVerifier</code> 来测试</h3>
<div class="paragraph">
<p>最常见的测试 Reactor 序列的场景就是定义一个 <code>Flux</code> 或 <code>Mono</code>,然后在订阅它的时候测试它的行为.</p>
</div>
<div class="paragraph">
<p>当你的测试关注于每一次的事件的时候,就非常容易转化为使用 StepVerifier 的测试场景,您可以根据事件逐步定义期望.您可以提出并回答以下问题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>下一个期望的事件是什么?</p>
</li>
<li>
<p>你是否期望使用 <code>Flux</code> 来发出一个特别的值?</p>
</li>
<li>
<p>或者接下来 <code>300ms</code> 什么都不做?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>所有这些都可以使用 <code>StepVerifier</code> API 来表示.</p>
</div>
<div class="paragraph">
<p>例如,你可能会使用如下的工具方法来包装一个 <code>Flux</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public &lt;T&gt; Flux&lt;T&gt; appendBoomError(Flux&lt;T&gt; source) {
  return source.concatWith(Mono.error(new IllegalArgumentException("boom")));
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要测试它的话,你需要校验如下内容:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>我希望这个 Flux 先发出 <code>thing1</code>,然后发出 <code>thing2</code>,然后 生成一个内容为 <code>boom</code> 的错误. 最后订阅并校验它们.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>使用 <code>StepVerifier</code> API 来表示以上的验证过程:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void testAppendBoomError() {
  Flux&lt;String&gt; source = Flux.just("thing1", "thing2"); <i class="conum" data-value="1"></i><b>(1)</b>

  StepVerifier.create( <i class="conum" data-value="2"></i><b>(2)</b>
    appendBoomError(source)) <i class="conum" data-value="3"></i><b>(3)</b>
    .expectNext("thing1") <i class="conum" data-value="4"></i><b>(4)</b>
    .expectNext("thing2")
    .expectErrorMessage("boom") <i class="conum" data-value="5"></i><b>(5)</b>
    .verify(); <i class="conum" data-value="6"></i><b>(6)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>由于被测试方法需要一个 <code>Flux</code>,定义一个简单的 <code>Flux</code> 用于测试.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建一个 <code>StepVerifier</code> 构造器来包装和校验一个 <code>Flux</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>传进来需要测试的 <code>Flux</code>(即待测方法的返回结果)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>第一个我们期望的信号是 <code>onNext</code>,它的值为 <code>thing1</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>最后我们期望的是一个终止信号 <code>onError</code>,异常内容应该为 <code>boom</code></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>不要忘了使用 <code>verify()</code> 触发测试.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>API 是一个构造器,通过传入一个要测试的序列来创建一个 <code>StepVerifier</code>.从而你可以:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>表示你 期望 发生的下一个信号.如果收到其他信号(或者信号与期望不匹配),整个测试就会 失败(<code>AssertionError</code>).例如你可能会用到 <code>expectNext(T&#8230;&#8203;)</code> 或 <code>expectNextCount(long)</code>.</p>
</li>
<li>
<p>消费 下一个信号.当你想要跳过部分序列或者当你想对信号内容进行自定义的 <code>assertion</code> 的时候会用到它(比如要校验是否有一个 <code>onNext</code> 信号,并校验对应发出的元素是否是一个 size 为 5 的 List).你可能会用到 <code>consumeNextWith(Consumer&lt;T&gt;)</code>.</p>
</li>
<li>
<p>更多样的操作 比如暂停或运行一段代码.比如,你想对测试状态或内容进行调整或处理, 你可能会用到 <code>thenAwait(Duration)</code> 和 <code>then(Runnable)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>对于终止事件,相应的期望方法(<code>expectComplete()</code>、<code>expectError()</code>,及其所有的变体方法) 使用之后就不能再继续增加别的期望方法了.最后你只能对 <code>StepVerifier</code> 进行一些额外的配置并 触发校验(通常调用 <code>verify()</code> 及其变体方法).</p>
</div>
<div class="paragraph">
<p>从 <code>StepVerifier</code> 内部来看,它订阅了待测试的 <code>Flux</code> 或 <code>Mono</code>,然后将序列中的每个信号与测试 场景的期望进行比对.如果匹配的话,测试成功.如果有不匹配的情况,则抛出 <code>AssertionError</code> 异常.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
请记住是 <code>verify()</code> 触发了校验过程.这个 API 还有一些结合了 <code>verify()</code> 与期望的终止信号 的方法: <code>verifyComplete()</code>, <code>verifyError()</code>, <code>verifyErrorMessage(String)</code> 等.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>注意,如果有一个传入 lambda 的期望方法抛出了 <code>AssertionError</code>,会被报告为测试失败. 这可用于自定义 assertion.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
默认情况下,<code>verify()</code> 方法(及同源的 <code>verifyThenAssertThat</code>、<code>verifyComplete()</code> 等) 没有超时的概念.它可能会永远阻塞住.你可以使用 <code>StepVerifier.setDefaultTimeout(Duration)</code> 来设置一个全局的超时时间,或使用 <code>verify(Duration)</code> 指定.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="识别测试失败"><a class="anchor" href="#识别测试失败"></a>8.1.1. 识别测试失败</h4>
<div class="paragraph">
<p><code>StepVerifier</code>  提供了两个选项,能够更好准确的识别导致测试失败的预期步骤:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>as(String)</code>: 在大多数 <code>expect*</code> 方法之后使用,以描述先前的期望.如果期望失败,则其错误消息将包含描述.终止期望和 <code>verify</code> 无法用这种方式描述.</p>
</li>
<li>
<p><code>StepVerifierOptions.create().scenarioName(String)</code>: 通过使用 <code>StepVerifierOptions</code> 创建您的 <code>StepVerifier</code>,可以使用 <code>scenarioName</code> 方法为整个场景指定一个名称,该名称也用于断言错误消息中.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意,在两种情况下,仅保证产生自己的 <code>AssertionError</code> 的 <code>StepVerifier</code> 方法在消息中使用描述或名称(例如,手动或通过 <code>assertNext</code> 中的断言库引发异常不会将描述或名称添加到 错误消息).</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="操控时间"><a class="anchor" href="#操控时间"></a>8.2. 操控时间</h3>
<div class="paragraph">
<p><code>StepVerifier</code> 可以用来测试基于时间的操作符,从而避免测试的长时间运行.可以使用构造器 <code>StepVerifier.withVirtualTime</code> 达到这一点.</p>
</div>
<div class="paragraph">
<p>示例如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(1)))
//... continue expectations here
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>虚拟时间(virtual time) 的功能会在 Reactor 的调度器(<code>Scheduler</code>)工厂方法中插入一个自定义的 调度器.这些基于时间的操作符通常默认使用 <code>Schedulers.parallel()</code> 调度器.(虚拟时间的) 技巧在于使用一个 <code>VirtualTimeScheduler</code> 来代替默认调度器.然而一个重要的前提就是,只有在初始化 虚拟时间调度器之后的操作符才会起作用.</p>
</div>
<div class="paragraph">
<p>为了提高 <code>StepVerifier</code> 正常起作用的概率,它一般不接收一个简单的 <code>Flux</code> 作为输入,而是接收 一个 <code>Supplier</code> <code>withVirtualTime</code>,从而可以在配置好订阅者 之后 “懒创建”待测试的 <code>flux</code>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
要注意的是,<code>Supplier&lt;Publisher&lt;T&gt;&gt;</code> 可用于 "懒创建",否则不能保证虚拟时间 能完全起作用.尤其要避免提前实例化 <code>Flux</code>,要在 <code>Supplier</code> 中用 lambda 创建并返回 <code>Flux</code> 变量.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有两种处理时间的期望方法,无论是否配置虚拟时间都是可用的:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>thenAwait(Duration)</code>: 暂停校验步骤(允许信号延迟发出).</p>
</li>
<li>
<p><code>expectNoEvent(Duration)</code>: 同样让序列持续一定的时间,期间如果有 任何 信号发出则测试失败.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>两个方法都会基于给定的持续时间暂停线程的执行,如果是在虚拟时间模式下就相应地使用虚拟时间.</p>
</div>
<div id="tip-expectNoEvent" class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>expectNoEvent</code>  将订阅(<code>subscription</code>)也认作一个事件.假设你用它作为第一步,如果检测 到有订阅信号,也会失败.这时候可以使用 <code>expectSubscription().expectNoEvent(duration)</code> 来代替.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>为了快速校验前边提到的 <code>Mono.delay</code>,我们可以这样完成代码:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.withVirtualTime(() -&gt; Mono.delay(Duration.ofDays(1)))
    .expectSubscription() <i class="conum" data-value="1"></i><b>(1)</b>
    .expectNoEvent(Duration.ofDays(1)) <i class="conum" data-value="2"></i><b>(2)</b>
    .expectNext(0L) <i class="conum" data-value="3"></i><b>(3)</b>
    .verifyComplete(); <i class="conum" data-value="4"></i><b>(4)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如上 <a href="#tip-expectNoEvent">tip</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>期待一天内没有信号发生.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>然后期待一个 next 信号为 <code>0</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>然后期待完成(同时触发校验).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>我们也可以使用 <code>thenAwait(Duration.ofDays(1))</code>,但是 <code>expectNoEvent</code> 的好处是 能够验证在此之前不会发生什么.</p>
</div>
<div class="paragraph">
<p>注意 <code>verify()</code> 返回一个 <code>Duration</code>,这是整个测试的 真实时间</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
虚拟时间并非银弹.请记住 所有的 调度器都会被替换为 <code>VirtualTimeScheduler</code>. 有些时候你可以锁定校验过程,因为虚拟时钟在遇到第一个期望校验之前并不会开始,所以对于 “无数据“的期望校验也必须能够运行在虚拟时间模式下.
在无限序列中,虚拟时间模式的发挥 空间也很有限,因为它可能导致线程(序列的发出和校验的运行都在这个线程上)卡住.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="使用-stepverifier-进行-后校验"><a class="anchor" href="#使用-stepverifier-进行-后校验"></a>8.3. 使用 <code>StepVerifier</code> 进行 "后校验"</h3>
<div class="paragraph">
<p>当配置完你测试场景的最后的期望方法后,你可以使用 <code>verifyThenAssertThat()</code> 来代替 <code>verify()</code> 触发执行后的校验.</p>
</div>
<div class="paragraph">
<p><code>verifyThenAssertThat()</code> 返回一个 <code>StepVerifier.Assertions</code> 对象,你可以用它来校验 整个测试场景成功刚结束后的一些状态(它也会调用 <code>verify()</code>).典型应用就是校验有多少 元素被操作符丢弃(参考 <a href="#hooks">Hooks</a>).</p>
</div>
</div>
<div class="sect2">
<h3 id="测试-context"><a class="anchor" href="#测试-context"></a>8.4. 测试 <code>Context</code></h3>
<div class="paragraph">
<p>更多关于 <code>Context</code> 的内容请参考 <a href="#context">增加一个 Context 到响应式序列</a>.</p>
</div>
<div class="paragraph">
<p><code>StepVerifier</code> 有一些期望方法可以用来测试 <code>Context</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>expectAccessibleContext</code>: 返回一个 <code>ContextExpectations</code> 对象,你可以用它来在 <code>Context</code> 上配置期望校验.一定记住要调用 <code>then()</code> 来返回到对序列的期望校验上来.</p>
</li>
<li>
<p><code>expectNoAccessibleContext</code>: 是对 "没有`Context`" 的校验.通常用于 被测试的 <code>Publisher</code> 并不是一个响应式的,或没有任何操作符能够传递 <code>Context</code> (比如一个 generate 的 Publisher).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此外,还可以用 <code>StepVerifierOptions</code> 方法传入一个测试用的初始 <code>Context</code> 给 <code>StepVerifier</code>, 从而可以创建一个校验(<code>verifier</code>).</p>
</div>
<div class="paragraph">
<p>这些特性通过下边的代码演示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(Mono.just(1).map(i -&gt; i + 10),
                StepVerifierOptions.create().withInitialContext(Context.of("thing1", "thing2"))) <i class="conum" data-value="1"></i><b>(1)</b>
                    .expectAccessibleContext() <i class="conum" data-value="2"></i><b>(2)</b>
                    .contains("thing1", "thing2") <i class="conum" data-value="3"></i><b>(3)</b>
                    .then() <i class="conum" data-value="4"></i><b>(4)</b>
                    .expectNext(11)
                    .verifyComplete(); <i class="conum" data-value="5"></i><b>(5)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>StepVerifierOptions</code> 创建 <code>StepVerifier</code> 并传入初始 <code>Context</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>开始对 <code>Context</code> 进行校验,这里只是确保 <code>Context</code> 正常传播了</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>对 Context 进行校验的例子: 比如验证是否包含一个 "thing1"  - "thing2" 键值对.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>使用 <code>then()</code> 切换回对序列的校验.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>不要忘了用 <code>verify()</code> 触发整个校验过程.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="用-testpublisher-手动发出元素"><a class="anchor" href="#用-testpublisher-手动发出元素"></a>8.5. 用 <code>TestPublisher</code> 手动发出元素</h3>
<div class="paragraph">
<p>对于更多高级的测试,如果能够完全掌控源发出的数据就会方便很多,因为这样就可以在测试的 时候更加有的放矢地发出想测的数据.</p>
</div>
<div class="paragraph">
<p>另一种情况就是你实现了自己的操作符,然后想校验它的行为——尤其是在源不稳定的时候——是否符合响应式流规范.</p>
</div>
<div class="paragraph">
<p><code>reactor-test</code> 提供了 <code>TestPublisher</code> 类来应对这两种需求.这个类本质上是一个 <code>Publisher&lt;T&gt;</code>, 你可以通过可编程的方式来用它发出各种信号:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>next(T)</code> 和 <code>next(T, T&#8230;&#8203;)</code> 发出 1-n 个 <code>onNext</code> 信号.</p>
</li>
<li>
<p><code>emit(T&#8230;&#8203;)</code> 发出 1-n 个 <code>onNext</code> 信号并且会执行 <code>complete()</code>.</p>
</li>
<li>
<p><code>complete()</code> 会发出终止信号 <code>onComplete</code>.</p>
</li>
<li>
<p><code>error(Throwable)</code> 会发出终止信号 <code>onError</code> .</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用 <code>create</code> 工厂方法就可以得到一个正常的 <code>TestPublisher</code>.而使用 <code>createNonCompliant</code> 工厂方法可以创建一个 "不正常" 的 <code>TestPublisher</code>.
后者需要传入由 <code>TestPublisher.Violation</code> 枚举指定的一组选项,这些选项可用于告诉 publisher 忽略哪些问题.枚举值有:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>REQUEST_OVERFLOW</code>: 允许 <code>next</code> 在请求不足的时候也可以调用,而不会触发 <code>IllegalStateException</code>.</p>
</li>
<li>
<p><code>ALLOW_NULL</code>: 允许 <code>next</code> 能够发出一个 <code>null</code> 值而不会触发 <code>NullPointerException</code>.</p>
</li>
<li>
<p><code>CLEANUP_ON_TERMINATE</code>: 可以重复多次发出终止信号,包括 <code>complete()</code>, <code>error()</code>, 和 `emit()</p>
</li>
<li>
<p><code>DEFER_CANCELLATION</code>: 允许 <code>TestPublisher</code> 忽略取消信号并继续发出信号,就好像丢失了与所述信号的竞争.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后,<code>TestPublisher</code> 还可以用不同的 <code>assert*</code> 来跟踪其内部的订阅状态.</p>
</div>
<div class="paragraph">
<p>使用转换方法 <code>flux()</code> 和 <code>mono()</code> 可以将其作为 <code>Flux</code> 和 <code>Mono</code> 来使用.</p>
</div>
</div>
<div class="sect2">
<h3 id="用-publisherprobe-检查执行路径"><a class="anchor" href="#用-publisherprobe-检查执行路径"></a>8.6. 用 <code>PublisherProbe</code> 检查执行路径</h3>
<div class="paragraph">
<p>当构建复杂的操作链时,可能会有多个子序列,从而导致多个执行路径.</p>
</div>
<div class="paragraph">
<p>多数时候,这些子序列会生成一个足够明确的 <code>onNext</code> 信号,你可以通过检查最终结果 来判断它是否执行.</p>
</div>
<div class="paragraph">
<p>考虑下边这个方法,它构建了一条操作链,并使用 <code>switchIfEmpty</code> 方法在源为空的情况下, 替换成另一个源.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public Flux&lt;String&gt; processOrFallback(Mono&lt;String&gt; source, Publisher&lt;String&gt; fallback) {
    return source
            .flatMapMany(phrase -&gt; Flux.fromArray(phrase.split("\\s+")))
            .switchIfEmpty(fallback);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>很容易就可以测试出 switchIfEmpty 的哪一个逻辑分支被使用了,如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void testSplitPathIsUsed() {
    StepVerifier.create(processOrFallback(Mono.just("just a  phrase with    tabs!"),
            Mono.just("EMPTY_PHRASE")))
                .expectNext("just", "a", "phrase", "with", "tabs!")
                .verifyComplete();
}

@Test
public void testEmptyPathIsUsed() {
    StepVerifier.create(processOrFallback(Mono.empty(), Mono.just("EMPTY_PHRASE")))
                .expectNext("EMPTY_PHRASE")
                .verifyComplete();
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>但是如果例子中的方法返回的是一个 <code>Mono&lt;Void&gt;</code> 呢? 它等待源发送结束,执行一个额外的任务, 然后就结束了.如果源是空的,则执行另一个备用的类似于 <code>Runnable</code> 的任务,如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private Mono&lt;String&gt; executeCommand(String command) {
    return Mono.just(command + " DONE");
}

public Mono&lt;Void&gt; processOrFallback(Mono&lt;String&gt; commandSource, Mono&lt;Void&gt; doWhenEmpty) {
    return commandSource
            .flatMap(command -&gt; executeCommand(command).then()) <i class="conum" data-value="1"></i><b>(1)</b>
            .switchIfEmpty(doWhenEmpty); <i class="conum" data-value="2"></i><b>(2)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>then()</code> 方法会忽略 command,它只关心是否结束.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>两个都是空序列,这个时候如何区分(哪边执行了)呢?</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>为了验证您的 <code>processOrFallback</code> 方法确实通过 <code>doWhenEmpty</code> 路径,你需要编写额外的代码,比如你需要一个这样的 <code>Mono&lt;Void&gt;</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>能够捕获到它被订阅的事实</p>
</li>
<li>
<p>以上事实需要在整个执行结束 之后 再进行验证.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 3.1 版本以前,你需要为每一种状态维护一个 <code>AtomicBoolean</code> 变量,然后在相应的 <code>doOn*</code> 回调中观察它的值.这需要添加不少的额外代码.好在,版本 3.1.0 之后可以使用 <code>PublisherProbe</code> 来做, 如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void testCommandEmptyPathIsUsed() {
    PublisherProbe&lt;Void&gt; probe = PublisherProbe.empty(); <i class="conum" data-value="1"></i><b>(1)</b>

    StepVerifier.create(processOrFallback(Mono.empty(), probe.mono())) <i class="conum" data-value="2"></i><b>(2)</b>
                .verifyComplete();

    probe.assertWasSubscribed(); <i class="conum" data-value="3"></i><b>(3)</b>
    probe.assertWasRequested(); <i class="conum" data-value="4"></i><b>(4)</b>
    probe.assertWasNotCancelled(); <i class="conum" data-value="5"></i><b>(5)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建一个探针(probe),它会转化为一个空序列.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在需要使用 <code>Mono&lt;Void&gt;</code> 的位置调用 <code>probe.mono()</code> 来替换为探针.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>序列结束之后,你可以用这个探针来判断序列是如何使用的,你可以检查是它从哪(条路径)被订阅的&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>&#8230;&#8203;对于请求也是一样的&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>&#8230;&#8203;以及是否被取消了.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>你也可以在使用 <code>Flux&lt;T&gt;</code> 的位置通过调用 <code>.flux()</code> 方法来放置探针.如果你既需要用探针检查执行路径 还需要它能够发出数据,你可以用 <code>PublisherProbe.of(Publisher)</code> 方法包装一个 <code>Publisher&lt;T&gt;</code> 来搞定.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/testing.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#testing">测试</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="debugging"><a class="anchor" href="#debugging"></a>9. 调试 Reactor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>从命令式和同步式编程切换到响应式和异步式编程有时候是令人生畏的. 学习曲线中最陡峭的异步就是出错时如何分析和调试.</p>
</div>
<div class="paragraph">
<p>在命令式世界,调试通常都是非常直观的: 直接看 stack trace 就可以找到问题出现的位置, 以及是否问题责任全部出在你自己的代码? 问题是不是发生在某些库代码? 如果是, 那你的哪部分代码调用了库,是不是传参不合适导致的问题?</p>
</div>
<div class="sect2">
<h3 id="典型的-reactor-stack-trace"><a class="anchor" href="#典型的-reactor-stack-trace"></a>9.1. 典型的 Reactor Stack Trace</h3>
<div class="paragraph">
<p>当你切换到异步代码,事情就变得复杂的多了.</p>
</div>
<div class="paragraph">
<p>看一下下边的 stack trace:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. A typical Reactor stack trace</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">java.lang.IndexOutOfBoundsException: Source emitted more than one item
    at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:129)
    at reactor.core.publisher.FluxFlatMap$FlatMapMain.tryEmitScalar(FluxFlatMap.java:445)
    at reactor.core.publisher.FluxFlatMap$FlatMapMain.onNext(FluxFlatMap.java:379)
    at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:121)
    at reactor.core.publisher.FluxRange$RangeSubscription.slowPath(FluxRange.java:154)
    at reactor.core.publisher.FluxRange$RangeSubscription.request(FluxRange.java:109)
    at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.request(FluxMapFuseable.java:162)
    at reactor.core.publisher.FluxFlatMap$FlatMapMain.onSubscribe(FluxFlatMap.java:332)
    at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onSubscribe(FluxMapFuseable.java:90)
    at reactor.core.publisher.FluxRange.subscribe(FluxRange.java:68)
    at reactor.core.publisher.FluxMapFuseable.subscribe(FluxMapFuseable.java:63)
    at reactor.core.publisher.FluxFlatMap.subscribe(FluxFlatMap.java:97)
    at reactor.core.publisher.MonoSingle.subscribe(MonoSingle.java:58)
    at reactor.core.publisher.Mono.subscribe(Mono.java:3096)
    at reactor.core.publisher.Mono.subscribeWith(Mono.java:3204)
    at reactor.core.publisher.Mono.subscribe(Mono.java:3090)
    at reactor.core.publisher.Mono.subscribe(Mono.java:3057)
    at reactor.core.publisher.Mono.subscribe(Mono.java:3029)
    at reactor.guide.GuideTests.debuggingCommonStacktrace(GuideTests.java:995)
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这里边有好多信息,我们得到了一个 <code>IndexOutOfBoundsException</code>,内容是 "源发出了 不止一个元素".</p>
</div>
<div class="paragraph">
<p>我们也许可以很快假定这个源是一个 <code>Flux/Mono</code>,并通过下一行提到的 <code>MonoSingle</code> 确定是 <code>Mono</code>. 看上去是来自一个 <code>single</code> 操作符的抱怨.</p>
</div>
<div class="paragraph">
<p>查看 Javadoc 中关于操作符 <code>Mono#single</code> 的说明,我们看到 <code>single</code> 有一个规定:  源必须只能发出一个元素.看来是有一个源发出了多于一个元素,从而违反了这一规定.</p>
</div>
<div class="paragraph">
<p>我们可以更进一步找出那个源吗? 下边的这些内容帮不上什么忙,只是打印了一些内部的似乎是一个响应式链的信息, 主要是一些 <code>subscribe</code> 和 <code>request</code> 的调用.</p>
</div>
<div class="paragraph">
<p>粗略过一下这些行,我们至少可以勾画出一个大致的出问题的链: 大概涉及一个 <code>MonoSingle</code>、一个 <code>FluxFlatMap</code>,以及一个 <code>FluxRange</code>(每一个都对应 trace 中的几行,但总体涉及这三个类). 所以难道是 <code>range().flatMap().single()</code>  这样的链?</p>
</div>
<div class="paragraph">
<p>但是如果在我们的应用中多处都用到这一模式,那怎么办? 通过这些还是不能确定什么, 搜索 <code>single</code> 也找不到问题所在.最后一行指向了我们的代码.我们似乎终于接近真相了.</p>
</div>
<div class="paragraph">
<p>不过,等等… 当我们找到源码文件,我们只能找到一个已存在的 <code>Flux</code> 被订阅了,如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">toDebug.subscribe(System.out::println, Throwable::printStackTrace);
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>所有这些都发生在订阅时,但是 <code>Flux</code> 本身没有在这里 声明 .更糟的是, 当我们找到变量声明的地方,我们看到:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public Mono&lt;String&gt; toDebug; //please overlook the public class attribute
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>变量声明的地方并没有 实例化 .我们必须做最坏的打算,那就是在这个应用中, 可能在几个不同的代码路径上对这个变量赋了值,但我们不确定是哪一个导致了问题.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这是一种 Reactor 运行时错误,而不是编译错误.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我们希望找到的是操作符在哪里添加到操作链上的 —— 也就是 <code>Flux</code> 在哪里 声明的.我们通常说这个 <code>Flux</code> 是被 组装(assembly) 的.</p>
</div>
</div>
<div class="sect2">
<h3 id="debug-activate"><a class="anchor" href="#debug-activate"></a>9.2. 开启调试模式 - aka tracebacks</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
本节介绍了启用调试功能的最简单但最慢的方法,因为它捕获了每个运算符上的 stacktrace. 有关更精细的调试方法,请参见 <a href="#checkpoint-alternative">用 <code>checkpoint()</code> 方式替代</a> 替代方法; 有关更高级和更高性能的全局选项, 请参见生产就绪的 <a href="#reactor-tools-debug">用于生产环境的全局调试</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>即便 stack trace 能够对有些许经验的开发者传递一些信息,但是在一些复杂的情况下, 这并不是一种理想的方式.</p>
</div>
<div class="paragraph">
<p>幸运的是,Reactor 内置了一种面向调试的能力—— 操作期测量(assembly-time instrumentation).</p>
</div>
<div class="paragraph">
<p>这通过 在应用启动的时候 (或至少在有问题的 <code>Flux</code> 或 <code>Mono</code> 实例化之前) 加入自定义的 <code>Hook.onOperator</code> 钩子(hook),如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Hooks.onOperatorDebug();
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这行代码——通过包装操作符的构造方法,并在此捕捉 stack trace——来监测对这个 <code>Flux</code>(或 <code>Mono</code>)的操作符的调用(也就是“组装”链的地方).由于这些在 操作链被声明的地方就搞定,这个 hook 应该在 早于 声明的时候被激活, 最保险的方式就是在你程序的最开始就激活它.</p>
</div>
<div class="paragraph">
<p>之后,如果发生了异常,导致失败的操作符能够找到捕捉点并补充 stack trace.</p>
</div>
<div class="paragraph">
<p>在下一小节,我们看一下 stack trace 会有什么不同,以及如何对其进行分析.</p>
</div>
</div>
<div class="sect2">
<h3 id="阅读调试模式的-stack-trace"><a class="anchor" href="#阅读调试模式的-stack-trace"></a>9.3. 阅读调试模式的 Stack Trace</h3>
<div class="paragraph">
<p>我们在对上边的例子激活 <code>operatorStacktrace</code> 调试功能后,stack trace 如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">java.lang.IndexOutOfBoundsException: Source emitted more than one item
    at reactor.core.publisher.MonoSingle$SingleSubscriber.onNext(MonoSingle.java:129)
    at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:375) <i class="conum" data-value="1"></i><b>(1)</b>
...
<i class="conum" data-value="2"></i><b>(2)</b>
...
    at reactor.core.publisher.Mono.subscribeWith(Mono.java:3204)
    at reactor.core.publisher.Mono.subscribe(Mono.java:3090)
    at reactor.core.publisher.Mono.subscribe(Mono.java:3057)
    at reactor.core.publisher.Mono.subscribe(Mono.java:3029)
    at reactor.guide.GuideTests.debuggingActivated(GuideTests.java:1000)
    Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: <i class="conum" data-value="3"></i><b>(3)</b>
Assembly trace from producer [reactor.core.publisher.MonoSingle] : <i class="conum" data-value="4"></i><b>(4)</b>
    reactor.core.publisher.Flux.single(Flux.java:6676)
    reactor.guide.GuideTests.scatterAndGather(GuideTests.java:949)
    reactor.guide.GuideTests.populateDebug(GuideTests.java:962)
    org.junit.rules.TestWatcher$1.evaluate(TestWatcher.java:55)
    org.junit.rules.RunRules.evaluate(RunRules.java:20)
Error has been observed by the following operator(s): <i class="conum" data-value="5"></i><b>(5)</b>
    |_  Flux.single ⇢ reactor.guide.GuideTests.scatterAndGather(GuideTests.java:949) <i class="conum" data-value="6"></i><b>(6)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这一条是新的: 可以发现外层操作符捕捉到了 stack trace.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第一部分的 stack trace 多数与上边一样,显示了操作符内部的信息(所以省略了这一块).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>从这里开始,是在调试模式下显示的内容.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>首先我们获得了关于操作符组装的信息.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>以及错误沿着操作链传播的轨迹(从错误点到订阅点).</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>每一个看到这个错误的操作符都会列出,包括类和行信息.如果操作符是在 Reactor 源码内部组装的,行信息会被忽略.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>可见,捕获的 stack trace 作为 <code>OnAssemblyException</code> 添加到原始错误信息的之后.有两部分, 但是第一部分更加有意思.它显示了操作符触发异常的路径.这里显示的是 <code>scatterAndGather</code> 方法中的 <code>single</code> 导致的问题,而 <code>scatterAndGather</code> 方法是在 JUnit 中被 <code>populateDebug</code> 方法调用的.</p>
</div>
<div class="paragraph">
<p>既然我们已经有足够的信息来查出罪魁祸首,我们就来看一下 <code>scatterAndGather</code> 方法吧:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private Mono&lt;String&gt; scatterAndGather(Flux&lt;String&gt; urls) {
    return urls.flatMap(url -&gt; doRequest(url))
           .single(); <i class="conum" data-value="1"></i><b>(1)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>找到了,就是这个 <code>single</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>现在我们可以发现错误的根源是将多个 HTTP 请求转化为 URLs 的 <code>flatMap</code> 方法后边接的是 <code>single</code>, 这太严格了.使用  <code>git blame</code> 找到代码作者,并同他讨论过后,发现他是本来是想用不那么严格的 <code>take(1)</code> 方法的.</p>
</div>
<div class="paragraph">
<p>我们解决了问题.</p>
</div>
<div class="paragraph">
<p>现在考虑 stack trace 中的以下行:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Error has been observed by the following operator(s):</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>调试信息的第二部分在这个例子中意义不大,因为错误实际发生在最后一个操作符上(离 <code>subscribe</code> 最近的一个). 另一个例子可能更加清楚:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">FakeRepository.findAllUserByName(Flux.just("pedro", "simon", "stephane"))
              .transform(FakeUtils1.applyFilters)
              .transform(FakeUtils2.enrichUser)
              .blockLast();
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在想象一下在 <code>findAllUserByName</code> 内部有个 <code>map</code> 方法报错了.我们可能会看到如下的 trace:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Error has been observed by the following operator(s):
    |_  Flux.map ⇢ reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:27)
    |_  Flux.map ⇢ reactor.guide.FakeRepository.findAllUserByName(FakeRepository.java:28)
    |_  Flux.filter ⇢ reactor.guide.FakeUtils1.lambda$static$1(FakeUtils1.java:29)
    |_  Flux.transform ⇢ reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:40)
    |_  Flux.elapsed ⇢ reactor.guide.FakeUtils2.lambda$static$0(FakeUtils2.java:30)
    |_  Flux.transform ⇢ reactor.guide.GuideDebuggingExtraTests.debuggingActivatedWithDeepTraceback(GuideDebuggingExtraTests.java:41)
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这与链上收到错误通知的操作符是一致:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>异常源自第一个 <code>map</code>.</p>
</li>
<li>
<p>被第二个 <code>map</code> 看到(都在 <code>findAllUserByName</code> 方法中).</p>
</li>
<li>
<p>接着被一个 <code>filter</code> 和一个 <code>transform</code> 看到,说明链的这部分是由一个可重复使用的转换方法组装的 (这里是 <code>applyFilters</code> 工具方法).</p>
</li>
<li>
<p>最后被一个 <code>elapsed</code> 和一个 <code>transform</code> 看到,类似的, <code>elapsed</code> 由第二个转换方法(<code>enrichUser</code>) 组装.</p>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
As tracebacks are appended to original errors as suppressed exceptions, this can somewhat
interfere with another type of exception that uses this mechanism: composite exceptions.
Such exceptions can be created directly via <code>Exceptions.multiple(Throwable&#8230;&#8203;)</code>, or by some
operators that might join multiple erroring sources (like <code>Flux#flatMapDelayError</code>). They
can be unwrapped into a <code>List</code> via <code>Exceptions.unwrapMultiple(Throwable)</code>, in which case the traceback
would be considered a component of the composite and be part of the returned <code>List</code>.
If that is somehow not desirable, tracebacks can be identified thanks to <code>Exceptions.isTraceback(Throwable)</code>
check, and excluded from such an unwrap by using <code>Exceptions.unwrapMultipleExcludingTracebacks(Throwable)</code>
instead.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>用这种形式的检测方式构造 stack trace 是成本较高的.也因此这种调试模式作为最终大招, 只应该在可控的方式下激活.</p>
</div>
<div class="sect3">
<h4 id="checkpoint-alternative"><a class="anchor" href="#checkpoint-alternative"></a>9.3.1. 用 <code>checkpoint()</code> 方式替代</h4>
<div class="paragraph">
<p>调试模式是全局性的,会影响到程序中每一个组装到一个 <code>Flux</code> 或 <code>Mono</code> 的操作符.好处在于可以进行 事后调试(after-the-fact debugging): 无论错误是什么,我们都会得到足够的调试信息.</p>
</div>
<div class="paragraph">
<p>就像前边见到的那样,这种全局性的调试会因为成本较高而影响性能(其影响在于生成的 stack traces 数量). 如果我们能大概定位到疑似出问题的操作符的话就可以不用花那么大的成本.然而,问题出现后, 我们通常无法定位到哪一个操作符可能存在问题,因为缺少一些 trace 信息,我们得修改代码, 打开调试模式,期望能够复现问题.</p>
</div>
<div class="paragraph">
<p>这种情况下,我们需要切换到调试模式,并进行一些必要的准备工作以便能够更好的发现复现的问题, 并捕捉到所有的信息.(译者加: 这两段感觉有点废话&#8230;&#8203;)</p>
</div>
<div class="paragraph">
<p>如果你能确定是在你的代码中组装的响应式链存在问题,而且程序的可服务性又是很重要的, 那么你可以 使用 <code>checkpoint()</code> 操作符,它有两种调试技术可用.</p>
</div>
<div class="paragraph">
<p>你可以把这个操作符加到链中.这时 <code>checkpoint</code> 操作符就像是一个 hook,但只对它所在的链起作用.</p>
</div>
<div class="paragraph">
<p>还有一个 <code>checkpoint(String)</code> 的方法变体,你可以传入一个独特的字符串以方便在 assembly traceback 中识别信息. 这样会省略 stack trace,你可以依赖这个字符串(以下改称“定位描述符”)来定位到组装点.
<code>checkpoint(String)</code> 比 <code>checkpoint</code> 有更低的执行成本.</p>
</div>
<div class="paragraph">
<p><code>checkpoint(String)</code> 在它的输出中包含 "light" (可以方便用于搜索),如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>...
    Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException:
Assembly site of producer [reactor.core.publisher.ParallelSource] is identified by light checkpoint [light checkpoint identifier].</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最后的但同样重要的是,如果你既想通过 checkpoint 添加定位描述符,同时又依赖于 stack trace 来定位组装点,你可以使用 <code>checkpoint("description", true)</code> 来实现这一点.这时回溯信息又出来了, 同时附加了定位描述符,如下例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Assembly trace from producer [reactor.core.publisher.ParallelSource], described as [descriptionCorrelation1234] : <i class="conum" data-value="1"></i><b>(1)</b>
    reactor.core.publisher.ParallelFlux.checkpoint(ParallelFlux.java:215)
    reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)
Error has been observed by the following operator(s):
    |_  ParallelFlux.checkpoint ⇢ reactor.core.publisher.FluxOnAssemblyTest.parallelFluxCheckpointDescriptionAndForceStack(FluxOnAssemblyTest.java:225)</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>descriptionCorrelation1234</code> 是通过 <code>checkpoint</code> 给出的定位描述符.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>定位描述符可以是静态的字符串、或人类可读的描述、或一个 correlation ID(例如, 来自 HTTP 请求头的信息).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当全局调试模式和 <code>checkpoint()</code> 都开启的时候,checkpoint 的 stacks 输出会作为 suppressed 错误输出,按照声明顺序添加在操作符图(graph)的后面.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactor-tools-debug"><a class="anchor" href="#reactor-tools-debug"></a>9.4. 用于生产环境的全局调试</h3>
<div class="paragraph">
<p>Project Reactor 带有一个单独的 Java 代理,可对您的代码进行检测并添加调试信息. 该行为与<a href="#debug-activate">开启调试模式 - aka tracebacks</a>(也称为回溯)非常相似,但没有运行时性能开销.</p>
</div>
<div class="paragraph">
<p>要在您的应用程序中使用它,必须将其添加为依赖.</p>
</div>
<div class="paragraph">
<p>以下示例显示如何在 Maven 中将  <code>reactor-tools</code> 添加为依赖:</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. reactor-tools in Maven, in <code>&lt;dependencies&gt;</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-tools&lt;/artifactId&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果你使用 <a href="#getting">BOM</a>, 你无需指定 <code>&lt;version&gt;</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在 Gradle 中添加 `reactor-tools' 依赖:</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. reactor-tools in Gradle, amend the <code>dependencies</code> block</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
   compile 'io.projectreactor:reactor-tools'
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>还需要使用以下命令初始化它:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ReactorDebugAgent.init();
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
由于该实现将在加载类时对其进行检测,因此放置它的最佳位置是在 main(String[]) 方法中的所有其他项之前:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static void main(String[] args) {
    ReactorDebugAgent.init();
    SpringApplication.run(Application.class, args);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您不着急执行初始化(例如在测试中),也可以重新处理现有的类:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ReactorDebugAgent.init();
ReactorDebugAgent.processExistingClasses();
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
请注意,由于需要遍历所有已加载的类并应用转换,因此重新处理需要花费几秒钟的时间.仅当看到某些 call-sites 没有检测到时才使用它.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="局限性"><a class="anchor" href="#局限性"></a>9.4.1. 局限性</h4>
<div class="paragraph">
<p><code>ReactorDebugAgent</code> 被实现为Java代理,并使用 <a href="https://bytebuddy.net/#/">ByteBuddy</a> 进行自连接.自连接可能不适用于某些 JVM,有关更多详细信息,请参考 ByteBuddy 的文档.</p>
</div>
</div>
<div class="sect3">
<h4 id="将-reactordebugagent-作为-java代-理运行"><a class="anchor" href="#将-reactordebugagent-作为-java代-理运行"></a>9.4.2. 将 ReactorDebugAgent 作为 Java代 理运行</h4>
<div class="paragraph">
<p>如果您的环境不支持 ByteBuddy 的自连接,则可以将 <code>reactor-tools</code> 作为 Java 代理运行:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-shell" data-lang="shell">java -javaagent reactor-tools.jar -jar app.jar</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="在构建时运行-reactordebugagent"><a class="anchor" href="#在构建时运行-reactordebugagent"></a>9.4.3. 在构建时运行 ReactorDebugAgent</h4>
<div class="paragraph">
<p>也可以在构建时运行 <code>reactor-tools</code>.为此,您需要将其作为 ByteBuddy 的构建工具的插件来应用.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
只会应用于您项目中的类.不会检测类路径库.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 23. reactor-tools with <a href="https://github.com/raphw/byte-buddy/tree/byte-buddy-1.10.9/byte-buddy-maven-plugin">ByteBuddy&#8217;s Maven plugin</a></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
        &lt;artifactId&gt;reactor-tools&lt;/artifactId&gt;
        <i class="conum" data-value="1"></i><b>(1)</b>
        &lt;classifier&gt;original&lt;/classifier&gt; <i class="conum" data-value="2"></i><b>(2)</b>
        &lt;scope&gt;runtime&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;

&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;net.bytebuddy&lt;/groupId&gt;
            &lt;artifactId&gt;byte-buddy-maven-plugin&lt;/artifactId&gt;
            &lt;configuration&gt;
                &lt;transformations&gt;
                    &lt;transformation&gt;
                        &lt;plugin&gt;reactor.tools.agent.ReactorDebugByteBuddyPlugin&lt;/plugin&gt;
                    &lt;/transformation&gt;
                &lt;/transformations&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果使用 <a href="#getting">BOM</a>,则无需指定  <code>&lt;version&gt;</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>classifier</code> 在这里很重要.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 24. reactor-tools with <a href="https://github.com/raphw/byte-buddy/tree/byte-buddy-1.10.9/byte-buddy-gradle-plugin">ByteBuddy&#8217;s Gradle plugin</a></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id 'net.bytebuddy.byte-buddy-gradle-plugin' version '1.10.9'
}

configurations {
    byteBuddyPlugin
}

dependencies {
    byteBuddyPlugin(
            group: 'io.projectreactor',
            name: 'reactor-tools',
            <i class="conum" data-value="1"></i><b>(1)</b>
            classifier: 'original', <i class="conum" data-value="2"></i><b>(2)</b>
    )
}

byteBuddy {
    transformation {
        plugin = "reactor.tools.agent.ReactorDebugByteBuddyPlugin"
        classPath = configurations.byteBuddyPlugin
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>如果使用 <a href="#getting">BOM</a>,则无需指定  <code>&lt;version&gt;</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>classifier</code> 在这里很重要.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="记录流的日志"><a class="anchor" href="#记录流的日志"></a>9.5. 记录流的日志</h3>
<div class="paragraph">
<p>除了基于 stack trace 的调试和分析,还有一个有效的工具可以跟踪异步序列并记录日志.</p>
</div>
<div class="paragraph">
<p>就是 <code>log()</code> 操作符.将其加到操作链上之后,它会读(只读,peek)每一个 在其上游的 <code>Flux</code> 或 <code>Mono</code> 事件(包括 <code>onNext</code>、<code>onError</code>、 <code>onComplete</code>, 以及 订阅、 取消、和 请求).</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">关于 logging 的具体实现</div>
<div class="paragraph">
<p><code>log</code> 操作符通过使用 Loggers 工具类,该类会自动选择通用的日志记录框架 例如通过 SLF4J 使用的 Log4J 和 Logback , 如果 SLF4J 不存在的话,则直接将日志输出到控制台.</p>
</div>
<div class="paragraph">
<p>控制台使用 <code>System.err</code> 记录 <code>WARN</code> 和 <code>ERROR</code> 级别的日志,使用 <code>System.out</code> 记录其他级别的日志.</p>
</div>
<div class="paragraph">
<p>如果你喜欢使用 JDK <code>java.util.logging</code>,在 3.0.x 你可以设置 JDK 的系统属性 <code>reactor.logging.fallback</code>.</p>
</div>
<div class="paragraph">
<p>在所有情况下,在生产环境中记录日志时,都应小心配置底层日志记录框架,以使用其最异步和非阻塞的方法(例如,Logback 中的 <code>AsyncAppender</code> 或 Log4j 2 中的 <code>AsyncLogger</code>).</p>
</div>
</div>
</div>
<div class="paragraph">
<p>假设我们配置并激活了 logback,以及一个形如 <code>range(1,10).take(3)</code> 的操作链.通过将 <code>log()</code> 放在 <code>take</code> 之前, 我们就可以看到它内部是如何运行的,以及什么样的事件会向上游传播给 range,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; flux = Flux.range(1, 10)
                         .log()
                         .take(3);
flux.subscribe();
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>输出如下(通过 logger 的 console appender):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>10:45:20.200 [main] INFO  reactor.Flux.Range.1 - | onSubscribe([Synchronous Fuseable] FluxRange.RangeSubscription) <i class="conum" data-value="1"></i><b>(1)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | request(unbounded) <i class="conum" data-value="2"></i><b>(2)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(1) <i class="conum" data-value="3"></i><b>(3)</b>
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(2)
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | onNext(3)
10:45:20.205 [main] INFO  reactor.Flux.Range.1 - | cancel() <i class="conum" data-value="4"></i><b>(4)</b></pre>
</div>
</div>
<div class="paragraph">
<p>这里,除了 logger 自己的格式(时间、线程、级别、消息),<code>log()</code> 操作符 还输出了其他一些格式化的东西:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>reactor.Flux.Range.1</code> 是自动生成的日志 类别(category),以防你在操作链中多次使用 同一个操作符.通过它你可以分辨出来是哪个操作符的事件(这里是 <code>range</code> 的). 你可以调用 <code>log(String)</code> 方法用自定义的类别替换这个标识符.在几个用于分隔的字符之后, 打印出了实际的事件.
这里是一个 <code>onSubscribe</code> 调用、一个 <code>request</code> 调用、三个 <code>onNext</code> 调用, 以及一个 <code>cancel</code> 调用.对于第一行的 <code>onSubscribe</code>,我们知道了 <code>Subscriber</code> 的具体实现,
通常与操作符指定的实现是一致的,在方括号内有一些额外信息,包括这个操作符是否能够 通过同步或异步融合的方式进行自动优化.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第二行,我们可以看到是一个由下游传播上来的个数无限的请求.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>然后 range 一下发出三个值.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>最后一行,我们看到了 <code>cancel()</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>最后一行,(4),最有意思.我们看到 take 在这里发挥作用了.在它拿到足够的元素之后, 就将序列切断了.简单来说,<code>take()</code> 导致源在发出用户请求的数量后 <code>cancel()</code> 了.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/debugging.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#debugging">调试 Reactor</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="metrics"><a class="anchor" href="#metrics"></a>10. 暴漏 Reactor 指标</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Project Reactor 是一个旨在提高性能和更好地利用资源的库.但是要真正了解系统的性能,最好是能够监视其各种组件.</p>
</div>
<div class="paragraph">
<p>这就是为什么 Reactor 提供与 <a href="https://micrometer.io">Micrometer</a> 的内置集成的原因.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果 Micrometer 不在类路径中,则指标什么也不会发生.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="scheduler-metrics"><a class="anchor" href="#scheduler-metrics"></a>10.1. Scheduler metrics</h3>
<div class="paragraph">
<p>Reactor 中的每个异步操作都是通过 Threading and Schedulers 中描述的 <a href="#schedulers">Threading and Schedulers(线程和调度器)</a> 抽象来完成的. 这就是为什么监视您的 <code>Scheduler</code></p>
</div>
<div class="paragraph">
<p>要启用 Scheduler metrics,您将需要使用以下方法:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Schedulers.enableMetrics();
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
创建调度程序时将执行检测.建议尽早调用此方法.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果您使用的是 Spring Boot,则最好将调用放在 <code>SpringApplication.run(Application.class, args)</code> 调用之前.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一旦启用了 scheduler metrics 并将其提供到类路径中,Reactor 将使用 <code>Micrometer</code> 的支持来检测执行程序.</p>
</div>
<div class="paragraph">
<p>请参阅 <a href="https://micrometer.io/docs/ref/jvm">Micrometer 的文档</a> 以了解公开的指标,例如:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>executor_active_threads</p>
</li>
<li>
<p>executor_completed_tasks_total</p>
</li>
<li>
<p>executor_pool_size_threads</p>
</li>
<li>
<p>executor_queued_tasks</p>
</li>
<li>
<p>executor_secounds_{count, max, sum}</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于一个调度程序可能具有多个执行程序,因此每个执行程序指标都有一个 <code>reactor_scheduler_id</code> 标记.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Grafana + Prometheus 用户可以使用 <a href="https://raw.githubusercontent.com/reactor/reactor-monitoring-demo/master/dashboards/schedulers.json">a pre-built dashboard</a>,其中包括用于线程,已完成任务,任务队列和其他方面指标的面板.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="publisher-metrics"><a class="anchor" href="#publisher-metrics"></a>10.2. Publisher metrics</h3>
<div class="paragraph">
<p>有时,能够在 reactive pipeline 的某个阶段记录指标很有用.</p>
</div>
<div class="paragraph">
<p>一种方法是将值手动推送到您选择的指标后端. 另一种选择是将 Reactor 的内置指标集成用于 <code>Flux/Mono</code> 并对其进行解释.</p>
</div>
<div class="paragraph">
<p>Consider the following pipeline:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">listenToEvents()
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要启用此源 <code>Flux</code> 的 metrics(从 <code>listenToEvents()</code> 返回),我们需要为其命名并打开收集的 metrics:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">listenToEvents()
    .name("events") <i class="conum" data-value="1"></i><b>(1)</b>
    .metrics() <i class="conum" data-value="2"></i><b>(2)</b>
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>此阶段的每个指标都将被标识为 "events" (可选的).</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>Flux#metrics</code> 运算符可启用指标报告,使用调用 <code>Flux#name</code> 操作符时提供的名称。如果没有使用 <code>Flux#name</code> 操作符，默认名称将是 <code>reactor</code>。</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>只需将这两个运算符相加,便可以揭示一大堆有用的指标！</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">metric name</th>
<th class="tableblock halign-left valign-top">type</th>
<th class="tableblock halign-left valign-top">description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[name].subscribed</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counts how many Reactor sequences have been subscribed to</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[name].malformed.source</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counts the number of events received from a malformed source (ie an onNext after an onComplete)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[name].requested</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DistributionSummary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counts the amount requested to a named Flux by all subscribers, until at least one requests an unbounded amount</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[name].onNext.delay</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Measures delays between onNext signals (or between onSubscribe and first onNext)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">[name].flow.duration</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timer</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Times the duration elapsed between a subscription and the termination or cancellation of the sequence. A status tag is added to specify what event caused the timer to end (<code>completed</code>, <code>completedEmpty</code>, <code>error</code>, <code>cancelled</code>).</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>是否想知道由于某些错误您的事件处理已重新启动了多少次?  读取 <code>[name].subscribed</code>,因为 <code>retry()</code> 运算符将在发生错误时重新订阅源发布者.</p>
</div>
<div class="paragraph">
<p>对 "每秒事件数" 指标感兴趣吗?  测量 <code>[name].onNext.delay</code> 计数的速率.</p>
</div>
<div class="paragraph">
<p>是否希望在监听器引发错误时收到警报?  使用带有 <code>status=error</code> 标签的 <code>[name].flow.duration</code> .</p>
</div>
<div class="paragraph">
<p>类似的, <code>status=completed</code> 和 <code>status=completedEmpty</code> 可以让您区分以完成的元素序列和已完成的空元素序列</p>
</div>
<div class="paragraph">
<p>请注意，给序列命名时，该序列不能再与其他序列聚合。如果您想识别您的序列但仍然可以与其他视图聚合，作为一种妥协，您可以通过调用 <code>(tag("flow", "events"))</code>  来使用 <a href="#tags">Tags</a> 作为名称例子。.</p>
</div>
<div class="sect3">
<h4 id="tags"><a class="anchor" href="#tags"></a>10.2.1. Tags</h4>
<div class="paragraph">
<p>Every metric will have a <code>type</code> tag in common, which value will be either <code>Flux</code> or <code>Mono</code> depending on the publisher&#8217;s nature.</p>
</div>
<div class="paragraph">
<p>允许用户向其响应式链中添加自定义标签:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">listenToEvents()
    .name("events") <i class="conum" data-value="1"></i><b>(1)</b>
    .tag("source", "kafka") <i class="conum" data-value="2"></i><b>(2)</b>
    .metrics() <i class="conum" data-value="3"></i><b>(3)</b>
    .doOnNext(event -&gt; log.info("Received {}", event))
    .delayUntil(this::processEvent)
    .retry()
    .subscribe();
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>此阶段的每个指标都将被标识为 "events".</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>设置自定义标签 "source" 值为 "kafka".</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>除上述常见标签外,所有报告的指标还将分配有 "source = kafka" 标签.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>Please note that depending on the monitoring system you&#8217;re using, using a name can be considered mandatory when using tags, since it would otherwise result in a different set of tags between two default-named sequences.
Some systems like Prometheus might also require to have the exact same set of tags for each metric with the same name.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/metrics.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#metrics">暴漏 Reactor 指标</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced"><a class="anchor" href="#advanced"></a>11. 高级特性与概念</h2>
<div class="sectionbody">
<div class="paragraph">
<p>这一章涉及如下的 Reactor 的高级特性与概念:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#advanced-mutualizing-operator-usage">打包重用操作符</a></p>
</li>
<li>
<p><a href="#reactor.hotCold">Hot vs Cold</a></p>
</li>
<li>
<p><a href="#advanced-broadcast-multiple-subscribers-connectableflux">使用 <code>ConnectableFlux</code> 对多个订阅者进行广播</a></p>
</li>
<li>
<p><a href="#advanced-three-sorts-batching">三种分批处理方式</a></p>
</li>
<li>
<p><a href="#advanced-parallelizing-parralelflux">使用 <code>ParallelFlux</code> 进行并行处理</a></p>
</li>
<li>
<p><a href="#scheduler-factory">替换默认的 <code>Schedulers</code></a></p>
</li>
<li>
<p><a href="#hooks">使用全局的 Hooks</a></p>
</li>
<li>
<p><a href="#context">增加一个 Context 到响应式序列</a></p>
</li>
<li>
<p><a href="#null-safety">空值安全</a></p>
</li>
<li>
<p><a href="#cleanup">处理需要清理的对象</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="advanced-mutualizing-operator-usage"><a class="anchor" href="#advanced-mutualizing-operator-usage"></a>11.1. 打包重用操作符</h3>
<div class="paragraph">
<p>从代码整洁的角度来说,重用代码是一个好办法.Reactor 提供了几种帮你打包重用代码的方式, 主要通过使用操作符或者常用的"操作符组合”的方法来实现.如果你觉得一段操作链很常用, 你可以将这段操作链打包封装后备用.</p>
</div>
<div class="sect3">
<h4 id="使用-transform-操作符"><a class="anchor" href="#使用-transform-操作符"></a>11.1.1. 使用 <code>transform</code> 操作符</h4>
<div class="paragraph">
<p><code>transform</code> 操作符可以将一段操作链封装为一个函数式(function).这个函数式能在操作期(assembly time) 将被封装的操作链中的操作符还原并接入到调用 transform 的位置.这样做和直接将被封装的操作符 加入到链上的效果是一样的.示例如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; filterAndMap =
f -&gt; f.filter(color -&gt; !color.equals("orange"))
      .map(String::toUpperCase);

Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
    .doOnNext(System.out::println)
    .transform(filterAndMap)
    .subscribe(d -&gt; System.out.println("Subscriber to Transformed MapAndFilter: "+d));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下图显示了  <code>transform</code>  运算符如何封装流:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/gs-transform.png" alt="Transform Operator : encapsulate flows">
</div>
</div>
<div class="paragraph">
<p>上边例子的输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>blue
Subscriber to Transformed MapAndFilter: BLUE
green
Subscriber to Transformed MapAndFilter: GREEN
orange
purple
Subscriber to Transformed MapAndFilter: PURPLE</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="使用-transformdeferred-操作符"><a class="anchor" href="#使用-transformdeferred-操作符"></a>11.1.2. 使用 <code>transformDeferred</code> 操作符</h4>
<div class="paragraph">
<p><code>transformDeferred</code> 运算符与 <code>transform</code> 相似,也能够将几个操作符封装到一个函数式中. 主要区别在于,这个函数式作用到原始序列上的话,是 基于每一个订阅者的(on a per-subscriber basis).
这意味着它对每一个 subscription 可以生成不同的操作链(通过维护一些状态值). 如下例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AtomicInteger ai = new AtomicInteger();
Function&lt;Flux&lt;String&gt;, Flux&lt;String&gt;&gt; filterAndMap = f -&gt; {
    if (ai.incrementAndGet() == 1) {
return f.filter(color -&gt; !color.equals("orange"))
        .map(String::toUpperCase);
    }
    return f.filter(color -&gt; !color.equals("purple"))
            .map(String::toUpperCase);
};

Flux&lt;String&gt; composedFlux =
Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
    .doOnNext(System.out::println)
    .transformDeferred(filterAndMap);

composedFlux.subscribe(d -&gt; System.out.println("Subscriber 1 to Composed MapAndFilter :"+d));
composedFlux.subscribe(d -&gt; System.out.println("Subscriber 2 to Composed MapAndFilter: "+d));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下图显示了 <code>transformDeferred</code> 运算符如何与每个用户进行转换:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/gs-compose.png" alt="Compose Operator : Per Subscriber transformation">
</div>
</div>
<div class="paragraph">
<p>上边的例子输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>blue
Subscriber 1 to Composed MapAndFilter :BLUE
green
Subscriber 1 to Composed MapAndFilter :GREEN
orange
purple
Subscriber 1 to Composed MapAndFilter :PURPLE
blue
Subscriber 2 to Composed MapAndFilter: BLUE
green
Subscriber 2 to Composed MapAndFilter: GREEN
orange
Subscriber 2 to Composed MapAndFilter: ORANGE
purple</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reactor.hotCold"><a class="anchor" href="#reactor.hotCold"></a>11.2. Hot vs Cold</h3>
<div class="paragraph">
<p>到目前为止,我们一直认为 <code>Flux</code>(和 <code>Mono</code>)都是这样的:它们都代表了一种异步的数据序列, 在订阅(subscribe)之前什么都不会发生.</p>
</div>
<div class="paragraph">
<p>但是实际上,广义上有两种发布者:"热”与"冷”(hot and cold).</p>
</div>
<div class="paragraph">
<p>(本文档)到目前介绍的其实都是 cold 家族的发布者.它们为每一个订阅(subscription) 都生成数据.如果没有创建任何订阅(subscription),那么就不会生成数据.</p>
</div>
<div class="paragraph">
<p>试想一个 HTTP 请求:每一个新的订阅者都会触发一个 HTTP 调用,但是如果没有订阅者关心结果的话, 那就不会有任何调用.</p>
</div>
<div class="paragraph">
<p>另一方面,热 发布者,不依赖于订阅者的数量.即使没有订阅者它们也会发出数据, 如果有一个订阅者接入进来,那么它就会收到订阅之后发出的元素.对于热发布者, 在你订阅它之前,确实已经发生了什么.</p>
</div>
<div class="paragraph">
<p><code>just</code> 是 Reactor 中少数几个"热”操作符的例子之一:它直接在组装期(assembly time) 就拿到数据,如果之后有谁订阅它,就重新发送数据给订阅者.再拿 HTTP 调用举例,如果给 <code>just</code> 传入的数据是一个 HTTP 调用的结果,那么之后在初始化 just 的时候才会进行唯一的一次网络调用.</p>
</div>
<div class="paragraph">
<p>如果想将 <code>just</code> 转化为一种 冷 的发布者,你可以使用 <code>defer</code>.它能够将刚才例子中对 HTTP 的请求延迟到订阅时(这样的话,对于每一个新的订阅来说,都会发生一次网络调用).</p>
</div>
<div class="paragraph">
<p>相反，<code>share()</code> 和 <code>replay(&#8230;&#8203;)</code> 方法可以将  cold publisher 变为 hot 。(至少有一次出现了首次订阅)。这两种方法都有 <code>Sinks</code> 。在 sink 类中有许多等价的东西，它们允许以编程方式提供序列。</p>
</div>
<div class="paragraph">
<p>考虑两个示例，一个是 cold Flux 的示例，另一个是利用 Sinks 来模拟 hot Flux 的例子。 以下代码显示了第一个示例：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; source = Flux.fromIterable(Arrays.asList("blue", "green", "orange", "purple"))
                          .map(String::toUpperCase);

source.subscribe(d -&gt; System.out.println("Subscriber 1: "+d));
source.subscribe(d -&gt; System.out.println("Subscriber 2: "+d));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一个例子输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Subscriber 1: BLUE
Subscriber 1: GREEN
Subscriber 1: ORANGE
Subscriber 1: PURPLE
Subscriber 2: BLUE
Subscriber 2: GREEN
Subscriber 2: ORANGE
Subscriber 2: PURPLE</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下图显示了重播行为:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/gs-cold.png" alt="Replaying behavior">
</div>
</div>
<div class="paragraph">
<p>两个订阅者都触发了所有的颜色,因为每一个订阅者都会让构造 <code>Flux</code> 的操作符运行一次.</p>
</div>
<div class="paragraph">
<p>将下边的例子与第一个例子对比:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Sinks.Many&lt;String&gt; hotSource = Sinks.unsafe().many().multicast().directBestEffort();

Flux&lt;String&gt; hotFlux = hotSource.asFlux().map(String::toUpperCase);

hotFlux.subscribe(d -&gt; System.out.println("Subscriber 1 to Hot Source: "+d));

hotSource.emitNext("blue", FAIL_FAST); <i class="conum" data-value="1"></i><b>(1)</b>
hotSource.tryEmitNext("green").orThrow(); <i class="conum" data-value="2"></i><b>(2)</b>

hotFlux.subscribe(d -&gt; System.out.println("Subscriber 2 to Hot Source: "+d));

hotSource.emitNext("orange", FAIL_FAST);
hotSource.emitNext("purple", FAIL_FAST);
hotSource.emitComplete(FAIL_FAST);
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>for more details about sinks, see <a href="#sinks">使用 <code>Sinks.One</code> 和 <code>Sinks.Many</code> 从多个线程生成</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>side note: <code>orThrow()</code> here is an alternative to <code>emitNext</code> + <code>Sinks.EmitFailureHandler.FAIL_FAST</code>
that is suitable for tests, since throwing there is acceptable (more so than in reactive
applications).</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>第二个例子输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Subscriber 1 to Hot Source: BLUE
Subscriber 1 to Hot Source: GREEN
Subscriber 1 to Hot Source: ORANGE
Subscriber 2 to Hot Source: ORANGE
Subscriber 1 to Hot Source: PURPLE
Subscriber 2 to Hot Source: PURPLE</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下图显示了如何广播订阅:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/gs-hot.png" alt="Broadcasting a subscription">
</div>
</div>
<div class="paragraph">
<p>第一个订阅者收到了所有的四个颜色,第二个订阅者由于是在前两个颜色发出之后订阅的, 故而收到了之后的两个颜色,在输出中有两次 &#8220;ORANGE&#8221; 和 &#8220;PURPLE&#8221;.从这个例子可见, 无论是否有订阅者接入进来,这个 Flux 都会运行.</p>
</div>
</div>
<div class="sect2">
<h3 id="advanced-broadcast-multiple-subscribers-connectableflux"><a class="anchor" href="#advanced-broadcast-multiple-subscribers-connectableflux"></a>11.3. 使用 <code>ConnectableFlux</code> 对多个订阅者进行广播</h3>
<div class="paragraph">
<p>有时候,你不仅想要延迟到某一个订阅者订阅之后才开始发出数据,可能还希望在多个订阅者 到齐 之后 才开始.</p>
</div>
<div class="paragraph">
<p><code>ConnectableFlux</code> 的用意便在于此.Flux API 中有两种主要的返回 <code>ConnectableFlux</code> 的方式:`publish` 和 <code>replay</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>publish</code> 会尝试满足各个不同订阅者的需求(背压),并综合这些请求反馈给源. 尤其是如果有某个订阅者的需求为 <code>0</code>,publish 会 暂停 它对源的请求.</p>
</li>
<li>
<p><code>replay</code> 将对第一个订阅后产生的数据进行缓存,最多缓存数量取决于配置(时间/缓存大小). 它会对后续接入的订阅者重新发送数据.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ConnectableFlux</code> 提供了多种对下游订阅的管理.包括:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>connect()</code> 当有足够的订阅接入后,可以对 <code>flux</code> 手动执行一次.它会触发对上游源的订阅.</p>
</li>
<li>
<p><code>autoConnect(n)</code> 与 connect 类似,不过是在有 <code>n</code> 个订阅的时候自动触发.</p>
</li>
<li>
<p><code>refCount(n)</code> 不仅能够在订阅者接入的时候自动触发,还会检测订阅者的取消动作.如果订阅者数量不够, 会将源"断开连接”,再有新的订阅者接入的时候才会继续"连上”源.</p>
</li>
<li>
<p><code>refCount(int, Duration)</code> 增加了一个 "优雅的倒计时":一旦订阅者数量太低了,它会等待 Duration 的时间,如果没有新的订阅者接入才会与源"断开连接”.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>示例如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; source = Flux.range(1, 3)
                           .doOnSubscribe(s -&gt; System.out.println("subscribed to source"));

ConnectableFlux&lt;Integer&gt; co = source.publish();

co.subscribe(System.out::println, e -&gt; {}, () -&gt; {});
co.subscribe(System.out::println, e -&gt; {}, () -&gt; {});

System.out.println("done subscribing");
Thread.sleep(500);
System.out.println("will now connect");

co.connect();
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的代码产生以下输出:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>done subscribing
will now connect
subscribed to source
1
1
2
2
3
3</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用  <code>autoConnect</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; source = Flux.range(1, 3)
                           .doOnSubscribe(s -&gt; System.out.println("subscribed to source"));

Flux&lt;Integer&gt; autoCo = source.publish().autoConnect(2);

autoCo.subscribe(System.out::println, e -&gt; {}, () -&gt; {});
System.out.println("subscribed first");
Thread.sleep(500);
System.out.println("subscribing second");
autoCo.subscribe(System.out::println, e -&gt; {}, () -&gt; {});
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的代码输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>subscribed first
subscribing second
subscribed to source
1
1
2
2
3
3</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-three-sorts-batching"><a class="anchor" href="#advanced-three-sorts-batching"></a>11.4. 三种分批处理方式</h3>
<div class="paragraph">
<p>当你有许多的元素,并且想将他们分批处理,Reactor 总体上有三种方案:分组(grouping)、 窗口(windowing)(译者注:感觉这个不翻译更明白&#8230;&#8203;)、缓存(buffering).
这三种在概念上类似,因为它们都是将 <code>Flux&lt;T&gt;</code> 进行聚集.分组和分段操作都会创建一个 <code>Flux&lt;Flux&lt;T&gt;&gt;</code>,而缓存操作得到的是一个 <code>Collection&lt;T&gt;</code>(译者注:应该是一个 <code>Flux&lt;Collection&lt;T&gt;&gt;</code>).</p>
</div>
<div class="sect3">
<h4 id="用-fluxgroupedfluxt-进行分组"><a class="anchor" href="#用-fluxgroupedfluxt-进行分组"></a>11.4.1. 用 <code>Flux&lt;GroupedFlux&lt;T&gt;&gt;</code> 进行分组</h4>
<div class="paragraph">
<p>分组能够根据 key 将源 <code>Flux&lt;T&gt;</code> 拆分为多个批次.</p>
</div>
<div class="paragraph">
<p>对应的操作符是 <code>groupBy</code>.</p>
</div>
<div class="paragraph">
<p>每一组用 <code>GroupedFlux&lt;T&gt;</code> 类型表示,使用它的 <code>key()</code> 方法可以得到该组的 key.</p>
</div>
<div class="paragraph">
<p>在组内,元素并不需要是连续的.当源发出一个新的元素,该元素会被分发到与之匹配的 key 所对应的组中(如果还没有该 key 对应的组,则创建一个).</p>
</div>
<div class="paragraph">
<p>这意味着组:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>是互相没有交集的(一个元素只属于一个组).</p>
</li>
<li>
<p>会包含原始序列中任意位置的元素.</p>
</li>
<li>
<p>不会为空.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>以下示例根据值是偶数还是奇数对值进行分组:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(
    Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
        .groupBy(i -&gt; i % 2 == 0 ? "even" : "odd")
        .concatMap(g -&gt; g.defaultIfEmpty(-1) //if empty groups, show them
                .map(String::valueOf) //map to string
                .startWith(g.key())) //start with the group's key
    )
    .expectNext("odd", "1", "3", "5", "11", "13")
    .expectNext("even", "2", "4", "6", "12")
    .verifyComplete();
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
分组操作适用于分组个数不多的场景.而且所有的组都必须被消费(例如,通过  <code>flatMap</code> ),这样 <code>groupBy</code> 才能持续从上游获取数据.有时候这两种要求在一起——比如元素数量超多, 但是并行的用来消费的 <code>flatMap</code> 又太少的时候——会导致程序卡死.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="使用-fluxfluxt-进行-window-操作"><a class="anchor" href="#使用-fluxfluxt-进行-window-操作"></a>11.4.2. 使用 <code>Flux&lt;Flux&lt;T&gt;&gt;</code> 进行 window 操作</h4>
<div class="paragraph">
<p><em>window</em> 操作是 根据个数、时间等条件,或能够定义边界的发布者(boundary-defining Publisher), 把源 <code>Flux&lt;T&gt;</code> 拆分为 windows.</p>
</div>
<div class="paragraph">
<p>对应的操作符有 <code>window</code>、<code>windowTimeout</code>、<code>windowUntil</code>、<code>windowWhile</code>,以及 <code>windowWhen</code>.</p>
</div>
<div class="paragraph">
<p>与 <code>groupBy</code> 的主要区别在于,窗口操作能够保持序列顺序.</p>
</div>
<div class="paragraph">
<p>但是,某些变体仍然可以重叠. 例如,在 <code>window(int maxSize, int skip)</code> 中,<code>maxSize</code> 指定收集多少个元素就关闭 <code>window</code>,而 <code>skip</code> 指定收集多数个元素后就打开下一个 <code>window</code>.所以如果 <code>maxSize &gt; skip</code> 的话, 一个新的 <code>window</code> 的开启会先于当前 <code>window</code> 的关闭, 从而二者会有重叠.</p>
</div>
<div class="paragraph">
<p>重叠的 window 示例如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(
    Flux.range(1, 10)
        .window(5, 3) //overlapping windows
        .concatMap(g -&gt; g.defaultIfEmpty(-1)) //show empty windows as -1
    )
        .expectNext(1, 2, 3, 4, 5)
        .expectNext(4, 5, 6, 7, 8)
        .expectNext(7, 8, 9, 10)
        .expectNext(10)
        .verifyComplete();
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果将两个参数的配置反过来(<code>maxSize</code> &lt; <code>skip</code>),序列中的一些元素就会被丢弃掉, 而不属于任何 window.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对基于判断条件的 <code>windowUntil</code> 和 <code>windowWhile</code>,如果序列中的元素不匹配判断条件, 那么可能导致 空 windows,如下例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(
    Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
        .windowWhile(i -&gt; i % 2 == 0)
        .concatMap(g -&gt; g.defaultIfEmpty(-1))
    )
        .expectNext(-1, -1, -1) //respectively triggered by odd 1 3 5
        .expectNext(2, 4, 6) // triggered by 11
        .expectNext(12) // triggered by 13
        // however, no empty completion window is emitted (would contain extra matching elements)
        .verifyComplete();
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="使用-fluxlistt-进行缓存"><a class="anchor" href="#使用-fluxlistt-进行缓存"></a>11.4.3. 使用 <code>Flux&lt;List&lt;T&gt;&gt;</code> 进行缓存</h4>
<div class="paragraph">
<p>缓存与窗口类似,不同在于:缓存操作之后会发出 <em>buffers</em> (类型为 <code>Collection&lt;T&gt;</code>, 默认是 <code>List&lt;T&gt;</code>),而不是 windows (类型为 <code>Flux&lt;T&gt;</code>).</p>
</div>
<div class="paragraph">
<p>缓存的操作符与窗口的操作符是对应的:`buffer`、<code>bufferTimeout</code>、<code>bufferUntil</code>、<code>bufferWhile</code>, 以及 <code>bufferWhen</code>.</p>
</div>
<div class="paragraph">
<p>如果说对于窗口操作符来说,是开启一个窗口,那么对于缓存操作符来说,就是创建一个新的集合, 然后对其添加元素.而窗口操作符在关闭窗口的时候,缓存操作符则是发出一个集合.</p>
</div>
<div class="paragraph">
<p>缓存操作也会有丢弃元素或内容重叠的情况,如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(
    Flux.range(1, 10)
        .buffer(5, 3) //overlapping buffers
    )
        .expectNext(Arrays.asList(1, 2, 3, 4, 5))
        .expectNext(Arrays.asList(4, 5, 6, 7, 8))
        .expectNext(Arrays.asList(7, 8, 9, 10))
        .expectNext(Collections.singletonList(10))
        .verifyComplete();
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>不像窗口方法,<code>bufferUntil</code> 和 <code>bufferWhile</code> 不会发出空的 buffer,如下例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">StepVerifier.create(
    Flux.just(1, 3, 5, 2, 4, 6, 11, 12, 13)
        .bufferWhile(i -&gt; i % 2 == 0)
    )
    .expectNext(Arrays.asList(2, 4, 6)) // triggered by 11
    .expectNext(Collections.singletonList(12)) // triggered by 13
    .verifyComplete();
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="advanced-parallelizing-parralelflux"><a class="anchor" href="#advanced-parallelizing-parralelflux"></a>11.5. 使用 <code>ParallelFlux</code> 进行并行处理</h3>
<div class="paragraph">
<p>如今多核架构已然普及,能够方便的进行并行处理是很重要的.Reactor 提供了一种特殊的类型 <code>ParallelFlux</code> 来实现并行,它能够将操作符调整为并行处理方式.</p>
</div>
<div class="paragraph">
<p>你可以对任何 <code>Flux</code> 使用 <code>parallel()</code> 操作符来得到一个 <code>ParallelFlux</code>. 不过这个操作符本身并不会进行并行处理,而是将负载划分到多个"轨道(rails)”上 (默认情况下,轨道个数与 CPU 核数相等).</p>
</div>
<div class="paragraph">
<p>为了配置 <code>ParallelFlux</code> 如何并行地执行每一个轨道,你需要使用 <code>runOn(Scheduler)</code>. 注意,<code>Schedulers.parallel()</code> 是推荐的专门用于并行处理的调度器.</p>
</div>
<div class="paragraph">
<p>下边有两个用于比较的例子,第一个如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.range(1, 10)
    .parallel(2) <i class="conum" data-value="1"></i><b>(1)</b>
    .subscribe(i -&gt; System.out.println(Thread.currentThread().getName() + " -&gt; " + i));
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们给定一个轨道数字,而不是依赖于 CPU 核数.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>下边是第二个例子:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux.range(1, 10)
    .parallel(2)
    .runOn(Schedulers.parallel())
    .subscribe(i -&gt; System.out.println(Thread.currentThread().getName() + " -&gt; " + i));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一个例子输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>main -&gt; 1
main -&gt; 2
main -&gt; 3
main -&gt; 4
main -&gt; 5
main -&gt; 6
main -&gt; 7
main -&gt; 8
main -&gt; 9
main -&gt; 10</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第二个例子在两个线程中并行执行,输出如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>parallel-1 -&gt; 1
parallel-2 -&gt; 2
parallel-1 -&gt; 3
parallel-2 -&gt; 4
parallel-1 -&gt; 5
parallel-2 -&gt; 6
parallel-1 -&gt; 7
parallel-1 -&gt; 9
parallel-2 -&gt; 8
parallel-2 -&gt; 10</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果在并行地处理之后,需要退回到一个"正常”的 <code>Flux</code> 而使后续的操作链按非并行模式执行, 你可以对 <code>ParallelFlux</code> 使用 <code>sequential()</code> 方法.</p>
</div>
<div class="paragraph">
<p>注意,当你在对 <code>ParallelFlux</code> 使用一个 <code>Subscriber</code> 而不是基于 lambda 进行订阅(<code>subscribe()</code>) 的时候,<code>sequential()</code> 会自动地被偷偷应用.</p>
</div>
<div class="paragraph">
<p>注意 <code>subscribe(Subscriber&lt;T&gt;)</code> 会合并所有的执行轨道,而 <code>subscribe(Consumer&lt;T&gt;)</code> 会在所有轨道上运行. 如果 <code>subscribe()</code> 方法中是一个 lambda,那么有几个轨道,lambda 就会被执行几次.</p>
</div>
<div class="paragraph">
<p>你还可以使用 <code>groups()</code> 作为 <code>Flux&lt;GroupedFlux&lt;T&gt;&gt;</code> 进入到各个轨道或组里边, 然后可以通过 <code>composeGroup()</code> 添加额外的操作符.</p>
</div>
</div>
<div class="sect2">
<h3 id="scheduler-factory"><a class="anchor" href="#scheduler-factory"></a>11.6. 替换默认的 <code>Schedulers</code></h3>
<div class="paragraph">
<p>就像我们在  <a href="#schedulers">Threading and Schedulers(线程和调度器)</a>(Schedulers) 这一节看到的那样, Reactor Core 内置许多 Scheduler 的具体实现. 你可以用形如 <code>new*</code> 的工厂方法来创建调度器,每一种调度器都有一个单例对象,
你可以使用单例工厂方法 (比如 <code>Schedulers.elastic()</code> 而不是 <code>Schedulers.newElastic()</code>)来获取它.</p>
</div>
<div class="paragraph">
<p>当你不明确指定调度器的时候,那些需要调度器的操作符会使用这些默认的单例调度器对象.例如, <code>Flux#delayElements(Duration)</code> 使用的是 <code>Schedulers.parallel()</code> 调度器对象.</p>
</div>
<div class="paragraph">
<p>然而有些情况下,你可能需要"一刀切”(就不用对每一个操作符都传入你自己的调度器作为参数了) 地调整这些默认调度器. 一个典型的例子就是,假设你需要对每一个被调度的任务统计执行时长, 就想把默认的调度器包装一下,然后添加计时功能.</p>
</div>
<div class="paragraph">
<p>那么可以使用 <code>Schedulers.Factory</code> 类来改变默认的调度器.默认情况下,一个 <code>Factory</code> 会使用一些"命名比较直白” 的方法来创建所有的标准 <code>Scheduler</code>.每一个方法你都可以用自己的实现方式来重写.</p>
</div>
<div class="paragraph">
<p>此外,<code>Factory</code> 还提供一个额外的自定义方法 <code>decorateExecutorService</code>.它会在创建每一个 reactor-core 调度器——内部有一个 <code>ScheduledExecutorService</code>(即使是比如用 <code>Schedulers.newParallel()</code> 方法创建的这种非默认的调度器)——的时候被调用.</p>
</div>
<div class="paragraph">
<p>你可以通过调整 <code>ScheduledExecutorService</code> 来改变调度器:(译者加:decorateExecutorService 方法)通过一个 <code>Supplier</code> 参数暴露出来,你可以直接绕过这个 <code>supplier</code> 返回你自己的调度器实例,或者用 (译者加: Schedulers.ScheduledExecutorService 的)<code>get()</code> 得到默认实例,然后包装它, 这取决于配置的调度器类型.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
当你搞定了一个定制好的 <code>Factory</code> 后,你必须使用 <code>Schedulers.setFactory(Factory)</code> 方法来安装它.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>最后,对于调度器来说,有一个可自定义的 hook:`onHandleError`.这个 hook 会在提交到这个调度器的 <code>Runnable</code> 任务抛出异常的时候被调用(注意,如果还设置了一个 <code>UncaughtExceptionHandler</code>, 那么它和 hook 都会被调用).</p>
</div>
</div>
<div class="sect2">
<h3 id="hooks"><a class="anchor" href="#hooks"></a>11.7. 使用全局的 Hooks</h3>
<div class="paragraph">
<p>Reactor 还有另外一类可配置的应用于多种场合的回调,它们都在 <code>Hooks</code> 类中定义,总体来说有三类:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#hooks-dropping">丢弃事件的 Hooks</a></p>
</li>
<li>
<p><a href="#hooks-internal">内部错误 Hook</a></p>
</li>
<li>
<p><a href="#hooks-assembly">组装 Hooks</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="hooks-dropping"><a class="anchor" href="#hooks-dropping"></a>11.7.1. 丢弃事件的 Hooks</h4>
<div class="paragraph">
<p>当生成源的操作符不遵从响应式流规范的时候,Dropping hooks(用于处理丢弃事件的 hooks)会被调用. 这种类型的错误是处于正常的执行路径之外的(也就是说它们不能通过 <code>onError</code> 传播).</p>
</div>
<div class="paragraph">
<p>典型的例子是,假设一个发布者即使在被调用 <code>onCompleted</code> 之后仍然可以通过操作符调用 <code>onNext</code>. 这种情况下,<code>onNext</code> 的值会被 丢弃,如果有多余的 <code>onError</code> 的信号亦是如此.</p>
</div>
<div class="paragraph">
<p>相应的 hook,<code>onNextDropped</code> 以及 <code>onErrorDropped</code>,可以提供一个全局的 <code>Consumer</code>, 以便能够在丢弃的情况发生时进行处理.例如,你可以使用它来对丢弃事件记录日志,或进行资源清理 (使用资源的值可能压根没有到达响应式链的下游).</p>
</div>
<div class="paragraph">
<p>连续设置两次 hook 的话都会起作用:提供的每一个 consumer 都会被调用.使用 <code>Hooks.resetOn*Dropped()</code> 方法可以将 hooks 全部重置为默认.</p>
</div>
</div>
<div class="sect3">
<h4 id="hooks-internal"><a class="anchor" href="#hooks-internal"></a>11.7.2. 内部错误 Hook</h4>
<div class="paragraph">
<p>如果操作符在执行其 <code>onNext</code>、<code>onError</code> 以及 <code>onComplete</code> 方法的时候抛出异常,那么 <code>onOperatorError</code> 这一个 hook 会被调用.</p>
</div>
<div class="paragraph">
<p>与上一类 hook 不同,这个 hook 还是处在正常的执行路径中的.一个典型的例子就是包含一个 map 函数式的 <code>map</code> 操作符抛出的异常(比如零作为除数),这时候还是会执行到 <code>onError</code> 的.</p>
</div>
<div class="paragraph">
<p>首先,它会将异常传递给 <code>onOperatorError</code>.利用这个 hook 你可以检查这个错误(以及有问题的相关数据), 并可以 改变 这个异常.当然你还可以做些别的事情,比如记录日志或返回原始异常.</p>
</div>
<div class="paragraph">
<p>注意,<code>onOperatorError</code> hook 也可以被多次设置:你可以提供一个 <code>String</code> 为一个特别的 <code>BiFunction</code> 类型的函数式设置识别符,不同识别符的函数式都会被执行,当然,重复使用一个识别符的话, 则后来的设置会覆盖前边的设置.</p>
</div>
<div class="paragraph">
<p>因此,默认的 hook 可以使用 <code>Hooks.resetOnOperatorError()</code> 方法重置,而提供识别符的 hook 可以使用 <code>Hooks.resetOnOperatorError(String)</code> 方法来重置.</p>
</div>
</div>
<div class="sect3">
<h4 id="hooks-assembly"><a class="anchor" href="#hooks-assembly"></a>11.7.3. 组装 Hooks</h4>
<div class="paragraph">
<p>这些组装(assembly) hooks 关联了操作符的生命周期.它们会在一个操作链被组装起来的时候(即实例化的时候) 被调用.每一个新的操作符组装到操作链上的时候,<code>onEachOperator</code> 都会返回一个不同的发布者,
从而可以利用它动态调整操作符.<code>onLastOperator</code> 与之类似,不过只会在被操作链上的最后一个 (<code>subscribe</code> 调用之前的)操作符调用.</p>
</div>
<div class="paragraph">
<p>如果您想使用 cross-cutting <code>Subscriber</code> 实现来装饰所有运算符,则可以研究 <code>Operators#lift*</code> 方法来帮助您处理各种类型的 Reactor <code>Publishers</code>(<code>Flux</code>,<code>Mono</code>,<code>ParallelFlux</code>,<code>GroupedFlux</code> 和 <code>ConnectableFlux</code>) ,以及它们的 <code>Fuseable</code> 版本.</p>
</div>
<div class="paragraph">
<p>类似于 <code>onOperatorError</code>,也可以叠加,并且通过识别符来标识.也是用类似的方式重置全部或部分 hooks.</p>
</div>
</div>
<div class="sect3">
<h4 id="预置-hook"><a class="anchor" href="#预置-hook"></a>11.7.4. 预置 Hook</h4>
<div class="paragraph">
<p><code>Hooks</code> 工具类还提供了一些预置的 hooks.利用他们可以改变一些默认的处理方式,而不用自己 编写 hook:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>onNextDroppedFail()</code>: <code>onNextDropped</code> 通常会抛出 <code>Exceptions.failWithCancel()</code> 异常. 现在它默认还会以 DEBUG 级别对被丢弃的值记录日志.如果想回到原来的只是抛出异常的方式,使用 <code>onNextDroppedFail()</code>.</p>
</li>
<li>
<p><code>onOperatorDebug()</code>: 这个方法会激活 <a href="#debug-activate">debug mode</a>.它与 <code>onOperatorError</code> hook 关联,所以调用 <code>resetOnOperatorError()</code> 同时也会重置它.不过它内部也用到了特别的识别符, 你可以通过 <code>resetOnOperatorDebug()</code> 方法来重置它.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="context"><a class="anchor" href="#context"></a>11.8. 增加一个 Context 到响应式序列</h3>
<div class="paragraph">
<p>当从命令式编程风格切换到响应式编程风格的时候,一个技术上最大的挑战就是线程处理.</p>
</div>
<div class="paragraph">
<p>与习惯做法不同的是,在响应式编程中,一个线程(Thread)可以被用于处理多个同时运行的异步序列 (实际上是非阻塞的).执行过程也会经常从一个线程切换到另一个线程.</p>
</div>
<div class="paragraph">
<p>这样的情况下,对于开发者来说,如果依赖线程模型中相对“稳定”的特性——比如 <code>ThreadLocal</code> ——就会变得很难.因为它会让你将数据绑定到一个 线程 上,所以在响应式环境中使用就变得 比较困难.因此,将使用了 <code>ThreadLocal</code> 的库应用于 Reactor 的时候就会带来新的挑战.通常会更糟, 它用起来效果会更差,甚至会失败. 比如,使用 Logback 的 MDC 来存储日志关联的 ID,就是一个非常符合 这种情况的例子.</p>
</div>
<div class="paragraph">
<p>通常的对 <code>ThreadLocal</code> 的替代方案是将环境相关的数据 <code>C</code>,同业务数据 <code>T</code> 一起置于序列中, 比如使用 <code>Tuple2&lt;T, C&gt;</code>.这种方案看起来并不好,况且会在方法和 <code>Flux</code> 泛型中暴露环境数据信息.</p>
</div>
<div class="paragraph">
<p>自从版本 <code>3.1.0</code>,Reactor 引入了一个类似于 <code>ThreadLocal</code> 的高级功能:`Context`.它作用于一个 <code>Flux</code> 或一个 <code>Mono</code> 上,而不是应用于一个线程(<code>Thread</code>).</p>
</div>
<div class="paragraph">
<p>为了说明,这里有个读写 <code>Context</code> 的简单例子:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
    .flatMap(s -&gt; Mono.deferContextual(ctx -&gt;
         Mono.just(s + " " + ctx.get(key))))
    .contextWrite(ctx -&gt; ctx.put(key, "World"));

StepVerifier.create(r)
            .expectNext("Hello World")
            .verifyComplete();
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来的几个小节,我们来了解 <code>Context</code> 是什么以及如何用,从而最终可以理解上边的例子.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
这是一个主要面向库开发人员的高级功能.这需要开发者对 <a href="https://github.com/reactive-streams/reactive-streams-jvm/blob/master/README.md#3-subscription-code"><code>Subscription</code> 的生命周期</a>  充分理解,并且明白它主要用于 subscription 相关的库.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="context.api"><a class="anchor" href="#context.api"></a>11.8.1. <code>Context</code> API</h4>
<div class="paragraph">
<p><code>Context</code> 是一个类似于 <code>Map</code>(这种数据结构)的接口:它存储键值(key-value)对,你需要通过 key 来获取值，还提供了一个简化的 <code>ContextView</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>key 和 value 都是 <code>Object</code> 类型,所以 <code>Context</code> (和 <code>ContextView</code> ) 可以包含任意数量的任意对象.</p>
</li>
<li>
<p><code>Context</code> 是 不可变的(immutable).它公开了像 <code>put</code> 和 <code>putAll</code>  这样的写方法，但它们会产生一个新实例。</p>
</li>
<li>
<p>对于一个没有公开类似的写方法的只读 API，从 3.4.0 开始就有了 <code>ContextView</code> 超接口</p>
</li>
<li>
<p>用 <code>hasKey(Object key)</code> 方法检查一个 key 是否已经存在.</p>
</li>
<li>
<p>用 <code>getOrDefault(Object key, T defaultValue)</code> 方法取回 key 对应的值(类型转换为 <code>T</code>), 或在找不到这个 key 的情况下返回一个默认值.</p>
</li>
<li>
<p>用 <code>getOrEmpty(Object key)</code> 来得到一个 <code>Optional&lt;T&gt;</code> (context 会尝试将值转换为 <code>T</code>).</p>
</li>
<li>
<p>用 <code>put(Object key, Object value)</code> 方法来存储一个键值对,返回一个新的 <code>Context</code> 对象. 你也可以用 <code>putAll(Context)</code> 方法将两个 context 合并为一个新的 context.</p>
</li>
<li>
<p>用 <code>delete(Object key)</code> 来删除 key 关联的值,并返回一个新的 <code>Context</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>创建一个 <code>Context</code> 时,你可以用静态方法 <code>Context.of</code> 预先存储最多 5 个键值对. 它接受 2, 4, 6, 8 或 10 个 <code>Object</code> 对象,两两一对作为键值对添加到 <code>Context</code>.</p>
</div>
<div class="paragraph">
<p>你也可以用 <code>Context.empty()</code> 方法来创建一个空的 <code>Context</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context.write"><a class="anchor" href="#context.write"></a>11.8.2. 把 <code>Context</code> 绑定到 <code>Flux</code> and Writing</h4>
<div class="paragraph">
<p>为了使用 <code>Context</code>,它必须要绑定到一个指定的序列,并且链上的每个操作符都可以访问它. 注意,这里的操作符必须是 Reactor 内置的操作符,因为 <code>Context</code> 是 Reactor 特有的.</p>
</div>
<div class="paragraph">
<p>实际上,一个 <code>Context</code> 是绑定到每一个链中的 <code>Subscriber</code> 上的. 它使用 <code>Subscription</code> 的传播机制来让自己对每一个操作符都可见(从最后一个 <code>subscribe</code> 沿链向上).</p>
</div>
<div class="paragraph">
<p>为了填充 <code>Context</code> ——只能在订阅时(subscription time)——你需要使用 <code>contextWrite</code> 操作符.</p>
</div>
<div class="paragraph">
<p><code>contextWrite(ContextView)</code> 方法会将你提供的 <code>ContextView</code> 与来自下游(记住,<code>Context</code> 是从下游 向上游传播的)的 <code>Context</code> 合并. 这通过调用 <code>putAll</code> 实现,最后会生成一个新的 <code>Context</code> 给上游.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
你也可以用更高级的 <code>contextWrite(Function&lt;Context, Context&gt;)</code>.它接受来自下游的 <code>Context</code> 的副本,然后你可以根据需要添加或删除值,然后返回新的 <code>Context</code>.你甚至可以返回一个完全不同 的对象,虽然不太建议这样(这样可能影响到依赖这个 <code>Context</code> 的库).
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="context.read"><a class="anchor" href="#context.read"></a>11.8.3. 通过  <code>ContextView</code> 读取 <code>Context</code></h4>
<div class="paragraph">
<p>一旦您填充了一个 <code>Context</code>，您可能希望在运行时查看它。.多数时候,添加内容到 <code>Context</code> 是终端用户的责任, 但是利用这些信息是在第三方库的一方，因为此类库通常位于客户端代码的上游。.</p>
</div>
<div class="paragraph">
<p>读取的操作符允许通过暴露其 <code>ContextView</code> 从操作符链中的 <code>Context</code> 获取数据：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>to access the context from a source-like operator, use <code>deferContextual</code> factory method</p>
</li>
<li>
<p>to access the context from the middle of an operator chain, use <code>transformDeferredContextual(BiFunction)</code></p>
</li>
<li>
<p>alternatively, when dealing with an inner sequence (like inside a <code>flatMap</code>), the <code>ContextView</code>
can be materialized using <code>Mono.deferContextual(Mono::just)</code>. Usually though, you might want
to perform meaningful work directly within the defer&#8217;s lambda, eg. <code>Mono.deferContextual(ctx &#8594; doSomethingAsyncWithContextData(v, ctx.get(key)))</code>
where <code>v</code> is the value being flatMapped.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
In order to read from the <code>Context</code> without misleading users into thinking one can write to it
while data is running through the pipeline, only the <code>ContextView</code> is exposed by the operators above.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="简单的-context-例子"><a class="anchor" href="#简单的-context-例子"></a>11.8.4. 简单的 <code>Context</code> 例子</h4>
<div class="paragraph">
<p>本例的初衷是为了让你对如何使用 <code>Context</code> 有个更好的理解.</p>
</div>
<div class="paragraph">
<p>让我们先回头看一下最初的例子:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
    .flatMap(s -&gt; Mono.deferContextual(ctx -&gt;
         Mono.just(s + " " + ctx.get(key)))) <i class="conum" data-value="2"></i><b>(2)</b>
    .contextWrite(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="1"></i><b>(1)</b>

StepVerifier.create(r)
            .expectNext("Hello World") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>操作链以调用 <code>contextWrite(Function)</code> 结尾,将 <code>"World"</code> 作为 <code>"message"</code> 这个 key 的 值添加到 <code>Context</code> 中.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>对源调用 <code>flatMap</code> 用 <code>Mono.deferContextual()</code> 方法拿到 <code>ContextView</code>.然后使用 <code>map</code> 读取关联到 <code>"message"</code> 的值,然后与原来的值连接.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>最后 <code>Mono&lt;String&gt;</code> 确实发出了 <code>"Hello World"</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
上边的数字顺序并不是按照代码行顺序排的,这并非错误:它代表了执行顺序.虽然 <code>subscriberContext</code> 是链上的最后一个环节,但确实最先执行的(原因在于 contextWrite 信号 是从下游向上的).
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
注意在你的操作链中,写入 与 读取 <code>Context</code> 的 相对位置 很重要:因为 <code>Context</code> 是不可变的,它的内容只能被上游的操作符看到,如下例所示:
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
    .contextWrite(ctx -&gt; ctx.put(key, "World")) <i class="conum" data-value="1"></i><b>(1)</b>
    .flatMap( s -&gt; Mono.deferContextual(ctx -&gt;
        Mono.just(s + " " + ctx.getOrDefault(key, "Stranger")))); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello Stranger") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>写入 <code>Context</code> 的位置太靠上了&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>所以在 <code>flatMap</code> 就没有 key 关联的值,使用了默认值</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>结果 <code>Mono&lt;String&gt;</code> 发出了 <code>"Hello Stranger"</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>类似的,如果多次对 <code>Context</code> 中的同一个 key 赋值的话,要看 写入的相对顺序 : 读取 <code>Context</code> 的操作符只能拿到下游最近的一次写入的值,如下例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono
    .deferContextual(ctx -&gt; Mono.just("Hello " + ctx.get(key)))
    .contextWrite(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="1"></i><b>(1)</b>
    .contextWrite(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello Reactor") <i class="conum" data-value="3"></i><b>(3)</b>
            .verifyComplete();
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>写入 <code>"message"</code> 的值.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>另一次写入 <code>"message"</code> 的值.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>deferContextual</code> 方法值能拿到下游最近的一次写入的值: <code>"Reactor"</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>这里,首先 <code>Context</code> 中的 key 被赋值 <code>"World"</code>.然后订阅信号(subscription signal)向上游 移动,又发生了另一次写入.这次生成了第二个不变的 <code>Context</code>,里边的值是 <code>"Reactor"</code>.
之后, 数据开始流动, <code>deferContextual</code> 拿到最近的 <code>Context</code> ,也就是第二个值为 <code>"Reactor"</code> 的 <code>Context</code>  (exposed to the user as a <code>ContextView</code>).</p>
</div>
<div class="paragraph">
<p>你可能会觉得 <code>Context</code> 是与数据信号一块传播的.如果是那样的话,在两次写入操作中间加入的一个 <code>flatMap</code> 会使用最上游的这个 <code>Context</code>.但并不是这样的,如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono
    .deferContextual(ctx -&gt; Mono.just("Hello " + ctx.get(key))) <i class="conum" data-value="3"></i><b>(3)</b>
    .contextWrite(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="2"></i><b>(2)</b>
    .flatMap( s -&gt; Mono.deferContextual(ctx -&gt;
        Mono.just(s + " " + ctx.get(key)))) <i class="conum" data-value="4"></i><b>(4)</b>
    .contextWrite(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="1"></i><b>(1)</b>

StepVerifier.create(r)
            .expectNext("Hello Reactor World") <i class="conum" data-value="5"></i><b>(5)</b>
            .verifyComplete();
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这里是第一次赋值.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>这里是第二次赋值.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>第一个 context 看到的是第二次的赋值.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>flatMap</code> 将上一个的结果与 第一次赋值 的 context 值连接.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>Mono</code> 发出的是 <code>"Hello Reactor World"</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>原因在于 <code>Context</code> 是与 <code>Subscriber</code> 关联的,而每一个操作符访问的 <code>Context</code> 来自其下游的 <code>Subscriber</code>.</p>
</div>
<div class="paragraph">
<p>最后一个有意思的传播方式是,对 <code>Context</code> 的赋值也可以在一个 <code>flatMap</code> 内部,如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String key = "message";
Mono&lt;String&gt; r = Mono.just("Hello")
    .flatMap( s -&gt; Mono
        .deferContextual(ctxView -&gt; Mono.just(s + " " + ctxView.get(key)))
    )
    .flatMap( s -&gt; Mono
        .deferContextual(ctxView -&gt; Mono.just(s + " " + ctxView.get(key)))
        .contextWrite(ctx -&gt; ctx.put(key, "Reactor")) <i class="conum" data-value="1"></i><b>(1)</b>
    )
    .contextWrite(ctx -&gt; ctx.put(key, "World")); <i class="conum" data-value="2"></i><b>(2)</b>

StepVerifier.create(r)
            .expectNext("Hello World Reactor")
            .verifyComplete();
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个 <code>contextWrite</code> 不会影响所在 <code>flatMap</code> 之外的任何东西.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>这个 <code>contextWrite</code> 会影响主序列的 <code>Context</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>上边的例子中,最后发出的值是 <code>"Hello World Reactor"</code> 而不是 <code>"Hello Reactor World"</code>,因为赋值 "Reactor" 的 <code>contextWrite</code> 是作用于第二个 <code>flatMap</code> 的内部序列的.所以不会在主序列可见/传播,第一个 <code>flatMap</code> 也看不到它.传播(Propagation) + 不可变性(immutability)将类似 <code>flatMap</code> 这样的操作符中的创建的内部序列中的 <code>Context</code> 与外部隔离开来.</p>
</div>
</div>
<div class="sect3">
<h4 id="完整示例"><a class="anchor" href="#完整示例"></a>11.8.5. 完整示例</h4>
<div class="paragraph">
<p>让我们来看一个实际的从 <code>Context</code> 中读取值的例子:一个响应式的 HTTP 客户端将一个 <code>Mono&lt;String&gt;</code> (用于 <code>PUT</code> 请求)作为数据源,同时通过一个特定的 key 使用 <code>Context</code> 将关联的ID信息放入请求头中.</p>
</div>
<div class="paragraph">
<p>从用户角度,是这样调用的:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">doPut("www.example.com", Mono.just("Walter"))
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了传播一个关联ID,应该这样调用:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">doPut("www.example.com", Mono.just("Walter"))
    .contextWrite(Context.of(HTTP_CORRELATION_ID, "2-j3r9afaf92j-afkaf"))
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由上可见,用户代码使用了 <code>contextWrite</code> 来为 <code>Context</code> 的 <code>HTTP_CORRELATION_ID</code> 赋值.上游的操作符是一个由 HTTP 客户端库返回的 <code>Mono&lt;Tuple2&lt;Integer, String&gt;&gt;</code> (一个简化的 HTTP 响应).所以能够正确将信息从用户代码传递给库代码.</p>
</div>
<div class="paragraph">
<p>下边的例子演示了从库的角度由 context 读取值的模拟代码,如果能够找到关联ID,则“增加请求”:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">static final String HTTP_CORRELATION_ID = "reactive.http.library.correlationId";

Mono&lt;Tuple2&lt;Integer, String&gt;&gt; doPut(String url, Mono&lt;String&gt; data) {
  Mono&lt;Tuple2&lt;String, Optional&lt;Object&gt;&gt;&gt; dataAndContext =
      data.zipWith(Mono.deferContextual(c -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
          Mono.just(c.getOrEmpty(HTTP_CORRELATION_ID))) <i class="conum" data-value="2"></i><b>(2)</b>
      );

  return dataAndContext.&lt;String&gt;handle((dac, sink) -&gt; {
      if (dac.getT2().isPresent()) { <i class="conum" data-value="3"></i><b>(3)</b>
        sink.next("PUT &lt;" + dac.getT1() + "&gt; sent to " + url +
            " with header X-Correlation-ID = " + dac.getT2().get());
      }
      else {
        sink.next("PUT &lt;" + dac.getT1() + "&gt; sent to " + url);
      }
        sink.complete();
      })
      .map(msg -&gt; Tuples.of(200, msg));
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>用 <code>Mono.deferContextual()</code> 拿到 <code>ContextView</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>提取出关联 ID 的值,是一个 <code>Optional</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>如果值存在,那么就将其加入请求头</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在这段库代码片段中,你可以看到它是如何将 <code>Mono</code> 和 <code>Mono.deferContextual(Mono::just)</code>  打包起来的. 返回的是一个 <code>Tuple2&lt;String, ContextView&gt;</code>,这个 <code>Context</code> 包含来自下游的 <code>HTTP_CORRELATION_ID</code> 的值.</p>
</div>
<div class="paragraph">
<p>库代码接着用 <code>map</code> 读取出那个 key 的值 <code>Optional&lt;String&gt;</code>,如果值存在,将其作为 <code>X-Correlation-ID</code> 请求头. 最后一块而用 <code>handle</code> 来处理.</p>
</div>
<div class="paragraph">
<p>用来验证上边的库代码的测试程序如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void contextForLibraryReactivePut() {
  Mono&lt;String&gt; put = doPut("www.example.com", Mono.just("Walter"))
      .contextWrite(Context.of(HTTP_CORRELATION_ID, "2-j3r9afaf92j-afkaf"))
      .filter(t -&gt; t.getT1() &lt; 300)
      .map(Tuple2::getT2);

  StepVerifier.create(put)
              .expectNext("PUT &lt;Walter&gt; sent to www.example.com" +
                  " with header X-Correlation-ID = 2-j3r9afaf92j-afkaf")
              .verifyComplete();
}
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cleanup"><a class="anchor" href="#cleanup"></a>11.9. 处理需要清理的对象</h3>
<div class="paragraph">
<p>在特定的情况下,您的应用程序可能会清理不再需要某种形式的的类型. 这是一种高级方案,例如,当您有引用计数的对象或处理堆外对象时. Netty 的 <code>ByteBuf</code> 就是这两者的典型例子.</p>
</div>
<div class="paragraph">
<p>为了确保正确清理此类对象,您需要在 <code>Flux</code>-by-<code>Flux</code> 基础上以及多个全局 hooks 中对其进行考虑(请参阅使用  <a href="#hooks">使用全局的 Hooks</a>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>doOnDiscard</code> <code>Flux</code>/<code>Mono</code> 操作符</p>
</li>
<li>
<p><code>onOperatorError</code> hook</p>
</li>
<li>
<p><code>onNextDropped</code> hook</p>
</li>
<li>
<p>特定操作符的处理</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>之所以需要这样做,是因为每个 hook 都考虑了清除特定的子集,并且用户可能希望(例如)除了 <code>onOperatorError</code> 中的清除逻辑之外,还实现特定的错误处理逻辑.</p>
</div>
<div class="paragraph">
<p>请注意,某些运算符不太适合处理需要清除的对象. 例如,<code>bufferWhen</code> 可以引入重叠的缓冲区,这意味着我们之前使用的废弃  &#8220;local hook&#8221;  可能会看到第一个缓冲区被废弃,并清理其中的一个元素,该元素在第二个缓冲区中仍然有效.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
为了达到清理的目的,所有这些 hook 一定要正确使用. 在某些情况下,它们可能多次应用于同一对象. 与 <code>doOnDiscard</code> 运算符执行类级 <code>instanceOf</code> 检查不同,全局挂钩也处理可以是任何 <code>Object</code> 的实例. 由用户来区分哪些实例需要清除,哪些不需要.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="doondiscard-操作符或本地-hook"><a class="anchor" href="#doondiscard-操作符或本地-hook"></a>11.9.1. <code>doOnDiscard</code> 操作符或本地 Hook</h4>
<div class="paragraph">
<p><code>doOnDiscard</code> hook 专门用于清理对象,否则这些对象将永远不会暴露给用户代码. 它的作用是清理正常运行的流的对象(不是异常的源,它推送了太多元素,而 <code>onNextDropped</code> 对此对象进行了覆盖).</p>
</div>
<div class="paragraph">
<p>它是本地的,从某种意义上说,它是通过操作符激活的,并且仅适用于给定的 <code>Flux</code> 或 <code>Mono</code>.</p>
</div>
<div class="paragraph">
<p>一个很明显的情况就是从上游过滤元素的运算符.这些元素永远不会到达下一个运算符(或最终订阅者),但这是正常执行路径的一部分. 这样,它们将传递到 <code>doOnDiscard</code> 挂钩. 何时使用 <code>doOnDiscard</code> 挂钩的示例有以下几种情况:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>filter</code>: 与过滤器不匹配的元素被视为 "已丢弃".</p>
</li>
<li>
<p><code>skip</code>: 跳过的元素将被丢弃..</p>
</li>
<li>
<p>在 <code>buffer(maxSize, skip)</code> 中当 <code>maxSize &lt; skip</code>: &#8220;dropping buffer&#8221;&#8201;&#8212;&#8201;在 buffer 之内的元素被丢弃.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是 <code>doOnDiscard</code> 不仅仅可以使用过滤运算符,还可以在内部出于背压目的而在内部排队数据的运算符使用. 更具体地说,在大多数情况下,这在取消期间很重要.
从其源中预取数据,然后根据需要排到其订阅者的生产者在取消数据时可能会收到未发射的数据. 此类操作员在取消过程中使用 <code>doOnDiscard</code> hook 清除其内部背压 <code>Queue</code>.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
每次对  <code>doOnDiscard(Class, Consumer)</code>  的调用都会与其他调用相加,只能由其上游的操作符看到和使用.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="onoperatorerror-hook"><a class="anchor" href="#onoperatorerror-hook"></a>11.9.2. <code>onOperatorError</code> hook</h4>
<div class="paragraph">
<p><code>onOperatorError</code> hook 以横向方式修改错误(类似于 AOP 的捕捉和重新抛出).</p>
</div>
<div class="paragraph">
<p>当在处理 <code>onNext</code> 信号期间发生错误时,正在发出的元素将传递给 <code>onOperatorError</code>.</p>
</div>
<div class="paragraph">
<p>如果需要清除该类型的元素,则需要在 <code>onOperatorError</code> hook 中实现它,可能在重写错误代码的顶部.</p>
</div>
</div>
<div class="sect3">
<h4 id="onnextdropped-hook"><a class="anchor" href="#onnextdropped-hook"></a>11.9.3. <code>onNextDropped</code> Hook</h4>
<div class="paragraph">
<p>对于异常的 <code>Publishers</code>,在某些情况下,操作符可能会在元素预期没有元素时收到该元素(通常是在收到 <code>onError</code> 或 <code>onComplete</code> 信号之后).
在这种情况下,意外元素将被 "丢弃",即传递给 <code>onNextDropped</code> hook. 如果您有需要清除的类型,则必须在 <code>onNextDropped</code> hook 中检测到它们,并在其中也执行清除代码.</p>
</div>
</div>
<div class="sect3">
<h4 id="operator-specific-handlers"><a class="anchor" href="#operator-specific-handlers"></a>11.9.4. Operator-specific Handlers</h4>
<div class="paragraph">
<p>一些处理缓冲区或在其操作中收集值的运算符具有特定的处理程序,以处理所收集的数据不向下游传播的情况. 如果将此类运算符与需要清除的类型一起使用,则需要在这些处理程序中执行清除.</p>
</div>
<div class="paragraph">
<p>例如,<code>distinct</code> 具有这样的回调,当操作符终止(或取消)时,该回调将被调用,以清除用于判断元素是否不同的集合. 默认情况下,该集合是 <code>HashSet</code>,而清理回调是 <code>HashSet::clear</code>.
但是,如果要处理引用计数的对象,则可能需要将其更改为涉及更多的处理程序,该处理程序在调用 <code>clear()</code> 之前会 <code>release</code> 集合中的每个元素.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="null-safety"><a class="anchor" href="#null-safety"></a>11.10. 空值安全</h3>
<div class="paragraph">
<p>虽然 Java 的类型系统没有表达空值安全(null-safety)的机制,但是 Reactor 现在提供了基于注解的用于声明 “可能为空(nullability)”的 API,类似于 Spring Framework 5 中提供的 API.</p>
</div>
<div class="paragraph">
<p>Reactor 自身就用到了这些注解,你也可以将其用于任何基于 Reactor 的自己的空值安全的 Java API 中. 不过,在 方法体内部 对“可能为空”的类型的使用就不在这一特性的范围内了.</p>
</div>
<div class="paragraph">
<p>这些注解是基于 <a href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a> 的注解(是受类似 IntelliJ IDEA 这样的工具支持的 JSR)作为元注解(meta-annotated)的.当 Java 开发者在编写空值安全的代码时, 它们能够提供有用的警告信息,以便避免在运行时(runtime)出现 <code>NullPointerException</code> 异常. JSR 305 元注解使得工具提供商可以以一种通用的方式提供对空值安全的支持,从而 Reactor 的注解就不用重复造轮子了.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
对于 Kotlin 1.1.5+,需要(同时也推荐)在项目 classpath 中添加对 JSR 305 的依赖.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>它们也可在 Kotlin 中使用,Kotlin 原生支持 <a href="https://kotlinlang.org/docs/reference/null-safety.html">null safety</a>.具体请参考 <a href="#kotlin-null-safety">this dedicated section</a> .</p>
</div>
<div class="paragraph">
<p><code>reactor.util.annotation</code> 包提供以下注解:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/NonNull.html"><code>@NonNull</code></a>: 表明一个具体的参数、返回值或域值不能为 <code>null</code>. (如果参数或返回值应用了 <code>@NonNullApi</code> 则无需再加它).</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/Nullable.html"><code>@Nullable</code></a>: 表明一个参数、返回值或域值可以为 <code>null</code>.</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/util/annotation/NonNullApi.html"><code>@NonNullApi</code></a>: 是一个包级别的注解,表明默认情况下参数或返回值不能为 <code>null</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
(Reactor 的空值安全的注解)对于通用类型参数(generic type arguments)、可变参数(varargs),以及数组元素(array elements) 尚不支持.参考 <a href="https://github.com/reactor/reactor-core/issues/878">issue #878</a> 查看最新信息.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/advancedFeatures.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#advanced">高级特性与概念</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="which-operator"><a class="anchor" href="#which-operator"></a>Appendix A: 我需要哪个操作符?</h2>
<div class="sectionbody">
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
在这一节,如果一个操作符是专属于 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> 或 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a> 的,那么会给它注明前缀, 例如 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromArray-T:A-">Flux#fromArray</a>. 公共的操作符没有前缀，并提供了两种实现的链接，例如：<code>just</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-">Mono</a>).如果一个具体的用例涉及多个操作符的组合,这里以方法调用的方式展现, 会以一个点(<code>.</code>)开头,并将参数置于圆括号内,
比如:  <code>.methodCall(parameter)</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>我想搞定:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#which.create">创建一个新序列,它&#8230;&#8203;</a></p>
</li>
<li>
<p><a href="#which.values">对序列进行转化</a></p>
</li>
<li>
<p><a href="#which.filtering">过滤序列</a></p>
</li>
<li>
<p><a href="#which.peeking">"窥视"(只读)序列</a></p>
</li>
<li>
<p><a href="#which.errors">错误处理</a></p>
</li>
<li>
<p><a href="#which.time">基于时间的操作</a></p>
</li>
<li>
<p><a href="#which.window">拆分 Flux</a></p>
</li>
<li>
<p><a href="#which.blocking">回到同步的世界</a></p>
</li>
<li>
<p><a href="#which.multicasting">将 Flux 传播给多个 to several Subscribers</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="which.create"><a class="anchor" href="#which.create"></a>A.1. 创建一个新序列,它&#8230;&#8203;</h3>
<div class="ulist">
<ul>
<li>
<p>发出一个 <code>T</code>,我已经有了:: <code>just</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>基于一个 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">Optional&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#justOrEmpty-java.util.Optional-">Mono#justOrEmpty(Optional&lt;T&gt;)</a></p>
</li>
<li>
<p>&#8230;&#8203;基于一个可能为 <code>null</code> 的 <code>T</code>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#justOrEmpty-T-">Mono#justOrEmpty(T)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>发出一个 <code>T</code>,且还是由: <code>just</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-">Mono</a>) 方法返回</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;但是 "延迟" 创建的: 使用 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromSupplier-java.util.function.Supplier-">Mono#fromSupplier</a> 或用 <code>defer</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defer-java.util.function.Supplier-">Mono</a>) 包装 <code>just</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#just-T-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>发出许多 <code>T</code>,这些元素我可以明确列举出来:: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#just-T%2E%2E%2E-">Flux#just(T&#8230;&#8203;)</a></p>
</li>
<li>
<p>基于迭代数据结构:</p>
<div class="ulist">
<ul>
<li>
<p>一个数组: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromArray-T:A-">Flux#fromArray</a></p>
</li>
<li>
<p>一个集合或 iterable: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromIterable-java.lang.Iterable-">Flux#fromIterable</a></p>
</li>
<li>
<p>一个 Integer 的 range: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#range-int-int-">Flux#range</a></p>
</li>
<li>
<p>一个 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream</a> 提供给每一个订阅: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#fromStream-java.util.function.Supplier-">Flux#fromStream(Supplier&lt;Stream&gt;)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>基于一个参数值给出的源:</p>
<div class="ulist">
<ul>
<li>
<p>一个 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html">Supplier&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromSupplier-java.util.function.Supplier-">Mono#fromSupplier</a></p>
</li>
<li>
<p>一个任务: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromCallable-java.util.concurrent.Callable-">Mono#fromCallable</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromRunnable-java.lang.Runnable-">Mono#fromRunnable</a></p>
</li>
<li>
<p>一个 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#fromFuture-java.util.concurrent.CompletableFuture-">Mono#fromFuture</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>直接完成: <code>empty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#empty--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#empty--">Mono</a>)</p>
</li>
<li>
<p>立即生成错误: <code>error</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;但是 "懒" 的方式生成 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html">Throwable</a>: <code>error(Supplier&lt;Throwable&gt;)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.util.function.Supplier-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.util.function.Supplier-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>什么都不做: <code>never</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#never--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#never--">Mono</a>)</p>
</li>
<li>
<p>订阅时才决定: <code>defer</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defer-java.util.function.Supplier-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defer-java.util.function.Supplier-">Mono</a>)</p>
</li>
<li>
<p>依赖一个可回收的资源: <code>using</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>可编程地生成事件(可以使用状态):</p>
<div class="ulist">
<ul>
<li>
<p>同步且逐个的: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#generate-java.util.concurrent.Callable-java.util.function.BiFunction-">Flux#generate</a></p>
</li>
<li>
<p>异步(也可同步)的,每次尽可能多发出元素: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#create-java.util.function.Consumer-">Flux#create</a>
(<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#create-java.util.function.Consumer-">Mono#create</a> 也是异步的,只不过只能发一个)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.values"><a class="anchor" href="#which.values"></a>A.2. 对序列进行转化</h3>
<div class="ulist">
<ul>
<li>
<p>我想转化一个序列:</p>
<div class="ulist">
<ul>
<li>
<p>1 对 1 地转化(比如字符串转化为它的长度): <code>map</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#map-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#map-java.util.function.Function-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;类型转化: <code>cast</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cast-java.lang.Class-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#cast-java.lang.Class-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;为了获得每个元素的序号: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#index--">Flux#index</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>1 对 n 地转化(如字符串转化为一串字符): <code>flatMap</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-">Mono</a>) + use a factory method</p>
</li>
<li>
<p>1 对 n 地转化可自定义转化方法和/或状态: <code>handle</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#handle-java.util.function.BiConsumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#handle-java.util.function.BiConsumer-">Mono</a>)</p>
</li>
<li>
<p>对每一个元素执行一个异步操作(如对 url 执行 http 请求): <code>flatMap</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMap-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMap-java.util.function.Function-">Mono</a>) + an async <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true">Publisher</a>-returning method</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;忽略一些数据: 在 flatMap lambda 中根据条件返回一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#empty--">Mono.empty()</a>.</p>
</li>
<li>
<p>&#8230;&#8203;保留原来的序列顺序: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#flatMapSequential-java.util.function.Function-">Flux#flatMapSequential</a> (对每个元素的异步任务会立即执行,但会将结果按照原序列顺序排序)</p>
</li>
<li>
<p>&#8230;&#8203;当 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a> 元素的异步任务会返回多个元素的序列时: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#flatMapMany-java.util.function.Function-">Mono#flatMapMany</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想添加一些数据元素到一个现有的序列:</p>
<div class="ulist">
<ul>
<li>
<p>在开头添加: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#startWith-T%2E%2E%2E-">Flux#startWith(T&#8230;&#8203;)</a></p>
</li>
<li>
<p>在最后添加: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatWithValues-T%2E%2E%2E-">Flux#concatWithValues(T&#8230;&#8203;)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想将 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> 转化为集合(以下都是针对 <code>Flux#</code> 的):</p>
<div class="ulist">
<ul>
<li>
<p>转化为 List: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectList--">collectList</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectSortedList--">collectSortedList</a></p>
</li>
<li>
<p>转化为 Map: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMap-java.util.function.Function-">collectMap</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collectMultimap-java.util.function.Function-">collectMultiMap</a></p>
</li>
<li>
<p>转化为任意容器: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#collect-java.util.stream.Collector-">collect</a></p>
</li>
<li>
<p>计数: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#count--">count</a></p>
</li>
<li>
<p>reduce 算法(将上个元素的reduce结果与当前元素值作为输入执行 reduce 方法,如 sum): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#reduce-A-java.util.function.BiFunction-">reduce</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;将每次 的结果立即发出: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#scan-A-java.util.function.BiFunction-">scan</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>转化为一个 boolean 值:</p>
<div class="ulist">
<ul>
<li>
<p>对所有元素判断都为 true (AND): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#all-java.util.function.Predicate-">all</a></p>
</li>
<li>
<p>对至少一个元素判断为 true (OR): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#any-java.util.function.Predicate-">any</a></p>
</li>
<li>
<p>判断序列是否有元素(不为空): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElements--">hasElements</a> <em>(there is a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a> equivalent in <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#hasElement--">hasElement</a>)</em></p>
</li>
<li>
<p>判断序列中是否有匹配的元素: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#hasElement-T-">hasElement(T)</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想合并 publishers&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>按序连接: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concat-org.reactivestreams.Publisher%2E%2E%2E-">Flux#concat</a> or <code>.concatWith(other)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatWith-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#concatWith-org.reactivestreams.Publisher-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;即使有错误,也会等所有的  publishers 连接完成: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#concatDelayError-org.reactivestreams.Publisher-">Flux#concatDelayError</a></p>
</li>
<li>
<p>&#8230;&#8203;按订阅顺序连接(这里的合并仍然可以理解成序列的连接): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeSequential-int-org.reactivestreams.Publisher%2E%2E%2E-">Flux#mergeSequential</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>按元素发出的顺序合并(无论哪个序列的,元素先到先合并): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#merge-int-org.reactivestreams.Publisher%2E%2E%2E-">Flux#merge</a> / <code>.mergeWith(other)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#mergeWith-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#mergeWith-org.reactivestreams.Publisher-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;元素类型会发生变化: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher%2E%2E%2E-">Flux#zip</a> / <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zipWith-org.reactivestreams.Publisher-">Flux#zipWith</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>将元素组合:</p>
<div class="ulist">
<ul>
<li>
<p>2 个 Monos 组成 1 个 <a href="https://projectreactor.io/docs/core/release/api/reactor/util/function/Tuple2.html">Tuple2</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zipWith-reactor.core.publisher.Mono-">Mono#zipWith</a></p>
</li>
<li>
<p>n 个 Monos 的元素都发出来后组成一个 Tuple: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#zip-java.util.function.Function-reactor.core.publisher.Mono%2E%2E%2E-">Mono#zip</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>在终止信号出现时 "采取行动":</p>
<div class="ulist">
<ul>
<li>
<p>在 Mono 终止时转换为一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono&lt;Void&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#and-org.reactivestreams.Publisher-">Mono#and</a></p>
</li>
<li>
<p>当 n 个 Mono 都终止时返回: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#when-java.lang.Iterable-">Mono#when</a></p>
</li>
<li>
<p>在任意容器类型中:</p>
<div class="ulist">
<ul>
<li>
<p>每个序列都发出一个元素时: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#zip-java.util.function.Function-org.reactivestreams.Publisher%2E%2E%2E-">Flux#zip</a> (up to the smallest cardinality)</p>
</li>
<li>
<p>任何一个序列发出元素时: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#combineLatest-java.util.function.Function-int-org.reactivestreams.Publisher%2E%2E%2E-">Flux#combineLatest</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>只取各个序列的第一个元素&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>produces a <em>value</em> (<code>onNext</code>): <code>firstWithValue</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#firstWithValue-java.lang.Iterable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#firstWithValue-java.lang.Iterable-">Mono</a>)</p>
</li>
<li>
<p>produces <em>any signal</em>: <code>firstWithSignal</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#firstWithSignal-java.lang.Iterable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#firstWithSignal-java.lang.Iterable-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>由一个序列触发(类似于 flatMap,不过 "喜新厌旧"): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchMap-java.util.function.Function-">switchMap</a> (each source element is mapped to a Publisher)</p>
</li>
<li>
<p>由每个新序列开始时触发(也是 "喜新厌旧" 风格): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchOnNext-org.reactivestreams.Publisher-">switchOnNext</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想重复一个序列: <code>repeat</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#repeat--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#repeat--">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;但是以一定的间隔重复: <code>Flux.interval(duration).flatMap(tick &#8594; myExistingPublisher)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个空序列,但是&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>我想要一个默认值来代替: <code>defaultIfEmpty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#defaultIfEmpty-T-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#defaultIfEmpty-T-">Mono</a>)</p>
</li>
<li>
<p>我想要一个默认值的序列来代替: <code>switchIfEmpty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#switchIfEmpty-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#switchIfEmpty-reactor.core.publisher.Mono-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个序列,但是我对序列的元素值不感兴趣: <code>ignoreElements</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--">Flux.ignoreElements()</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--">Mono.ignoreElement()</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;并且我希望用 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono&lt;Void&gt;</a> 来表示序列已经结束: <code>then</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#then--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then--">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;并且我想在序列结束后等待另一个任务完成: <code>thenEmpty</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenEmpty-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenEmpty-org.reactivestreams.Publisher-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;并且我想在序列结束之后返回一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#then-reactor.core.publisher.Mono-">Mono#then(mono)</a></p>
</li>
<li>
<p>&#8230;&#8203;并且我想在序列结束之后返回一个值: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenReturn-V-">Mono#thenReturn(T)</a></p>
</li>
<li>
<p>&#8230;&#8203;并且我想在序列结束之后返回一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a>: <code>thenMany</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#thenMany-org.reactivestreams.Publisher-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#thenMany-org.reactivestreams.Publisher-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个 Mono 但我想延迟完成&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;使用一个函数式来定义如何获取其他 publisher: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayUntil-java.util.function.Function-">Mono#delayUntil(Function)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想基于一个递归的生成序列的规则扩展每一个元素, 然后合并为一个序列发出&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;广度优先: <code>expand(Function)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expand-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expand-java.util.function.Function-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;深度优先: <code>expandDeep(Function)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#expandDeep-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#expandDeep-java.util.function.Function-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.peeking"><a class="anchor" href="#which.peeking"></a>A.3. "窥视"(只读)序列</h3>
<div class="ulist">
<ul>
<li>
<p>在不对序列造成改变的情况下,我想:</p>
<div class="ulist">
<ul>
<li>
<p>得到通知或执行一些操作:</p>
<div class="ulist">
<ul>
<li>
<p>发出元素: <code>doOnNext</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnNext-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnNext-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>序列完成: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnComplete-java.lang.Runnable-">Flux#doOnComplete</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSuccess-java.util.function.Consumer-">Mono#doOnSuccess</a> (includes the result, if any)</p>
</li>
<li>
<p>因错误终止: <code>doOnError</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnError-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnError-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>取消: <code>doOnCancel</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnCancel-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnCancel-java.lang.Runnable-">Mono</a>)</p>
</li>
<li>
<p>"start": <code>doFirst</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFirst-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFirst-java.lang.Runnable-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>this is tied to <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true#subscribe(org.reactivestreams.Subscriber)">Publisher#subscribe(Subscriber)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>post-subscription : <code>doOnSubscribe</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnSubscribe-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnSubscribe-java.util.function.Consumer-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p><code>Subscription</code> acknowledgment after <code>subscribe</code></p>
</li>
<li>
<p>this is tied to <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true#onSubscribe(org.reactivestreams.Subscription)">Subscriber#onSubscribe(Subscription)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>请求时: <code>doOnRequest</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnRequest-java.util.function.LongConsumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnRequest-java.util.function.LongConsumer-">Mono</a>)</p>
</li>
<li>
<p>完成或错误终止: <code>doOnTerminate</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnTerminate-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnTerminate-java.lang.Runnable-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>但是在终止信号向下游传递 之后: <code>doAfterTerminate</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doAfterTerminate-java.lang.Runnable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doAfterTerminate-java.lang.Runnable-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>所有类型的信号 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Signal.html">Signal</a>: <code>doOnEach</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>所有结束的情况 (complete, error, cancel): <code>doFinally</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>记录日志: <code>log</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#log--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#log--">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>我想知道所有的事件:</p>
<div class="ulist">
<ul>
<li>
<p>每一个事件都体现为一个  <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Signal.html">Signal</a> 对象:</p>
<div class="ulist">
<ul>
<li>
<p>执行 callback: <code>doOnEach</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doOnEach-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doOnEach-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>每个元素转化为: <code>materialize</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#materialize--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#materialize--">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;在转化回元素: <code>dematerialize</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#dematerialize--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#dematerialize--">Mono</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>转化为一行日志: <code>log</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#log--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#log--">Mono</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.filtering"><a class="anchor" href="#which.filtering"></a>A.4. 过滤序列</h3>
<div class="ulist">
<ul>
<li>
<p>我想过滤一个序列:</p>
<div class="ulist">
<ul>
<li>
<p>基于给定的判断条件: <code>filter</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filter-java.util.function.Predicate-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filter-java.util.function.Predicate-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;异步地进行判断: <code>filterWhen</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#filterWhen-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#filterWhen-java.util.function.Function-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>仅限于指定类型的对象: <code>ofType</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ofType-java.lang.Class-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ofType-java.lang.Class-">Mono</a>)</p>
</li>
<li>
<p>忽略所有元素: <code>ignoreElements</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#ignoreElements--">Flux.ignoreElements()</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#ignoreElement--">Mono.ignoreElement()</a>)</p>
</li>
<li>
<p>去重:</p>
<div class="ulist">
<ul>
<li>
<p>对于整个序列: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinct--">Flux#distinct</a></p>
</li>
<li>
<p>去掉连续重复的元素: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#distinctUntilChanged--">Flux#distinctUntilChanged</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我只想要一部分序列:</p>
<div class="ulist">
<ul>
<li>
<p>只要 N 个元素:</p>
<div class="ulist">
<ul>
<li>
<p>从序列的第一个元素开始算: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-boolean-">Flux#take(long, true)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;取一段时间内发出的元素: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-long-boolean-">Flux#take(long, false)</a></p>
</li>
<li>
<p>&#8230;&#8203;based on a duration: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#take-java.time.Duration-">Flux#take(Duration)</a></p>
</li>
<li>
<p>&#8230;&#8203;只取第一个元素放到 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#next--">Flux#next()</a></p>
</li>
<li>
<p>&#8230;&#8203;使用 <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscription.html#request(long)">request(N)</a> 而不是 cancellation: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#limitRequest-long-">Flux#limitRequest(long)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>从序列的最后一个元素倒数: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-">Flux#takeLast</a></p>
</li>
<li>
<p>直到满足某个条件 (inclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntil-java.util.function.Predicate-">Flux#takeUntil</a> (predicate-based), <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeUntilOther-org.reactivestreams.Publisher-">Flux#takeUntilOther</a> (companion publisher-based)</p>
</li>
<li>
<p>直到满足某个条件 (exclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeWhile-java.util.function.Predicate-">Flux#takeWhile</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>最多只取 1 个元素:</p>
<div class="ulist">
<ul>
<li>
<p>给定序号: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elementAt-int-">Flux#elementAt</a></p>
</li>
<li>
<p>最后一个: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#takeLast-int-">.takeLast(1)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;如果为序列空则发出错误信号: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last--">Flux#last()</a></p>
</li>
<li>
<p>&#8230;&#8203;如果序列为空则返回默认值: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#last-T-">Flux#last(T)</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>跳过一些元素:</p>
<div class="ulist">
<ul>
<li>
<p>从序列的第一个元素开始跳过: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-long-">Flux#skip(long)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;跳过一段时间内发出的元素: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skip-java.time.Duration-">Flux#skip(Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>跳过最后的 n 个元素: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipLast-int-">Flux#skipLast</a></p>
</li>
<li>
<p>直到满足某个条件 (inclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntil-java.util.function.Predicate-">Flux#skipUntil</a> (predicate-based), <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipUntilOther-org.reactivestreams.Publisher-">Flux#skipUntilOther</a> (companion publisher-based)</p>
</li>
<li>
<p>直到满足某个条件 (exclusive): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#skipWhile-java.util.function.Predicate-">Flux#skipWhile</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>采样:</p>
<div class="ulist">
<ul>
<li>
<p>给定采样周期: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-java.time.Duration-">Flux#sample(Duration)</a></p>
<div class="ulist">
<ul>
<li>
<p>取采样周期里的第一个元素而不是最后一个: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleFirst-java.time.Duration-">sampleFirst</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>by a publisher-based window: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sample-org.reactivestreams.Publisher-">Flux#sample(Publisher)</a></p>
</li>
<li>
<p>based on a publisher "timing out": <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#sampleTimeout-java.util.function.Function-">Flux#sampleTimeout</a> (每一个元素会触发一个 publisher, 如果这个 publisher 不被下一个元素触发的 publisher 覆盖就发出这个元素)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我只想要一个元素(如果多于一个就返回错误)&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>如果序列为空,发出错误信号: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single--">Flux#single()</a></p>
</li>
<li>
<p>如果序列为空,发出一个默认值: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#single-T-">Flux#single(T)</a></p>
</li>
<li>
<p>如果序列为空就返回一个空序列: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#singleOrEmpty--">Flux#singleOrEmpty</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.errors"><a class="anchor" href="#which.errors"></a>A.5. 错误处理</h3>
<div class="ulist">
<ul>
<li>
<p>我想创建一个错误序列: <code>error</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-">Mono</a>)&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;替换一个完成的 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a>: <code>.concat(Flux.error(e))</code></p>
</li>
<li>
<p>&#8230;&#8203;替换一个完成的 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>: <code>.then(Mono.error(e))</code></p>
</li>
<li>
<p>&#8230;&#8203;如果元素超时未发出: <code>timeout</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;lazily: <code>error(Supplier&lt;Throwable&gt;)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.util.function.Supplier-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.util.function.Supplier-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>我想要类似 try/catch 的表达方式:</p>
<div class="ulist">
<ul>
<li>
<p>抛出异常: <code>error</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#error-java.lang.Throwable-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#error-java.lang.Throwable-">Mono</a>)</p>
</li>
<li>
<p>捕获异常:</p>
<div class="ulist">
<ul>
<li>
<p>然后返回默认值: <code>onErrorReturn</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-">Mono</a>)</p>
</li>
<li>
<p>然后返回一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> 或 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>: <code>onErrorResume</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-">Mono</a>)</p>
</li>
<li>
<p>包装异常后再抛出: <code>.onErrorMap(t &#8594; new RuntimeException(t))</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorMap-java.util.function.Function-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorMap-java.util.function.Function-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
<li>
<p>finally 代码块: <code>doFinally</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#doFinally-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#doFinally-java.util.function.Consumer-">Mono</a>)</p>
</li>
<li>
<p>Java 7 之后的 try-with-resources 写法: <code>using</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#using-java.util.concurrent.Callable-java.util.function.Function-java.util.function.Consumer-">Mono</a>) factory method</p>
</li>
</ul>
</div>
</li>
<li>
<p>我想从错误中恢复&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>返回一个默认的:</p>
<div class="ulist">
<ul>
<li>
<p>的值: <code>onErrorReturn</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorReturn-java.lang.Class-T-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorReturn-java.lang.Class-T-">Mono</a>)</p>
</li>
<li>
<p>to a <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true">Publisher</a> or <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>, possibly different ones depending on the error: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onErrorResume-java.lang.Class-java.util.function.Function-">Flux#onErrorResume</a> and <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#onErrorResume-java.lang.Class-java.util.function.Function-">Mono#onErrorResume</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>重试&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with a simple policy (max number of attempts): <code>retry()</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry--">Mono</a>), <code>retry(long)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retry-long-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retry-long-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;由一个用于伴随 Flux 触发: <code>retryWhen</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-">Mono</a>)</p>
</li>
<li>
<p>&#8230;&#8203;using a standard backoff strategy (exponential backoff with jitter): <code>retryWhen(Retry.backoff(&#8230;&#8203;))</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#retryWhen-reactor.util.retry.Retry-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#retryWhen-reactor.util.retry.Retry-">Mono</a>) (see also other factory methods in <a href="https://projectreactor.io/docs/core/release/api/reactor/util/retry/Retry.html">Retry</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想处理回压错误(向上游发出"MAX”的 request,如果下游的 request 比较少,则应用策略)&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>抛出 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/IllegalStateException.html?is-external=true">IllegalStateException</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureError--">Flux#onBackpressureError</a></p>
</li>
<li>
<p>丢弃策略: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureDrop--">Flux#onBackpressureDrop</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;但是不丢弃最后一个元素: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureLatest--">Flux#onBackpressureLatest</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>缓存策略(有限或无限): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer--">Flux#onBackpressureBuffer</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;当有限的缓存空间用满则应用给定策略: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#onBackpressureBuffer-int-reactor.core.publisher.BufferOverflowStrategy-">Flux#onBackpressureBuffer</a> 带有策略 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/BufferOverflowStrategy.html">BufferOverflowStrategy</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.time"><a class="anchor" href="#which.time"></a>A.6. 基于时间的操作</h3>
<div class="ulist">
<ul>
<li>
<p>I want to associate emissions with a timing measured&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;with best available precision and versatility of provided data: <code>timed</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timed--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timed--">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsed--">Timed&lt;T&gt;#elapsed()</a> for <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true">Duration</a> since last <code>onNext</code></p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#timestamp--">Timed&lt;T&gt;#timestamp()</a> for <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Instant.html?is-external=true">Instant</a> representation of the epoch timestamp (milliseconds resolution)</p>
</li>
<li>
<p><a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Timed.html#elapsedSinceSubscription--">Timed&lt;T&gt;#elapsedSinceSubcription()</a> for <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true">Duration</a> since subscription (rather than last onNext)</p>
</li>
<li>
<p>can have nanoseconds resolution for elapsed <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true">Duration</a>s</p>
</li>
</ul>
</div>
</li>
<li>
<p>&#8230;&#8203;as a (legacy) <a href="https://projectreactor.io/docs/core/release/api/reactor/util/function/Tuple2.html">Tuple2&lt;Long, T&gt;</a>&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>since last onNext: <code>elapsed</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#elapsed--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#elapsed--">Mono</a>)</p>
</li>
<li>
<p>since the dawn of time (well, computer time): <code>timestamp</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timestamp--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timestamp--">Mono</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>I want my sequence to be interrupted if there is too much delay between emissions: <code>timeout</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#timeout-java.time.Duration-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#timeout-java.time.Duration-">Mono</a>)</p>
</li>
<li>
<p>I want to get ticks from a clock, regular time intervals: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#interval-java.time.Duration-">Flux#interval</a></p>
</li>
<li>
<p>I want to emit a single <code>0</code> after an initial delay: static <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delay-java.time.Duration-">Mono.delay</a>.</p>
</li>
<li>
<p>I want to introduce a delay:</p>
<div class="ulist">
<ul>
<li>
<p>between each onNext signal: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delayElement-java.time.Duration-">Mono#delayElement</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delayElements-java.time.Duration-">Flux#delayElements</a></p>
</li>
<li>
<p>before the subscription happens: <code>delaySubscription</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#delaySubscription-java.time.Duration-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#delaySubscription-java.time.Duration-">Mono</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.window"><a class="anchor" href="#which.window"></a>A.7. 拆分 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a></h3>
<div class="ulist">
<ul>
<li>
<p>我想将一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux&lt;T&gt;</a> 拆分为一个 <code>Flux&lt;Flux&lt;T&gt;&gt;</code>:</p>
<div class="ulist">
<ul>
<li>
<p>以个数为界: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-">window(int)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;会出现重叠或丢弃的情况: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-int-int-">window(int, int)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>以时间为界: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-java.time.Duration-">window(Duration)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;会出现重叠或丢弃的情况: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-java.time.Duration-java.time.Duration-">window(Duration, Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>以个数或时间为界: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowTimeout-int-java.time.Duration-">windowTimeout(int, Duration)</a></p>
</li>
<li>
<p>基于对元素的判断条件: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-">windowUntil</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;…触发判断条件的元素会分到下一波 (<code>cutBefore</code> variant): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowUntil-java.util.function.Predicate-boolean-">.windowUntil(predicate, true)</a></p>
</li>
<li>
<p>&#8230;&#8203;满足条件的元素在一波,直到不满足条件的元素发出开始下一波: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhile-java.util.function.Predicate-">windowWhile</a> (non-matching elements are not emitted)</p>
</li>
</ul>
</div>
</li>
<li>
<p>通过另一个 Publisher 的每一个 onNext 信号来拆分序列: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#window-org.reactivestreams.Publisher-">window(Publisher)</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#windowWhen-org.reactivestreams.Publisher-java.util.function.Function-">windowWhen</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想将一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux&lt;T&gt;</a> 的元素拆分到集合&#8230;&#8203;</p>
<div class="ulist">
<ul>
<li>
<p>拆分为一个一个的 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html?is-external=true">List</a>:</p>
<div class="ulist">
<ul>
<li>
<p>以个数为界: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-">buffer(int)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;会出现重叠或丢弃的情况: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-int-">buffer(int, int)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>以时间为界: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-">buffer(Duration)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;会出现重叠或丢弃的情况: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-java.time.Duration-java.time.Duration-">buffer(Duration, Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>以个数或时间为界: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferTimeout-int-java.time.Duration-">bufferTimeout(int, Duration)</a></p>
</li>
<li>
<p>基于对元素的判断条件: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-">bufferUntil(Predicate)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;触发判断条件的元素会分到下一个 buffer: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferUntil-java.util.function.Predicate-boolean-">.bufferUntil(predicate, true)</a></p>
</li>
<li>
<p>&#8230;&#8203;满足条件的元素在一个 buffer,直到不满足条件的元素发出开始下一 buffer: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferWhile-java.util.function.Predicate-">bufferWhile(Predicate)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>通过另一个 Publisher 的每一个 onNext 信号来拆分序列: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-org.reactivestreams.Publisher-">buffer(Publisher)</a>, <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#bufferWhen-org.reactivestreams.Publisher-java.util.function.Function-">bufferWhen</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>into an arbitrary "collection" type <code>C</code>: use variants like <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#buffer-int-java.util.function.Supplier-">buffer(int, Supplier&lt;C&gt;)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>我想将 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux&lt;T&gt;</a> 中具有共同特征的元素分组到子 Flux: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#groupBy-java.util.function.Function-">groupBy(Function&lt;T,K&gt;)</a>
TIP: 注意返回值是 <code>Flux&lt;GroupedFlux&lt;K, T&gt;&gt;</code>, 每一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/GroupedFlux.html">GroupedFlux</a> 具有相同的 key 值 <code>K</code> ,可以通过  <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/GroupedFlux.html#key--">key()</a> 方法获取.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.blocking"><a class="anchor" href="#which.blocking"></a>A.8. 回到同步的世界</h3>
<div class="paragraph">
<p>注意:所有这些方法除了 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--">Mono#toFuture</a> 将抛出 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/UnsupportedOperationException.html?is-external=true">UnsupportedOperatorException</a>，如果从标记为“非阻塞”(默认情况下 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#parallel--">parallel()</a> 和 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Schedulers.html#single--">single()</a> )的 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/scheduler/Scheduler.html">Scheduler</a> 内调用.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>我有一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux&lt;T&gt;</a> ,我想:</p>
<div class="ulist">
<ul>
<li>
<p>在拿到第一个元素前阻塞: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst--">Flux#blockFirst</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;并给出超时时限: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockFirst-java.time.Duration-">Flux#blockFirst(Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>在拿到最后一个元素前阻塞(如果序列为空则返回 null): <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast--">Flux#blockLast</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;并给出超时时限: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#blockLast-java.time.Duration-">Flux#blockLast(Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>同步地转换为 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html?is-external=true">Iterable&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toIterable--">Flux#toIterable</a></p>
</li>
<li>
<p>同步地转换为 Java 8 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#toStream--">Flux#toStream</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>我有一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono&lt;T&gt;</a> ,我想:</p>
<div class="ulist">
<ul>
<li>
<p>在拿到元素前阻塞: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block--">Mono#block</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;并给出超时时限: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#block-java.time.Duration-">Mono#block(Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>转换为 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html">CompletableFuture&lt;T&gt;</a>: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#toFuture--">Mono#toFuture</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="which.multicasting"><a class="anchor" href="#which.multicasting"></a>A.9. 将 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> 传播给多个 to several <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true">Subscribers</a></h3>
<div class="ulist">
<ul>
<li>
<p>我想将多个 <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Subscriber.html?is-external=true">Subscriber</a> 连接到一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a>:</p>
<div class="ulist">
<ul>
<li>
<p>并决定何时使用 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#connect--">connect()</a> 触发: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#publish--">publish()</a> (returns a <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html">ConnectableFlux</a>)</p>
</li>
<li>
<p>立即触发 (之后的 subscribers 只能看到之后的数据): <code>share()</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#share--">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#share--">Mono</a>)</p>
</li>
<li>
<p>注册足够的订阅者后建立永久连接: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#autoConnect-int-">.publish().autoConnect(n)</a></p>
</li>
<li>
<p>当订阅者低于或高于一定的阀值后自动连接或取消: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-">.publish().refCount(n)</a></p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;但在取消之前让新订阅者有机会进来: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html#refCount-int-java.time.Duration-">.publish().refCount(n, Duration)</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>我想缓存来自 <a href="https://www.reactive-streams.org/reactive-streams-1.0.3-javadoc/org/reactivestreams/Publisher.html?is-external=true">Publisher</a> 的数据并将其重播给以后的 subscribers:</p>
<div class="ulist">
<ul>
<li>
<p>最多 <code>n</code> 个元素: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-">cache(int)</a></p>
</li>
<li>
<p>缓存在 <a href="https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html?is-external=true">Duration</a> (Time-To-Live)内看到的最新元素 : <code>cache(Duration)</code> (<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-java.time.Duration-">Flux</a>|<a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html#cache-java.time.Duration-">Mono</a>)</p>
<div class="ulist">
<ul>
<li>
<p>&#8230;&#8203;但保留不超过 <code>n</code> 个元素: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#cache-int-java.time.Duration-">cache(int, Duration)</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>但没有立即触发源: <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html#replay--">Flux#replay</a> (返回一个 <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/ConnectableFlux.html">ConnectableFlux</a>)</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/apdx-operatorChoice.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#which-operator">我需要哪个操作符?</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="howtoReadMarbles"><a class="anchor" href="#howtoReadMarbles"></a>Appendix B: 如何阅读 marble diagrams(弹珠图)?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>当我们介绍 <code>Flux</code> 和 <code>Mono</code> 时，我们展示了一个 "弹珠图" 的例子。为了以更直观的方式解释操作符的行为，在 javadoc 中可以找到这些操作符.</p>
</div>
<div class="paragraph">
<p>在本节中，我们将更深入地研究 Reactor 文档对这些弹珠图所使用的约定。首先，让我们看看最常见的运算符模式是如何表示的.</p>
</div>
<div class="paragraph">
<p>有些操作符是实例方法:它们的输出是通过调用 <code>Flux</code> 实例上的一个方法产生的(比如 <code>Flux&lt;T&gt; output = source.fluxOperator()</code>):</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/legend-operator-method.svg" alt="A common operator">
</div>
</div>
<div class="paragraph">
<p>其他操作符是静态方法。它们仍然可以将 <code>Flux</code> 作为输入参数，如  <code>Flux&lt;T&gt; output = Flux.merge(sourceFlux1, sourcePublisher2)</code>。如下所示:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/legend-operator-static.svg" alt="A static operator">
</div>
</div>
<div class="paragraph">
<p>注意，有时我们根据操作符的输入表示多个变量或行为，在这种情况下有一个操作符 "框"，source 变量和输出变量像下面这样分开:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/legend-operator-double-source.svg" alt="An operator with two examples of input">
</div>
</div>
<div class="paragraph">
<p>这些都是基本情况，但有些操作符显示的模式稍微高级一些。</p>
</div>
<div class="paragraph">
<p>例如，<code>ParallelFlux</code> 创建了多个 rails，因此它们有多个 <code>Flux</code> 输出。如下图所示:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/legend-operator-parallel.svg" alt="A parallel operator">
</div>
</div>
<div class="paragraph">
<p>Windowing 操作符产生一个 <code>Flux&lt;Flux&lt;T&gt;&gt;</code> :每个 windows 打开的主要 <code>Flux</code> 通知，而内部 <code>Flux</code> 表示 windows 内容和终止。windows 被表示为主要 <code>Flux</code> 的分支，如下图所示:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/legend-operator-windowing.svg" alt="The output of a windowing operator">
</div>
</div>
<div class="paragraph">
<p>有时，操作符将 "companion publisher" 作为输入(<code>Flux</code>、<code>Mono</code> 或任意的 Reactive Stream 发布者)。这样的 "companion publisher" 帮助您自定义操作符的行为，这将使用 companion 的一些信号作为其内部行为的触发器。它们如下图所示:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/legend-operator-companion.svg" alt="An operator with a companion Publisher">
</div>
</div>
<div class="paragraph">
<p>现在我们已经看到了最常见的操作模式，让我们来展示 <code>Flux</code> 或 <code>Mono</code> 中可能发生的所有不同信号、事件和元素的图形表示:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/legend-events.svg" alt="All types of signals and events">
</div>
</div>
<div class="paragraph">
<p>最后，以同样的方式，我们有  <em>side effects</em> 的图形表示，这发生在 Reactive Stream 信号:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/legend-sideEffects1.svg" alt="Side effects: representation of doOn* handlers">
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/reactor/legend-sideEffects2.svg" alt="Side effects: in a diagram">
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/apdx-howtoReadMarbles.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#howtoReadMarbles">如何阅读 marble diagrams(弹珠图)?</a>"</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="faq"><a class="anchor" href="#faq"></a>Appendix C: FAQ,最佳实践,以及 "我如何&#8230;&#8203;?"</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节涵盖以下内容:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#faq.wrap-blocking">如何包装一个同步阻塞的调用?</a></p>
</li>
<li>
<p><a href="#faq.chain">用在 <code>Flux</code> 上的操作符好像没起作用,为啥?</a></p>
</li>
<li>
<p><a href="#faq.monoThen"><code>Mono</code> <code>zipWith/zipWhen</code> 没有被调用</a></p>
</li>
<li>
<p><a href="#faq.retryWhen">如何用 <code>retryWhen</code> 来实现 <code>retry(3)</code> 的效果?</a></p>
</li>
<li>
<p><a href="#faq.exponentialBackoff">如何使用 <code>retryWhen</code> 进行 exponential backoff?</a></p>
</li>
<li>
<p><a href="#faq.thread-affinity-publishon">如何使用 <code>publishOn()</code> 确保线程 Affinity ?</a></p>
</li>
<li>
<p><a href="#faq.mdc">是你是上下文日志记录的最好模式? (MDC)</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="faq.wrap-blocking"><a class="anchor" href="#faq.wrap-blocking"></a>C.1. 如何包装一个同步阻塞的调用?</h3>
<div class="paragraph">
<p>很多时候,信息源是同步和阻塞的.在 Reactor 中,我们用以下方式处理这种信息源:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Mono blockingWrapper = Mono.fromCallable(() -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
    return /* make a remote synchronous call */ <i class="conum" data-value="2"></i><b>(2)</b>
});
blockingWrapper = blockingWrapper.subscribeOn(Schedulers.boundedElastic()); <i class="conum" data-value="3"></i><b>(3)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>使用 <code>fromCallable</code> 方法生成一个 <code>Mono</code>;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>返回同步、阻塞的资源;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>使用 <code>Schedulers.boundedElastic()</code> 确保对每一个订阅来说运行在一个专门的线程上.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>因为调用返回一个值,所以你应该使用 <code>Mono</code>.你应该使用 <code>Schedulers.boundedElastic</code> 因为它会创建一个专门的线程来等待阻塞的调用返回.同时还确保可以创建的线程数量和可以在高峰期间被排队和推迟.</p>
</div>
<div class="paragraph">
<p>注意 <code>subscribeOn</code> 方法并不会 "订阅" 这个 <code>Mono</code>.它只是指定了订阅操作使用哪个 <code>Scheduler</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="faq.chain"><a class="anchor" href="#faq.chain"></a>C.2. 用在 <code>Flux</code> 上的操作符好像没起作用,为啥?</h3>
<div class="paragraph">
<p>请确认你确实对调用 <code>.subscribe()</code> 的发布者应用了这个操作符.</p>
</div>
<div class="paragraph">
<p>Reactor 的操作符是装饰器(decorators).它们会返回一个不同的(发布者)实例, 这个实例对上游序列进行了包装并增加了一些的处理行为.所以,最推荐的方式是将操作符 "串" 起来.</p>
</div>
<div class="paragraph">
<p>对比下边的两个例子:</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. 没有串起来(不正确的)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux.just("something", "chain");
flux.map(secret -&gt; secret.replaceAll(".", "*")); <i class="conum" data-value="1"></i><b>(1)</b>
flux.subscribe(next -&gt; System.out.println("Received: " + next));
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The mistake is here. The result is not attached to the <code>flux</code> variable.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 26. 串起来(正确的)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; flux = Flux.just("something", "chain");
flux = flux.map(secret -&gt; secret.replaceAll(".", "*"));
flux.subscribe(next -&gt; System.out.println("Received: " + next));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下示例甚至更好(因为它更简单):</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. 串起来(最好的)</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;String&gt; secrets = Flux
  .just("something", "chain")
  .map(secret -&gt; secret.replaceAll(".", "*"))
  .subscribe(next -&gt; System.out.println("Received: " + next));
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>第一个例子的输出:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Received: something
Received: chain</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>后两个例子的输出:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Received: *********
Received: *****</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.monoThen"><a class="anchor" href="#faq.monoThen"></a>C.3. <code>Mono</code> <code>zipWith/zipWhen</code> 没有被调用</h3>
<div class="paragraph">
<p>例子:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">myMethod.process("a") // this method returns Mono&lt;Void&gt;
        .zipWith(myMethod.process("b"), combinator) //this is never called
        .subscribe();
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果源 <code>Mono</code> 为空或是一个 <code>Mono&lt;Void&gt;</code>(<code>Mono&lt;Void&gt;</code> 通常用于 <code>empty</code> 的场景), 下边的组合操作就不会被调用.</p>
</div>
<div class="paragraph">
<p>这是任何数据转换都有可能发生的典型情况,例如 <code>zip</code> 静态方法或 <code>zipWith</code> <code>zipWhen</code> 运算符,根据定义,这些操作符依赖于数据元素来转换为输出的元素.</p>
</div>
<div class="paragraph">
<p>因此,在 <code>zip</code> 源上使用 data-suppressing 操作符是有问题的.  data-suppressing 的示例包括 <code>then()</code>, <code>thenEmpty(Publisher&lt;Void&gt;)</code>,
<code>ignoreElements()</code> 和 <code>ignoreElement()</code>, 和 <code>when(Publisher&#8230;&#8203;)</code>.</p>
</div>
<div class="paragraph">
<p>同样,使用 <code>Function&lt;T,?&gt;</code>  来调整其行为的操作符(例如 <code>flatMap</code>)需要至少发出一个元素,该函数才有机会应用. 将它们应用于空(或 <code>&lt;Void&gt;</code>)序列永远不会产生元素.</p>
</div>
<div class="paragraph">
<p>你可以使用 <code>.defaultIfEmpty(T)</code> 和 <code>.switchIfEmpty(Publisher&lt;T&gt;)</code> 将空序列替换为包含 <code>T</code> 类型默认值的 <code>Publisher&lt;T&gt;</code> 序列(而不是 <code>Void</code> 序列), 从而可以避免类似的情况出现.
请注意,这不适用于 <code>Flux&lt;Void&gt;</code>/<code>Mono&lt;Void&gt;</code> 源,因为您只能切换到另一个 <code>Publisher&lt;Void&gt;</code>,但仍保证为空. 以下示例使用 <code>defaultIfEmpty</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. 在 <code>zipWhen</code> 之前使用  <code>defaultIfEmpty</code></div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">myMethod.emptySequenceForKey("a") // this method returns empty Mono&lt;String&gt;
        .defaultIfEmpty("") // this converts empty sequence to just the empty String
        .zipWhen(aString -&gt; myMethod.process("b")) //this is called with the empty String
        .subscribe();
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.retryWhen"><a class="anchor" href="#faq.retryWhen"></a>C.4. 如何用 <code>retryWhen</code> 来实现 <code>retry(3)</code> 的效果?</h3>
<div class="paragraph">
<p><code>retryWhen</code> 方法比较复杂,希望下边的一段模拟 <code>retry(3)</code> 的代码能够帮你更好地理解它的工作方式:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AtomicInteger errorCount = new AtomicInteger();
Flux&lt;String&gt; flux =
        Flux.&lt;String&gt;error(new IllegalArgumentException())
                .doOnError(e -&gt; errorCount.incrementAndGet())
                .retryWhen(Retry.from(companion -&gt; <i class="conum" data-value="1"></i><b>(1)</b>
                        companion.map(rs -&gt; { <i class="conum" data-value="2"></i><b>(2)</b>
                            if (rs.totalRetries() &lt; 3) return rs.totalRetries(); <i class="conum" data-value="3"></i><b>(3)</b>
                            else throw Exceptions.propagate(rs.failure()); <i class="conum" data-value="4"></i><b>(4)</b>
                        })
                ));
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们通过改写 lambda <code>Function</code> 而不是提供具体的类来自定义 <code>Retry</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>伴随 <code>RetrySignal</code> 对象,该对象包含重试次数以及上一次失败</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>为了允许进行三次重试,我们考虑让 indexes&lt;3,然后返回要发出的值(这里我们只是返回索引).</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>为了终止错误的序列,我们在这三个重试之后抛出了原始异常.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.exponentialBackoff"><a class="anchor" href="#faq.exponentialBackoff"></a>C.5. 如何使用 <code>retryWhen</code> 进行 exponential backoff?</h3>
<div class="paragraph">
<p>Exponential backoff 的意思是进行的多次重试之间的间隔越来越长, 从而避免对源系统造成过载,甚至宕机.基本原理是,如果源产生了一个错误, 那么已经是处于不稳定状态,可能不会立刻复原.
所以,如果立刻就重试可能会产生另一个错误, 导致源更加不稳定.</p>
</div>
<div class="paragraph">
<p>从 <code>3.3.4.RELEASE</code> 开始,Reactor 附带了用于此类重试的构建器,可与 <code>Flux#retryWhen</code>:`Retry.backoff` 一起使用.</p>
</div>
<div class="paragraph">
<p>以下示例展示了构建器的简单用法,在重试尝试延迟之前和之后,hook 都记录了消息,每次重试的间隔都会递增 (伪代码: delay = attempt number * 100 milliseconds):</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">AtomicInteger errorCount = new AtomicInteger();
Flux&lt;String&gt; flux =
Flux.&lt;String&gt;error(new IllegalStateException("boom"))
        .doOnError(e -&gt; { <i class="conum" data-value="1"></i><b>(1)</b>
            errorCount.incrementAndGet();
            System.out.println(e + " at " + LocalTime.now());
        })
        .retryWhen(Retry
                .backoff(3, Duration.ofMillis(100)).jitter(0d) <i class="conum" data-value="2"></i><b>(2)</b>
                .doAfterRetry(rs -&gt; System.out.println("retried at " + LocalTime.now())) <i class="conum" data-value="3"></i><b>(3)</b>
                .onRetryExhaustedThrow((spec, rs) -&gt; rs.failure()) <i class="conum" data-value="4"></i><b>(4)</b>
        );
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>记录错误出现的时间;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们配置了重试 3 次的效果.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们还会记录重试发生的时间.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>默认情况下,将抛出 <code>Exceptions.retryExhausted</code>  异常,并以最后一个  <code>failure()</code> 为异常原因. 在这里,我们将其自定义为直接原因并作为 <code>onError</code> 发出.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>订阅后,它将失败并在打印出以下内容后终止:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre>java.lang.IllegalArgumentException at 18:02:29.338
retried at 18:02:29.459 <i class="conum" data-value="1"></i><b>(1)</b>
java.lang.IllegalArgumentException at 18:02:29.460
retried at 18:02:29.663 <i class="conum" data-value="2"></i><b>(2)</b>
java.lang.IllegalArgumentException at 18:02:29.663
retried at 18:02:29.964 <i class="conum" data-value="3"></i><b>(3)</b>
java.lang.IllegalArgumentException at 18:02:29.964</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>第一次重试延迟大约 100ms</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第二次重试延迟大约 200ms</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>第三次重试延迟大约 300ms</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="faq.thread-affinity-publishon"><a class="anchor" href="#faq.thread-affinity-publishon"></a>C.6. 如何使用 <code>publishOn()</code> 确保线程 Affinity ?</h3>
<div class="paragraph">
<p>如  <a href="#schedulers">Schedulers</a> 所述,<code>publishOn()</code> 可以用来切换执行线程. <code>publishOn</code> 能够影响到其之后的操作符的执行线程,直到有新的 <code>publishOn</code> 出现. 所以 <code>publishOn</code> 的位置很重要.</p>
</div>
<div class="paragraph">
<p>考虑下面的例子:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Flux&lt;Integer&gt; source = Sinks.many().unicast().onBackpressureBuffer().asFlux();
source.publishOn(scheduler1)
      .map(i -&gt; transform(i))
      .publishOn(scheduler2)
      .doOnNext(i -&gt; processNext(i))
      .subscribe();
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>比如下边的例子, <code>map()</code> 中的 <code>transform</code> 方法是在 <code>scheduler1</code> 的一个工作线程上执行的, 而 <code>doOnNext()</code> 中的 <code>processNext</code> 方法是在 <code>scheduler2</code> 的一个工作线程上执行的.</p>
</div>
<div class="paragraph">
<p>可能用于</p>
</div>
<div class="paragraph">
<p>您可以使用单线程的调度器来确保对不同阶段的任务或不同的订阅者确保线程关联性.</p>
</div>
</div>
<div class="sect2">
<h3 id="faq.mdc"><a class="anchor" href="#faq.mdc"></a>C.7. 是你是上下文日志记录的最好模式? (MDC)</h3>
<div class="paragraph">
<p>大多数日志框架都允许进行上下文日志记录,用户通过一个 <code>Map</code> 记录日志中的变量,通常称为 MDC(“映射的诊断上下文”) . 这是 Java 中 <code>ThreadLocal</code> 的最经常使用的方法之一,因此,此模式假定所记录的代码与 Thread 是一对一关系.</p>
</div>
<div class="paragraph">
<p>在 Java 8 之前,这可能是一个安全的假设,但是随着 Java 语言中函数式编程的出现,事情发生了一些变化&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>让我们模板方法模式的 API 为例,然后切换到更具函数式的样式. 使用模板方法模式,继承就发挥了作用. 现在,在函数式的方法中,传递了更高阶的函数来定义算法的 "步骤".
现在,事情比声明式命令更具声明性,这使库可以自由决定每个步骤应该在哪里运行. 例如,知道基础算法的哪些步骤可以并行化,该库可以使用 <code>ExecutorService</code> 并行执行某些步骤.</p>
</div>
<div class="paragraph">
<p>这种功能性API的一个具体示例是Java 8中引入的Stream API及其parallel()风格. 在并行Stream中使用MDC记录不是免费的午餐:需要确保在每个步骤中都捕获并重新应用MDC.</p>
</div>
<div class="paragraph">
<p>函数式风格可实现此类优化,因为每个步骤都是线程不可知的,并且引用是透明的,但是它可能会破坏单个线程的 MDC 假设. 确保所有阶段都可以访问任何种类的上下文信息的最惯用的方法是将整个上下文传递给整个组合链.
在 Reactor 的开发过程中,我们遇到了相同的一般问题,因此我们希望避免这种不实际的,明确的方法. 这就是引入 <code>Context</code> 的原因:只要让阶段(运算符)窥视下游阶段的 <code>Context</code>,只要它将 <code>Flux</code> 和 <code>Mono</code> 用作返回值,
它就会在执行链中传播. 因此,Reactor 提供了此类似于 <code>Map</code> 的对象,该对象与 <code>Subscription</code> 而非 <code>Thread</code> 绑定,而不是使用 <code>ThreadLocal</code>.</p>
</div>
<div class="paragraph">
<p>既然我们已经确定 MDC 并不是在声明性 API 中做出的最佳假设,那么如何在响应式流(<code>onNext</code>,<code>onError</code> 和 <code>onComplete</code>)中与事件相关地执行上下文化的日志语句?</p>
</div>
<div class="paragraph">
<p>当人们想要以直接和明确的方式登录这些信号时,FAQ 的此项提供了一种可能的中间解决方案. 确保事先阅读  <a href="#context">增加一个 Context 到响应式序列</a> 部分,尤其是如何在操作符链的底部进行写操作,以使上方的操作符可以看到它.</p>
</div>
<div class="paragraph">
<p>要从 <code>Context</code> 到 MDC 获取上下文信息,最简单的方法是使用一点样板代码将日志记录语句包装在 <code>doOnEach</code> 操作符中. 该样板取决于您选择的日志记录框架/摘要以及要放入 MDC 中的信息,因此它必须在您的代码库中.</p>
</div>
<div class="paragraph">
<p>以下是使用 Java 9 增强的 <code>Optional</code> API 围绕单个 MDC 变量的此类帮助器函数的示例,并着重于记录 <code>onNext</code> 事件:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static &lt;T&gt; Consumer&lt;Signal&lt;T&gt;&gt; logOnNext(Consumer&lt;T&gt; logStatement) {
    return signal -&gt; {
        if (!signal.isOnNext()) return; <i class="conum" data-value="1"></i><b>(1)</b>
        Optional&lt;String&gt; toPutInMdc = signal.getContext().getOrEmpty("CONTEXT_KEY"); <i class="conum" data-value="2"></i><b>(2)</b>

        toPutInMdc.ifPresentOrElse(tpim -&gt; {
            try (MDC.MDCCloseable cMdc = MDC.putCloseable("MDC_KEY", tpim)) { <i class="conum" data-value="3"></i><b>(3)</b>
                logStatement.accept(signal.get()); <i class="conum" data-value="4"></i><b>(4)</b>
            }
        },
        () -&gt; logStatement.accept(signal.get())); <i class="conum" data-value="5"></i><b>(5)</b>
    };
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>doOnEach</code> 信号包括 <code>onComplete</code> 和 <code>onError</code>. 在此示例中,我们仅对 <code>onNext</code> 感兴趣.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们将从Reactor <code>Context</code> 中提取一个有趣的值(请参见  <a href="#context.api"><code>Context</code> API</a> 部分)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在此示例中,我们使用 SLF4J 2 中的 <code>MDCCloseable</code>,允许在使用 log 语句后使用 try-with-source 语法自动清除 MDC.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>调用者以 <code>Consumer&lt;T&gt;</code> 的形式提供正确的日志语句(使用 onNext 值)</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>如果未在 <code>Context</code> 中设置预期的密钥,我们将使用替代路径,即在 MDC 中不添加任何内容</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>使用此样板代码可确保我们是MDC的良好公民:我们在执行日志记录语句之前立即设置了密钥,并在之后立即将其删除. 不会为后续的日志记录语句污染MDC.</p>
</div>
<div class="paragraph">
<p>当然,这是一个建议. 您可能对从 <code>Context</code> 中提取多个值或在 <code>onError</code> 的情况下记录事件感兴趣. 您可能想要为这些情况创建其他辅助方法,或设计一个利用其他 lambda 覆盖更多区域的方法.</p>
</div>
<div class="paragraph">
<p>无论如何,前面的辅助方法的用法可能类似于以下响应式 Web 控制器:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/byPrice")
public Flux&lt;Restaurant&gt; byPrice(@RequestParam Double maxPrice, @RequestHeader(required = false, name = "X-UserId") String userId) {
    String apiId = userId == null ? "" : userId; <i class="conum" data-value="1"></i><b>(1)</b>

    return restaurantService.byPrice(maxPrice))
               .doOnEach(logOnNext(r -&gt; LOG.debug("found restaurant {} for ${}", <i class="conum" data-value="2"></i><b>(2)</b>
                    r.getName(), r.getPricePerPerson())))
               .contextWrite(Context.of("CONTEXT_KEY", apiId)); <i class="conum" data-value="3"></i><b>(3)</b>
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>We need to get the contextual information from the request header to put it in the <code>Context</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here we apply our helper method to the <code>Flux</code>, using <code>doOnEach</code>. Remember: operators see <code>Context</code> values defined below them.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>We write the value from the header to the <code>Context</code> using the chosen key <code>CONTEXT_KEY</code>.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种配置中,<code>restaurantService</code> 可以在共享线程上发出其数据,但是日志仍将为每个请求引用正确的 <code>X-UserId</code>.</p>
</div>
<div class="paragraph">
<p>为了完整起见,我们还可以看到错误记录助手的外观:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static Consumer&lt;Signal&lt;?&gt;&gt; logOnError(Consumer&lt;Throwable&gt; errorLogStatement) {
    return signal -&gt; {
        if (!signal.isOnError()) return;
        Optional&lt;String&gt; toPutInMdc = signal.getContext().getOrEmpty("CONTEXT_KEY");

        toPutInMdc.ifPresentOrElse(tpim -&gt; {
            try (MDC.MDCCloseable cMdc = MDC.putCloseable("MDC_KEY", tpim)) {
                errorLogStatement.accept(signal.getThrowable());
            }
        },
        () -&gt; errorLogStatement.accept(signal.getThrowable()));
    };
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了我们检查 Signal 实际上是 <code>onError</code> 并向日志语句 lambda 提供上述错误(<code>Throwable</code>)这一事实之外,其他任何事情都没有改变.</p>
</div>
<div class="paragraph">
<p>在控制器中应用此辅助程序与我们之前所做的非常相似:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/byPrice")
public Flux&lt;Restaurant&gt; byPrice(@RequestParam Double maxPrice, @RequestHeader(required = false, name = "X-UserId") String userId) {
    String apiId = userId == null ? "" : userId;

    return restaurantService.byPrice(maxPrice))
               .doOnEach(logOnNext(v -&gt; LOG.info("found restaurant {}", v))
               .doOnEach(logOnError(e -&gt; LOG.error("error when searching restaurants", e)) <i class="conum" data-value="1"></i><b>(1)</b>
               .contextWrite(Context.of("CONTEXT_KEY", apiId));
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>In case the <code>restaurantService</code> emits an error, it will be logged with MDC context here</td>
</tr>
</table>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/faq.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#faq">FAQ,最佳实践,以及 "我如何&#8230;&#8203;?"</a>"</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactor-extra"><a class="anchor" href="#reactor-extra"></a>Appendix D: Reactor-Extra</h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>reactor-extra</code> 为满足 <code>reactor-core</code> 用户的更高级需求,提供了一些额外的操作符和工具.</p>
</div>
<div class="paragraph">
<p>由于这是一个单独的包,使用时需要明确它的依赖:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
     compile 'io.projectreactor:reactor-core'
     compile 'io.projectreactor.addons:reactor-extra' <i class="conum" data-value="1"></i><b>(1)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>添加 reactor-extra 的依赖.参考 <a href="#getting">获取  Reactor</a>  Reactor 了解为什么使用BOM的情况下不需要指定 version.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extra-tuples"><a class="anchor" href="#extra-tuples"></a>D.1. <code>TupleUtils</code> 以及函数式接口</h3>
<div class="paragraph">
<p>在 Java 8 提供的函数式接口基础上,<code>reactor.function</code> 包又提供了一些支持 3 到 8 个值的 <code>Function</code>、<code>Predicate</code> 和 <code>Consumer</code>.</p>
</div>
<div class="paragraph">
<p><code>TupleUtils</code> 提供的静态方法可以方便地用于将相应的 <code>Tuple</code> 函数式接口的 lambda 转换为更简单的接口.</p>
</div>
<div class="paragraph">
<p>这使得我们在使用 <code>Tuple</code> 中各成员的时候更加容易,比如:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">.map(tuple -&gt; {
  String firstName = tuple.getT1();
  String lastName = tuple.getT2();
  String address = tuple.getT3();

  return new Customer(firstName, lastName, address);
});
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以用下面的方式代替:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">.map(TupleUtils.function(Customer::new)); <i class="conum" data-value="1"></i><b>(1)</b>
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>(因为 <code>Customer</code> 的构造方法符合 <code>Consumer3</code> 的函数式接口标签)</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="extra-math"><a class="anchor" href="#extra-math"></a>D.2. <code>MathFlux</code> 的数学操作符</h3>
<div class="paragraph">
<p><code>reactor.math</code>  包的 <code>MathFlux</code> 提供了一些用于数学计算的操作符,如 <code>max</code>、<code>min</code>、<code>sumInt</code>、<code>averageDouble</code>&#8230;&#8203;</p>
</div>
</div>
<div class="sect2">
<h3 id="extra-schedulers"><a class="anchor" href="#extra-schedulers"></a>D.3. 调度器</h3>
<div class="paragraph">
<p>Reactor-extra 提供了若干专用的调度器:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ForkJoinPoolScheduler</code> (位于 <code>reactor.scheduler.forkjoin</code> 包): 使用 Java <code>ForkJoinPool</code> 执行任务.</p>
</li>
<li>
<p><code>SwingScheduler</code> (位于 <code>reactor.swing</code> 包): 在Swing UI事件循环线程 "EDT" 中运行任务.</p>
</li>
<li>
<p><code>SwtScheduler</code> (位于 <code>reactor.swing</code> 包): 在SWT UI事件循环线程中运行任务.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://github.com/reactor/reactor-core/edit/main/docs/asciidoc/apdx-reactorExtra.adoc" class="fa fa-edit" title="Suggest an edit to the above section via github" target="_blank" rel="noopener">Suggest Edit</a>
to "<a href="#reactor-extra">Reactor-Extra</a>"</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-09-13 15:54:20 +0800
</div>
</div>
</div>
  </div>
</div>
</body>
</html>
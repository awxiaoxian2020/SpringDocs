<!DOCTYPE html>
<html lang="zh-cn">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.12">
<meta name="author" content="Ben Alex, Luke Taylor, Rob Winch, Gunnar Hillert, Joe Grandja, Jay Bryant, Eddú Meléndez, Josh Cummings, Dave Syer">
<title>Spring Security 中文文档</title>
<link rel="stylesheet" href="css/site.css">
<script src="js/setup.js"></script><script defer src="js/site.js"></script>

</head>
<body class="book toc2 toc-left"><div id="banner-container" class="container" role="banner">
  <div id="banner" class="contained" role="banner">
    <div id="switch-theme">
      <input type="checkbox" id="switch-theme-checkbox" />
      <label for="switch-theme-checkbox">Dark Theme</label>
    </div>
  </div>
</div>
<div id="tocbar-container" class="container" role="navigation">
  <div id="tocbar" class="contained" role="navigation">
    <button id="toggle-toc"></button>
  </div>
</div>
<div id="main-container" class="container">
  <div id="main" class="contained">
    <div id="doc" class="doc">
<div id="header">
<h1>Spring Security 中文文档</h1>
<div class="details">
<span id="author" class="author">Ben Alex</span><br>
<span id="author2" class="author">Luke Taylor</span><br>
<span id="author3" class="author">Rob Winch</span><br>
<span id="author4" class="author">Gunnar Hillert</span><br>
<span id="author5" class="author">Joe Grandja</span><br>
<span id="author6" class="author">Jay Bryant</span><br>
<span id="author7" class="author">Eddú Meléndez</span><br>
<span id="author8" class="author">Josh Cummings</span><br>
<span id="author9" class="author">Dave Syer</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel0">
<li><a href="#介绍">介绍</a>
<ul class="sectlevel1">
<li><a href="#prerequisites">1. 要求</a></li>
<li><a href="#community">2. Spring Security 社区</a>
<ul class="sectlevel2">
<li><a href="#community-help">2.1. 获取帮助</a></li>
<li><a href="#community-becoming-involved">2.2. 参与其中</a></li>
<li><a href="#community-source">2.3. 源码</a></li>
<li><a href="#community-license">2.4. Apache 2 License</a></li>
<li><a href="#社交媒体">2.5. 社交媒体</a></li>
</ul>
</li>
<li><a href="#new">3. Spring Security 5.4 的新功能</a>
<ul class="sectlevel2">
<li><a href="#whats-new-documentation">3.1. 文档更新</a></li>
<li><a href="#whats-new-logging">3.2. Logging 更新</a></li>
<li><a href="#whats-new-servlet">3.3. Servlet</a></li>
<li><a href="#whats-new-webflux">3.4. WebFlux</a></li>
<li><a href="#whats-new-additional">3.5. 其他更新</a></li>
<li><a href="#whats-new-build">3.6. 构建变化</a></li>
</ul>
</li>
<li><a href="#getting">4. 获取 Spring Security</a>
<ul class="sectlevel2">
<li><a href="#release-版本号">4.1. Release 版本号</a></li>
<li><a href="#maven">4.2. 使用 Maven</a>
<ul class="sectlevel3">
<li><a href="#getting-maven-boot">4.2.1. 使用 Spring Boot</a></li>
<li><a href="#getting-maven-no-boot">4.2.2. 不使用 Spring Boot</a></li>
<li><a href="#maven-repositories">4.2.3. Maven 仓库</a></li>
</ul>
</li>
<li><a href="#getting-gradle">4.3. 使用 Gradle</a>
<ul class="sectlevel3">
<li><a href="#getting-gradle-boot">4.3.1. 使用 Spring Boot</a></li>
<li><a href="#不使用-spring-boot">4.3.2. 不使用 Spring Boot</a></li>
<li><a href="#gradle-repositories">4.3.3. Gradle 仓库</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#features">5. 特性</a>
<ul class="sectlevel2">
<li><a href="#authentication">5.1. 认证</a>
<ul class="sectlevel3">
<li><a href="#authentication-support">5.1.1. 认证支持</a></li>
<li><a href="#authentication-password-storage">5.1.2. 密码存储</a>
<ul class="sectlevel4">
<li><a href="#authentication-password-storage-history">密码存储历史</a></li>
<li><a href="#authentication-password-storage-dpe">DelegatingPasswordEncoder</a></li>
<li><a href="#authentication-password-storage-bcrypt">BCryptPasswordEncoder</a></li>
<li><a href="#authentication-password-storage-argon2">Argon2PasswordEncoder</a></li>
<li><a href="#authentication-password-storage-pbkdf2">Pbkdf2PasswordEncoder</a></li>
<li><a href="#authentication-password-storage-scrypt">SCryptPasswordEncoder</a></li>
<li><a href="#authentication-password-storage-other">其他的 PasswordEncoders</a></li>
<li><a href="#authentication-password-storage-configuration">密码存储配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#exploits">5.2. 防止利用漏洞</a>
<ul class="sectlevel3">
<li><a href="#csrf">5.2.1. 跨站请求伪造 (CSRF)</a>
<ul class="sectlevel4">
<li><a href="#csrf-explained">什么是 CSRF 攻击?</a></li>
<li><a href="#csrf-protection">防御 CSRF 攻击</a></li>
<li><a href="#csrf-when">何时使用CSRF保护</a></li>
<li><a href="#csrf-considerations">CSRF注意事项</a></li>
</ul>
</li>
<li><a href="#headers">5.2.2. 安全HTTP响应头</a>
<ul class="sectlevel4">
<li><a href="#headers-default">默认安全响应头</a></li>
<li><a href="#headers-cache-control">缓存控制</a></li>
<li><a href="#headers-content-type-options">Content Type 选项</a></li>
<li><a href="#headers-hsts">HTTP Strict Transport Security (HSTS)</a></li>
<li><a href="#headers-hpkp">HTTP Public Key Pinning (HPKP)</a></li>
<li><a href="#headers-frame-options">X-Frame-Options</a></li>
<li><a href="#headers-xss-protection">X-XSS-Protection</a></li>
<li><a href="#headers-csp">Content Security Policy (CSP)</a></li>
<li><a href="#headers-referrer">Referrer Policy</a></li>
<li><a href="#headers-feature">Feature Policy</a></li>
<li><a href="#headers-clear-site-data">清除站点数据</a></li>
<li><a href="#headers-custom">自定义 Headers</a></li>
</ul>
</li>
<li><a href="#http">5.2.3. HTTP</a>
<ul class="sectlevel4">
<li><a href="#http-redirect">重定向为 HTTPS</a></li>
<li><a href="#http-hsts">严格的安全传输</a></li>
<li><a href="#http-proxy-server">代理服务器配置</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#modules">6. 项目模块和依赖</a>
<ul class="sectlevel2">
<li><a href="#spring-security-core">6.1. 核心模块&#8201;&#8212;&#8201;<code>spring-security-core.jar</code></a></li>
<li><a href="#spring-security-remoting">6.2. 远程调用&#8201;&#8212;&#8201;<code>spring-security-remoting.jar</code></a></li>
<li><a href="#spring-security-web">6.3. Web&#8201;&#8212;&#8201;<code>spring-security-web.jar</code></a></li>
<li><a href="#spring-security-config">6.4. 配置&#8201;&#8212;&#8201;<code>spring-security-config.jar</code></a></li>
<li><a href="#spring-security-ldap">6.5. LDAP&#8201;&#8212;&#8201;<code>spring-security-ldap.jar</code></a></li>
<li><a href="#spring-security-oauth2-core">6.6. OAuth 2.0 核心包&#8201;&#8212;&#8201;<code>spring-security-oauth2-core.jar</code></a></li>
<li><a href="#spring-security-oauth2-client">6.7. OAuth 2.0 客户端&#8201;&#8212;&#8201;<code>spring-security-oauth2-client.jar</code></a></li>
<li><a href="#spring-security-oauth2-jose">6.8. OAuth 2.0 JOSE&#8201;&#8212;&#8201;<code>spring-security-oauth2-jose.jar</code></a></li>
<li><a href="#spring-security-oauth2-resource-server">6.9. OAuth 2.0 资源 服务器&#8201;&#8212;&#8201;<code>spring-security-oauth2-resource-server.jar</code></a></li>
<li><a href="#spring-security-acl">6.10. ACL&#8201;&#8212;&#8201;<code>spring-security-acl.jar</code></a></li>
<li><a href="#spring-security-cas">6.11. CAS&#8201;&#8212;&#8201;<code>spring-security-cas.jar</code></a></li>
<li><a href="#spring-security-openid">6.12. OpenID&#8201;&#8212;&#8201;<code>spring-security-openid.jar</code></a></li>
<li><a href="#spring-security-test">6.13. 测试&#8201;&#8212;&#8201;<code>spring-security-test.jar</code></a></li>
<li><a href="#spring-security-taglibs">6.14. Taglibs&#8201;&#8212;&#8201;<code>spring-secuity-taglibs.jar</code></a></li>
</ul>
</li>
<li><a href="#samples">7. 示例程序</a></li>
</ul>
</li>
<li><a href="#servlet-应用程序">Servlet 应用程序</a>
<ul class="sectlevel1">
<li><a href="#servlet-hello">8. Hello Spring Security</a>
<ul class="sectlevel2">
<li><a href="#servlet-hello-dependencies">8.1. 更新依赖</a></li>
<li><a href="#servlet-hello-starting">8.2. Starting Hello Spring Security Boot</a></li>
<li><a href="#servlet-hello-auto-configuration">8.3. Spring Boot 自动配置</a></li>
</ul>
</li>
<li><a href="#servlet-architecture">9. Servlet Security: 图景</a>
<ul class="sectlevel2">
<li><a href="#servlet-filters-review">9.1. 回顾过滤器</a></li>
<li><a href="#servlet-delegatingfilterproxy">9.2. DelegatingFilterProxy</a></li>
<li><a href="#servlet-filterchainproxy">9.3. FilterChainProxy</a></li>
<li><a href="#servlet-securityfilterchain">9.4. SecurityFilterChain</a></li>
<li><a href="#servlet-security-filters">9.5. Security Filters</a></li>
<li><a href="#servlet-exceptiontranslationfilter">9.6. 处理 Security 异常</a></li>
</ul>
</li>
<li><a href="#servlet-authentication">10. 认证</a>
<ul class="sectlevel2">
<li><a href="#servlet-authentication-securitycontextholder">10.1. SecurityContextHolder</a></li>
<li><a href="#servlet-authentication-securitycontext">10.2. SecurityContext</a></li>
<li><a href="#servlet-authentication-authentication">10.3. Authentication</a></li>
<li><a href="#servlet-authentication-granted-authority">10.4. GrantedAuthority</a></li>
<li><a href="#servlet-authentication-authenticationmanager">10.5. AuthenticationManager</a></li>
<li><a href="#servlet-authentication-providermanager">10.6. ProviderManager</a></li>
<li><a href="#servlet-authentication-authenticationprovider">10.7. AuthenticationProvider</a></li>
<li><a href="#servlet-authentication-authenticationentrypoint">10.8. 使用 <code>AuthenticationEntryPoint</code> 请求凭据</a></li>
<li><a href="#servlet-authentication-abstractprocessingfilter">10.9. AbstractAuthenticationProcessingFilter</a></li>
<li><a href="#servlet-authentication-unpwd">10.10. Username/Password 认证</a>
<ul class="sectlevel3">
<li><a href="#servlet-authentication-form">10.10.1. 表单登录</a></li>
<li><a href="#servlet-authentication-basic">10.10.2. Basic Authentication</a></li>
<li><a href="#servlet-authentication-digest">10.10.3. Digest Authentication</a></li>
<li><a href="#servlet-authentication-inmemory">10.10.4. In-Memory Authentication</a></li>
<li><a href="#servlet-authentication-jdbc">10.10.5. JDBC Authentication</a>
<ul class="sectlevel4">
<li><a href="#servlet-authentication-jdbc-schema">默认架构</a></li>
<li><a href="#servlet-authentication-jdbc-datasource">设置数据源</a></li>
<li><a href="#servlet-authentication-jdbc-bean">JdbcUserDetailsManager Bean</a></li>
</ul>
</li>
<li><a href="#servlet-authentication-userdetails">10.10.6. UserDetails</a></li>
<li><a href="#servlet-authentication-userdetailsservice">10.10.7. UserDetailsService</a></li>
<li><a href="#servlet-authentication-password-storage">10.10.8. PasswordEncoder</a></li>
<li><a href="#servlet-authentication-daoauthenticationprovider">10.10.9. DaoAuthenticationProvider</a></li>
<li><a href="#servlet-authentication-ldap">10.10.10. LDAP 认证</a>
<ul class="sectlevel4">
<li><a href="#servlet-authentication-ldap-prerequisites">前提条件</a></li>
<li><a href="#servlet-authentication-ldap-embedded">设置嵌入式LDAP服务器</a></li>
<li><a href="#servlet-authentication-ldap-contextsource">LDAP ContextSource</a></li>
<li><a href="#servlet-authentication-ldap-authentication">认证</a></li>
<li><a href="#servlet-authentication-ldap-bind">使用绑定身份验证</a></li>
<li><a href="#servlet-authentication-ldap-pwd">使用密码认证</a></li>
<li><a href="#ldapauthoritiespopulator">LdapAuthoritiesPopulator</a></li>
<li><a href="#激活目录">激活目录</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#session-mgmt">10.11. Session 管理器</a>
<ul class="sectlevel3">
<li><a href="#检测超时">10.11.1. 检测超时</a></li>
<li><a href="#ns-concurrent-sessions">10.11.2. 并发会话控制</a></li>
<li><a href="#ns-session-fixation">10.11.3. 会话固定攻击防护</a></li>
<li><a href="#sessionmanagementfilter">10.11.4. SessionManagementFilter</a></li>
<li><a href="#sessionauthenticationstrategy">10.11.5. SessionAuthenticationStrategy</a></li>
<li><a href="#concurrent-sessions">10.11.6. 并发控制</a>
<ul class="sectlevel4">
<li><a href="#list-authenticated-principals">查询 SessionRegistry 中当前经过身份验证的用户及其会话</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#servlet-rememberme">10.12. Remember-Me 认证</a>
<ul class="sectlevel3">
<li><a href="#remember-me-overview">10.12.1. 概述</a></li>
<li><a href="#remember-me-hash-token">10.12.2. 简单的基于哈希的令牌方法</a></li>
<li><a href="#remember-me-persistent-token">10.12.3. 持久令牌方法</a></li>
<li><a href="#remember-me-impls">10.12.4. Remember-Me 接口和实现</a>
<ul class="sectlevel4">
<li><a href="#tokenbasedremembermeservices">TokenBasedRememberMeServices</a></li>
<li><a href="#persistenttokenbasedremembermeservices">PersistentTokenBasedRememberMeServices</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#servlet-openid">10.13. OpenID 支持</a>
<ul class="sectlevel3">
<li><a href="#属性交换">10.13.1. 属性交换</a></li>
</ul>
</li>
<li><a href="#anonymous">10.14. 匿名认证</a>
<ul class="sectlevel3">
<li><a href="#anonymous-overview">10.14.1. 概述</a></li>
<li><a href="#anonymous-config">10.14.2. 配置</a></li>
<li><a href="#anonymous-auth-trust-resolver">10.14.3. AuthenticationTrustResolver</a></li>
</ul>
</li>
<li><a href="#servlet-preauth">10.15. Pre-Authentication 场景</a>
<ul class="sectlevel3">
<li><a href="#pre-authentication-框架类">10.15.1. Pre-Authentication 框架类</a>
<ul class="sectlevel4">
<li><a href="#abstractpreauthenticatedprocessingfilter">AbstractPreAuthenticatedProcessingFilter</a></li>
<li><a href="#预身份验证提供者">预身份验证提供者</a></li>
<li><a href="#http403-禁止入口点">Http403 禁止入口点</a></li>
</ul>
</li>
<li><a href="#具体实现">10.15.2. 具体实现</a>
<ul class="sectlevel4">
<li><a href="#请求头身份验证-siteminder">请求头身份验证 (Siteminder)</a></li>
<li><a href="#java-ee-容器认证">Java EE 容器认证</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#servlet-jaas">10.16. Java Authentication Authorization Service(JAAS,Java验证和授权API)  提供者</a>
<ul class="sectlevel3">
<li><a href="#概述">10.16.1. 概述</a></li>
<li><a href="#jaas-abstractjaasauthenticationprovider">10.16.2. AbstractJaasAuthenticationProvider</a>
<ul class="sectlevel4">
<li><a href="#jaas-callbackhandler">JAAS 回调处理</a></li>
<li><a href="#jaas-authoritygranter">JAAS 授权者</a></li>
</ul>
</li>
<li><a href="#jaas-defaultjaasauthenticationprovider">10.16.3. DefaultJaasAuthenticationProvider</a>
<ul class="sectlevel4">
<li><a href="#jaas-inmemoryconfiguration">InMemoryConfiguration</a></li>
<li><a href="#jaas-djap-config">DefaultJaasAuthenticationProvider 示例配置</a></li>
</ul>
</li>
<li><a href="#jaas-jaasauthenticationprovider">10.16.4. JaasAuthenticationProvider</a></li>
<li><a href="#jaas-apiprovision">10.16.5. Subject 运行</a></li>
</ul>
</li>
<li><a href="#servlet-cas">10.17. CAS 认证</a>
<ul class="sectlevel3">
<li><a href="#cas-overview">10.17.1. 概述</a></li>
<li><a href="#cas-how-it-works">10.17.2. CAS 如何工作?</a>
<ul class="sectlevel4">
<li><a href="#cas-sequence">Spring Security 和 CAS 交互序列</a></li>
</ul>
</li>
<li><a href="#cas-client">10.17.3. CAS 客户端配置</a>
<ul class="sectlevel4">
<li><a href="#cas-st">Service Ticket 认证</a></li>
<li><a href="#cas-singlelogout">单点注销</a></li>
<li><a href="#cas-pt-client">通过CAS向无状态服务进行身份验证</a></li>
<li><a href="#cas-pt">代理票证认证</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#servlet-x509">10.18. X.509 认证</a>
<ul class="sectlevel3">
<li><a href="#x509-overview">10.18.1. 概述</a></li>
<li><a href="#向您的web应用程序添加x-509身份验证">10.18.2. 向您的Web应用程序添加X.509身份验证</a></li>
<li><a href="#x509-ssl-config">10.18.3. 在Tomcat中设置SSL</a></li>
</ul>
</li>
<li><a href="#runas">10.19. Run-As 验证替换</a>
<ul class="sectlevel3">
<li><a href="#runas-overview">10.19.1. 概述</a></li>
<li><a href="#runas-config">10.19.2. 配置</a></li>
</ul>
</li>
<li><a href="#jc-logout">10.20. Logout 处理</a>
<ul class="sectlevel3">
<li><a href="#logout-java-configuration">10.20.1. Logout Java/Kotlin 配置</a></li>
<li><a href="#ns-logout">10.20.2. Logout XML 配置</a></li>
<li><a href="#jc-logout-handler">10.20.3. LogoutHandler</a></li>
<li><a href="#jc-logout-success-handler">10.20.4. LogoutSuccessHandler</a></li>
<li><a href="#jc-logout-references">10.20.5. 其他注销相关参考</a></li>
</ul>
</li>
<li><a href="#servlet-events">10.21. 认证事件</a>
<ul class="sectlevel3">
<li><a href="#添加异常映射">10.21.1. 添加异常映射</a></li>
<li><a href="#默认事件">10.21.2. 默认事件</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#servlet-authorization">11. 授权</a>
<ul class="sectlevel2">
<li><a href="#authz-arch">11.1. 授权体系结构</a>
<ul class="sectlevel3">
<li><a href="#authz-authorities">11.1.1. Authorities</a></li>
<li><a href="#authz-pre-invocation">11.1.2. 调用处理前</a>
<ul class="sectlevel4">
<li><a href="#authz-access-decision-manager">AccessDecisionManager</a></li>
<li><a href="#authz-voting-based">基于 <code>AccessDecisionManager</code> 实现</a></li>
</ul>
</li>
<li><a href="#authz-after-invocation-handling">11.1.3. 调用处理后</a></li>
<li><a href="#authz-hierarchical-roles">11.1.4. 角色层次</a></li>
</ul>
</li>
<li><a href="#servlet-authorization-filtersecurityinterceptor">11.2. 使用 <code>FilterSecurityInterceptor</code> 授权 <code>HttpServletRequest</code></a></li>
<li><a href="#el-access">11.3. 基于表达式的访问控制</a>
<ul class="sectlevel3">
<li><a href="#概述-2">11.3.1. 概述</a>
<ul class="sectlevel4">
<li><a href="#el-common-built-in">常见的内置表达式</a></li>
</ul>
</li>
<li><a href="#el-access-web">11.3.2. Web Security 表达式</a>
<ul class="sectlevel4">
<li><a href="#el-access-web-beans">在Web安全表达式中引用Bean</a></li>
<li><a href="#el-access-web-path-variables">Web安全表达式中的路径变量</a></li>
</ul>
</li>
<li><a href="#方法安全性表达式">11.3.3. 方法安全性表达式</a>
<ul class="sectlevel4">
<li><a href="#el-pre-post-annotations">@Pre 和 @Post 注解</a></li>
<li><a href="#el-method-built-in">内置表达式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#secure-object-impls">11.4. 安全对象实现</a>
<ul class="sectlevel3">
<li><a href="#aop-alliance">11.4.1. AOP 联盟 (MethodInvocation) 安全拦截器</a>
<ul class="sectlevel4">
<li><a href="#显式配置-securityinterceptor-方法">显式配置 <code>SecurityInterceptor</code> 方法</a></li>
</ul>
</li>
<li><a href="#aspectj">11.4.2. AspectJ (JoinPoint) 安全拦截器</a></li>
</ul>
</li>
<li><a href="#jc-method">11.5. 方法的安全</a>
<ul class="sectlevel3">
<li><a href="#enableglobalmethodsecurity">11.5.1. EnableGlobalMethodSecurity</a></li>
<li><a href="#globalmethodsecurityconfiguration">11.5.2. GlobalMethodSecurityConfiguration</a></li>
<li><a href="#ns-global-method">11.5.3. &lt;global-method-security&gt; 元素</a></li>
<li><a href="#ns-protect-pointcut">11.5.4. 使用  protect-pointcut 添加安全的切点</a></li>
</ul>
</li>
<li><a href="#domain-acls">11.6. 域对象安全 (ACLs)</a>
<ul class="sectlevel3">
<li><a href="#domain-acls-overview">11.6.1. 概述</a></li>
<li><a href="#domain-acls-key-concepts">11.6.2. 关键概念</a></li>
<li><a href="#domain-acls-getting-started">11.6.3. 入门</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#oauth2">12. OAuth2</a>
<ul class="sectlevel2">
<li><a href="#oauth2login">12.1. OAuth 2.0 登录</a>
<ul class="sectlevel3">
<li><a href="#oauth2login-sample-boot">12.1.1. Spring Boot 2.x 示例</a>
<ul class="sectlevel4">
<li><a href="#oauth2login-sample-initial-setup">初始设置</a></li>
<li><a href="#oauth2login-sample-redirect-uri">设置重定向URI</a></li>
<li><a href="#oauth2login-sample-application-config">配置application.yml</a></li>
<li><a href="#oauth2login-sample-boot-application">启动应用程序</a></li>
</ul>
</li>
<li><a href="#oauth2login-boot-property-mappings">12.1.2. Spring Boot 2.x 属性映射</a></li>
<li><a href="#oauth2login-common-oauth2-provider">12.1.3. CommonOAuth2Provider</a></li>
<li><a href="#oauth2login-custom-provider-properties">12.1.4. 配置自定义 提供者 属性</a></li>
<li><a href="#oauth2login-override-boot-autoconfig">12.1.5. 覆盖Spring Boot 2.x自动配置</a>
<ul class="sectlevel4">
<li><a href="#oauth2login-register-clientregistrationrepository-bean">注册一个 ClientRegistrationRepository @Bean</a></li>
<li><a href="#oauth2login-provide-websecurityconfigureradapter">Provide a WebSecurityConfigurerAdapter</a></li>
<li><a href="#oauth2login-completely-override-autoconfiguration">完全覆盖自动配置</a></li>
</ul>
</li>
<li><a href="#oauth2login-javaconfig-wo-boot">12.1.6. 低于 Spring Boot 2.x 使用 Java 配置</a></li>
<li><a href="#oauth2login-advanced">12.1.7. 高级配置</a>
<ul class="sectlevel4">
<li><a href="#oauth2login-advanced-login-page">OAuth 2.0 Login Page</a></li>
<li><a href="#oauth2login-advanced-redirection-endpoint">重定向端点</a></li>
<li><a href="#oauth2login-advanced-userinfo-endpoint">UserInfo Endpoint</a></li>
<li><a href="#oauth2login-advanced-idtoken-verify">ID令牌签名验证</a></li>
<li><a href="#oauth2login-advanced-oidc-logout">OpenID Connect 1.0 注销</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#oauth2client">12.2. OAuth 2.0 客户端</a>
<ul class="sectlevel3">
<li><a href="#oauth2Client-core-interface-class">12.2.1. 核心 "类和接口"</a>
<ul class="sectlevel4">
<li><a href="#oauth2Client-client-registration">ClientRegistration</a></li>
<li><a href="#oauth2Client-client-registration-repo">ClientRegistrationRepository</a></li>
<li><a href="#oauth2Client-authorized-client">OAuth2AuthorizedClient</a></li>
<li><a href="#oauth2Client-authorized-repo-service">OAuth2AuthorizedClientRepository / OAuth2AuthorizedClientService</a></li>
<li><a href="#oauth2Client-authorized-manager-provider">OAuth2AuthorizedClientManager / OAuth2AuthorizedClientProvider</a></li>
</ul>
</li>
<li><a href="#oauth2Client-auth-grant-support">12.2.2. 授权类型支持</a>
<ul class="sectlevel4">
<li><a href="#oauth2Client-auth-code-grant">Authorization Code  (授权码)</a></li>
<li><a href="#oauth2Client-refresh-token-grant">刷新 Token</a></li>
<li><a href="#oauth2Client-client-creds-grant">Client Credentials(客户端凭证)</a></li>
<li><a href="#oauth2Client-password-grant">资源所有者密码凭证</a></li>
</ul>
</li>
<li><a href="#oauth2Client-additional-features">12.2.3. 其他功能</a>
<ul class="sectlevel4">
<li><a href="#oauth2Client-registered-authorized-client">解析授权客户端</a></li>
</ul>
</li>
<li><a href="#oauth2Client-webclient-servlet">12.2.4. 在Servlet环境中集成WebClient</a>
<ul class="sectlevel4">
<li><a href="#提供授权客户端">提供授权客户端</a></li>
<li><a href="#默认授权客户端">默认授权客户端</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#oauth2resourceserver">12.3. OAuth 2.0 资源服务器</a>
<ul class="sectlevel3">
<li><a href="#oauth2resourceserver-jwt-minimalconfiguration">12.3.1. JWT 的最小配置</a>
<ul class="sectlevel4">
<li><a href="#指定授权服务器">指定授权服务器</a></li>
<li><a href="#启动预期">启动预期</a></li>
<li><a href="#运行时预期">运行时预期</a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-jwt-architecture">12.3.2. JWT Authentication 如何工作</a></li>
<li><a href="#oauth2resourceserver-jwt-jwkseturi">12.3.3. 直接指定授权服务器 JWK 设置 Uri</a></li>
<li><a href="#oauth2resourceserver-jwt-sansboot">12.3.4. 覆盖或替换引导自动配置</a>
<ul class="sectlevel4">
<li><a href="#oauth2resourceserver-jwt-jwkseturi-dsl">使用 <code>jwkSetUri()</code></a></li>
<li><a href="#oauth2resourceserver-jwt-decoder-dsl">使用 <code>decoder()</code></a></li>
<li><a href="#oauth2resourceserver-jwt-decoder-bean">暴露  <code>JwtDecoder</code> <code>@Bean</code></a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-jwt-decoder-algorithm">12.3.5. 配置可信算法</a>
<ul class="sectlevel4">
<li><a href="#oauth2resourceserver-jwt-boot-algorithm">通过Spring Boot</a></li>
<li><a href="#oauth2resourceserver-jwt-decoder-builder">使用 Builder</a></li>
<li><a href="#oauth2resourceserver-jwt-decoder-jwk-response">来自 JWK Set 的回复</a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-jwt-decoder-public-key">12.3.6. 信任单个非对称密钥</a>
<ul class="sectlevel4">
<li><a href="#oauth2resourceserver-jwt-decoder-public-key-boot">通过 Spring Boot</a></li>
<li><a href="#oauth2resourceserver-jwt-decoder-public-key-builder">使用 Builder</a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-jwt-decoder-secret-key">12.3.7. 信任单个对称密钥</a></li>
<li><a href="#oauth2resourceserver-jwt-authorization">12.3.8. 配置授权</a>
<ul class="sectlevel4">
<li><a href="#oauth2resourceserver-jwt-authorization-extraction">手动提取权限</a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-jwt-validation">12.3.9. 配置验证</a>
<ul class="sectlevel4">
<li><a href="#oauth2resourceserver-jwt-validation-clockskew">自定义时间戳验证</a></li>
<li><a href="#oauth2resourceserver-jwt-validation-custom">配置自定义验证器</a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-jwt-claimsetmapping">12.3.10. 配置 Claim (声明)集映射</a>
<ul class="sectlevel4">
<li><a href="#oauth2resourceserver-jwt-claimsetmapping-singleclaim">自定义单个 Claim 的转换</a></li>
<li><a href="#oauth2resourceserver-jwt-claimsetmapping-add">添加一个 Claim</a></li>
<li><a href="#oauth2resourceserver-jwt-claimsetmapping-remove">删除一个 Claim</a></li>
<li><a href="#oauth2resourceserver-jwt-claimsetmapping-rename">重命名一个 Claim</a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-jwt-timeouts">12.3.11. 配置超时</a></li>
<li><a href="#oauth2resourceserver-opaque-minimaldependencies">12.3.12. Minimal Dependencies for Introspection</a></li>
<li><a href="#oauth2resourceserver-opaque-minimalconfiguration">12.3.13. Introspection 最小配置</a>
<ul class="sectlevel4">
<li><a href="#oauth2resourceserver-opaque-introspectionuri">指定授权服务器</a></li>
<li><a href="#启动时预期">启动时预期</a></li>
<li><a href="#运行时预期-2">运行时预期</a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-opaque-architecture">12.3.14. Opaque Token Authentication 是如何工作的</a></li>
<li><a href="#oauth2resourceserver-opaque-attributes">12.3.15. 查找身份验证后的属性</a>
<ul class="sectlevel4">
<li><a href="#通过-spel-查找属性">通过 SpEL 查找属性</a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-opaque-sansboot">12.3.16. 覆盖或替换自动配置</a>
<ul class="sectlevel4">
<li><a href="#oauth2resourceserver-opaque-introspectionuri-dsl">使用 <code>introspectionUri()</code></a></li>
<li><a href="#oauth2resourceserver-opaque-introspector-dsl">使用 <code>introspector()</code></a></li>
<li><a href="#oauth2resourceserver-opaque-introspector-bean">暴露 <code>OpaqueTokenIntrospector</code> <code>@Bean</code></a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-opaque-authorization">12.3.17. 配置授权</a>
<ul class="sectlevel4">
<li><a href="#oauth2resourceserver-opaque-authorization-extraction">手动提取权限</a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-opaque-timeouts">12.3.18. 配置超时</a></li>
<li><a href="#oauth2resourceserver-opaque-jwt-introspector">12.3.19. 对JWT使用内省</a></li>
<li><a href="#oauth2resourceserver-opaque-userinfo">12.3.20. 调用 <code>/userinfo</code> 端点</a></li>
<li><a href="#oauth2reourceserver-opaqueandjwt">12.3.21. 同时支持 JWT 和 Opaque Token</a></li>
<li><a href="#oauth2resourceserver-multitenancy">12.3.22. 多租户</a>
<ul class="sectlevel4">
<li><a href="#通过-claim-解析租户">通过 Claim 解析租户</a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-bearertoken-resolver">12.3.23. Bearer Token 解析</a>
<ul class="sectlevel4">
<li><a href="#从自定义请求头读取-bearer-令牌">从自定义请求头读取 bearer 令牌</a></li>
<li><a href="#从表单参数读取-bearer-令牌">从表单参数读取 bearer 令牌</a></li>
</ul>
</li>
<li><a href="#bearer-token-传递">12.3.24. Bearer Token 传递</a>
<ul class="sectlevel4">
<li><a href="#resttemplate-支持"><code>RestTemplate</code> 支持</a></li>
</ul>
</li>
<li><a href="#oauth2resourceserver-bearertoken-failure">12.3.25. Bearer Token 失败</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#servlet-saml2">13. SAML2</a>
<ul class="sectlevel2">
<li><a href="#servlet-saml2login">13.1. SAML 2.0 Login</a>
<ul class="sectlevel3">
<li><a href="#servlet-saml2login-minimaldependencies">13.1.1. 最小依赖</a></li>
<li><a href="#servlet-saml2login-minimalconfiguration">13.1.2. 最小配置</a>
<ul class="sectlevel4">
<li><a href="#指定身份提供者元数据">指定身份提供者元数据</a></li>
<li><a href="#runtime-expectations">Runtime Expectations</a></li>
</ul>
</li>
<li><a href="#servlet-saml2login-architecture">13.1.3. Saml 2.0 登录如何与 OpenSAML 集成</a>
<ul class="sectlevel4">
<li><a href="#servlet-saml2login-opensaml-customization">自定义 OpenSAML 配置</a></li>
</ul>
</li>
<li><a href="#servlet-saml2login-sansboot">13.1.4. 如何覆盖或替换的 Spring Boot 自动配置</a></li>
<li><a href="#servlet-saml2login-relyingpartyregistration">13.1.5. RelyingPartyRegistration</a>
<ul class="sectlevel4">
<li><a href="#servlet-saml2login-rpr-uripatterns">URI 模式</a></li>
<li><a href="#servlet-saml2login-rpr-credentials">Credentials(凭据)</a></li>
<li><a href="#servlet-saml2login-rpr-relyingpartyregistrationresolver">解决请求中的 relying party</a></li>
<li><a href="#servlet-saml2login-rpr-duplicated">重复 Relying Party 配置</a></li>
</ul>
</li>
<li><a href="#servlet-saml2login-sp-initiated-factory">13.1.6. 生成 <code>&lt;saml2:AuthnRequest&gt;</code></a>
<ul class="sectlevel4">
<li><a href="#servlet-saml2login-sp-initiated-factory-signing">改变 <code>&lt;saml2:AuthnRequest&gt;</code> 的发送方式</a></li>
<li><a href="#servlet-saml2login-sp-initiated-factory-custom-authnrequest">自定义 OpenSAML 的 <code>AuthnRequest</code> 实例</a></li>
</ul>
</li>
<li><a href="#servlet-saml2login-authenticate-responses">13.1.7. Authenticating <code>&lt;saml2:Response&gt;</code></a>
<ul class="sectlevel4">
<li><a href="#servlet-saml2login-opensamlauthenticationprovider-clockskew">设置 Clock Skew</a></li>
<li><a href="#servlet-saml2login-opensamlauthenticationprovider-userdetailsservice">与  <code>UserDetailsService</code> 关联</a></li>
<li><a href="#servlet-saml2login-opensamlauthenticationprovider-additionalvalidation">执行额外验证</a></li>
<li><a href="#servlet-saml2login-authenticationmanager-custom">使用自定义 Authentication Manager</a></li>
</ul>
</li>
<li><a href="#servlet-saml2login-authenticatedprincipal">13.1.8. 使用 <code>Saml2AuthenticatedPrincipal</code></a></li>
<li><a href="#servlet-saml2login-metadata">13.1.9. 生成 <code>&lt;saml2:SPSSODescriptor&gt;</code> 元数据</a></li>
<li><a href="#servlet-saml2login-logout">13.1.10. 执行单次注销</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#servlet-exploits">14. 防御利用漏洞</a>
<ul class="sectlevel2">
<li><a href="#servlet-csrf">14.1. Servlet环境的跨站点请求伪造(CSRF)</a>
<ul class="sectlevel3">
<li><a href="#servlet-csrf-using">14.1.1. 使用 Spring Security 保护 CSRF</a>
<ul class="sectlevel4">
<li><a href="#servlet-csrf-idempotent">使用正确的HTTP动词</a></li>
<li><a href="#servlet-csrf-configure">配置防御CSRF</a></li>
<li><a href="#servlet-csrf-include">包括CSRF令牌</a></li>
</ul>
</li>
<li><a href="#servlet-csrf-considerations">14.1.2. CSRF 注意事项</a>
<ul class="sectlevel4">
<li><a href="#servlet-considerations-csrf-login">登录</a></li>
<li><a href="#servlet-considerations-csrf-logout">注销</a></li>
<li><a href="#servlet-considerations-csrf-timeouts">CSRF 和 Session 超时</a></li>
<li><a href="#servlet-csrf-considerations-multipart">Multipart (文件上传)</a></li>
<li><a href="#servlet-csrf-considerations-override-method">HiddenHttpMethodFilter</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#servlet-headers">14.2. 安全HTTP响应头</a>
<ul class="sectlevel3">
<li><a href="#servlet-headers-default">14.2.1. 默认安全请求头</a></li>
<li><a href="#servlet-headers-cache-control">14.2.2. 缓存控制</a></li>
<li><a href="#servlet-headers-content-type-options">14.2.3. Content Type 选项</a></li>
<li><a href="#servlet-headers-hsts">14.2.4. HTTP Strict Transport Security (HSTS)</a></li>
<li><a href="#servlet-headers-hpkp">14.2.5. HTTP Public Key Pinning (HPKP)</a></li>
<li><a href="#servlet-headers-frame-options">14.2.6. X-Frame-Options</a></li>
<li><a href="#servlet-headers-xss-protection">14.2.7. X-XSS-Protection</a></li>
<li><a href="#servlet-headers-csp">14.2.8. Content Security Policy (CSP)</a></li>
<li><a href="#servlet-headers-referrer">14.2.9. 推荐人策略</a></li>
<li><a href="#servlet-headers-feature">14.2.10. Feature Policy (功能策略)</a></li>
<li><a href="#servlet-headers-clear-site-data">14.2.11. 清除站点数据</a></li>
<li><a href="#servlet-headers-custom">14.2.12. 自定义 Headers</a>
<ul class="sectlevel4">
<li><a href="#servlet-headers-static">Static Headers</a></li>
<li><a href="#servlet-headers-writer">Headers Writer</a></li>
<li><a href="#headers-delegatingrequestmatcherheaderwriter">DelegatingRequestMatcherHeaderWriter</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#servlet-http">14.3. HTTP</a>
<ul class="sectlevel3">
<li><a href="#servlet-http-redirect">14.3.1. 重定向 HTTPS</a></li>
<li><a href="#servlet-hsts">14.3.2. 严格的安全传输</a></li>
<li><a href="#servlet-http-proxy-server">14.3.3. 代理服务器配置</a></li>
</ul>
</li>
<li><a href="#servlet-httpfirewall">14.4. HttpFirewall</a></li>
</ul>
</li>
<li><a href="#集成">15. 集成</a>
<ul class="sectlevel2">
<li><a href="#servletapi">15.1. Servlet API 整合</a>
<ul class="sectlevel3">
<li><a href="#servletapi-25">15.1.1. Servlet 2.5+ 整合</a>
<ul class="sectlevel4">
<li><a href="#servletapi-remote-user">HttpServletRequest.getRemoteUser()</a></li>
<li><a href="#servletapi-user-principal">HttpServletRequest.getUserPrincipal()</a></li>
<li><a href="#servletapi-user-in-role">HttpServletRequest.isUserInRole(String)</a></li>
</ul>
</li>
<li><a href="#servletapi-3">15.1.2. Servlet 3+ 整合</a>
<ul class="sectlevel4">
<li><a href="#servletapi-authenticate">HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)</a></li>
<li><a href="#servletapi-login">HttpServletRequest.login(String,String)</a></li>
<li><a href="#servletapi-logout">HttpServletRequest.logout()</a></li>
<li><a href="#servletapi-start-runnable">AsyncContext.start(Runnable)</a></li>
<li><a href="#servletapi-async">异步 Servlet 支持</a></li>
</ul>
</li>
<li><a href="#servletapi-31">15.1.3. Servlet 3.1+ 整合</a>
<ul class="sectlevel4">
<li><a href="#servletapi-change-session-id">HttpServletRequest#changeSessionId()</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#data">15.2. Spring Data 集成</a>
<ul class="sectlevel3">
<li><a href="#data-configuration">15.2.1. Spring Data &amp; Spring Security 配置</a></li>
<li><a href="#data-query">15.2.2. Security Expressions within @Query</a></li>
</ul>
</li>
<li><a href="#concurrency">15.3. 并发支持</a>
<ul class="sectlevel3">
<li><a href="#delegatingsecuritycontextrunnable">15.3.1. DelegatingSecurityContextRunnable</a></li>
<li><a href="#delegatingsecuritycontextexecutor">15.3.2. DelegatingSecurityContextExecutor</a></li>
<li><a href="#spring-security-concurrency-classes">15.3.3. Spring Security Concurrency Classes</a></li>
</ul>
</li>
<li><a href="#jackson">15.4. Jackson 支持</a></li>
<li><a href="#localization">15.5. 国际化</a></li>
<li><a href="#mvc">15.6. Spring MVC 整合</a>
<ul class="sectlevel3">
<li><a href="#mvc-enablewebmvcsecurity">15.6.1. @EnableWebMvcSecurity</a></li>
<li><a href="#mvc-requestmatcher">15.6.2. MvcRequestMatcher</a></li>
<li><a href="#mvc-authentication-principal">15.6.3. @AuthenticationPrincipal</a></li>
<li><a href="#mvc-async">15.6.4. Spring MVC 异步整合</a></li>
<li><a href="#mvc-csrf">15.6.5. Spring MVC 和 CSRF 整合</a>
<ul class="sectlevel4">
<li><a href="#自动包含令牌">自动包含令牌</a></li>
<li><a href="#mvc-csrf-resolver">CsrfToken 解析</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#websocket">15.7. WebSocket 安全</a>
<ul class="sectlevel3">
<li><a href="#websocket-configuration">15.7.1. WebSocket 配置</a></li>
<li><a href="#websocket-authentication">15.7.2. WebSocket 认证</a></li>
<li><a href="#websocket-authorization">15.7.3. WebSocket 授权</a>
<ul class="sectlevel4">
<li><a href="#websocket-authorization-notes">WebSocket授权说明</a></li>
<li><a href="#websocket-authorization-notes-outbound">出站邮件</a></li>
</ul>
</li>
<li><a href="#websocket-sameorigin">15.7.4. 强制同源策略</a>
<ul class="sectlevel4">
<li><a href="#websocket-sameorigin-why">为什么同源?</a></li>
<li><a href="#websocket-sameorigin-spring">Spring WebSocket允许的来源</a></li>
<li><a href="#websocket-sameorigin-csrf">将 CSRF 添加到 Stomp 头</a></li>
<li><a href="#websocket-sameorigin-disable">在WebSockets中禁用CSRF</a></li>
</ul>
</li>
<li><a href="#websocket-sockjs">15.7.5. 使用SockJS</a>
<ul class="sectlevel4">
<li><a href="#websocket-sockjs-sameorigin">SockJS &amp; frame-options</a></li>
<li><a href="#websocket-sockjs-csrf">SockJS &amp; 放宽CSRF</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#cors">15.8. CORS</a></li>
<li><a href="#taglibs">15.9. JSP 标签库</a>
<ul class="sectlevel3">
<li><a href="#declaring-the-taglib">15.9.1. Declaring the Taglib</a></li>
<li><a href="#taglibs-authorize">15.9.2. 授权标签</a>
<ul class="sectlevel4">
<li><a href="#禁用测试的授权标签">禁用测试的授权标签</a></li>
</ul>
</li>
<li><a href="#authentication-标签">15.9.3. authentication 标签</a></li>
<li><a href="#accesscontrollist-标签">15.9.4. accesscontrollist 标签</a></li>
<li><a href="#taglibs-csrfinput">15.9.5. csrfInput 标签</a></li>
<li><a href="#taglibs-csrfmeta">15.9.6. csrfMetaTags 标签</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#jc">16. Java Configuration</a>
<ul class="sectlevel2">
<li><a href="#hello-web-security-java配置">16.1. Hello Web Security Java配置</a>
<ul class="sectlevel3">
<li><a href="#abstractsecuritywebapplicationinitializer">16.1.1. AbstractSecurityWebApplicationInitializer</a></li>
<li><a href="#abstractsecuritywebapplicationinitializer-without-existing-spring">16.1.2. 没有 Spring 的 AbstractSecurityWebApplicationInitializer</a></li>
<li><a href="#abstractsecuritywebapplicationinitializer-with-spring-mvc">16.1.3. Spring MVC 的 AbstractSecurityWebApplicationInitializer</a></li>
</ul>
</li>
<li><a href="#jc-httpsecurity">16.2. HttpSecurity</a></li>
<li><a href="#multiple-httpsecurity">16.3. Multiple HttpSecurity</a></li>
<li><a href="#jc-custom-dsls">16.4. 自定义 DSLs</a></li>
<li><a href="#post-processing-configured-objects">16.5. 配置对象后置处理器</a></li>
</ul>
</li>
<li><a href="#kotlin-config">17. Kotlin Configuration</a>
<ul class="sectlevel2">
<li><a href="#kotlin-config-httpsecurity">17.1. HttpSecurity</a></li>
<li><a href="#多个-httpsecurity">17.2. 多个 HttpSecurity</a></li>
</ul>
</li>
<li><a href="#ns-config">18. Security 命名空间配置</a>
<ul class="sectlevel2">
<li><a href="#介绍-2">18.1. 介绍</a>
<ul class="sectlevel3">
<li><a href="#命名空间的设计">18.1.1. 命名空间的设计</a></li>
</ul>
</li>
<li><a href="#ns-getting-started">18.2. security 命名空间配置入门</a>
<ul class="sectlevel3">
<li><a href="#ns-web-xml">18.2.1. web.xml 配置</a></li>
<li><a href="#ns-minimal">18.2.2. 最小化 &lt;http&gt; 配置</a>
<ul class="sectlevel4">
<li><a href="#ns-form-target">设置默认的登录后目标</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#ns-web-advanced">18.3. 高级 Web 功能</a>
<ul class="sectlevel3">
<li><a href="#ns-custom-filters">18.3.1. 添加自己的过滤器</a></li>
</ul>
</li>
<li><a href="#ns-method-security">18.4. 安全方法</a></li>
<li><a href="#ns-access-manager">18.5. 默认 AccessDecisionManager</a>
<ul class="sectlevel3">
<li><a href="#ns-custom-access-mgr">18.5.1. 自定义 AccessDecisionManager</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#test">19. 测试</a>
<ul class="sectlevel2">
<li><a href="#test-method">19.1. 测试安全方法</a>
<ul class="sectlevel3">
<li><a href="#test-method-setup">19.1.1. 安全测试设置</a></li>
<li><a href="#test-method-withmockuser">19.1.2. @WithMockUser</a></li>
<li><a href="#test-method-withanonymoususer">19.1.3. @WithAnonymousUser</a></li>
<li><a href="#test-method-withuserdetails">19.1.4. @WithUserDetails</a></li>
<li><a href="#test-method-withsecuritycontext">19.1.5. @WithSecurityContext</a></li>
<li><a href="#test-method-meta-annotations">19.1.6. 测试元注解</a></li>
</ul>
</li>
<li><a href="#test-mockmvc">19.2. Spring MVC 集成测试</a>
<ul class="sectlevel3">
<li><a href="#test-mockmvc-setup">19.2.1. 设置MockMvc和Spring Security</a></li>
<li><a href="#test-mockmvc-smmrpp">19.2.2. SecurityMockMvcRequestPostProcessors</a>
<ul class="sectlevel4">
<li><a href="#test-mockmvc-csrf">使用 CSRF 保护进行测试</a></li>
<li><a href="#test-mockmvc-securitycontextholder">在 Spring MVC 测试中以用户身份运行测试</a></li>
<li><a href="#test-mockmvc-securitycontextholder-rpp">在 Spring MVC Test 中使用 RequestPostProcessor 以用户身份运行</a></li>
<li><a href="#测试-http-基本身份验证">测试 HTTP 基本身份验证</a></li>
<li><a href="#testing-oauth2">测试 OAuth 2.0</a></li>
<li><a href="#testing-oidc-login">Testing OIDC Login</a></li>
<li><a href="#testing-oauth2-login">测试 OAuth 2.0 登录</a></li>
<li><a href="#testing-oauth2-client">测试 OAuth 2.0 客户端</a></li>
<li><a href="#testing-jwt">测试 JWT 认证</a></li>
<li><a href="#testing-opaque-token">测试 Opaque Token 认证</a></li>
<li><a href="#test-logout">测试注销</a></li>
</ul>
</li>
<li><a href="#securitymockmvcresultmatchers">19.2.3. SecurityMockMvcResultMatchers</a>
<ul class="sectlevel4">
<li><a href="#未经身份验证的断言">未经身份验证的断言</a></li>
<li><a href="#认证断言">认证断言</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#crypto">20. Spring Security 加密 模块</a>
<ul class="sectlevel2">
<li><a href="#spring-security-crypto-introduction">20.1. 简介</a></li>
<li><a href="#spring-security-crypto-encryption">20.2. Encryptors(加密器)</a>
<ul class="sectlevel3">
<li><a href="#spring-security-crypto-encryption-bytes">20.2.1. BytesEncryptor</a></li>
<li><a href="#spring-security-crypto-encryption-text">20.2.2. TextEncryptor</a></li>
</ul>
</li>
<li><a href="#spring-security-crypto-keygenerators">20.3. 密钥生成器</a>
<ul class="sectlevel3">
<li><a href="#byteskeygenerator">20.3.1. BytesKeyGenerator</a></li>
<li><a href="#stringkeygenerator">20.3.2. StringKeyGenerator</a></li>
</ul>
</li>
<li><a href="#spring-security-crypto-passwordencoders">20.4. Password Encoding</a></li>
</ul>
</li>
<li><a href="#附录">21. 附录</a>
<ul class="sectlevel2">
<li><a href="#appendix-schema">21.1. Security Database Schema</a>
<ul class="sectlevel3">
<li><a href="#user-schema">21.1.1. User Schema</a>
<ul class="sectlevel4">
<li><a href="#oracle-数据库">Oracle 数据库</a></li>
<li><a href="#组授权">组授权</a></li>
</ul>
</li>
<li><a href="#永久登录-记住我-schema">21.1.2. 永久登录 (记住我)  Schema</a></li>
<li><a href="#dbschema-acl">21.1.3. ACL Schema</a>
<ul class="sectlevel4">
<li><a href="#hypersql">HyperSQL</a></li>
<li><a href="#postgresql">PostgreSQL</a></li>
<li><a href="#microsoft-sql-server">Microsoft SQL Server</a></li>
<li><a href="#oracle-database">Oracle Database</a></li>
</ul>
</li>
<li><a href="#dbschema-oauth2-client">21.1.4. OAuth 2.0 Client Schema</a></li>
</ul>
</li>
<li><a href="#appendix-namespace">21.2. Security 命名空间</a>
<ul class="sectlevel3">
<li><a href="#nsa-web">21.2.1. Web Application Security</a>
<ul class="sectlevel4">
<li><a href="#nsa-debug">&lt;debug&gt;</a></li>
<li><a href="#nsa-http">&lt;http&gt;</a></li>
<li><a href="#nsa-access-denied-handler">&lt;access-denied-handler&gt;</a></li>
<li><a href="#nsa-cors">&lt;cors&gt;</a></li>
<li><a href="#nsa-headers">&lt;headers&gt;</a></li>
<li><a href="#nsa-cache-control">&lt;cache-control&gt;</a></li>
<li><a href="#nsa-hsts">&lt;hsts&gt;</a></li>
<li><a href="#nsa-hpkp">&lt;hpkp&gt;</a></li>
<li><a href="#nsa-pins">&lt;pins&gt;</a></li>
<li><a href="#nsa-pin">&lt;pin&gt;</a></li>
<li><a href="#nsa-content-security-policy">&lt;content-security-policy&gt;</a></li>
<li><a href="#nsa-referrer-policy">&lt;referrer-policy&gt;</a></li>
<li><a href="#nsa-feature-policy">&lt;feature-policy&gt;</a></li>
<li><a href="#nsa-frame-options">&lt;frame-options&gt;</a></li>
<li><a href="#nsa-xss-protection">&lt;xss-protection&gt;</a></li>
<li><a href="#nsa-content-type-options">&lt;content-type-options&gt;</a></li>
<li><a href="#nsa-header">&lt;header&gt;</a></li>
<li><a href="#nsa-anonymous">&lt;anonymous&gt;</a></li>
<li><a href="#nsa-csrf">&lt;csrf&gt;</a></li>
<li><a href="#nsa-custom-filter">&lt;custom-filter&gt;</a></li>
<li><a href="#nsa-expression-handler">&lt;expression-handler&gt;</a></li>
<li><a href="#nsa-form-login">&lt;form-login&gt;</a></li>
<li><a href="#nsa-oauth2-login">&lt;oauth2-login&gt;</a></li>
<li><a href="#nsa-oauth2-client">&lt;oauth2-client&gt;</a></li>
<li><a href="#nsa-authorization-code-grant">&lt;authorization-code-grant&gt;</a></li>
<li><a href="#nsa-client-registrations">&lt;client-registrations&gt;</a></li>
<li><a href="#nsa-client-registration">&lt;client-registration&gt;</a></li>
<li><a href="#nsa-provider">&lt;provider&gt;</a></li>
<li><a href="#nsa-oauth2-resource-server">&lt;oauth2-resource-server&gt;</a></li>
<li><a href="#nsa-jwt">&lt;jwt&gt;</a></li>
<li><a href="#nsa-opaque-token">&lt;opaque-token&gt;</a></li>
<li><a href="#nsa-http-basic">&lt;http-basic&gt;</a></li>
<li><a href="#nsa-http-firewall">&lt;http-firewall&gt; 元素</a></li>
<li><a href="#nsa-intercept-url">&lt;intercept-url&gt;</a></li>
<li><a href="#nsa-jee">&lt;jee&gt;</a></li>
<li><a href="#nsa-logout">&lt;logout&gt;</a></li>
<li><a href="#nsa-openid-login">&lt;openid-login&gt;</a></li>
<li><a href="#nsa-attribute-exchange">&lt;attribute-exchange&gt;</a></li>
<li><a href="#nsa-openid-attribute">&lt;openid-attribute&gt;</a></li>
<li><a href="#nsa-port-mappings">&lt;port-mappings&gt;</a></li>
<li><a href="#nsa-port-mapping">&lt;port-mapping&gt;</a></li>
<li><a href="#nsa-remember-me">&lt;remember-me&gt;</a></li>
<li><a href="#nsa-request-cache">&lt;request-cache&gt; 元素</a></li>
<li><a href="#nsa-session-management">&lt;session-management&gt;</a></li>
<li><a href="#nsa-concurrency-control">&lt;concurrency-control&gt;</a></li>
<li><a href="#nsa-x509">&lt;x509&gt;</a></li>
<li><a href="#nsa-filter-chain-map">&lt;filter-chain-map&gt;</a></li>
<li><a href="#nsa-filter-chain">&lt;filter-chain&gt;</a></li>
<li><a href="#nsa-filter-security-metadata-source">&lt;filter-security-metadata-source&gt;</a></li>
</ul>
</li>
<li><a href="#nsa-websocket-security">21.2.2. WebSocket Security</a>
<ul class="sectlevel4">
<li><a href="#nsa-websocket-message-broker">&lt;websocket-message-broker&gt;</a></li>
<li><a href="#nsa-intercept-message">&lt;intercept-message&gt;</a></li>
</ul>
</li>
<li><a href="#nsa-authentication">21.2.3. Authentication Services</a>
<ul class="sectlevel4">
<li><a href="#nsa-authentication-manager">&lt;authentication-manager&gt;</a></li>
<li><a href="#nsa-authentication-provider">&lt;authentication-provider&gt;</a></li>
<li><a href="#nsa-jdbc-user-service">&lt;jdbc-user-service&gt;</a></li>
<li><a href="#nsa-password-encoder">&lt;password-encoder&gt;</a></li>
<li><a href="#nsa-user-service">&lt;user-service&gt;</a></li>
<li><a href="#nsa-user">&lt;user&gt;</a></li>
</ul>
</li>
<li><a href="#nsa-method-security">21.2.4. Method Security</a>
<ul class="sectlevel4">
<li><a href="#nsa-global-method-security">&lt;global-method-security&gt;</a></li>
<li><a href="#nsa-after-invocation-provider">&lt;after-invocation-provider&gt;</a></li>
<li><a href="#nsa-pre-post-annotation-handling">&lt;pre-post-annotation-handling&gt;</a></li>
<li><a href="#nsa-invocation-attribute-factory">&lt;invocation-attribute-factory&gt;</a></li>
<li><a href="#nsa-post-invocation-advice">&lt;post-invocation-advice&gt;</a></li>
<li><a href="#nsa-pre-invocation-advice">&lt;pre-invocation-advice&gt;</a></li>
<li><a href="#nsa-protect-pointcut">Securing Methods using</a></li>
<li><a href="#nsa-intercept-methods">&lt;intercept-methods&gt;</a></li>
<li><a href="#nsa-method-security-metadata-source">&lt;method-security-metadata-source&gt;</a></li>
<li><a href="#nsa-protect">&lt;protect&gt;</a></li>
</ul>
</li>
<li><a href="#nsa-ldap">21.2.5. LDAP Namespace 选项</a>
<ul class="sectlevel4">
<li><a href="#nsa-ldap-server">Defining the LDAP Server using the</a></li>
<li><a href="#nsa-ldap-authentication-provider">&lt;ldap-authentication-provider&gt;</a></li>
<li><a href="#nsa-password-compare">&lt;password-compare&gt;</a></li>
<li><a href="#nsa-ldap-user-service">&lt;ldap-user-service&gt;</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#appendix-faq">21.3. Spring Security常见问题解答</a>
<ul class="sectlevel3">
<li><a href="#appendix-faq-general-questions">21.3.1. 一般问题</a>
<ul class="sectlevel4">
<li><a href="#appendix-faq-other-concerns">Spring Security 会满足我所有的应用程序安全性要求吗?</a></li>
<li><a href="#appendix-faq-web-xml">为什么不仅仅使用 web.xml 安全性?</a></li>
<li><a href="#appendix-faq-requirements">需要哪些 Java 和 Spring Framework 版本?</a></li>
<li><a href="#appendix-faq-start-simple">我是 Spring Security 的新手,我需要构建一个支持通过 HTTPS 进行 CAS 单一登录的应用程序,同时允许对某些 URL 在本地进行基本身份验证,并针对多个后端用户信息源 (LDAP 和 JDBC) 进行身份验证.  我已经复制了一些找到的配置文件,但是没有用.</a></li>
</ul>
</li>
<li><a href="#appendix-faq-common-problems">21.3.2. 常见问题</a>
<ul class="sectlevel4">
<li><a href="#appendix-faq-bad-credentials">当我尝试登录时,出现一条错误消息,提示"Bad Credentials".  怎么了?</a></li>
<li><a href="#appendix-faq-login-loop">当我尝试登录时,我的应用程序进入 "endless loop(无限循环)",这是怎么回事?</a></li>
<li><a href="#appendix-faq-anon-access-denied">我收到一条消息 "访问被拒绝 (用户是匿名用户) " 的异常. 怎么了?</a></li>
<li><a href="#appendix-faq-cached-secure-page">为什么即使我退出了应用程序,仍然可以看到受保护的页面?</a></li>
<li><a href="#auth-exception-credentials-not-found">我收到一条消息  "An Authentication object was not found in the SecurityContext" 的异常. 怎么了?</a></li>
<li><a href="#appendix-faq-ldap-authentication">我无法使用 LDAP 身份验证.</a></li>
<li><a href="#会话管理">会话管理</a></li>
<li><a href="#appendix-faq-concurrent-session-same-browser">我正在使用 Spring Security 的并发会话控制来防止用户一次登录多次.</a></li>
<li><a href="#appendix-faq-new-session-on-authentication">通过 Spring Security 进行身份验证时,为什么会话 ID 会更改?</a></li>
<li><a href="#appendix-faq-tomcat-https-session">我正在使用 Tomcat (或其他一些 servlet 容器) ,并且已为登录页面启用 HTTPS,然后再切换回 HTTP.</a></li>
<li><a href="#我没有在http和https之间切换但是我的会话仍然丢失">我没有在HTTP和HTTPS之间切换,但是我的会话仍然丢失</a></li>
<li><a href="#appendix-faq-session-listener-missing">我正在尝试使用并发会话控制支持,但是即使我确定我已经注销并且没有超出允许的会话,它也不允许我重新登录.</a></li>
<li><a href="#appendix-faq-unwanted-session-creation">通过将 create-session 属性设置为 never,即使我未配置,Spring Security 也会在某个地方创建会话.</a></li>
<li><a href="#appendix-faq-forbidden-csrf">执行POST时收到403 Forbidden</a></li>
<li><a href="#appendix-faq-no-security-on-forward">我正在使用RequestDispatcher将请求转发到另一个URL,但没有应用我的安全约束.</a></li>
<li><a href="#appendix-faq-method-security-in-web-context">我已经在应用程序上下文中添加了 Spring Security 的 &lt;global-method-security&gt; 元素,但是如果我在 Spring MVC 控制器bean (Struts 操作等) 中添加了安全注解,那么它们似乎没有效果.</a></li>
<li><a href="#appendix-faq-no-filters-no-context">我有一个已经通过身份验证的用户,但是当我在某些请求期间尝试访问 SecurityContextHolder 时,<code>Authentication</code> 为 null.</a></li>
<li><a href="#appendix-faq-method-security-with-taglib">使用 URL 属性时,授权 JSP 标记不遵守我的方法安全注解.</a></li>
</ul>
</li>
<li><a href="#appendix-faq-architecture">21.3.3. Spring Security Architecture Questions</a>
<ul class="sectlevel4">
<li><a href="#appendix-faq-where-is-class-x">我怎么知道 X 属于哪个包类?</a></li>
<li><a href="#appendix-faq-namespace-to-bean-mapping">命名空间元素如何映射到常规 bean 配置?</a></li>
<li><a href="#appendix-faq-role-prefix">"ROLE_" 是什么意思,为什么我在角色名称上需要它?</a></li>
<li><a href="#appendix-faq-what-dependencies">我如何知道要添加到我的应用程序中的哪些依赖才能与 Spring Security 一起使用?</a></li>
<li><a href="#appendix-faq-apacheds-deps">运行嵌入式 ApacheDS LDAP 服务器需要什么依赖?</a></li>
<li><a href="#appendix-faq-what-is-userdetailservice">什么是 UserDetailsService,我需要一个吗?</a></li>
</ul>
</li>
<li><a href="#appendix-faq-howto">21.3.4. 常见的 "操作方法" 请求</a>
<ul class="sectlevel4">
<li><a href="#appendix-faq-extra-login-fields">我需要登录的信息不仅仅是用户名.</a></li>
<li><a href="#appendix-faq-matching-url-fragments">在只有所请求的 URL 的片段值不同的地方 (e.g./foo#bar and /foo#blah?) ,我如何应用不同的拦截URL约束?</a></li>
<li><a href="#appendix-faq-request-details-in-user-service">如何在 UserDetailsService 中访问用户的IP地址 (或其他网络请求数据) ?</a></li>
<li><a href="#appendix-faq-access-session-from-user-service">如何从UserDetailsService访问HttpSession?</a></li>
<li><a href="#appendix-faq-password-in-user-service">如何在UserDetailsService中访问用户密码?</a></li>
<li><a href="#appendix-faq-dynamic-url-metadata">如何动态定义应用程序中的安全 URL?</a></li>
<li><a href="#appendix-faq-ldap-authorities">如何针对LDAP进行身份验证,但如何从数据库中加载用户角色?</a></li>
<li><a href="#appendix-faq-namespace-post-processor">我想修改由命名空间创建的 bean 的属性,但是架构中没有任何东西可以支持它.</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#reactive-应用程序">Reactive 应用程序</a>
<ul class="sectlevel1">
<li><a href="#jc-webflux">22. WebFlux Security</a>
<ul class="sectlevel2">
<li><a href="#最小化-webflux-security-配置">22.1. 最小化 WebFlux Security 配置</a></li>
<li><a href="#显式-webflux-security-配置">22.2. 显式 WebFlux Security 配置</a></li>
</ul>
</li>
<li><a href="#防止利用漏洞">23. 防止利用漏洞</a>
<ul class="sectlevel2">
<li><a href="#webflux-csrf">23.1. WebFlux环境的跨站点请求伪造 (CSRF)</a>
<ul class="sectlevel3">
<li><a href="#webflux-csrf-using">23.1.1. 使用Spring Security CSRF保护</a>
<ul class="sectlevel4">
<li><a href="#webflux-csrf-idempotent">使用正确的HTTP动词</a></li>
<li><a href="#webflux-csrf-configure">配置CSRF保护</a></li>
<li><a href="#webflux-csrf-include">包括 CSRF 令牌</a></li>
</ul>
</li>
<li><a href="#webflux-csrf-considerations">23.1.2. CSRF 注意事项</a>
<ul class="sectlevel4">
<li><a href="#webflux-considerations-csrf-login">登录</a></li>
<li><a href="#webflux-considerations-csrf-logout">注销</a></li>
<li><a href="#webflux-considerations-csrf-timeouts">CSRF 和会话超时</a></li>
<li><a href="#webflux-csrf-considerations-multipart">Multipart (文件上传)</a></li>
<li><a href="#webflux-csrf-considerations-override-method">HiddenHttpMethodFilter</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-headers">23.2. 安全HTTP响应头</a>
<ul class="sectlevel3">
<li><a href="#webflux-headers-default">23.2.1. 默认安全头</a></li>
<li><a href="#webflux-headers-cache-control">23.2.2. Cache Control</a></li>
<li><a href="#webflux-headers-content-type-options">23.2.3. Content Type 选项</a></li>
<li><a href="#webflux-headers-hsts">23.2.4. HTTP Strict Transport Security (HSTS)</a></li>
<li><a href="#webflux-headers-frame-options">23.2.5. X-Frame-Options</a></li>
<li><a href="#webflux-headers-xss-protection">23.2.6. X-XSS-Protection</a></li>
<li><a href="#webflux-headers-csp">23.2.7. Content Security Policy (CSP)</a></li>
<li><a href="#webflux-headers-referrer">23.2.8. 推荐人策略</a></li>
<li><a href="#webflux-headers-feature">23.2.9. Feature Policy (功能策略)</a>
<ul class="sectlevel4">
<li><a href="#webflux-headers-clear-site-data">配置内容安全策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-http">23.3. HTTP</a>
<ul class="sectlevel3">
<li><a href="#webflux-http-redirect">23.3.1. 重定向 HTTPS</a></li>
<li><a href="#webflux-hsts">23.3.2. 严格的安全传输</a></li>
<li><a href="#webflux-http-proxy-server">23.3.3. 代理服务器配置</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-oauth2">24. OAuth2 WebFlux</a>
<ul class="sectlevel2">
<li><a href="#webflux-oauth2-login">24.1. OAuth 2.0 Login</a>
<ul class="sectlevel3">
<li><a href="#webflux-oauth2-login-sample">24.1.1. Spring Boot 2.0 示例</a>
<ul class="sectlevel4">
<li><a href="#webflux-oauth2-login-sample-setup">初始设置</a></li>
<li><a href="#webflux-oauth2-login-sample-redirect">设置重定向URI</a></li>
<li><a href="#webflux-oauth2-login-sample-config">Configure <code>application.yml</code></a></li>
<li><a href="#webflux-oauth2-login-sample-start">启动应用程序</a></li>
</ul>
</li>
<li><a href="#webflux-oauth2-login-openid-provider-configuration">24.1.2. 使用OpenID提供程序配置</a></li>
<li><a href="#webflux-oauth2-login-explicit">24.1.3. 显式 OAuth2 登录配置</a></li>
</ul>
</li>
<li><a href="#webflux-oauth2-client">24.2. OAuth2 客户端</a></li>
<li><a href="#webflux-oauth2-resource-server">24.3. OAuth 2.0 资源服务器</a>
<ul class="sectlevel3">
<li><a href="#webflux-oauth2resourceserver-jwt-minimaldependencies">24.3.1. JWT 的最小配置</a></li>
<li><a href="#webflux-oauth2resourceserver-jwt-minimalconfiguration">24.3.2. JWT 的最小配置</a>
<ul class="sectlevel4">
<li><a href="#指定授权服务器-2">指定授权服务器</a></li>
<li><a href="#启动预期-2">启动预期</a></li>
<li><a href="#运行时预期-3">运行时预期</a></li>
<li><a href="#webflux-oauth2resourceserver-jwt-jwkseturi">直接指定授权服务器JWK设置Uri</a></li>
<li><a href="#webflux-oauth2resourceserver-jwt-sansboot">覆盖或替换引导自动配置</a></li>
</ul>
</li>
<li><a href="#webflux-oauth2resourceserver-jwt-decoder-algorithm">24.3.3. 配置可信算法</a>
<ul class="sectlevel4">
<li><a href="#webflux-oauth2resourceserver-jwt-boot-algorithm">通过 Spring Boot</a></li>
<li><a href="#webflux-oauth2resourceserver-jwt-decoder-builder">使用 Builder</a></li>
<li><a href="#webflux-oauth2resourceserver-jwt-decoder-public-key">信任单个非对称密钥</a></li>
<li><a href="#webflux-oauth2resourceserver-jwt-decoder-secret-key">信任单个对称密钥</a></li>
<li><a href="#webflux-oauth2resourceserver-jwt-authorization">配置授权</a></li>
<li><a href="#webflux-oauth2resourceserver-jwt-validation">配置验证</a></li>
<li><a href="#webflux-oauth2resourceserver-opaque-minimaldependencies">Introspection 最小配置</a></li>
<li><a href="#webflux-oauth2resourceserver-opaque-minimalconfiguration">Introspection 最小配置</a></li>
<li><a href="#webflux-oauth2resourceserver-opaque-attributes">查找身份验证后的属性</a></li>
<li><a href="#webflux-oauth2resourceserver-opaque-sansboot">覆盖或替换自动配置</a></li>
<li><a href="#webflux-oauth2resourceserver-opaque-authorization">配置授权</a></li>
<li><a href="#webflux-oauth2resourceserver-opaque-jwt-introspector">对 JWT 使用内省</a></li>
<li><a href="#webflux-oauth2resourceserver-opaque-userinfo">调用 <code>/userinfo</code> 端点</a></li>
</ul>
</li>
<li><a href="#webflux-oauth2resourceserver-multitenancy">24.3.4. 多租户</a>
<ul class="sectlevel4">
<li><a href="#通过-claim-解析租户-2">通过 Claim 解析租户</a></li>
</ul>
</li>
<li><a href="#webflux-oauth2resourceserver-bearertoken-resolver">24.3.5. Bearer Token Resolution</a></li>
<li><a href="#bearer-token-传播">24.3.6. Bearer Token 传播</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#webflux-roac">25. @RegisteredOAuth2AuthorizedClient</a></li>
<li><a href="#reactive-x509">26. Reactive X.509 认证</a></li>
<li><a href="#webclient">27. WebClient</a>
<ul class="sectlevel2">
<li><a href="#webclient-setup">27.1. WebClient OAuth2 Setup</a></li>
<li><a href="#webclient-implicit">27.2. 隐式 OAuth2AuthorizedClient</a></li>
<li><a href="#webclient-explicit">27.3. 显式 OAuth2AuthorizedClient</a></li>
<li><a href="#webclient-clientregistrationid">27.4. clientRegistrationId</a></li>
</ul>
</li>
<li><a href="#jc-erms">28. EnableReactiveMethodSecurity</a></li>
<li><a href="#test-webflux">29. Reactive 测试支持</a>
<ul class="sectlevel2">
<li><a href="#test-erms">29.1. 测试 Reactive 方法安全</a></li>
<li><a href="#test-webtestclient">29.2. WebTestClientSupport</a>
<ul class="sectlevel3">
<li><a href="#认证">29.2.1. 认证</a></li>
<li><a href="#csrf-支持">29.2.2. CSRF 支持</a></li>
<li><a href="#webflux-testing-oauth2">29.2.3. 测试 OAuth 2.0</a></li>
<li><a href="#webflux-testing-oidc-login">29.2.4. 测试 OIDC Login</a>
<ul class="sectlevel4">
<li><a href="#webflux-testing-oidc-login-authorities">配置权限</a></li>
<li><a href="#webflux-testing-oidc-login-claims">配置 Claims</a></li>
<li><a href="#webflux-testing-oidc-login-user">其他配置</a></li>
</ul>
</li>
<li><a href="#webflux-testing-oauth2-login">29.2.5. 测试 OAuth 2.0 登录</a>
<ul class="sectlevel4">
<li><a href="#webflux-testing-oauth2-login-authorities">配置权限</a></li>
<li><a href="#webflux-testing-oauth2-login-claims">配置 Claims</a></li>
<li><a href="#webflux-testing-oauth2-login-user">其他配置</a></li>
</ul>
</li>
<li><a href="#webflux-testing-oauth2-client">29.2.6. 测试 OAuth 2.0 客户端</a>
<ul class="sectlevel4">
<li><a href="#webflux-testing-oauth2-client-scopes">配置 Scopes</a></li>
<li><a href="#webflux-testing-oauth2-client-registration">其他配置</a></li>
</ul>
</li>
<li><a href="#webflux-testing-jwt">29.2.7. 测试 JWT 认证</a>
<ul class="sectlevel4">
<li><a href="#mockjwt-webtestclientconfigurer"><code>mockJwt() WebTestClientConfigurer</code></a></li>
<li><a href="#authentication-webtestclientconfigurer"><code>authentication()</code> <code>WebTestClientConfigurer</code></a></li>
</ul>
</li>
<li><a href="#webflux-testing-opaque-token">29.2.8. 测试 Opaque Token 认证</a>
<ul class="sectlevel4">
<li><a href="#webflux-testing-opaque-token-authorities">配置权限</a></li>
<li><a href="#webflux-testing-opaque-token-attributes">配置 Claims</a></li>
<li><a href="#webflux-testing-opaque-token-principal">其他配置</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#rsocket">30. RSocket Security</a>
<ul class="sectlevel2">
<li><a href="#最小的-rsocket-安全配置">30.1. 最小的 RSocket 安全配置</a></li>
<li><a href="#adding-securitysocketacceptorinterceptor">30.2. Adding SecuritySocketAcceptorInterceptor</a></li>
<li><a href="#rsocket-authentication">30.3. RSocket 认证</a>
<ul class="sectlevel3">
<li><a href="#rsocket-authentication-setup-vs-request">30.3.1. 设置时的身份验证与请求时间</a></li>
<li><a href="#rsocket-authentication-simple">30.3.2. Simple Authentication</a></li>
<li><a href="#rsocket-authentication-jwt">30.3.3. JWT</a></li>
</ul>
</li>
<li><a href="#rsocket-authorization">30.4. RSocket 授权</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Spring security 是一个强大的,并且可以高度定制的身份验证和访问控制框架.  其对命令式和响应式应用程序有着一流的支持,它是用于保护基于 Spring 的应用程序的实际标准.</p>
</div>
</div>
</div>
<h1 id="介绍" class="sect0"><a class="anchor" href="#介绍"></a>介绍</h1>
<div class="openblock partintro">
<div class="content">
本节讨论 Spring Security 的组织.
</div>
</div>
<div class="sect1">
<h2 id="prerequisites"><a class="anchor" href="#prerequisites"></a>1. 要求</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 5.4.6 需要 JDK 8 或更高的版本运行</p>
</div>
<div class="paragraph">
<p>由于 Spring Security 是以独立的方式运作, 所以,不需要在你的Java运行环境配置特殊的文件. 也不需要配置专门的 Java 认证和授权服务(JAAS)策略文件,只需要将 Spring Security 的位置放到普通路径中.</p>
</div>
<div class="paragraph">
<p>同样,如果你使用的是 EJB 容器或者 Servlet 容器也没有必要在任何地方放置特殊的配置文件,也不包括 Spring Security 的服务加载器. 所有必须的文件都已经包含在你的应用程序中.</p>
</div>
<div class="paragraph">
<p>这种设计给部署时间提供了最大的灵活性,你可以简单的复制你的目标文件(可以是 JAR, WAR 或者 EAR)从一个系统到另一个系统,它会立即开始工作.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="community"><a class="anchor" href="#community"></a>2. Spring Security 社区</h2>
<div class="sectionbody">
<div class="paragraph">
<p>欢迎来到 Spring Security 社区！ 本节讨论如何充分利用我们庞大的社区.</p>
</div>
<div class="sect2">
<h3 id="community-help"><a class="anchor" href="#community-help"></a>2.1. 获取帮助</h3>
<div class="paragraph">
<p>如果您需要有关 Spring Security 的帮助,我们将在这里为您提供帮助.
以下是获得帮助的一些最佳方法:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通读本文档.</p>
</li>
<li>
<p>尝试使用我们众多的 <a href="#samples">sample 应用</a>.</p>
</li>
<li>
<p>可以在 <a href="https://stackoverflow.com/questions/tagged/spring-security">https://stackoverflow.com</a>  <code>spring-security</code> 标签处提问题.</p>
</li>
<li>
<p>提供 bugs 和功能地址:  <a href="https://github.com/spring-projects/spring-security/issues" class="bare">github.com/spring-projects/spring-security/issues</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="community-becoming-involved"><a class="anchor" href="#community-becoming-involved"></a>2.2. 参与其中</h3>
<div class="paragraph">
<p>我们欢迎您参与 Spring Security 项目.
有很多贡献的方法,包括回答有关 StackOverflow 的问题,编写新代码,改进现有代码,协助编写文档,开发示例或教程,报告错误或仅提出建议.
获取更多信息,请参看 <a href="https://github.com/spring-projects/spring-security/blob/master/CONTRIBUTING.adoc">Contributing</a> 文档.</p>
</div>
</div>
<div class="sect2">
<h3 id="community-source"><a class="anchor" href="#community-source"></a>2.3. 源码</h3>
<div class="paragraph">
<p>您可以在 GitHub 上找到 Spring Security 的源代码:  <a href="https://github.com/spring-projects/spring-security/" class="bare">github.com/spring-projects/spring-security/</a></p>
</div>
</div>
<div class="sect2">
<h3 id="community-license"><a class="anchor" href="#community-license"></a>2.4. Apache 2 License</h3>
<div class="paragraph">
<p>Spring Security 使用的是 <a href="https://www.apache.org/licenses/LICENSE-2.0.html">Apache 2.0 许可证</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="社交媒体"><a class="anchor" href="#社交媒体"></a>2.5. 社交媒体</h3>
<div class="paragraph">
<p>你可以关注 <a href="https://twitter.com/SpringSecurity">@SpringSecurity</a> 和 <a href="https://twitter.com/SpringSecurity/lists/team">Spring Security team</a>  Twitter 来获取最新的消息.
您还可以关注 <a href="https://twitter.com/SpringCentral">@SpringCentral</a> 以了解整个 Spring 产品组合的最新信息.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="new"><a class="anchor" href="#new"></a>3. Spring Security 5.4 的新功能</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 5.4 提供了许多新功能.
以下是该版本的重点内容.</p>
</div>
<div class="sect2">
<h3 id="whats-new-documentation"><a class="anchor" href="#whats-new-documentation"></a>3.1. 文档更新</h3>
<div class="paragraph">
<p>我们将继续努力重写文档.</p>
</div>
<div class="paragraph">
<p>在此版本中,您将看到以下内容:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为 <a href="#oauth2resourceserver-jwt-architecture">JWT</a> 和 <a href="#oauth2resourceserver-opaque-architecture">Opaque Token</a> 添加了 <a href="#oauth2resourceserver">OAuth 2.0 Resource Server diagrams</a></p>
</li>
<li>
<p>重新组织了 <a href="#servlet-saml2login">SAML 2.0 Relying Party documentation</a> 并添加了图表</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="whats-new-logging"><a class="anchor" href="#whats-new-logging"></a>3.2. Logging 更新</h3>
<div class="paragraph">
<p>我们已经开始努力重写日志记录.</p>
</div>
<div class="paragraph">
<p>在此版本中， 您将看到以下内容:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>重新组织了 <a href="https://github.com/spring-projects/spring-security/commit/fa7baf551dc55eab50b9ad94720e7521f0b1d26f">authorization logs</a></p>
</li>
<li>
<p>重新组织了 <a href="https://github.com/spring-projects/spring-security/commit/fa7baf551dc55eab50b9ad94720e7521f0b1d26f">Form Login</a> 和 <a href="https://github.com/spring-projects/spring-security/commit/02d1516c566a58574af0a1d0391fd2ec8c5ad774">HTTP Basic</a> authentication logs</p>
</li>
<li>
<p>添加了 <a href="https://github.com/spring-projects/spring-security/commit/bf067d679fb5990d6b3d31cee292af171f8a5014">Resource Server</a> <a href="https://github.com/spring-projects/spring-security/commit/b2728059ae903d027d0da0f4a25bed6df213a0ce">logs</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="whats-new-servlet"><a class="anchor" href="#whats-new-servlet"></a>3.3. Servlet</h3>
<div class="ulist">
<ul>
<li>
<p>配置</p>
<div class="ulist">
<ul>
<li>
<p>添加了对将 <a href="https://github.com/spring-projects/spring-security/issues/8804">publishing <code>SecurityFilterChain</code>  <code>@Bean</code></a> 的支持</p>
</li>
</ul>
</div>
</li>
<li>
<p>Kotlin DSL</p>
<div class="ulist">
<ul>
<li>
<p>添加了 <a href="https://github.com/spring-projects/spring-security/issues/8981"><code>authenticationManagerResolver</code></a></p>
</li>
<li>
<p>添加了 <a href="https://github.com/spring-projects/spring-security/issues/8892"><code>hasAnyRole</code> 和 <code>hasAnyAuthority</code></a></p>
</li>
<li>
<p>添加了 <a href="https://github.com/spring-projects/spring-security/issues/8823">自定义 HeaderWriter 支持</a></p>
</li>
<li>
<p>更新为 <a href="https://github.com/spring-projects/spring-security/issues/8697">use reified types</a></p>
</li>
<li>
<p>添加了 <a href="https://github.com/spring-projects/spring-security/pull/8350">接受 <code>HttpMethod</code> 的 <code>authorize()</code> 方法</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>OAuth 2.0 Client</p>
<div class="ulist">
<ul>
<li>
<p>完善了 <a href="#testing-oauth2-client">OAuth 2.0 Client</a> 测试支持,现在不需要 <code>HttpSessionOAuth2AuthorizedClientRepository</code> bean</p>
</li>
<li>
<p>Added support for <a href="https://github.com/spring-projects/spring-security/issues/8453">client ID and secret placeholders in XML support</a></p>
</li>
<li>
<p>将 <code>ClientRegistrations</code> 的范围调整为默认值， <a href="https://github.com/spring-projects/spring-security/issues/8514">而不是 OIDC <code>scopes_supported</code> 属性的默认范围</a></p>
</li>
<li>
<p>在 <code>ClientRegistration</code> 中 <a href="https://github.com/spring-projects/spring-security/issues/8903">中允许自定义客户端身份验证方法</a>.</p>
</li>
<li>
<p>增强 <code>OAuth2AuthorizedClientArgumentResolver</code>  <a href="https://github.com/spring-projects/spring-security/issues/8700">可以从应用程序上下文中提取 <code>OAuth2AuthorizedClientManager</code></a></p>
</li>
<li>
<p>在 XML 配置中添加了 <a href="https://github.com/spring-projects/spring-security/issues/8669"><code>OAuth2AuthorizedClientArgumentResolver</code></a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-security/issues/8120"><code>OAuth2AuthorizationCodeGrantFilter</code></a> 添加了 <code>RequestCache</code> 支持.</p>
</li>
<li>
<p>已将 <a href="https://github.com/spring-projects/spring-security/issues/8326"><code>issuerUri</code> 添加到 <code>ClientRegistration</code></a></p>
</li>
</ul>
</div>
</li>
<li>
<p>OAuth 2.0 Resource Server</p>
<div class="ulist">
<ul>
<li>
<p>在 <a href="#oauth2resourceserver-jwt-timeouts"><code>NimbusJwtDecoder</code> 中添加了缓存支持</a></p>
</li>
<li>
<p>使 <a href="https://github.com/spring-projects/spring-security/issues/8186">principal claim 可以在 <code>JwtAuthenticationConverter</code> 中配置</a></p>
</li>
<li>
<p>增强配置 <a href="#oauth2resourceserver-jwt-authorization-extraction">可以将 <code>JwtAuthenticationConverter</code> 作为 <code>@Bean</code></a></p>
</li>
<li>
<p>简化 <a href="https://github.com/spring-projects/spring-security/pull/8740">attribute retrieval for opaque token</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>SAML 2.0</p>
<div class="ulist">
<ul>
<li>
<p>使 <a href="#servlet-saml2login-sp-initiated-factory-custom-authnrequest">Open SAML <code>AuthnRequest</code> construction 可配置</a></p>
</li>
<li>
<p>增强 <a href="#servlet-saml2login-sp-initiated-factory-custom-authnrequest"><code>AuthnRequest</code> 构造,可以访问 <code>HttpServletRequest</code> 数据</a></p>
</li>
<li>
<p>打开 <a href="#servlet-saml2login-sp-initiated-factory-custom-authnrequest"><code>Saml2AuthenticationRequestContext</code> 扩展</a></p>
</li>
<li>
<p>增强 <a href="#servlet-saml2login-authenticatedprincipal"><code>Saml2AuthenticatedPrincipal</code> 包含 <code>&lt;saml2:AttributeStatement&gt;</code></a></p>
</li>
<li>
<p>增强 <a href="#servlet-saml2login-opensamlauthenticationprovider-userdetailsservice"><code>OpenSamlAuthenticationProvider`支持自定义返回的 `Authentication</code></a></p>
</li>
<li>
<p>增强 <a href="#servlet-saml2login-opensamlauthenticationprovider-additionalvalidation"><code>OpenSamlAuthenticationProvider</code> 支持自定义 <code>&lt;saml2:Assertion&gt;</code> 验证</a></p>
</li>
<li>
<p>添加了 <a href="#servlet-saml2login-rpr-relyingpartyregistrationresolver">从请求中解析 <code>RelyingPartyRegistration</code></a></p>
</li>
<li>
<p>添加了 <a href="#servlet-saml2login-opensaml-customization">an initialization service 取代了 Open SAML&#8217;s <code>InitializationService</code></a></p>
</li>
<li>
<p>添加了 <a href="#servlet-saml2login-metadata">SAML 2.0 Metadata Filter</a></p>
</li>
<li>
<p>简化 <a href="#servlet-saml2login-rpr-credentials"><code>Saml2X509Credential</code> 构造</a></p>
</li>
<li>
<p>重新组织了 <code>RelyingPartyRegistration</code> <a href="#servlet-saml2login-relyingpartyregistration">可区分依赖和声明配置</a></p>
</li>
<li>
<p>添加了 <a href="#servlet-saml2login-relyingpartyregistration">通过声明方元数据端点的配置</a></p>
</li>
<li>
<p>重新组织了 <code>RelyingPartyRegistration</code> 以 <a href="#servlet-saml2login-relyingpartyregistration">reflect metadata terminology</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>LDAP</p>
<div class="ulist">
<ul>
<li>
<p>添加了对使用随机端口配置 <a href="https://github.com/spring-projects/spring-security/issues/8144"><code>ApacheDSContainer</code></a> 的支持</p>
</li>
<li>
<p>增加了对使用随机端口配置 <a href="https://github.com/spring-projects/spring-security/issues/8138">application</a> 的支持</p>
</li>
</ul>
</div>
</li>
<li>
<p>CSRF</p>
<div class="ulist">
<ul>
<li>
<p>使 <a href="https://github.com/spring-projects/spring-security/pull/8749"><code>secure</code> flag 可配置</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="whats-new-webflux"><a class="anchor" href="#whats-new-webflux"></a>3.4. WebFlux</h3>
<div class="ulist">
<ul>
<li>
<p>为 <a href="https://github.com/spring-projects/spring-security/issues/5558">WebFlux 添加了 Kotlin DSL</a></p>
</li>
<li>
<p>在  OAuth 2.0 Login 登录中添加了 <a href="https://github.com/spring-projects/spring-security/issues/8324"><code>AuthoritiesMapper</code> 配置</a></p>
</li>
<li>
<p>添加了 <a href="https://github.com/spring-projects/spring-security/issues/8599"><code>SwitchUserWebFilter</code></a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="whats-new-additional"><a class="anchor" href="#whats-new-additional"></a>3.5. 其他更新</h3>
<div class="ulist">
<ul>
<li>
<p>将 <a href="https://github.com/spring-projects/spring-security/issues/8676">whitelist 和 blacklist 重命名为 allowlist 和 blocklist</a></p>
</li>
<li>
<p>添加了 <a href="https://github.com/spring-projects/spring-security/pull/7052"><code>RequestRejectedHandler</code></a></p>
</li>
<li>
<p>加强了 <a href="https://github.com/spring-projects/spring-security/pull/8644"><code>StrictHttpFirewall</code></a> <a href="#servlet-httpfirewall-headers-parameters">验证 header 和 parameter 的 names 和 values</a></p>
</li>
<li>
<p>Made <a href="https://github.com/spring-projects/spring-security/issues/5438"><code>SessionRegistry</code> aware of <code>SessionIdChangedEvent</code></a></p>
</li>
<li>
<p>Allow <a href="https://github.com/spring-projects/spring-security/issues/8402">允许使用真实密钥构造 <code>AesBytesEncryptor</code></a></p>
</li>
<li>
<p><a href="https://github.com/spring-projects/spring-security/pull/8450">不建议使用 OpenID 2.0 支持</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="whats-new-build"><a class="anchor" href="#whats-new-build"></a>3.6. 构建变化</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/spring-projects/spring-security/issues/8113">进一步提高性能</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="getting"><a class="anchor" href="#getting"></a>4. 获取 Spring Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节讨论了有关获取 Spring Security 文件的所有信息.  有关如何获取源代码的信息,请参见<a href="#community-source">第2.3节 "源代码"</a> .</p>
</div>
<div class="sect2">
<h3 id="release-版本号"><a class="anchor" href="#release-版本号"></a>4.1. Release 版本号</h3>
<div class="paragraph">
<p>Spring Security 版本的格式为 MAJOR.MINOR.PATCH,如下:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>MAJOR 版本可能包含重大更改. 通常,这样做是为了提供改进的安全性以匹配现代安全性实践</p>
</li>
<li>
<p>MINOR 版本包含增强功能,但被视为被动更新</p>
</li>
<li>
<p>PATCH 级别应该是完全兼容的,向前和向后兼容,可能存在修正错误的更改除外.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="maven"><a class="anchor" href="#maven"></a>4.2. 使用 Maven</h3>
<div class="paragraph">
<p>与大多数开源项目一样,Spring Security 将其依赖部署为 Maven  artifacts .  本节中的主题提供有关使用 Maven 时如何使用 Spring Security 的详细信息.</p>
</div>
<div class="sect3">
<h4 id="getting-maven-boot"><a class="anchor" href="#getting-maven-boot"></a>4.2.1. 使用 Spring Boot</h4>
<div class="paragraph">
<p>Spring Boot 提供了一个 <code>spring-boot-starter-security</code> 起步依赖,它将 Spring Security 相关的依赖聚合在一起.
使用起步依赖最简单且首选的方法是通过使用 IDE 集成(<a href="https://joshlong.com/jl/blogPost/tech_tip_geting_started_with_spring_boot.html">Eclipse</a>, <a href="https://www.jetbrains.com/help/idea/spring-boot.html#d1489567e2">IntelliJ</a>, <a href="https://github.com/AlexFalappa/nb-springboot/wiki/Quick-Tour">NetBeans</a>)或通过 <code><a href="https://start.spring.io" class="bare">start.spring.io</a></code> 使用 <a href="https://docs.spring.io/initializr/docs/current/reference/htmlsingle/">Spring Initializr</a>.</p>
</div>
<div class="paragraph">
<p>另外,您可以手动添加启动依赖,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 1. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
    &lt;!-- ... other dependency elements ... --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于 Spring Boot 提供了 Maven BOM 来管理依赖版本,因此您无需指定版本.  如果您希望覆盖 Spring Security 版本,可以通过提供 Maven 属性来实现,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 2. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;properties&gt;
    &lt;!-- ... --&gt;
    &lt;spring-security.version&gt;5.4.6&lt;/spring-security.version&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于 Spring Security 仅在主要版本中进行重大更改,因此可以将较新版本的 Spring Security 与 Spring Boot 一起使用是安全的.  但是,有时您可能还需要更新 Spring Framework 的版本.  您可以通过添加 Maven 属性来执行此操作,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 3. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;properties&gt;
    &lt;!-- ... --&gt;
    &lt;spring.version&gt;5.3.6&lt;/spring.version&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用其他功能 (例如 LDAP,OpenID 和其他功能) ,则还需要包括相应 <a href="#modules">项目模块</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="getting-maven-no-boot"><a class="anchor" href="#getting-maven-no-boot"></a>4.2.2. 不使用 Spring Boot</h4>
<div class="paragraph">
<p>使用不带 Spring Boot 的 Spring Security 时,首选方法是使用 Spring Security 的 BOM,以确保在整个项目中使用一致的 Spring Security 版本.  以下示例显示了如何执行此操作:</p>
</div>
<div class="exampleblock">
<div class="title">Example 4. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;!-- ... other dependency elements ... --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
            &lt;artifactId&gt;spring-security-bom&lt;/artifactId&gt;
            &lt;version&gt;{spring-security-version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最小化的 Spring Security Maven 依赖集通常如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 5. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencies&gt;
    &lt;!-- ... other dependency elements ... --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
        &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.security&lt;/groupId&gt;
        &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用其他功能 (例如 LDAP,OpenID 和其他功能) ,则还需要包括相应 <a href="#modules">项目模块</a>.</p>
</div>
<div class="paragraph">
<p>Spring Security 是根据 Spring Framework 5.3.6 构建的,但通常可以与任何较新版本的 Spring Framework 5.x 一起使用.
Spring Security 的可传递性解决了 Spring Framework 5.3.6 版本依赖的问题,但这可能会引起奇怪的类路径问题,因此许多用户可能会误以为是.
解决此问题的最简单方法是在 <code>pom.xml</code> 的 <code>&lt;dependencyManagement&gt;</code> 部分中使用 <code>spring-framework-bom</code>,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 6. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;!-- ... other dependency elements ... --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-framework-bom&lt;/artifactId&gt;
            &lt;version&gt;5.3.6&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例确保 Spring Security 的所有传递依赖都使用 Spring  5.3.6 模块.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
这种方法使用了 Maven 的 &#8220;bill of materials&#8221; (BOM)概念,并且仅在 Maven 2.0.9+ 中可用.  有关如何解决依赖的其他详细信息,请参阅 <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">Maven 的依赖机制简介</a>文档.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="maven-repositories"><a class="anchor" href="#maven-repositories"></a>4.2.3. Maven 仓库</h4>
<div class="paragraph">
<p>所有 GA 版本 (即以 .RELEASE 结尾的版本) 均已部署到 Maven Central,因此无需在 pom 中声明其他 Maven 仓库.</p>
</div>
<div class="paragraph">
<p>如果使用 SNAPSHOT 版本,则需要定义 Spring Snapshot 仓库,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 7. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
    &lt;!-- ... possibly other repository elements ... --&gt;
    &lt;repository&gt;
        &lt;id&gt;spring-snapshot&lt;/id&gt;
        &lt;name&gt;Spring Snapshot Repository&lt;/name&gt;
        &lt;url&gt;https://repo.spring.io/snapshot&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用里程碑版本或候选版本,则需要定义 Spring Milestone 仓库,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 8. pom.xml</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;repositories&gt;
    &lt;!-- ... possibly other repository elements ... --&gt;
    &lt;repository&gt;
        &lt;id&gt;spring-milestone&lt;/id&gt;
        &lt;name&gt;Spring Milestone Repository&lt;/name&gt;
        &lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="getting-gradle"><a class="anchor" href="#getting-gradle"></a>4.3. 使用 Gradle</h3>
<div class="paragraph">
<p>作为大多数开源项目,Spring Security 将其依赖部署为 Maven  artifacts ,从而提供了一流的 Gradle 支持.  以下主题详细介绍了使用 Gradle 时如何使用 Spring Security.</p>
</div>
<div class="sect3">
<h4 id="getting-gradle-boot"><a class="anchor" href="#getting-gradle-boot"></a>4.3.1. 使用 Spring Boot</h4>
<div class="paragraph">
<p>Spring Boot 提供了一个 <code>spring-boot-starter-security</code> 起步依赖,它将 Spring Security 相关的依赖聚合在一起.
使用起步依赖最简单且首选的方法是通过使用IDE集成( <a href="https://joshlong.com/jl/blogPost/tech_tip_geting_started_with_spring_boot.html">Eclipse</a>, <a href="https://www.jetbrains.com/help/idea/spring-boot.html#d1489567e2">IntelliJ</a>, <a href="https://github.com/AlexFalappa/nb-springboot/wiki/Quick-Tour">NetBeans</a>) 或通过 <code><a href="https://start.spring.io" class="bare">start.spring.io</a></code> 使用 <a href="https://docs.spring.io/initializr/docs/current/reference/htmlsingle/">Spring Initializr</a>.</p>
</div>
<div class="paragraph">
<p>另外,您可以手动添加起步依赖,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 9. build.gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    compile "org.springframework.boot:spring-boot-starter-security"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于 Spring Boot 提供了 Maven BOM 来管理依赖版本,因此您无需指定版本.  如果您希望覆盖 Spring Security 版本,可以通过提供 Gradle 属性来实现,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 10. build.gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">ext['spring-security.version']='5.4.6'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于 Spring Security 仅在主要版本中进行重大更改,因此可以将较新版本的 Spring Security 与 Spring Boot 一起使用是安全的.  但是,有时您可能还需要更新 Spring Framework 的版本.
您可以通过添加 Gradle 属性来执行此操作,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 11. build.gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">ext['spring.version']='5.3.6'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用其他功能 (例如 LDAP,OpenID 和其他功能) ,则还需要包括相应 <a href="#modules">项目模块</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="不使用-spring-boot"><a class="anchor" href="#不使用-spring-boot"></a>4.3.2. 不使用 Spring Boot</h4>
<div class="paragraph">
<p>使用不带 Spring Boot 的 Spring Security 时,首选方法是使用 Spring Security 的 BOM,以确保在整个项目中使用一致的 Spring Security 版本.
您可以使用 <a href="https://github.com/spring-gradle-plugins/dependency-management-plugin">Dependency Management Plugin</a> 插件来做到这一点,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 12. build.gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id "io.spring.dependency-management" version "1.0.6.RELEASE"
}

dependencyManagement {
    imports {
        mavenBom 'org.springframework.security:spring-security-bom:5.4.6'
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>最小的 Spring Security Maven 依赖集通常如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 13. build.gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">dependencies {
    compile "org.springframework.security:spring-security-web"
    compile "org.springframework.security:spring-security-config"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用其他功能 (例如 LDAP,OpenID 和其他功能) ,则还需要包括相应 <a href="#modules">项目模块</a>.</p>
</div>
<div class="paragraph">
<p>Spring Security 是根据 Spring Framework 5.3.6 构建的,但通常可以与任何较新版本的 Spring Framework 5.x一起使用.
Spring Security 的可传递性解决了 Spring Framework 5.3.6 版本依赖的问题,但这可能会引起奇怪的类路径问题,因此许多用户可能会误以为是.
解决此问题的最简单方法是在 <code>pom.xml</code> 的 <code>&lt;dependencyManagement&gt;</code> 部分中使用 <code>spring-framework-bom</code>,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 14. build.gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">plugins {
    id "io.spring.dependency-management" version "1.0.6.RELEASE"
}

dependencyManagement {
    imports {
        mavenBom 'org.springframework:spring-framework-bom:5.3.6'
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>前面的示例确保 Spring Security 的所有传递依赖都使用 Spring 5.3.6 模块.</p>
</div>
</div>
<div class="sect3">
<h4 id="gradle-repositories"><a class="anchor" href="#gradle-repositories"></a>4.3.3. Gradle 仓库</h4>
<div class="paragraph">
<p>所有 GA 版本 (即以 <code>.RELEASE</code> 结尾的版本) 均已部署到 Maven Central,因此使用 mavenCentral() 仓库足以满足 GA 版本的要求.  以下示例显示了如何执行此操作:</p>
</div>
<div class="exampleblock">
<div class="title">Example 15. build.gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
    mavenCentral()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用 SNAPSHOT 版本,则需要定义 Spring Snapshot 仓库,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 16. build.gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven { url 'https://repo.spring.io/snapshot' }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果使用里程碑版本或候选版本,则需要定义 Spring Milestone 仓库,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 17. build.gradle</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">repositories {
    maven { url 'https://repo.spring.io/milestone' }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="features"><a class="anchor" href="#features"></a>5. 特性</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 为身份验证,授权和针对<a href="#exploits">常见漏洞</a>的防护提供了全面的支持.  它还提供与其他库的集成,以简化其使用.</p>
</div>
<div class="sect2">
<h3 id="authentication"><a class="anchor" href="#authentication"></a>5.1. 认证</h3>
<div class="paragraph">
<p>Spring Security 为 <a href="https://en.wikipedia.org/wiki/Authentication">身份验证</a> 提供了全面的支持.  身份验证是我们验证谁试图访问特定资源的身份的方法.
验证用户身份的常用方法是要求用户输入用户名和密码.  一旦执行了身份验证,我们就会知道用户身份并可以执行授权.</p>
</div>
<div class="sect3">
<h4 id="authentication-support"><a class="anchor" href="#authentication-support"></a>5.1.1. 认证支持</h4>
<div class="paragraph">
<p>Spring Security 内置许多用于验证用户身份的支持.  有关每个技术栈支持什么的详细信息,请参阅关于 <a href="#servlet-authentication">Servlet</a>  和 WebFlux 的身份验证的部分.</p>
</div>
</div>
<div class="sect3">
<h4 id="authentication-password-storage"><a class="anchor" href="#authentication-password-storage"></a>5.1.2. 密码存储</h4>
<div class="paragraph">
<p>Spring Security 的 <code>PasswordEncoder</code> 接口用于对密码执行单向转换,以允许安全地存储密码.  鉴于 <code>PasswordEncoder</code> 是一种单向转换,
因此当密码转换需要采用两种方式 (即向数据库存储进行身份验证的凭据) 时,则不打算使用它.  通常,<code>PasswordEncoder</code> 是在身份验证时与用户提供的密码和存储的密码进行比较.</p>
</div>
<div class="sect4">
<h5 id="authentication-password-storage-history"><a class="anchor" href="#authentication-password-storage-history"></a>密码存储历史</h5>
<div class="paragraph">
<p>多年来,存储密码的标准机制在不断的发展.  最初,密码以纯文本格式存储.  假设密码是安全的,因为密码已保存在访问它所需的凭据中.
但是,恶意用户能够使用 SQL 注入 这样的攻击方式来获取用户名和密码的大量的 "data dumps".  随着越来越多的用户凭证成为公共安全,保护用户密码至关重要.</p>
</div>
<div class="paragraph">
<p>接下来,开发人员在通过诸如 SHA-256 之类的单向哈希算法对密码进行加密后存储.  当用户尝试进行身份验证时,会将加密后的密码与他们输入的密码的散列值进行比较.  这意味着系统仅需要存储加密后的密码.  如果发生了密码泄漏,则仅暴露密码的一种哈希方式.
由于哈希算法是单向的,所以给定哈希值,反向计算密码很难. 因此想找出系统中的每个密码都很困难而且不值得.  为了破解密码,恶意用户决定创建称为  <a href="https://en.wikipedia.org/wiki/Rainbow_table">彩虹表</a> 的查找表.  他们不必每次都猜测每个密码,而是计算一次密码并将其存储在查找表中.</p>
</div>
<div class="paragraph">
<p>为了预防 彩虹表 的破解攻击,鼓励开发人员使用加盐的密码.  不仅将密码用作哈希函数的输入,还将为每个用户的密码生成随机字节 (称为 <code>salt</code> ) .  盐和用户密码将通过散列函数运行,从而产生唯一的散列.  盐将以明文形式与用户密码一起存储.
然后,当用户尝试进行身份验证时,会将哈希密码与存储的盐的哈希值和他们输入的密码进行比较.  唯一的盐意味着 <code>彩虹表</code> 不再有效,因为每种盐和密码组合的哈希值都不同.</p>
</div>
<div class="paragraph">
<p>在现代,我们意识到加密哈希 (例如 SHA-256) 不再安全.  原因是使用现代硬件,我们可以每秒执行数十亿次哈希计算.  这意味着我们可以轻松地分别破解每个密码.</p>
</div>
<div class="paragraph">
<p>现在鼓励开发人员利用自适应单向函数来存储密码.  具有自适应单向函数的密码验证意味着会消耗大量资源 (即 CPU,内存等) .
自适应单向函数允许配置 "work factor"  (工作因子) ,该因数会随着硬件的改进而增加.  建议将 "work factor" 调整为大约1秒钟,以验证系统上的密码.  这种权衡使攻击者难以破解密码,但代价却不高,这给您自己的系统带来了沉重负担.
Spring Security 试图为 "work factor" 提供一个良好的起点,但是鼓励用户为自己的系统自定义 "work factor" ,因为不同系统之间的性能会有很大差异.  具有自适应单向函数的有 <a href="https://en.wikipedia.org/wiki/Bcrypt">bcrypt</a>,
<a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a>,
<a href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a>,
和 <a href="https://en.wikipedia.org/wiki/Argon2">Argon2</a></p>
</div>
<div class="paragraph">
<p>由于自适应单向函数会占用大量资源,因此为每个请求验证用户名和密码都会大大降低应用程序的性能.  Spring Security (或任何其他库) 无法采取任何措施来加快密码的验证速度,因为通过增加验证资源的强度来获得安全性.
鼓励用户将长期凭证 (即用户名和密码) 替换为短期凭证 (即会话,OAuth令牌等) .  可以快速验证短期凭证,而不会损失任何安全性.</p>
</div>
</div>
<div class="sect4">
<h5 id="authentication-password-storage-dpe"><a class="anchor" href="#authentication-password-storage-dpe"></a>DelegatingPasswordEncoder</h5>
<div class="paragraph">
<p>在 Spring Security 5.0 之前,默认的 <code>PasswordEncoder</code> 是 <code>NoOpPasswordEncoder</code>,它需要纯文本密码.  根据 <a href="#authentication-password-storage-history">"密码历史记录"</a> 所述,您可能希望默认的 <code>PasswordEncoder</code> 是 <code>BCryptPasswordEncoder</code>.  但是,这忽略了三个现实问题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>有许多使用旧密码编码的应用程序无法轻松迁移</p>
</li>
<li>
<p>密码存储的最佳做法将再次更改.</p>
</li>
<li>
<p>作为一个框架,Spring Security 不能经常进行重大更改</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>相反,Spring Security 引入了 <code>DelegatingPasswordEncoder</code>,它通过以下方式解决了所有问题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保使用建议的对当前密码密码进行编码</p>
</li>
<li>
<p>允许以新的和旧的格式验证密码</p>
</li>
<li>
<p>允许将来升级编码</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您可以使用 <code>PasswordEncoderFactories</code> 轻松构造 <code>DelegatingPasswordEncoder</code> 的实例.</p>
</div>
<div class="exampleblock">
<div class="title">Example 18. Create Default DelegatingPasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">PasswordEncoder passwordEncoder =
    PasswordEncoderFactories.createDelegatingPasswordEncoder();
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val passwordEncoder: PasswordEncoder = PasswordEncoderFactories.createDelegatingPasswordEncoder()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者,您可以创建自己的自定义实例.</p>
</div>
<div class="exampleblock">
<div class="title">Example 19. Create Custom DelegatingPasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String idForEncode = "bcrypt";
Map encoders = new HashMap&lt;&gt;();
encoders.put(idForEncode, new BCryptPasswordEncoder());
encoders.put("noop", NoOpPasswordEncoder.getInstance());
encoders.put("pbkdf2", new Pbkdf2PasswordEncoder());
encoders.put("scrypt", new SCryptPasswordEncoder());
encoders.put("sha256", new StandardPasswordEncoder());

PasswordEncoder passwordEncoder =
    new DelegatingPasswordEncoder(idForEncode, encoders);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val idForEncode = "bcrypt"
val encoders: MutableMap&lt;String, PasswordEncoder&gt; = mutableMapOf()
encoders[idForEncode] = BCryptPasswordEncoder()
encoders["noop"] = NoOpPasswordEncoder.getInstance()
encoders["pbkdf2"] = Pbkdf2PasswordEncoder()
encoders["scrypt"] = SCryptPasswordEncoder()
encoders["sha256"] = StandardPasswordEncoder()

val passwordEncoder: PasswordEncoder = DelegatingPasswordEncoder(idForEncode, encoders)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="authentication-password-storage-dpe-format"><a class="anchor" href="#authentication-password-storage-dpe-format"></a>密码存储格式</h6>
<div class="paragraph">
<p>密码的一般格式是:</p>
</div>
<div class="exampleblock">
<div class="title">Example 20. DelegatingPasswordEncoder 存储格式</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">{id}encodedPassword</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>id</code> 是用于查找应该使用那个 <code>PasswordEncoder</code> 的标识符,<code>encodedPassword</code> 是所选 <code>PasswordEncoder</code> 的加密原始密码后得到的密码.  <code>id</code> 必须位于密码的开头,以 <code>{</code> 开头,以 <code>}</code> 结束. 如果找不到 <code>id</code>,则 <code>id</code> 将为 <code>null</code>. 例如,以下可能是使用不同 <code>id</code> 编码的密码列表. 所有原始密码都是 "password"..</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG <i class="conum" data-value="1"></i><b>(1)</b>
{noop}password <i class="conum" data-value="2"></i><b>(2)</b>
{pbkdf2}5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc <i class="conum" data-value="3"></i><b>(3)</b>
{scrypt}$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc=  <i class="conum" data-value="4"></i><b>(4)</b>
{sha256}97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>第一个密码是 id 为 <code>bcrypt</code> 的 <code>PasswordEncoder</code>,encodedPassword 为 <code>$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG</code>. 匹配时会委托给 <code>BCryptPasswordEncoder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>第二个密码是 id 为 <code>noop</code> 的 <code>PasswordEncoder</code>,encodedPassword 为 <code>password</code>. 匹配时会委托给 <code>NoOpPasswordEncoder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>第三个密码是 id 为 <code>pbkdf2</code> 的 <code>PasswordEncoder</code>,encodedPassword 为 <code>5d923b44a6d129f3ddf3e3c8d29412723dcbde72445e8ef6bf3b508fbf17fa4ed4d6b99ca763d8dc</code>. 匹配时会委托给 <code>Pbkdf2PasswordEncoder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>第四个密码是 id 为 <code>scrypt</code> 的 <code>PasswordEncoder</code>,encodedPassword 为 <code>$e0801$8bWJaSu2IKSn9Z9kM+TPXfOc/9bdYSrN1oD9qfVThWEwdRTnO7re7Ei+fUZRJ68k9lTyuTeUp4of4g24hHnazw==$OAOec05+bXxvuu/1qZ6NUR+xQYvYv7BeL1QxwRpY5Pc=</code> ,匹配时它将委托给 <code>SCryptPasswordEncoder</code></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>最后一个密码是 id 为 <code>sha256</code>  的 <code>PasswordEncoder</code> ,encodedPassword 为 <code>97cde38028ad898ebc02e690819fa220e88c62e0699403e94fff291cfffaf8410849f27605abcbc0</code>. 匹配时会委托给 <code>StandardPasswordEncoder</code></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一些用户可能担心这会为黑客提供存储格式. 其实不必担心,因为密码的存储不依赖于算法是秘密. 此外,大多数格式很容易让攻击者在没有前缀的情况下弄清楚. 例如,BCrypt 密码通常以 $2a$ 开头.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="authentication-password-storage-dpe-encoding"><a class="anchor" href="#authentication-password-storage-dpe-encoding"></a>密码编码</h6>
<div class="paragraph">
<p>传入构造函数的 <code>idForEncode</code> 确定将使用哪个 <code>PasswordEncoder</code> 来编码密码. 在上面构造的 <code>DelegatingPasswordEncoder</code> 中,这意味着编码 password 的结果将被委托给 <code>BCryptPasswordEncoder</code> 并以 <code>{bcrypt}</code> 为前缀. 最终结果如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 21. DelegatingPasswordEncoder Encode Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="authentication-password-storage-dpe-matching"><a class="anchor" href="#authentication-password-storage-dpe-matching"></a>密码匹配</h6>
<div class="paragraph">
<p>匹配是基于 <code>{id}</code> 以及构造函数中提供的 <code>id</code> 到 <code>PasswordEncoder</code> 的映射完成的. 我们在<a href="#authentication-password-storage-dpe-format">密码存储格式</a> 一节中的 example 提供了一个如何完成的工作示例.
默认情况下,使用密码调用 <code>matches(CharSequence, String)</code> 和未映射的id(包括空 <code>id</code>)的结果将导致 <code>IllegalArgumentException</code>.
可以使用 <code>DelegatingPasswordEncoder.setDefaultPasswordEncoderForMatches(PasswordEncoder)</code> 自定义此行为.</p>
</div>
<div class="paragraph">
<p>通过使用 <code>id</code>,我们可以匹配任何密码编码,但使用最现代的密码编码. 这很重要,
因为与加密不同,密码哈希的设计使得没有简单的方法来恢复明文. 由于无法恢复明文,因此难以迁移密码. 虽然用户很容易迁移 <code>NoOpPasswordEncoder</code>,但我们默认选择将其包含在内,但不是默认的 <code>PasswordEncoder</code>. 以便简化入门体验.</p>
</div>
</div>
<div class="sect5">
<h6 id="authentication-password-storage-dep-getting-started"><a class="anchor" href="#authentication-password-storage-dep-getting-started"></a>入门体验</h6>
<div class="paragraph">
<p>如果您要编写演示或示例,则花一些时间来对用户密码进行哈希运算会很麻烦.  有一些便利机制可以简化此过程,但这仍然不适合生产.</p>
</div>
<div class="exampleblock">
<div class="title">Example 22. withDefaultPasswordEncoder Example</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">User user = User.withDefaultPasswordEncoder()
  .username("user")
  .password("password")
  .roles("user")
  .build();
System.out.println(user.getPassword());
// {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val user = User.withDefaultPasswordEncoder()
    .username("user")
    .password("password")
    .roles("user")
    .build()
println(user.password)
// {bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果要创建多个用户,则还可以重复使用该构建器.</p>
</div>
<div class="exampleblock">
<div class="title">Example 23. withDefaultPasswordEncoder Reusing the Builder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">UserBuilder users = User.withDefaultPasswordEncoder();
User user = users
  .username("user")
  .password("password")
  .roles("USER")
  .build();
User admin = users
  .username("admin")
  .password("password")
  .roles("USER","ADMIN")
  .build();
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val users = User.withDefaultPasswordEncoder()
val user = users
    .username("user")
    .password("password")
    .roles("USER")
    .build()
val admin = users
    .username("admin")
    .password("password")
    .roles("USER", "ADMIN")
    .build()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这会散列存储的密码,但是密码仍在内存和已编译的源代码中暴露.  因此,对于生产环境它仍然不被认为是安全的.  对于生产,您应该<a href="#authentication-password-storage-boot-cli">在外部对密码进行哈希处理</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="authentication-password-storage-boot-cli"><a class="anchor" href="#authentication-password-storage-boot-cli"></a>使用 Spring Boot CLI 编码</h6>
<div class="paragraph">
<p>正确编码密码的最简单方法是使用 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-cli.html">Spring Boot CLI</a>.</p>
</div>
<div class="paragraph">
<p>例如,以下将对与 <a href="#authentication-password-storage-dpe">DelegatingPasswordEncoder</a> 一起使用的 <code>password</code> 密码进行编码:</p>
</div>
<div class="exampleblock">
<div class="title">Example 24. Spring Boot CLI encodepassword Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>spring encodepassword password
{bcrypt}$2a$10$X5wFBtLrL/kHcmrOGGTrGufsBX8CJ0WpQpF3pgeuxBB/H73BK1DW6</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="authentication-password-storage-dpe-troubleshoot"><a class="anchor" href="#authentication-password-storage-dpe-troubleshoot"></a>故障排除</h6>
<div class="paragraph">
<p>如果 <a href="#authentication-password-storage-dpe-format">密码存储格式</a> 一节中描述的其中一个密码没有 id,则会发生以下错误. .</p>
</div>
<div class="listingblock">
<div class="content">
<pre>java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id "null"
    at org.springframework.security.crypto.password.DelegatingPasswordEncoder$UnmappedIdPasswordEncoder.matches(DelegatingPasswordEncoder.java:233)
    at org.springframework.security.crypto.password.DelegatingPasswordEncoder.matches(DelegatingPasswordEncoder.java:196)</pre>
</div>
</div>
<div class="paragraph">
<p>解决错误的最简单方法是切换到显式提供密码编码的 <code>PasswordEncoder</code>. 解决问题的最简单方法是弄清楚当前如何存储密码并明确提供正确的 <code>PasswordEncoder</code>.</p>
</div>
<div class="paragraph">
<p>如果要从 Spring Security 4.2.x 进行迁移,则可以通过 <a href="#authentication-password-storage-configuration">暴露 <code>NoOpPasswordEncoder</code> bean</a> 恢复到先前的行为.</p>
</div>
<div class="paragraph">
<p>或者,您可以为所有密码加上正确的ID前缀,然后继续使用 <code>DelegatingPasswordEncoder</code>.  例如,如果您使用的是 <code>BCrypt</code>,则可以从以下方式迁移密码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG</pre>
</div>
</div>
<div class="paragraph">
<p>to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>{bcrypt}$2a$10$dXJ3SW6G7P50lGmMkkmwe.20cQQubK3.HZWzG3YB1tlRy.fqvM/BG</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关映射的完整列表,请参阅 <a href="https://docs.spring.io/spring-security/site/docs/5.0.x/api/org/springframework/security/crypto/factory/PasswordEncoderFactories.html">PasswordEncoderFactories</a> 上的 Javadoc.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="authentication-password-storage-bcrypt"><a class="anchor" href="#authentication-password-storage-bcrypt"></a>BCryptPasswordEncoder</h5>
<div class="paragraph">
<p><code>BCryptPasswordEncoder</code> 实现使用广泛支持的 <a href="https://en.wikipedia.org/wiki/Bcrypt">bcrypt</a> 算法对密码进行哈希处理.  为了使其更能抵抗密码破解,<code>bcrypt</code> 故意降低了速度.  与其他自适应单向函数一样,应将其调整为大约1秒钟,以验证系统上的密码.
<code>BCryptPasswordEncoder</code> 的默认实现使用强度 10， 如 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/crypto/bcrypt/BCryptPasswordEncoder.html">BCryptPasswordEncoder</a> 的 Javadoc 中所述.  鼓励您
在您自己的系统上调整和测试强度参数， 以使验证密码大约需要 <code>1</code> 秒钟.</p>
</div>
<div class="exampleblock">
<div class="title">Example 25. BCryptPasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Create an encoder with strength 16
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16);
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Create an encoder with strength 16
val encoder = BCryptPasswordEncoder(16)
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="authentication-password-storage-argon2"><a class="anchor" href="#authentication-password-storage-argon2"></a>Argon2PasswordEncoder</h5>
<div class="paragraph">
<p><code>Argon2PasswordEncoder</code> 实现使用 Argon2 算法对密码进行哈希处理.  <a href="https://en.wikipedia.org/wiki/Argon2">Argon2</a> 是 <a href="https://en.wikipedia.org/wiki/Password_Hashing_Competition">Password Hashing Competition</a> 的获胜者.
为了克服自定义硬件上的密码破解问题,<code>Argon2</code> 是一种故意慢速的算法,需要大量内存.
与其他自适应单向函数一样,应将其调整为大约1秒钟,以验证系统上的密码.  如果 <code>Argon2PasswordEncoder</code> 需要 BouncyCastle,则为当前实现.</p>
</div>
<div class="exampleblock">
<div class="title">Example 26. Argon2PasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Create an encoder with all the defaults
Argon2PasswordEncoder encoder = new Argon2PasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Create an encoder with all the defaults
val encoder = Argon2PasswordEncoder()
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="authentication-password-storage-pbkdf2"><a class="anchor" href="#authentication-password-storage-pbkdf2"></a>Pbkdf2PasswordEncoder</h5>
<div class="paragraph">
<p><code>Pbkdf2PasswordEncoder</code> 实现使用 <a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> 算法对密码进行哈希处理.  为了消除密码破解,PBKDF2 是一种故意缓慢的算法.  与其他自适应单向函数一样,应将其调整为大约1秒钟,以验证系统上的密码.  当需要 FIPS 认证时,此算法是不错的选择.</p>
</div>
<div class="exampleblock">
<div class="title">Example 27. Pbkdf2PasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Create an encoder with all the defaults
Pbkdf2PasswordEncoder encoder = new Pbkdf2PasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Create an encoder with all the defaults
val encoder = Pbkdf2PasswordEncoder()
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="authentication-password-storage-scrypt"><a class="anchor" href="#authentication-password-storage-scrypt"></a>SCryptPasswordEncoder</h5>
<div class="paragraph">
<p><code>SCryptPasswordEncoder</code> 实现使用 <a href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a> 算法对密码进行哈希处理.  为了克服自定义硬件 scrypt 上的密码破解问题,它是一种故意缓慢的算法,需要大量内存.
与其他自适应单向函数一样,应将其调整为大约 1 秒钟,以验证系统上的密码.</p>
</div>
<div class="exampleblock">
<div class="title">Example 28. SCryptPasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Create an encoder with all the defaults
SCryptPasswordEncoder encoder = new SCryptPasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Create an encoder with all the defaults
val encoder = SCryptPasswordEncoder()
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="authentication-password-storage-other"><a class="anchor" href="#authentication-password-storage-other"></a>其他的 PasswordEncoders</h5>
<div class="paragraph">
<p>还有许多其他的 <code>PasswordEncoder</code> 的实现,他们完全是为了保持向后兼容而存在的.  目前均已弃用,以表明它们不再被视为安全.  但是,由于很难迁移现有的旧系统,因此没有删除它们的计划.</p>
</div>
</div>
<div class="sect4">
<h5 id="authentication-password-storage-configuration"><a class="anchor" href="#authentication-password-storage-configuration"></a>密码存储配置</h5>
<div class="paragraph">
<p>Spring Security 默认使用 <a href="#authentication-password-storage-dpe">DelegatingPasswordEncoder</a>.  但是,可以通过将 <code>PasswordEncoder</code> 暴露为 Spring Bean 来对其进行自定义.</p>
</div>
<div class="paragraph">
<p>如果您是从 Spring Security 4.2.x 迁移的,则可以通过暴露 <code>NoOpPasswordEncoder</code> bean恢复到以前的行为.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>恢复为 <code>NoOpPasswordEncoder</code> 不被认为是安全的.  相反,您应该迁移到使用 <code>DelegatingPasswordEncoder</code> 来支持安全密码编码.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 29. NoOpPasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public static NoOpPasswordEncoder passwordEncoder() {
    return NoOpPasswordEncoder.getInstance();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;b:bean id="passwordEncoder"
        class="org.springframework.security.crypto.password.NoOpPasswordEncoder" factory-method="getInstance"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun passwordEncoder(): PasswordEncoder {
    return NoOpPasswordEncoder.getInstance();
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>XML 配置要求 <code>NoOpPasswordEncoder</code> Bean名称为 <code>passwordEncoder</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="exploits"><a class="anchor" href="#exploits"></a>5.2. 防止利用漏洞</h3>
<div class="paragraph">
<p>Spring Security 提供了针对常见漏洞的保护.  默认情况下启动.  在下面,您将找到 Spring Security 如何防御各种漏洞的描述.</p>
</div>
<div class="sect3">
<h4 id="csrf"><a class="anchor" href="#csrf"></a>5.2.1. 跨站请求伪造 (CSRF)</h4>
<div class="paragraph">
<p>Spring 为防止 <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">跨站请求伪造(CSRF) </a>攻击提供了全面的支持.  在以下各节中,我们将探讨:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#csrf-explained">什么是 CSRF 攻击? </a></p>
</li>
<li>
<p><a href="#csrf-protection">防御 CSRF 攻击</a></p>
</li>
<li>
<p><a href="#csrf-considerations">CSRF 注意事项</a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本文档的这一部分讨论 CSRF 保护的简单说明.
有关针对<a href="#servlet-csrf">servlet</a> 和基于<a href="#webflux-csrf">WebFlux</a> 的应用程序的 CSRF 保护的特定信息,请参阅相关部分.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="csrf-explained"><a class="anchor" href="#csrf-explained"></a>什么是 CSRF 攻击?</h5>
<div class="paragraph">
<p>理解 CSRF 攻击的最佳方法是看一个具体示例.</p>
</div>
<div class="paragraph">
<p>假设您的银行网站提供了一种表单,该表单允许将资金从当前登录的用户转移到另一个银行帐户.
例如,转帐表单可能看起来像:</p>
</div>
<div class="exampleblock">
<div class="title">Example 30. 转帐表单</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form method="post"
    action="/transfer"&gt;
&lt;input type="text"
    name="amount"/&gt;
&lt;input type="text"
    name="routingNumber"/&gt;
&lt;input type="text"
    name="account"/&gt;
&lt;input type="submit"
    value="Transfer"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>相应的 HTTP 请求可能如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 31. 转账 HTTP 请求</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&amp;routingNumber=1234&amp;account=9876</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在,假装您对银行的网站进行身份验证,然后没有注销,访问了一个恶意的网站.  恶意网站包含具有以下格式的 HTML 页面:</p>
</div>
<div class="exampleblock">
<div class="title">Example 32. 恶意的转账表单</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form method="post"
    action="https://bank.example.com/transfer"&gt;
&lt;input type="hidden"
    name="amount"
    value="100.00"/&gt;
&lt;input type="hidden"
    name="routingNumber"
    value="evilsRoutingNumber"/&gt;
&lt;input type="hidden"
    name="account"
    value="evilsAccountNumber"/&gt;
&lt;input type="submit"
    value="Win Money!"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您想赢钱,因此单击 "submit" 按钮.  在此过程中,您无意中将 $100 转让给了恶意用户.  发生这种情况的原因是,尽管恶意网站无法看到您的 cookie,但与您的银行关联的 cookie 仍与请求一起发送.</p>
</div>
<div class="paragraph">
<p>最糟糕的是,使用 JavaScript 可以使整个过程自动化.  这意味着您甚至不需要单击该按钮.  此外,在访问受 <a href="https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)">XSS攻击</a> 的可靠站点时,也很容易发生这种情况.  那么,我们如何保护用户免受此类攻击呢?</p>
</div>
</div>
<div class="sect4">
<h5 id="csrf-protection"><a class="anchor" href="#csrf-protection"></a>防御 CSRF 攻击</h5>
<div class="paragraph">
<p>CSRF 攻击之所以发生是因为从银行网站上的发出的 HTTP 请求,和从恶意的网站发出的请求完全一样的.
这就意味着没有办法拒绝来自恶意的网站的请求和允许来自银行的网站请求. 为了抵御 CSRF 攻击,我们需要确保请求中有一些信息是恶意网站是无法提供的.</p>
</div>
<div class="paragraph">
<p>Spring 提供了两种机制来防御 CSRF 攻击:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#csrf-protection-stp">同步器令牌模式</a></p>
</li>
<li>
<p>在会话 Cookie 上指定<a href="#csrf-protection-ssa">SameSite 属性</a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>两种保护机制都要求<a href="#csrf-protection-idempotent">安全方法必须是幂等的</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="csrf-protection-idempotent"><a class="anchor" href="#csrf-protection-idempotent"></a>安全方法必须是幂等的</h6>
<div class="paragraph">
<p>为了使针对 CSRF 的<a href="#csrf-protection">任何一种</a>方法起作用,应用程序必须确保 <a href="https://tools.ietf.org/html/rfc7231#section-4.2.1"> 安全的 HTTP方法是幂等的</a>.
这意味着使用 HTTP 方法 <code>GET</code>,<code>HEAD</code>,<code>OPTIONS</code> 和 <code>TRACE</code> 进行的请求不应更改应用程序的状态.</p>
</div>
</div>
<div class="sect5">
<h6 id="csrf-protection-stp"><a class="anchor" href="#csrf-protection-stp"></a>Synchronizer token pattern(STP)同步器令牌模式</h6>
<div class="paragraph">
<p>抵御 CSRF 攻击的最主要,最全面的方法是使用 <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet#General_Recommendation:_Synchronizer_Token_Pattern">同步器令牌模式</a>.
该解决方案是为了确保每个 HTTP 请求除了我们的会话 cookie 外,还必须在 HTTP 请求中提供一个安全的,随机生成的值,称为 CSRF 令牌.</p>
</div>
<div class="paragraph">
<p>提交 HTTP 请求时,服务器必须查找预期的 CSRF 令牌,并将其与 HTTP 请求中的实际 CSRF 令牌进行比较.  如果值不匹配,则应拒绝 HTTP 请求.</p>
</div>
<div class="paragraph">
<p>这项工作的关键在于,实际的 CSRF 令牌应该位于浏览器不会自动包含的 HTTP 请求的一部分中. 例如,在 HTTP 参数或 HTTP 头中设置实际的 CSRF 令牌. 在 cookie 中设置实际 CSRF 令牌不起作用,因为浏览器会自动将 cookie 包含在 HTTP 请求中.</p>
</div>
<div class="paragraph">
<p>我们可以放宽一点,仅对每个更新应用程序状态的 HTTP 请求要求使用 CSRF 令牌. 为此,我们的应用程序必须确保<a href="#csrf-protection-idempotent">HTTP 方法是幂等</a>的. 因为我们希望允许使用外部站点的链接来链接到我们的网站,所以这提高了可用性.
此外,我们不想在 HTTP <code>GET</code> 中包含随机令牌,因为这可能导致令牌泄漏.</p>
</div>
<div class="paragraph">
<p>让我们看一下使用同步器令牌 时<a href="#csrf-explained">示例</a>将如何变化. 假设实际的 CSRF 令牌必须位于名为的 HTTP 参数中 <code>_csrf</code>. 我们应用程序的传输形式如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 33. 同步器令牌表单</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form method="post"
    action="/transfer"&gt;
&lt;input type="hidden"
    name="_csrf"
    value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/&gt;
&lt;input type="text"
    name="amount"/&gt;
&lt;input type="text"
    name="routingNumber"/&gt;
&lt;input type="hidden"
    name="account"/&gt;
&lt;input type="submit"
    value="Transfer"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>表单现在包含带有 CSRF 令牌值的隐藏域. 外部站点无法读取 CSRF 令牌,因为浏览器的同源策略可确保恶意站点无法读取.</p>
</div>
<div class="paragraph">
<p>相应的 HTTP 汇款请求如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 34. 同步器令牌 请求</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>POST /transfer HTTP/1.1
Host: bank.example.com
Cookie: JSESSIONID=randomid
Content-Type: application/x-www-form-urlencoded

amount=100.00&amp;routingNumber=1234&amp;account=9876&amp;_csrf=4bfd1575-3ad1-4d21-96c7-4ef2d9f86721</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您会注意到,HTTP 请求现在包含 <code>_csrf</code> 带有安全随机值的参数. 恶意网站无法为 <code>_csrf</code> 参数提供正确的值,当服务器将实际的令牌与预期的令牌进行比较时,如果不匹配,传输将失败.</p>
</div>
</div>
<div class="sect5">
<h6 id="csrf-protection-ssa"><a class="anchor" href="#csrf-protection-ssa"></a>SameSite 属性</h6>
<div class="paragraph">
<p>防止<a href="#csrf">CSRF 攻击</a> 的一种新兴方法是在 cookie 上指定 <a href="https://tools.ietf.org/html/draft-west-first-party-cookies">SameSite 属性</a>. 服务器可以 <code>SameSite</code> 在设置 cookie 时指定属性,以指示从外部站点发出时不应发送该 cookie.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Security 不直接控制会话 cookie 的创建,因此不提供对 SameSite 属性的支持.  <a href="https://spring.io/projects/spring-session">Spring Session</a>支持 <code>SameSite</code> 基于 servlet 的应用程序中的属性. Spring Framework 的 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/server/session/CookieWebSessionIdResolver.html">CookieWebSessionIdResolver</a> 为 <code>SameSite</code> 基于 <code>WebFlux</code> 的应用程序中的属性提供了开箱即用的支持.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一个带有 <code>SameSite</code> 属性的 HTTP 响应头可能类似于以下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 35. SameSite HTTP 响应</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Set-Cookie: JSESSIONID=randomid; Domain=bank.example.com; Secure; HttpOnly; SameSite=Lax</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该 <code>SameSite</code> 属性的有效值为:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Strict</code> - 指定后,来自 <a href="https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1">同一站点</a>的任何请求都将包含cookie. 否则,cookie将不会包含在HTTP请求中.</p>
</li>
<li>
<p><code>Lax</code> - 当来自 <a href="https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-2.1">同一站点</a>或请求来自顶级导航且<a href="#csrf-protection-idempotent">方法为幂等</a>时,将发送指定的 cookie . 否则,cookie 将不会包含在 HTTP 请求中.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>让我们看一下如何使用属性保护 <a href="#csrf-explained">示例</a> <code>SameSite</code>. 银行应用程序可以通过 <code>SameSite</code> 在会话 cookie 上指定属性来防止 CSRF .</p>
</div>
<div class="paragraph">
<p>随着 <code>SameSite</code> 我们的会话 cookie 属性集,浏览器将继续发送 <code>JSESSIONID</code> 从银行网站来请求的 cookie. 但是,浏览器将不再发送 <code>JSESSIONID</code> 带有来自邪恶网站的传输请求的 cookie. 由于会话不再存在于来自邪恶网站的传输请求中,因此可以保护应用程序免受 CSRF 攻击.</p>
</div>
<div class="paragraph">
<p>使用 <code>SameSite</code> 属性防御 CSRF 攻击时,应注意一些重要的 <a href="https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-5">注意事项</a>.</p>
</div>
<div class="paragraph">
<p>将 <code>SameSite</code> 属性设置为 <code>Strict</code> 可以提供更强的防御能力,但会使用户困惑. 考虑一个保持登录到  <a href="https://social.example.com" class="bare">social.example.com</a>. 托管的社交媒体网站的用户. 用户在 <a href="https://email.example.org" class="bare">email.example.org</a> 上收到一封电子邮件,其中包含指向社交媒体网站的链接.
如果用户单击该链接,则他们理所当然地希望能够通过社交媒体站点进行身份验证. 但是,如果 <code>SameSite</code> 属性为 <code>Strict</code> cookie,则不会发送 cookie,因此不会对用户进行身份验证.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通过实施 <a href="https://github.com/spring-projects/spring-security/issues/7537">gh-7537</a>,我们可以提高 <code>SameSite</code> 保护针对CSRF攻击的保护性和可用性.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>另一个明显的考虑因素是,为了使 <code>SameSite</code> 属性能够保护用户,浏览器必须 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/headers/Set-Cookie#Browser_compatibility">支持 <code>SameSite</code> </a>属性.  大多数现代浏览器都支持 <code>SameSite</code> 属性.  但是,旧的浏览器可能不支持.</p>
</div>
<div class="paragraph">
<p>因此,通常建议将 <code>SameSite</code> 属性用作深度防御,而不是针对 CSRF 攻击的唯一防护.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="csrf-when"><a class="anchor" href="#csrf-when"></a>何时使用CSRF保护</h5>
<div class="paragraph">
<p>什么时候应该使用 CSRF 保护?
什么时候应该使用 CSRF 保护? 我们的建议是对普通用户可能由浏览器处理的任何请求使用 CSRF 保护.  如果仅创建非浏览器客户端使用的服务,则可能需要禁用 CSRF 保护.</p>
</div>
<div class="sect5">
<h6 id="csrf-when-json"><a class="anchor" href="#csrf-when-json"></a>CSRF保护和JSON</h6>
<div class="paragraph">
<p>一个常见的问题是 "我需要保护由 javascript 发出的 JSON 请求吗? " 简短的答案是,视情况而定.  但是,你必须非常小心,因为有 CSRF 攻击可以影响 JSON 请求. 例如,一个恶意用户可以使用以下格式,创建一个 <a href="http://blog.opensecurityresearch.com/2012/02/json-csrf-with-parameter-padding.html">CSRF和JSON使用以下form</a>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form action="https://bank.example.com/transfer" method="post" enctype="text/plain"&gt;
    &lt;input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'&gt;
    &lt;input type="submit"
        value="Win Money!"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将产生以下 JSON 结构</p>
</div>
<div class="exampleblock">
<div class="title">Example 36. CSRF JSON 请求</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">{ "amount": 100,
"routingNumber": "evilsRoutingNumber",
"account": "evilsAccountNumber",
"ignore_me": "=test"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果一个应用程序没有验证内容类型,那么它会接触到这种攻击. 根据设置,验证内容类型的 Spring MVC 应用程序仍然可以利用更新 URL 后缀结尾 <code>".json"</code> 如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 37. CSRF 与 JSON Spring MVC表单</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form action="https://bank.example.com/transfer.json" method="post" enctype="text/plain"&gt;
    &lt;input name='{"amount":100,"routingNumber":"evilsRoutingNumber","account":"evilsAccountNumber", "ignore_me":"' value='test"}' type='hidden'&gt;
    &lt;input type="submit"
        value="Win Money!"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="csrf-when-stateless"><a class="anchor" href="#csrf-when-stateless"></a>CSRF和无状态的浏览器应用程序</h6>
<div class="paragraph">
<p>如果我的应用程序是无状态的呢?这并不意味着你是受保护的. 事实上,如果用户对于一个给定的请求不需要在 web 浏览器中执行任何操作,他们可能仍然容易受到 CSRF 攻击.</p>
</div>
<div class="paragraph">
<p>例如,考虑一个应用程序使用一个定制的 cookie,其中包含所有的声明进行身份验证,而不是 JSESSIONID. 当 CSRF 是由自定义 cookie 与在该 JSESSIONID cookie 在前面的例子中相同的方式发送的,请求被发送.</p>
</div>
<div class="paragraph">
<p>使用基本身份验证的用户也容易受到 CSRF 攻击,因为浏览器会自动包括以同样的方式,在我们前面的例子中该 JSESSIONID 的 cookie 会发送任何请求的用户名密码.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="csrf-considerations"><a class="anchor" href="#csrf-considerations"></a>CSRF注意事项</h5>
<div class="paragraph">
<p>实施针对CSRF攻击的防护时需要考虑一些特殊注意事项.</p>
</div>
<div class="sect5">
<h6 id="csrf-considerations-login"><a class="anchor" href="#csrf-considerations-login"></a>登录</h6>
<div class="paragraph">
<p>为了防止 <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery#Forging_login_requests">forging登录请求</a> 应保护 HTTP 请求中的登录免受 CSRF 攻击.  必须防止伪造登录请求,以使恶意用户无法读取受害者的敏感信息.
攻击通常通过以下方式执行:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>恶意用户使用恶意用户的凭据执行 CSRF 登录.  现在,将受害者验证为恶意用户.</p>
</li>
<li>
<p>然后,恶意用户诱骗受害者访问受感染的网站并输入敏感信息</p>
</li>
<li>
<p>该信息与恶意用户的帐户相关联,因此恶意用户可以使用自己的凭据登录并查看受害者的敏感信息</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>确保保护HTTP请求不受CSRF攻击的可能的麻烦在于,用户可能会遇到会话超时,从而导致请求被拒绝.  会话超时对于不需要登录才需要会话的用户来说是令人惊讶的. 有关更多信息,请参阅<a href="#csrf-considerations-timeouts">CSRF和会话超时</a>部分.</p>
</div>
</div>
<div class="sect5">
<h6 id="csrf-considerations-logout"><a class="anchor" href="#csrf-considerations-logout"></a>注销</h6>
<div class="paragraph">
<p>为了防止伪造注销请求,应该保护注销HTTP请求免受CSRF攻击.  必须防止伪造注销请求,以便恶意用户无法读取受害者的敏感信息.  有关攻击的详细信息,请参阅此 <a href="https://labs.detectify.com/2017/03/15/loginlogout-csrf-time-to-reconsider/">博客文章</a>.</p>
</div>
<div class="paragraph">
<p>确保保护 HTTP 请求不受 CSRF 攻击的可能的麻烦在于,用户可能会遇到会话超时,从而导致请求被拒绝.  会话超时对于不需要登录才需要会话的用户来说是令人惊讶的. 有关更多信息,请参阅<a href="#csrf-considerations-timeouts">CSRF 和会话超时</a>部分.</p>
</div>
</div>
<div class="sect5">
<h6 id="csrf-considerations-timeouts"><a class="anchor" href="#csrf-considerations-timeouts"></a>CSRF和会话超时</h6>
<div class="paragraph">
<p>通常,预期的 CSRF 令牌存储在会话中.  这意味着会话超时后,服务器将不会找到预期的 CSRF 令牌并拒绝 HTTP 请求.  有很多选项可以解决超时问题,每个选项都需要权衡取舍.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>解决超时的最佳方法是使用 JavaScript 在表单提交时请求 CSRF 令牌.  然后使用 CSRF 令牌更新表单并提交.</p>
</li>
<li>
<p>另一个选择是使用一些 JavaScript,让用户知道他们的会话即将到期.  用户可以单击按钮继续并刷新会话.</p>
</li>
<li>
<p>最后,预期的 CSRF 令牌可以存储在 cookie 中.  这样可以使预期的 CSRF 令牌寿命更长.</p>
<div class="paragraph">
<p>有人可能会问为什么默认情况下预期的CSRF令牌没有存储在 Cookie 中.  这是因为存在已知的漏洞,可以通过另一个 domain 来设置请求头(即指定 cookie) .
这与 <a href="https://weblog.rubyonrails.org/2011/2/8/csrf-protection-bypass-in-ruby-on-rails/">当请求头 <code>X-Requested-With</code> 存在时,不再跳过CSRF检查</a>原因相同.
请参阅此 <a href="http://lists.webappsec.org/pipermail/websecurity_lists.webappsec.org/2011-February/007533.html"> webappsec.org thread</a>以获取有关如何执行漏洞利用的详细信息.  另一个缺点是,通过删除状态(即超时) ,您将失去在令牌遭到破坏时强制终止令牌的能力.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="csrf-considerations-multipart"><a class="anchor" href="#csrf-considerations-multipart"></a>Multipart (file upload)</h6>
<div class="paragraph">
<p>保护分段请求(文件上传) 免受 CSRF 攻击会导致 <a href="https://en.wikipedia.org/wiki/Chicken_or_the_egg">鸡和蛋</a> 的问题.  为了防止发生 CSRF 攻击,必须读取 HTTP 请求的正文以获得实际的CSRF令牌.  但是,读取正文表示文件将被上传,这意味着外部站点可以上传文件.</p>
</div>
<div class="paragraph">
<p>有两个选项来使用 CSRF 保护 multipart/form-data.每个选项都有其权衡.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#csrf-considerations-multipart-body">将 CSRF 令牌放入 body 中</a></p>
</li>
<li>
<p><a href="#csrf-considerations-multipart-url">将 CSRF 令牌放入 URL</a></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在将 Spring Security 的 CSRF 保护与分段文件上传集成之前,确保没有 CSRF 保护你可以第一时间上传.
有关在Spring中使用multipart表单的更多信息,请参见  <a href="https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart">1.1.11. Multipart Resolver</a> .  Spring 参考的Multipart Resolver部分和 <a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html">MultipartFilter javadoc</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect6">
<h7 id="csrf-considerations-multipart-body"><a class="anchor" href="#csrf-considerations-multipart-body"></a>将CSRF令牌放入body 中</h7>
<div class="paragraph">
<p>第一种选择是在请求正文中包含实际的 CSRF 令牌.  通过将 CSRF 令牌放入正文中,将在执行授权之前读取正文.  这意味着任何人都可以在您的服务器上放置临时文件.  但是,只有授权用户才能提交由您的应用程序处理的文件.  通常,这是推荐的方法,因为临时文件上传对大多数服务器的影响可以忽略不计.</p>
</div>
</div>
<div class="sect6">
<h7 id="csrf-considerations-multipart-url"><a class="anchor" href="#csrf-considerations-multipart-url"></a>将CSRF令牌放入URL</h7>
<div class="paragraph">
<p>如果不允许未经授权的用户上传临时文件,则可以选择将预期的 CSRF 令牌作为查询参数包括在表单的 <code>action</code> 属性中.  这种方法的缺点是查询参数可能会泄漏.  更一般而言,将敏感数据放置在 body 或 header 中以确保其不会泄漏是最佳实践.  可以在 <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec15.html#sec15.1.3">RFC 2616第15.1.3节在URI中编码敏感信息</a>中找到其他信息.</p>
</div>
</div>
<div class="sect6">
<h7 id="csrf-considerations-override-method"><a class="anchor" href="#csrf-considerations-override-method"></a>HiddenHttpMethodFilter</h7>
<div class="paragraph">
<p>在某些应用程序中,可以使用 form 参数来覆盖HTTP方法.  例如,下面的表格可用于将 HTTP 方法视为 <code>delete</code> 而不是 <code>post</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 38. CSRF form 隐藏的 HTTP 方法</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form action="/process"
    method="post"&gt;
    &lt;!-- ... --&gt;
    &lt;input type="hidden"
        name="_method"
        value="delete"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该 <code>HiddenHttpMethodFilter</code> 应放在 Spring Security 的过滤器之前. 一般来说这是事实,但它可能能够对防止 CSRF 攻击有更多的影响.
请注意,<code>HiddenHttpMethodFilter</code> 只覆盖一个 <code>POST</code> HTTP 方法,所以这实际上是不可能造成任何实际问题. 但是,它仍然是最好的做法,以确保它被放置在 Spring Security 过滤器之前.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="headers"><a class="anchor" href="#headers"></a>5.2.2. 安全HTTP响应头</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>文档的此部分讨论安全 HTTP 响应头的一般主题.  有关安全HTTP响应头 <a href="#servlet-headers">servlet</a> 和基于 <a href="#webflux-headers">WebFlux</a> 的应用程序的特定信息,请参阅相关部分.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有许多  <a href="https://www.owasp.org/index.php/OWASP_Secure_Headers_Project#tab=Headers">HTTP响应头</a>  可用于提高Web应用程序的安全性.
本节专门介绍 Spring Security 提供显式支持的各种 HTTP 响应头.  如有必要,还可以使用 Spring Security 配置 <a href="#headers-custom">自定义响应头</a>.</p>
</div>
<div class="sect4">
<h5 id="headers-default"><a class="anchor" href="#headers-default"></a>默认安全响应头</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请参阅相关部分,以了解如何为基于 <a href="#servlet-headers-default">servlet</a> 和基于 <a href="#webflux-headers-default">webflux</a> 的应用程序定制默认值.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security 提供了一组默认的与安全性相关的HTTP响应头,以提供安全的默认值.</p>
</div>
<div class="exampleblock">
<div class="title">Example 39. 默认安全的 HTTP 响应头</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-http" data-lang="http">Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0
X-Content-Type-Options: nosniff
Strict-Transport-Security: max-age=31536000 ; includeSubDomains
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
仅在 HTTPS 请求上添加严格传输安全性
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果默认设置不能满足您的需求,则可以轻松地从这些默认设置中删除,修改或添加 headers .  有关这些 header 中的每个 header 的更多详细信息,请参阅相应的部分:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#headers-cache-control">缓存控制</a></p>
</li>
<li>
<p><a href="#headers-content-type-options">Content Type 选项</a></p>
</li>
<li>
<p><a href="#headers-hsts">HTTP 严格传输安全</a></p>
</li>
<li>
<p><a href="#headers-frame-options">X-Frame-Options</a></p>
</li>
<li>
<p><a href="#headers-xss-protection">X-XSS-Protection</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="headers-cache-control"><a class="anchor" href="#headers-cache-control"></a>缓存控制</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请参阅相关部分,以了解如何为基于 <a href="#servlet-headers-cache-control">servlet</a> 和基于 <a href="#webflux-headers-cache-control">webflux</a> 的应用程序定制默认值.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security 的默认设置是禁用缓存以保护用户的内容.</p>
</div>
<div class="paragraph">
<p>如果用户进行了身份验证以查看敏感信息然后注销,则我们不希望恶意用户能够单击 "后退" 按钮查看敏感信息.  默认情况下发送的缓存控制 header 是:</p>
</div>
<div class="exampleblock">
<div class="title">Example 40. 默认缓存控制 HTTP 响应头</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Cache-Control: no-cache, no-store, max-age=0, must-revalidate
Pragma: no-cache
Expires: 0</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了默认安全,Spring Security 默认添加这些头.  但是,如果您的应用程序提供了它自己的缓存控制 header ,Spring Security 将会退出.  这允许应用程序确保可以缓存 CSS 和 JavaScript 之类的静态资源.</p>
</div>
</div>
<div class="sect4">
<h5 id="headers-content-type-options"><a class="anchor" href="#headers-content-type-options"></a>Content Type 选项</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请参阅相关部分,以了解如何为基于 <a href="#servlet-headers-content-type-options">servlet</a> 和基于 <a href="#webflux-headers-content-type-options">webflux</a> 的应用程序定制默认值.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>历史上,包括 Internet Explorer 在内的浏览器都会尝试使用内容 <a href="https://en.wikipedia.org/wiki/Content_sniffing">嗅探</a> 来猜测请求的内容类型.  这允许浏览器通过猜测未指定内容类型的资源上的内容类型来改善用户体验.  例如,如果浏览器遇到一个未指定内容类型的 JavaScript 文件,它将能够猜测该内容类型然后执行.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>允许上传内容时,还有许多其他事情 (即,仅在不同的域中显示文档,确保设置了 Content-Type 头,清理文档等) .  但是,这些措施不在Spring Security 提供的范围之内.  指出禁用内容嗅探时也很重要,您必须指定内容类型才能使内容正常工作.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>内容嗅探的问题在于,这允许恶意用户使用多义词 (即,可以作为多种内容类型有效的文件) 执行 XSS 攻击.  例如,某些网站可能允许用户向网站提交有效的附言文档并进行查看.  恶意用户可能会创建一个也是 <a href="http://webblaze.cs.berkeley.edu/papers/barth-caballero-song.pdf">有效 JavaScript 文件的 Postscript 文档</a>,并对其执行 XSS 攻击.</p>
</div>
<div class="paragraph">
<p>可以通过在响应中添加以下 header 来禁用内容嗅探:</p>
</div>
<div class="exampleblock">
<div class="title">Example 41. nosniff HTTP 响应头</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-http" data-lang="http">X-Content-Type-Options: nosniff</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="headers-hsts"><a class="anchor" href="#headers-hsts"></a>HTTP Strict Transport Security (HSTS)</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请参阅相关部分,以了解如何为基于 <a href="#servlet-headers-hsts">servlet</a> 和基于 <a href="#webflux-headers-hsts">webflux</a> 的应用程序定制默认值.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当您输入您的银行的网站,您进入 mybank.example.com 或进入 <a href="https://mybank.example.com" class="bare">mybank.example.com</a> 如果您忽略了 https 协议,您可能会受到 <a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">中间人攻击</a>.
即使网站执行重定向到 <a href="https://mybank.example.com" class="bare">mybank.example.com</a>, 恶意用户也可以截获初始 HTTP 请求并操纵响应(即重定向到  <a href="https://mibank.example.com" class="bare">mibank.example.com</a>  并窃取他们的凭证).</p>
</div>
<div class="paragraph">
<p>许多用户忽略了 https 协议,这就是创建HTTP <a href="https://tools.ietf.org/html/rfc6797">严格传输安全性 (HSTS) </a>的原因.  将  mybank.example.com 添加为 <a href="https://tools.ietf.org/html/rfc6797#section-5.1">HSTS主机</a> 后,浏览器可以提前知道对  mybank.example.com 的任何请求都应解释为 <a href="https://mybank.example.com" class="bare">mybank.example.com</a>.  这大大降低了发生中间人攻击的可能性.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>根据 <a href="https://tools.ietf.org/html/rfc6797#section-7.2">RFC6797</a>,HSTS 头仅注入到 HTTPS 响应中.  为了使浏览器能够确认 header ,浏览器必须首先信任对用于建立连接的 SSL 证书 (不仅仅是 SSL 证书) 进行签名的 CA.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>将站点标记为 HSTS 主机的一种方法是将主机预加载到浏览器中.  另一方法是将 <code>Strict-Transport-Security</code>  header 添加到响应中.  例如,以下内容将指示浏览器将域视为一年的HSTS主机 (一年大约 31536000 秒) :</p>
</div>
<div class="exampleblock">
<div class="title">Example 42. Strict Transport Security HTTP Response Header</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Strict-Transport-Security: max-age=31536000 ; includeSubDomains ; preload</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可选的 <code>includeSubDomains</code> 指令指示 Spring Security 子域 (即secure.mybank.example.com) 也应被视为 HSTS 域.</p>
</div>
<div class="paragraph">
<p>可选的 <code>preload</code> 指令指示 Spring Security 该域应在浏览器中预加载为HSTS域.  有关 HSTS 预加载的更多详细信息,请参见 <a href="https://hstspreload.org" class="bare">hstspreload.org</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="headers-hpkp"><a class="anchor" href="#headers-hpkp"></a>HTTP Public Key Pinning (HPKP)</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了保持被动,Spring Security 仍在 <a href="#servlet-headers-hpkp">servlet 环境中提供对 HPKP 的支持</a>,但是由于上述原因,安全团队不再推荐 HPKP.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning">HTTP Public Key Pinning (HPKP)</a>  向 Web 客户端指定要与某些 Web 服务器一起使用的公共密钥,以防止使用伪造证书的中间人 (MITM) 攻击.
如果使用得当,HPKP 可以添加更多的保护层,以防止受到破坏的证书.  但是,由于 HPKP 的复杂性,许多专家不再建议使用它, <a href="https://www.chromestatus.com/feature/5903385005916160">Chrome甚至取消了对它的支持</a>.</p>
</div>
<div id="headers-hpkp-deprecated" class="paragraph">
<p>有关为何不再推荐使用 HPKP 的更多详细信息,请阅读  <a href="https://blog.qualys.com/ssllabs/2016/09/06/is-http-public-key-pinning-dead">Is HTTP Public Key Pinning Dead?</a> 和 <a href="https://scotthelme.co.uk/im-giving-up-on-hpkp/">I&#8217;m giving up on HPKP</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="headers-frame-options"><a class="anchor" href="#headers-frame-options"></a>X-Frame-Options</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请参阅相关部分,以了解如何为基于 <a href="#servlet-headers-frame-options">servlet</a> 和基于 <a href="#webflux-headers-frame-options">webflux</a> 的应用程序定制默认值.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>允许将您的网站添加到框架可能是一个安全问题.  例如,使用聪明的CSS样式用户可能会被诱骗点击他们不想要的内容. 例如,登录到其银行的用户可以单击将按钮授予其他用户访问权限.  这种攻击称为 <a href="https://en.wikipedia.org/wiki/Clickjacking">Clickjacking</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>处理点击劫持的另一种现代方法是使用<a href="#headers-csp">"内容安全策略 (CSP) " </a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>有许多方法可以缓解点击劫持攻击.  例如,要保护旧版浏览器免遭点击劫持攻击,可以使用分帧代码.  虽然不完美,但是对于传统浏览器而言, <a href="https://www.owasp.org/index.php/Clickjacking_Defense_Cheat_Sheet#Best-for-now_Legacy_Browser_Frame_Breaking_Script">frame breaking code</a> 是最好的选择.</p>
</div>
<div class="paragraph">
<p>解决点击劫持的更现代方法是使用 <a href="https://developer.mozilla.org/en-US/docs/HTTP/X-Frame-Options">X-Frame-Options</a>  头:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>X-Frame-Options: DENY</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="headers-xss-protection"><a class="anchor" href="#headers-xss-protection"></a>X-XSS-Protection</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请参阅相关部分,以了解如何为基于 <a href="#servlet-headers-xss-protection">servlet</a> 和基于 <a href="#webflux-headers-xss-protection">webflux</a> 的应用程序定制默认值.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>一些浏览器内置了对过滤掉 <a href="https://www.owasp.org/index.php/Testing_for_Reflected_Cross_site_scripting_(OWASP-DV-001)">reflected XSS attacks</a>的支持.  这绝非万无一失,但确实有助于 XSS 保护.</p>
</div>
<div class="paragraph">
<p>通常默认情况下会启用过滤,因此添加 header 通常只会确保 header 已启用,并指示浏览器在检测到 XSS 攻击时应采取的措施.
例如,过滤器可能会尝试以最小侵入性的方式更改内容以仍然呈现所有内容.  有时,这种替换本身可能会成为 <a href="https://hackademix.net/2009/11/21/ies-xss-filter-creates-xss-vulnerabilities/">XSS漏洞本身</a>.  相反,最好是阻止内容,而不要尝试对其进行修复.  为此,我们可以添加以下 header :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>X-XSS-Protection: 1; mode=block</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="headers-csp"><a class="anchor" href="#headers-csp"></a>Content Security Policy (CSP)</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请参阅相关部分,以了解如何为基于 <a href="#servlet-headers-csp">servlet</a> 和基于 <a href="#webflux-headers-csp">webflux</a> 的应用程序定制默认值.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://www.w3.org/TR/CSP2/">Content Security Policy (CSP)</a> 是Web应用程序可以利用的一种机制,可以缓解诸如跨站点脚本 (XSS) 之类的内容注入漏洞.  CSP 是一种声明性策略,为Web应用程序作者提供了一种工具,可以声明该 Web 应用程序希望从中加载资源的来源,并最终将这些信息通知客户端 (用户代理) .</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>内容安全策略并非旨在解决所有内容注入漏洞.  取而代之的是,可以利用 CSP 帮助减少内容注入攻击所造成的危害.  作为第一道防线,Web 应用程序作者应验证其输入并对其输出进行编码.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Web应用程序可以通过在响应中包括以下 HTTP header 之一来使用 CSP:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Content-Security-Policy</code></p>
</li>
<li>
<p><code>Content-Security-Policy-Report-Only</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些 header 中的每一个都用作将安全策略传递给客户端的机制.  安全策略包含一组安全策略指令,每个指令负责声明对特定资源表示形式的限制.</p>
</div>
<div class="paragraph">
<p>例如,Web应用程序可以通过在响应中包括以下 header 来声明它希望从特定的受信任源中加载脚本:</p>
</div>
<div class="exampleblock">
<div class="title">Example 43. Content Security Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Content-Security-Policy: script-src https://trustedscripts.example.com</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>用户代理会阻止尝试从另一个源 (而不是 <em>script-src</em> 指令中声明的内容) 加载脚本.  此外,如果在安全策略中声明了  <a href="https://www.w3.org/TR/CSP2/#directive-report-uri"><strong><em>report-uri</em></strong></a>  指令,则用户代理会将违反行为报告给声明的URL.</p>
</div>
<div class="paragraph">
<p>例如,如果 Web 应用程序违反了已声明的安全策略,则以下响应头将指示用户代理将违规报告发送到策略的  <em>report-uri</em>  指令中指定的 URL.</p>
</div>
<div class="exampleblock">
<div class="title">Example 44. Content Security Policy with report-uri</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Content-Security-Policy: script-src https://trustedscripts.example.com; report-uri /csp-report-endpoint/</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://www.w3.org/TR/CSP2/#violation-reports"><strong><em>Violation reports</em></strong></a> 是标准的 JSON 结构,可以由 Web 应用程序自己的 API 或公共托管的 CSP 违规报告服务 (例如 <a href="https://report-uri.io/"><strong><em>REPORT-URI</em></strong></a>) 捕获.</p>
</div>
<div class="paragraph">
<p>Content-Security-Policy-Report-Only  header 为 Web 应用程序作者和管理员提供了监视安全策略而不是强制执行这些策略的功能.  该标题通常在试验和/或开发站点的安全策略时使用.  当某个策略被认为有效时,可以通过使用  <em>Content-Security-Policy</em>   header 字段来强制实施.</p>
</div>
<div class="paragraph">
<p>给定以下响应头,该策略声明可以从两个可能的来源之一加载脚本.</p>
</div>
<div class="exampleblock">
<div class="title">Example 45. Content Security Policy Report Only</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Content-Security-Policy-Report-Only: script-src 'self' https://trustedscripts.example.com; report-uri /csp-report-endpoint/</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果站点违反了此策略,则通过尝试从 <em>evil.com</em> 加载脚本,用户代理会将违规报告发送到 <em>report-uri</em> 指令指定的声明 URL,但仍然允许违规资源加载.</p>
</div>
<div class="paragraph">
<p>将内容安全策略应用于 Web 应用程序通常是一项艰巨的任务.  以下资源可能会为您的网站制定有效的安全策略提供进一步的帮助.</p>
</div>
<div class="paragraph">
<p><a href="https://www.html5rocks.com/en/tutorials/security/content-security-policy/">An Introduction to Content Security Policy</a></p>
</div>
<div class="paragraph">
<p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/CSP">CSP Guide - Mozilla Developer Network</a></p>
</div>
<div class="paragraph">
<p><a href="https://www.w3.org/TR/CSP2/">W3C Candidate Recommendation</a></p>
</div>
</div>
<div class="sect4">
<h5 id="headers-referrer"><a class="anchor" href="#headers-referrer"></a>Referrer Policy</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请参阅相关部分,以了解如何为基于 <a href="#servlet-headers-referrer">servlet</a> 和基于 <a href="#webflux-headers-referrer">webflux</a> 的应用程序定制默认值.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://www.w3.org/TR/referrer-policy">Referrer Policy</a> 是一种机制,Web应用程序可以利用该机制来管理引荐来源网址字段,该字段包含用户所在的最后一页.
Spring Security 的方法是使用 <a href="https://www.w3.org/TR/referrer-policy/">Referrer Policy</a> 头,该 header 提供了不同的 <a href="https://www.w3.org/TR/referrer-policy/#referrer-policies">策略</a>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 46. Referrer Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Referrer-Policy: same-origin</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Referrer-Policy 响应头指示浏览器让目的地知道用户先前所在的源.</p>
</div>
</div>
<div class="sect4">
<h5 id="headers-feature"><a class="anchor" href="#headers-feature"></a>Feature Policy</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请参阅相关部分,以了解如何为基于 <a href="#servlet-headers-feature">servlet</a> 和基于 <a href="#webflux-headers-feature">webflux</a> 的应用程序定制默认值.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://wicg.github.io/feature-policy/">Feature Policy</a> 是一种机制,允许 Web 开发人员在浏览器中选择性地启用,禁用和修改某些 API 和 Web 功能的行为.</p>
</div>
<div class="exampleblock">
<div class="title">Example 47. Feature Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Feature-Policy: geolocation 'self'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>借助 Feature Policy,开发人员可以为浏览器选择一套 "策略",以实施整个站点中使用的特定功能.  这些政策限制了网站可以访问或修改某些功能的浏览器默认行为的 API.</p>
</div>
</div>
<div class="sect4">
<h5 id="headers-clear-site-data"><a class="anchor" href="#headers-clear-site-data"></a>清除站点数据</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请参阅相关部分,以了解如何为基于 <a href="#servlet-headers-clear-site-data">servlet</a> 和基于 <a href="#webflux-headers-clear-site-data">webflux</a> 的应用程序定制默认值.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="https://www.w3.org/TR/clear-site-data/">Clear Site Data</a> 清除站点数据是一种机制,通过该机制,当 HTTP 响应包含以下 header 时,可以删除所有浏览器端数据 (Cookie,本地存储等) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Clear-Site-Data: "cache", "cookies", "storage", "executionContexts"</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是注销时执行的不错的清理操作.</p>
</div>
</div>
<div class="sect4">
<h5 id="headers-custom"><a class="anchor" href="#headers-custom"></a>自定义 Headers</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请参阅相关部分,以了解如何配置两个基于 <a href="#servlet-headers-custom">servlet</a> 的应用程序.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security 具有使您可以方便地将更常见的安全 header 添加到您的应用程序的机制.  但是,它也提供了挂钩来启用添加自定义 header .</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="http"><a class="anchor" href="#http"></a>5.2.3. HTTP</h4>
<div class="paragraph">
<p>所有基于 HTTP 的通信(包括 <a href="https://www.troyhunt.com/heres-why-your-static-website-needs-https/">静态资源</a>) 都应 <a href="https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html">使用 TLS</a> 进行保护.</p>
</div>
<div class="paragraph">
<p>作为一个框架,Spring Security 不处理 HTTP 连接,因此不直接提供对 HTTPS 的支持.  但是,它确实提供了许多有助于 HTTPS 使用的功能.</p>
</div>
<div class="sect4">
<h5 id="http-redirect"><a class="anchor" href="#http-redirect"></a>重定向为 HTTPS</h5>
<div class="paragraph">
<p>当客户端使用 HTTP 时,Spring Security 可以为  <a href="#servlet-http-redirect">Servlet</a>  和  <a href="#webflux-http-redirect">WebFlux</a> 环境配置重定向到   到 HTTPS.</p>
</div>
</div>
<div class="sect4">
<h5 id="http-hsts"><a class="anchor" href="#http-hsts"></a>严格的安全传输</h5>
<div class="paragraph">
<p>Spring Security 提供对  <a href="#headers-hsts">严格安全传输</a>  的支持,并默认启用它.</p>
</div>
</div>
<div class="sect4">
<h5 id="http-proxy-server"><a class="anchor" href="#http-proxy-server"></a>代理服务器配置</h5>
<div class="paragraph">
<p>使用代理服务器时,确保已正确配置应用程序很重要.  例如,许多应用程序将具有负载平衡器,该负载平衡器通过将请求转发到位于 <a href="https://192.168.1:8080" class="bare">192.168.1:8080</a> 的应用程序服务器来响应对 <a href="https://example.com/" class="bare">example.com/</a> 的请求.  知道负载均衡器存在,并将请求视为客户端请求 <a href="https://192.168.1:8080" class="bare">192.168.1:8080</a></p>
</div>
<div class="paragraph">
<p>要解决此问题,您可以使用 <a href="https://tools.ietf.org/html/rfc7239">RFC 7239</a> 来指定正在使用负载平衡器.  为了使应用程序意识到这一点,您需要配置应用程序服务器以了解 <code>X-Forwarded</code> header.  例如,Tomcat使用 <a href="https://tomcat.apache.org/tomcat-8.0-doc/api/org/apache/catalina/valves/RemoteIpValve.html">RemoteIpValve</a>,
而Jetty使用 <a href="https://download.eclipse.org/jetty/stable-9/apidocs/org/eclipse/jetty/server/ForwardedRequestCustomizer.html">ForwardedRequestCustomizer</a>.  另外,Spring 4.3 及更高版本的用户可以利用 <a href="https://github.com/spring-projects/spring-framework/blob/v4.3.3.RELEASE/spring-web/src/main/java/org/springframework/web/filter/ForwardedHeaderFilter.java">ForwardedHeaderFilter</a>.</p>
</div>
<div class="paragraph">
<p>Spring Boot 用户可以使用 <code>server.use-forward-headers</code> 属性配置应用程序.  有关更多详细信息,请参见 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-use-tomcat-behind-a-proxy-server">Spring Boot documentation</a>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="modules"><a class="anchor" href="#modules"></a>6. 项目模块和依赖</h2>
<div class="sectionbody">
<div class="paragraph">
<p>在 Spring Security 3.0, 代码库被分割到单独的 jar,这样可以更清楚的分隔不用功能区域和第三方依赖. 如果你使用Maven构建你的项目,那么这些都是需要你添加到你的 <code>pom.xml</code> 中的. 甚至你没有使用Maven,我们建议你请求 <code>pom.xml</code> 文件来获取第三方依赖和版本. 另一个好办法是检查实例应用程序的库.</p>
</div>
<div class="paragraph">
<p>本节介绍了 Spring Security 中各模块的文档介绍以及他们在应用程序中运行所需的其他依赖. 我们没有包括在构建或测试 Spring Security 本身时使用的依赖. 也没有包含外部依赖所要求的依赖传递.</p>
</div>
<div class="paragraph">
<p>项目网站上列出了所需的 Spring 版本， 因此下面的 Spring 依赖省略了版本号.
请注意， Spring 应用程序中的其他非安全功能可能仍需要下面列出为  "optional"  的某些依赖.
另外， 如果大多数应用程序中都使用了 "optional" 的依赖， 则在项目的 Maven POM 文件中可能实际上并未将其标记为此类.
除非您使用指定的功能， 否则它们仅在不需要它们的意义上是  "optional" .</p>
</div>
<div class="paragraph">
<p>在模块依赖于另一个 Spring Security 模块的情况下， 也认为该模块所依赖的模块的  "optional"  依赖是必需的， 因此未单独列出.</p>
</div>
<div class="sect2">
<h3 id="spring-security-core"><a class="anchor" href="#spring-security-core"></a>6.1. 核心模块&#8201;&#8212;&#8201;<code>spring-security-core.jar</code></h3>
<div class="paragraph">
<p>包含核心的验证和访问控制类和接口,远程支持和基本的配置 API. 任何使用 Spring Security 的应用程序都需要这个模块. 支持独立应用程序、远程客户端、服务层方法安全和 JDBC 用户配置. 包含以下顶层包:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.security.core</code></p>
</li>
<li>
<p><code>org.springframework.security.access</code></p>
</li>
<li>
<p><code>org.springframework.security.authentication</code></p>
</li>
<li>
<p><code>org.springframework.security.provisioning</code></p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Core Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ehcache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if the Ehcache-based user cache implementation is used (optional).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-aop</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Method security is based on Spring AOP</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-beans</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required for Spring configuration</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-expression</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required for expression-based method security (optional)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-jdbc</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if using a database to store user data (optional).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-tx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if using a database to store user data (optional).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aspectjrt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if using AspectJ support (optional).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">jsr250-api</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if you are using JSR-250 method-security annotations (optional).</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="spring-security-remoting"><a class="anchor" href="#spring-security-remoting"></a>6.2. 远程调用&#8201;&#8212;&#8201;<code>spring-security-remoting.jar</code></h3>
<div class="paragraph">
<p>提供与 Spring Remoting 的集成,通常你不需要这个模块,除非你正使用 Spring Remoting 编写远程客户端. 主要的包是 <code>org.springframework.security.remoting</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Remoting Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required for clients which use HTTP remoting support.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="spring-security-web"><a class="anchor" href="#spring-security-web"></a>6.3. Web&#8201;&#8212;&#8201;<code>spring-security-web.jar</code></h3>
<div class="paragraph">
<p>该模块包含过滤器和相关的 Web 安全基础结构代码.  它包含任何与 Servlet API 相关的内容.  如果需要 Spring Security Web 认证服务和基于 URL 的访问控制,则需要它.  主要包是 <code>org.springframework.security.web</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 3. Web Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring web support classes are used extensively.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-jdbc</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required for JDBC-based persistent remember-me token repository (optional).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-tx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required by remember-me persistent token repository implementations (optional).</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="spring-security-config"><a class="anchor" href="#spring-security-config"></a>6.4. 配置&#8201;&#8212;&#8201;<code>spring-security-config.jar</code></h3>
<div class="paragraph">
<p>包含安全命名空间解析和 Java 配置代码. 如果您使用 Spring Security XML 命名空间进行配置或 Spring Security 的 Java 配置支持,则需要它.  主包名为  <code>org.springframework.security.config</code>.这些类都不打算直接在应用程序中使用.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 4. Config Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if you are using any web-related namespace configuration (optional).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-ldap</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if you are using the LDAP namespace options (optional).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-openid</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if you are using OpenID authentication (optional).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aspectjweaver</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if using the protect-pointcut namespace syntax (optional).</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="spring-security-ldap"><a class="anchor" href="#spring-security-ldap"></a>6.5. LDAP&#8201;&#8212;&#8201;<code>spring-security-ldap.jar</code></h3>
<div class="paragraph">
<p>LDAP 验证和配置代码,如果你需要使用 LDAP 验证和管理 LDAP 用户实体,你需要这个模块. 主包名为 <code>org.springframework.security.ldap</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 5. LDAP Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-ldap-core</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.3.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LDAP support is based on Spring LDAP.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-tx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data exception classes are required.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">apache-ds <sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.5.5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if you are using an embedded LDAP server (optional).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">shared-ldap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9.15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if you are using an embedded LDAP server (optional).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ldapsdk</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mozilla LdapSDK.
Used for decoding LDAP password policy controls if you are using password-policy functionality with OpenLDAP, for example.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="spring-security-oauth2-core"><a class="anchor" href="#spring-security-oauth2-core"></a>6.6. OAuth 2.0 核心包&#8201;&#8212;&#8201;<code>spring-security-oauth2-core.jar</code></h3>
<div class="paragraph">
<p><code>spring-security-oauth2-core.jar</code> 包含核心类和接口,这些类和接口提供对 OAuth 2.0授权框架和 OpenID Connect Core 1.0的支持.  使用 OAuth 2.0 或 OpenID Connect Core 1.0 的应用程序 (例如客户端,资源服务器和授权服务器) 需要它.  顶层的包是 <code>org.springframework.security.oauth2.core</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-oauth2-client"><a class="anchor" href="#spring-security-oauth2-client"></a>6.7. OAuth 2.0 客户端&#8201;&#8212;&#8201;<code>spring-security-oauth2-client.jar</code></h3>
<div class="paragraph">
<p><code>spring-security-oauth2-client.jar</code> 包含 Spring Security 对 OAuth 2.0 授权框架和 OpenID Connect Core 1.0的客户端支持.  使用 OAuth 2.0 登录 或 OAuth 客户端支持的应用程序需要使用它.  顶层的包是 <code>org.springframework.security.oauth2.client</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-oauth2-jose"><a class="anchor" href="#spring-security-oauth2-jose"></a>6.8. OAuth 2.0 JOSE&#8201;&#8212;&#8201;<code>spring-security-oauth2-jose.jar</code></h3>
<div class="paragraph">
<p><code>spring-security-oauth2-jose.jar</code> 包含 Spring Security 对 JOSE (Javascript 对象签名和加密) 框架的支持.  JOSE 框架旨在提供一种在各方之间安全地转移 <code>claims</code> 的方法.  它是根据一系列规范构建的:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>JSON Web Token (JWT)</p>
</li>
<li>
<p>JSON Web Signature (JWS)</p>
</li>
<li>
<p>JSON Web Encryption (JWE)</p>
</li>
<li>
<p>JSON Web Key (JWK)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>它包含以下顶级包:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.springframework.security.oauth2.jwt</code></p>
</li>
<li>
<p><code>org.springframework.security.oauth2.jose</code></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-oauth2-resource-server"><a class="anchor" href="#spring-security-oauth2-resource-server"></a>6.9. OAuth 2.0 资源 服务器&#8201;&#8212;&#8201;<code>spring-security-oauth2-resource-server.jar</code></h3>
<div class="paragraph">
<p><code>spring-security-oauth2-resource-server.jar</code> 包含 Spring Security 对 OAuth 2.0 资源服务器的支持.  它用于通过 OAuth 2.0 Bearer 令牌保护 API.  顶层的包是 <code>org.springframework.security.oauth2.server.resource</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-acl"><a class="anchor" href="#spring-security-acl"></a>6.10. ACL&#8201;&#8212;&#8201;<code>spring-security-acl.jar</code></h3>
<div class="paragraph">
<p>ACL 专门的领域对象的实现. 用来在你的应用程序中应用安全特定的领域对象实例. 主包名为 <code>org.springframework.security.acls</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 6. ACL Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ehcache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if the Ehcache-based ACL cache implementation is used (optional if you are using your own implementation).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-jdbc</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if you are using the default JDBC-based AclService (optional if you implement your own).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-tx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if you are using the default JDBC-based AclService (optional if you implement your own).</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="spring-security-cas"><a class="anchor" href="#spring-security-cas"></a>6.11. CAS&#8201;&#8212;&#8201;<code>spring-security-cas.jar</code></h3>
<div class="paragraph">
<p>Spring Security 的 CAS 客户端集成. 如果你想用 CAS 的 SSO 服务器使用 Spring Security 网页验证需要该模块. 顶层的包是 <code>org.springframework.security.cas</code>.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 7. CAS Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cas-client-core</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3.1.12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The JA-SIG CAS Client.
This is the basis of the Spring Security integration.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ehcache</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1.6.2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if you are using the Ehcache-based ticket cache (optional).</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="spring-security-openid"><a class="anchor" href="#spring-security-openid"></a>6.12. OpenID&#8201;&#8212;&#8201;<code>spring-security-openid.jar</code></h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
已弃用 OpenID 1.0 和 2.0 协议， 并鼓励用户迁移到 Spring-security-oauth2 支持的 OpenID Connect. .
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>该模块包含 OpenID Web 身份验证支持.  它用于根据外部 OpenID 服务器对用户进行身份验证.  顶层的包是 <code>org.springframework.security.openid</code>.  它需要 OpenID4Java.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 8. OpenID Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">openid4java-nodeps</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.9.6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Spring Security&#8217;s OpenID integration uses OpenID4Java.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">httpclient</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4.1.1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">openid4java-nodeps depends on HttpClient 4.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">guice</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">openid4java-nodeps depends on Guice 2.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="spring-security-test"><a class="anchor" href="#spring-security-test"></a>6.13. 测试&#8201;&#8212;&#8201;<code>spring-security-test.jar</code></h3>
<div class="paragraph">
<p>该模块包含对使用 Spring Security 进行测试的支持.</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-taglibs"><a class="anchor" href="#spring-security-taglibs"></a>6.14. Taglibs&#8201;&#8212;&#8201;<code>spring-secuity-taglibs.jar</code></h3>
<div class="paragraph">
<p>提供 Spring Security 的 JSP 标签实现.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 9. Taglib Dependencies</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Dependency</th>
<th class="tableblock halign-left valign-top">Version</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-core</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-web</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-security-acl</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if you are using the <code>accesscontrollist</code> tag or <code>hasPermission()</code> expressions with ACLs (optional).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">spring-expression</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required if you are using SPEL expressions in your tag access constraints.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="samples"><a class="anchor" href="#samples"></a>7. 示例程序</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 包含许多 <a href="https://github.com/spring-projects/spring-security/master/">示例</a> 应用程序.</p>
</div>
</div>
</div>
<h1 id="servlet-应用程序" class="sect0"><a class="anchor" href="#servlet-应用程序"></a>Servlet 应用程序</h1>
<div class="openblock partintro">
<div class="content">
Spring Security 使用标准的 Servlet 过滤器与 Servlet 容器集成.  这意味着它可以和使用 Servlet 容器运行的任何应用程序一起使用.  更具体地说,你可以在不使用 Spring,而是基于 Servlet 的应用程序中使用 Spring Security.
</div>
</div>
<div class="sect1">
<h2 id="servlet-hello"><a class="anchor" href="#servlet-hello"></a>8. Hello Spring Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节介绍了如何将 Spring Security 与 Spring Boot 结合使用的最小设置.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>完整的应用程序可以在  <a href="https://github.com/spring-projects/spring-security/master//boot/helloworld">samples/boot/helloworld</a> 中找到. 为方便起见,您可以通过 <a href="https://start.spring.io/starter.zip?type=maven-project&amp;language=java&amp;packaging=jar&amp;jvmVersion=1.8&amp;groupId=example&amp;artifactId=hello-security&amp;name=hello-security&amp;description=Hello%20Security&amp;packageName=example.hello-security&amp;dependencies=web,security">单击此处</a> 下载最小的  Spring Boot + Spring Security 应用程序.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="servlet-hello-dependencies"><a class="anchor" href="#servlet-hello-dependencies"></a>8.1. 更新依赖</h3>
<div class="paragraph">
<p>您需要做的唯一步骤是使用<a href="#getting-maven-boot">Maven</a> 或<a href="#getting-gradle-boot">Gradle</a> 更新依赖.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-hello-starting"><a class="anchor" href="#servlet-hello-starting"></a>8.2. Starting Hello Spring Security Boot</h3>
<div class="paragraph">
<p>现在,您可以使用 Maven 插件来运行 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#using-boot-running-with-the-maven-plugin">运行 Spring Boot应用程序</a>.  以下示例显示了如何执行此操作(以及执行此操作的输出的开头) :</p>
</div>
<div class="exampleblock">
<div class="title">Example 48. Running Spring Boot Application</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-bash" data-lang="bash">$ ./mvn spring-boot:run
...
INFO 23689 --- [  restartedMain] .s.s.UserDetailsServiceAutoConfiguration :

Using generated security password: 8e557245-73e2-4286-969a-ff57fe326336

...</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-hello-auto-configuration"><a class="anchor" href="#servlet-hello-auto-configuration"></a>8.3. Spring Boot 自动配置</h3>
<div class="paragraph">
<p>Spring Boot 自动配置:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>启用 Spring Security 的默认配置,该配置会创建 <code>springSecurityFilterChain</code> ,然后加入到 <code>Servlet</code> 过滤器链中.  此 bean 负责应用程序内的所有安全性(保护应用程序URL,验证提交的用户名和密码,重定向到登录表单等) .</p>
</li>
<li>
<p>创建一个 <code>UserDetailsService</code> bean,其中包含用户名 <code>user</code> 和随机生成的密码,该密码将记录到控制台.</p>
</li>
<li>
<p>针对每个请求,使用 Servlet 容器向 <code>springSecurityFilterChain</code> 注册过滤器.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Boot 的配置不多,但功能很多.
主要功能如下:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>要求经过身份验证的用户才能与应用程序进行任何交互</p>
</li>
<li>
<p>为您生成一个默认的登录表单</p>
</li>
<li>
<p>让用户使用用户名为 <code>user</code> 和密码为 <code>8e557245-73e2-4286-969a-ff57fe326336</code> 进行表单登录</p>
</li>
<li>
<p>使用 BCrypt 算法进行密码加密保存</p>
</li>
<li>
<p>让用户注销</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF 攻击</a> 防御</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Session_fixation">会话固定攻击</a> 防御</p>
</li>
<li>
<p>安全 Header 集成</p>
<div class="ulist">
<ul>
<li>
<p>为安全请求使用 <a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HTTP Strict Transport Security</a></p>
</li>
<li>
<p><a href="https://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx">X-Content-Type-Options</a> 集成</p>
</li>
<li>
<p>缓存控制(以后可以由您的应用程序覆盖,以允许缓存您的静态资源)</p>
</li>
<li>
<p><a href="https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx">X-XSS-Protection</a> 集成</p>
</li>
<li>
<p>X-Frame-Options 集成防止点击劫持 <a href="https://en.wikipedia.org/wiki/Clickjacking">Clickjacking</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>与以下 Servlet API 方法集成:</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()"><code>HttpServletRequest#getRemoteUser()</code></a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()"><code>HttpServletRequest.html#getUserPrincipal()</code></a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)"><code>HttpServletRequest.html#isUserInRole(java.lang.String)</code></a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String,%20java.lang.String)"><code>HttpServletRequest.html#login(java.lang.String, java.lang.String)</code></a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout()"><code>HttpServletRequest.html#logout()</code></a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-architecture"><a class="anchor" href="#servlet-architecture"></a>9. Servlet Security: 图景</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节讨论基于 Servlet 的应用程序中 Spring Security 的高级体系结构.
我们在  <a href="#servlet-authentication">认证</a>, <a href="#servlet-authorization">授权</a>,<a href="#servlet-exploits">防御利用漏洞</a> 部分中建立了这种高级理解.</p>
</div>
<div class="sect2">
<h3 id="servlet-filters-review"><a class="anchor" href="#servlet-filters-review"></a>9.1. 回顾过滤器</h3>
<div class="paragraph">
<p>Spring Security 对 Servlet 的支持基于 Servlet 过滤器,因此通常首先了解过滤器的作用会很有帮助.  下图显示了单个 HTTP 请求的处理程序的典型分层.</p>
</div>
<div id="servlet-filterchain-figure" class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/architecture/filterchain.png" alt="filterchain">
</div>
<div class="title">Figure 1. FilterChain</div>
</div>
<div class="paragraph">
<p>客户端向应用程序发送请求,然后容器创建一个 <code>FilterChain</code>,其中包含根据请求URI的路径处理 <code>HttpServletRequest</code> 的过滤器和 Servlet.  在 Spring MVC 应用程序中,Servlet 的实例是 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet"><code>DispatcherServlet</code></a> .
一个 Servlet 最多只能处理一个 <code>HttpServletRequest</code> 和 <code>HttpServletResponse</code>.  但是,可以使用多个过滤器来:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>组织下游的过滤器或 Servlet 被调用.  在这种情况下,过滤器实例通常为 <code>HttpServletResponse</code>.</p>
</li>
<li>
<p>修改下游过滤器和 Servlet 使用的 <code>HttpServletRequest</code> 或 <code>HttpServletResponse</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>过滤器的功能来自传递给它的 <code>FilterChain</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 49. <code>FilterChain</code> Usage Example</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
    // do something before the rest of the application
    chain.doFilter(request, response); // invoke the rest of the application
    // do something after the rest of the application
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) {
    // do something before the rest of the application
    chain.doFilter(request, response) // invoke the rest of the application
    // do something after the rest of the application
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于过滤器仅影响下游过滤器和 Servlet,因此调用每个过滤器的顺序非常重要.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-delegatingfilterproxy"><a class="anchor" href="#servlet-delegatingfilterproxy"></a>9.2. DelegatingFilterProxy</h3>
<div class="paragraph">
<p>Spring 提供了一个名为 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/web/filter/DelegatingFilterProxy.html/"><code>DelegatingFilterProxy</code></a>  的 Filter 实现,该实现允许在 Servlet 容器的生命周期和 Spring 的 <code>ApplicationContext</code> 之间进行桥接.
Servlet 容器允许使用其自己的标准注册 Filters,但它不了解 Spring 定义的 Bean.  DelegatingFilterProxy 可以通过标准的Servlet 容器机制进行注册,但是可以将所有工作委托给实现 Filter 的 Spring Bean.</p>
</div>
<div class="paragraph">
<p>这是 <code>DelegatingFilterProxy</code> 如何适合 <a href="#servlet-filters-review"><code>Filter</code> 和  <code>FilterChain</code></a> 的图片.</p>
</div>
<div id="servlet-delegatingfilterproxy-figure" class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/architecture/delegatingfilterproxy.png" alt="delegatingfilterproxy">
</div>
<div class="title">Figure 2. DelegatingFilterProxy</div>
</div>
<div class="paragraph">
<p><code>DelegatingFilterProxy</code> 从 <code>ApplicationContext</code> 查找 <em>Bean Filter<sub>0</sub></em> ,然后调用  <em>Bean Filter<sub>0</sub></em>.  <code>DelegatingFilterProxy</code> 的伪代码可以在下面看到.</p>
</div>
<div class="exampleblock">
<div class="title">Example 50. <code>DelegatingFilterProxy</code> Pseudo Code</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
    // Lazily get Filter that was registered as a Spring Bean
    // For the example in <a href="#servlet-delegatingfilterproxy-figure">DelegatingFilterProxy</a> <code>delegate</code> is an instance of <em>Bean Filter<sub>0</sub></em>
    Filter delegate = getFilterBean(someBeanName);
    // delegate work to the Spring Bean
    delegate.doFilter(request, response);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun doFilter(request: ServletRequest, response: ServletResponse, chain: FilterChain) {
    // Lazily get Filter that was registered as a Spring Bean
    // For the example in <a href="#servlet-delegatingfilterproxy-figure">DelegatingFilterProxy</a> <code>delegate</code> is an instance of <em>Bean Filter<sub>0</sub></em>
    val delegate: Filter = getFilterBean(someBeanName)
    // delegate work to the Spring Bean
    delegate.doFilter(request, response)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>DelegatingFilterProxy</code> 的另一个好处是,它允许延迟查找 Filter bean 实例.  这很重要,因为容器需要在容器启动之前注册 Filter实例.  但是,Spring 通常使用 <code>ContextLoaderListener</code> 来加载 Spring Bean,直到需要注册 Filter 实例之后,Spring 才会完成.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-filterchainproxy"><a class="anchor" href="#servlet-filterchainproxy"></a>9.3. FilterChainProxy</h3>
<div class="paragraph">
<p>Spring Security 的 Servlet 支持包含在 <code>FilterChainProxy</code> 中.  <code>FilterChainProxy</code> 是 Spring Security 提供的特殊过滤器,允许通过  <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> 委派许多过滤器实例.
 由于 <code>FilterChainProxy</code> 是Bean,因此通常将其包装在  <a href="#servlet-delegatingfilterproxy"><code>DelegatingFilterProxy</code></a> 中.</p>
</div>
<div id="servlet-filterchainproxy-figure" class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/architecture/filterchainproxy.png" alt="filterchainproxy">
</div>
<div class="title">Figure 3. FilterChainProxy</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-securityfilterchain"><a class="anchor" href="#servlet-securityfilterchain"></a>9.4. SecurityFilterChain</h3>
<div class="paragraph">
<p><a href="#servlet-filterchainproxy">FilterChainProxy</a> 使用 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/SecurityFilterChain.html"><code>SecurityFilterChain</code></a>  确定应对此请求调用哪些 Spring Security 过滤器.</p>
</div>
<div id="servlet-securityfilterchain-figure" class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/architecture/securityfilterchain.png" alt="securityfilterchain">
</div>
<div class="title">Figure 4. SecurityFilterChain</div>
</div>
<div class="paragraph">
<p><code>SecurityFilterChain</code> 中的 <a href="#servlet-security-filters">Security Filters</a> 通常是Bean,但它们是使用 <code>FilterChainProxy</code> 而不是  <a href="#servlet-delegatingfilterproxy">DelegatingFilterProxy</a> 注册的.
 <code>FilterChainProxy</code> 具有直接向 Servlet 容器或 DelegatingFilterProxy 注册的许多优点.
 首先,它为 Spring Security 的所有 Servlet 支持提供了一个起点.  因此,如果您想对 Spring Security 的 Servlet 支持进行故障排除,那么在 <code>FilterChainProxy</code> 中添加调试点是一个很好的起点.</p>
</div>
<div class="paragraph">
<p>其次,由于 <code>FilterChainProxy</code> 对于 Spring Security 的使用至关重要,因此它可以执行不被视为可选任务的任务.  例如,它清除 <code>SecurityContext</code> 以避免内存泄漏.
它还使用 Spring Security 的  <a href="#servlet-httpfirewall"><code>HttpFirewall</code></a>  来保护应用程序免受某些类型的攻击.</p>
</div>
<div class="paragraph">
<p>此外,它在确定何时应调用 <code>SecurityFilterChain</code> 时提供了更大的灵活性.  在 Servlet 容器中,仅根据 URL 调用过滤器.  但是,<code>FilterChainProxy</code> 可以利用 <code>RequestMatcher</code> 接口,根据 <code>HttpServletRequest</code> 中的任何内容确定调用.</p>
</div>
<div class="paragraph">
<p>实际上,<code>FilterChainProxy</code> 可用于确定应使用哪个 <code>SecurityFilterChain</code>.  如果您的应用程序可以为不同的片提供完全独立的配置.</p>
</div>
<div id="servlet-multi-securityfilterchain-figure" class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/architecture/multi-securityfilterchain.png" alt="multi securityfilterchain">
</div>
<div class="title">Figure 5. Multiple SecurityFilterChain</div>
</div>
<div class="paragraph">
<p>在 <a href="#servlet-multi-securityfilterchain-figure">多个 SecurityFilterChain</a> 链中,<code>FilterChainProxy</code> 决定应使用哪个 <code>SecurityFilterChain</code>.  仅匹配的第一个 <code>SecurityFilterChain</code> 将被调用.
如果请求的URL是 <code>/api/messages/</code>,则它将首先与 <code>SecurityFilterChain<sub>0</sub></code> 的 <code>/api/**</code> 模式匹配,因此即使  <code>SecurityFilterChain<sub>0</sub></code> 也与<code>SecurityFilterChain<sub>n</sub></code> 匹配,也会仅调用 SecurityFilterChain0.
如果请求的URL是 <code>/messages/</code>,则在 <code>SecurityFilterChain<sub>0</sub></code> 的 <code>/api/**</code> 模式下将不匹配,因此 FilterChainProxy 将继续尝试每个 <code>SecurityFilterChain</code>.  假设没有其他匹配的 <code>SecurityFilterChain</code> , <code>SecurityFilterChain<sub>n</sub></code> 实例将被调用.</p>
</div>
<div class="paragraph">
<p>请注意, <code>SecurityFilterChain<sub>0</sub></code> 配置了三个安全过滤器实例.  但是,<code>SecurityFilterChainn</code> 配置了四个安全过滤器.
重要的是要注意,每个 <code>SecurityFilterChain</code> 可以是唯一的,并且可以独立配置.  实际上,如果应用程序希望 Spring Security 忽略某些请求,则 <code>SecurityFilterChain</code> 可能具有零个安全过滤器.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-security-filters"><a class="anchor" href="#servlet-security-filters"></a>9.5. Security Filters</h3>
<div class="paragraph">
<p>安全过滤器通过  <a href="#servlet-securityfilterchain">SecurityFilterChain</a>  API 插入到  <a href="#servlet-filterchainproxy"><code>FilterChainProxy</code></a> 中.  过滤器的顺序很重要.  通常无需知道 Spring Security 过滤器的顺序.  但是,有时候知道顺序是有益的</p>
</div>
<div class="paragraph">
<p>以下是 Spring Security 过滤器顺序的完整列表:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ChannelProcessingFilter</p>
</li>
<li>
<p>WebAsyncManagerIntegrationFilter</p>
</li>
<li>
<p>SecurityContextPersistenceFilter</p>
</li>
<li>
<p>HeaderWriterFilter</p>
</li>
<li>
<p>CorsFilter</p>
</li>
<li>
<p>CsrfFilter</p>
</li>
<li>
<p>LogoutFilter</p>
</li>
<li>
<p>OAuth2AuthorizationRequestRedirectFilter</p>
</li>
<li>
<p>Saml2WebSsoAuthenticationRequestFilter</p>
</li>
<li>
<p>X509AuthenticationFilter</p>
</li>
<li>
<p>AbstractPreAuthenticatedProcessingFilter</p>
</li>
<li>
<p>CasAuthenticationFilter</p>
</li>
<li>
<p>OAuth2LoginAuthenticationFilter</p>
</li>
<li>
<p>Saml2WebSsoAuthenticationFilter</p>
</li>
<li>
<p><a href="#servlet-authentication-usernamepasswordauthenticationfilter"><code>UsernamePasswordAuthenticationFilter</code></a></p>
</li>
<li>
<p>OpenIDAuthenticationFilter</p>
</li>
<li>
<p>DefaultLoginPageGeneratingFilter</p>
</li>
<li>
<p>DefaultLogoutPageGeneratingFilter</p>
</li>
<li>
<p>ConcurrentSessionFilter</p>
</li>
<li>
<p><a href="#servlet-authentication-digest"><code>DigestAuthenticationFilter</code></a></p>
</li>
<li>
<p>BearerTokenAuthenticationFilter</p>
</li>
<li>
<p><a href="#servlet-authentication-basic"><code>BasicAuthenticationFilter</code></a></p>
</li>
<li>
<p>RequestCacheAwareFilter</p>
</li>
<li>
<p>SecurityContextHolderAwareRequestFilter</p>
</li>
<li>
<p>JaasApiIntegrationFilter</p>
</li>
<li>
<p>RememberMeAuthenticationFilter</p>
</li>
<li>
<p>AnonymousAuthenticationFilter</p>
</li>
<li>
<p>OAuth2AuthorizationCodeGrantFilter</p>
</li>
<li>
<p>SessionManagementFilter</p>
</li>
<li>
<p><a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a></p>
</li>
<li>
<p><a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a></p>
</li>
<li>
<p>SwitchUserFilter</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="servlet-exceptiontranslationfilter"><a class="anchor" href="#servlet-exceptiontranslationfilter"></a>9.6. 处理 Security 异常</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/access/ExceptionTranslationFilter.html"><code>ExceptionTranslationFilter</code></a>  允许将  <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/access/AccessDeniedException.html"><code>AccessDeniedException</code></a>  和  <a href="https://docs.spring.io/spring-security/site/docs/current/api//org/springframework/security/core/AuthenticationException.html"><code>AuthenticationException</code></a> 转换为 HTTP 响应.</p>
</div>
<div class="paragraph">
<p><code>ExceptionTranslationFilter</code> 作为安全过滤器之一插入到 <a href="#servlet-filterchainproxy">FilterChainProxy</a>  中.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/architecture/exceptiontranslationfilter.png" alt="exceptiontranslationfilter">
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> 首先,<code>ExceptionTranslationFilter</code> 调用 FilterChain.doFilter(request,response)  来调用应用程序的其余部分.</p>
</li>
<li>
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> 如果用户未通过身份验证或它是 <code>AuthenticationException</code>,则启动身份验证.</p>
<div class="ulist">
<ul>
<li>
<p>已清除  <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a></p>
</li>
<li>
<p><code>HttpServletRequest</code> 保存在 <code>RequestCache</code> 中.  用户成功进行身份验证后,将使用  <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/savedrequest/RequestCache.html"><code>RequestCache</code></a> 重发原始请求. .</p>
</li>
<li>
<p><code>AuthenticationEntryPoint</code> 用于从客户端请求凭据.  例如,它可能重定向到登录页面或发送 <code>WWW-Authenticate</code>  header .</p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> 否则,如果它是 <code>AccessDeniedException</code>,则拒绝访问.  调用 <code>AccessDeniedHandler</code> 来处理被拒绝的访问.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果应用程序未引发 <code>AccessDeniedException</code> 或 <code>AuthenticationException</code>,则 <code>ExceptionTranslationFilter</code> 不执行任何操作.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>ExceptionTranslationFilter</code> 的伪代码如下所示:</p>
</div>
<div class="listingblock">
<div class="title">ExceptionTranslationFilter pseudocode</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
    filterChain.doFilter(request, response); <i class="conum" data-value="1"></i><b>(1)</b>
} catch (AccessDeniedException | AuthenticationException ex) {
    if (!authenticated || ex instanceof AuthenticationException) {
        startAuthentication(); <i class="conum" data-value="2"></i><b>(2)</b>
    } else {
        accessDenied(); <i class="conum" data-value="3"></i><b>(3)</b>
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>您将在 <a href="#servlet-filters-review">过滤器回顾</a>,调用  <code>FilterChain.doFilter(request, response)</code> 等同于调用应用程序的其余部分.  这意味着如果应用程序的另一部分(即 <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> 或方法安全性) 抛出 <code>AuthenticationException</code> 或 <code>AccessDeniedException</code>,则会在此处捕获并处理.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果用户未通过身份验证或它是 <code>AuthenticationException</code>,则启动身份验证.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>否则,访问被拒绝</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authentication"><a class="anchor" href="#servlet-authentication"></a>10. 认证</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 提供了对身份验证的全面支持.  本节讨论:</p>
</div>
<div id="servlet-authentication-architecture" class="paragraph">
<p><strong>架构组件</strong></p>
</div>
<div class="paragraph">
<p>本部分描述了 Servlet 身份验证中使用的 Spring Security 的主要架构组件.  如果您需要解释这些部分如何组合的具体流程,请查看 "身份验证机制" 特定部分.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> - Spring Security 在其中存储 <code>SecurityContextHolder</code>,用于存储通过<a href="#authentication">身份验证</a>的人员的详细信息.</p>
</li>
<li>
<p><a href="#servlet-authentication-securitycontext">SecurityContext</a> - 从 <code>SecurityContextHolder</code> 获得,并包含当前经过身份验证的用户的 <code>Authentication</code> .</p>
</li>
<li>
<p><a href="#servlet-authentication-authentication">Authentication</a> - 可以是 <code>AuthenticationManager</code> 的输入,用户提供的用于身份验证的凭据或来自 <code>SecurityContext</code> 的当前用户.</p>
</li>
<li>
<p><a href="#servlet-authentication-granted-authority">GrantedAuthority</a> - 在 <code>Authentication</code> 授予委托人的权限 (即角色,作用域等) .</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationmanager">AuthenticationManager</a> -  定义 Spring Security 的过滤器如何执行<a href="#authentication">身份验证</a> 的 API.</p>
</li>
<li>
<p><a href="#servlet-authentication-providermanager">ProviderManager</a> -  <code>AuthenticationManager</code> 的最常见实现.</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationprovider">AuthenticationProvider</a> - 由 <code>ProviderManager</code> 用于执行特定类型的身份验证.</p>
</li>
<li>
<p><a href="#servlet-authentication-authenticationentrypoint">使用 <code>AuthenticationEntryPoint</code> 请求凭据</a> -带 <code>AuthenticationEntryPoint</code> 的请求凭据-用于从客户端请求凭据 (即重定向到登录页面,发送 WWW-Authenticate 响应等) .</p>
</li>
<li>
<p><a href="#servlet-authentication-abstractprocessingfilter">AbstractAuthenticationProcessingFilter</a> - 用于验证的基本过滤器.  这也为高级的身份验证流程以及各个部分如何协同工作提供了一个好主意.</p>
</li>
</ul>
</div>
<div id="servlet-authentication-mechanisms" class="paragraph">
<p><strong>认证机制</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-unpwd">Username and Password</a> - 如何使用用户名/密码进行身份验证</p>
</li>
<li>
<p><a href="#oauth2login">OAuth 2.0 Login</a> - 使用 OpenID Connect 和非标准 OAuth 2.0 Log 进行 OAuth 2.0 Login (即GitHub)</p>
</li>
<li>
<p><a href="#servlet-saml2">SAML 2.0 Login</a> - SAML 2.0 登录</p>
</li>
<li>
<p><a href="#servlet-cas">Central Authentication Server (CAS)</a> - 中央身份验证服务器 (CAS) 支持</p>
</li>
<li>
<p><a href="#servlet-rememberme">Remember Me</a> - 如何记住用户过期的会话</p>
</li>
<li>
<p><a href="#servlet-jaas">JAAS Authentication</a> - 使用 JAAS 进行认证</p>
</li>
<li>
<p><a href="#servlet-openid">OpenID</a> - OpenID 身份验证 (请勿与 OpenID Connect 混淆)</p>
</li>
<li>
<p><a href="#servlet-preauth">Pre-Authentication 场景</a> - 使用诸如 <a href="https://www.siteminder.com/">SiteMinder</a> 或 Java EE 安全性之类的外部机制进行身份验证,但仍使用 Spring Security 进行授权并防范常见漏洞.</p>
</li>
<li>
<p><a href="#servlet-x509">X509 Authentication</a> - X509 验证</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="servlet-authentication-securitycontextholder"><a class="anchor" href="#servlet-authentication-securitycontextholder"></a>10.1. SecurityContextHolder</h3>
<div class="paragraph">
<p>Spring Security 身份验证模型的核心是 <code>SecurityContextHolder</code>.  它包含 <a href="#servlet-authentication-securitycontext">SecurityContext</a>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/authentication/architecture/securitycontextholder.png" alt="securitycontextholder">
</div>
</div>
<div class="paragraph">
<p>Spring Security 在 <code>SecurityContextHolder</code> 存储通过<a href="#authentication">身份验证</a>的人员的详细信息.  Spring Security 并不关心如何填充 <code>SecurityContextHolder</code>.  如果它存在一个值,那么它将用作当前经过身份验证的用户.</p>
</div>
<div class="paragraph">
<p>表示用户已通过身份验证的最简单方法是直接设置 <code>SecurityContextHolder</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 51. Setting <code>SecurityContextHolder</code></div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SecurityContext context = SecurityContextHolder.createEmptyContext(); <i class="conum" data-value="1"></i><b>(1)</b>
Authentication authentication =
    new TestingAuthenticationToken("username", "password", "ROLE_USER"); <i class="conum" data-value="2"></i><b>(2)</b>
context.setAuthentication(authentication);

SecurityContextHolder.setContext(context); <i class="conum" data-value="3"></i><b>(3)</b>
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val context: SecurityContext = SecurityContextHolder.createEmptyContext() <i class="conum" data-value="1"></i><b>(1)</b>
val authentication: Authentication = TestingAuthenticationToken("username", "password", "ROLE_USER") <i class="conum" data-value="2"></i><b>(2)</b>
context.authentication = authentication

SecurityContextHolder.setContext(context) <i class="conum" data-value="3"></i><b>(3)</b></code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>我们首先创建一个空的 <code>SecurityContext</code>.  重要的是创建一个新的 <code>SecurityContext</code> 实例,而不要使用 <code>SecurityContextHolder.getContext().setAuthentication(authentication)</code>  以避免跨多个线程出现竞争状况.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>接下来,我们创建一个新的  <a href="#servlet-authentication-authentication"><code>Authentication</code></a>  对象.  Spring Security 并不关心在 <code>SecurityContext</code> 上设置什么类型的 <code>Authentication</code> 实现.
在这里我们使用 <code>TestingAuthenticationToken</code>,因为它非常简单.  一个更常见的生产方案是  <code>UsernamePasswordAuthenticationToken(userDetails, password, authorities)</code>..</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>最后,我们在 <code>SecurityContextHolder</code> 上设置 <code>SecurityContext</code>.  Spring Security 将使用此信息进行  <a href="#servlet-authorization">授权</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果希望获取有关已验证的主体的信息,可以通过访问 <code>SecurityContextHolder</code> 来获得.</p>
</div>
<div class="exampleblock">
<div class="title">Example 52. Access Currently Authenticated User</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();
String username = authentication.getName();
Object principal = authentication.getPrincipal();
Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val context = SecurityContextHolder.getContext()
val authentication = context.authentication
val username = authentication.name
val principal = authentication.principal
val authorities = authentication.authorities</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下,<code>SecurityContextHolder</code> 使用 <code>ThreadLocal</code> 存储这些详细信息,这意味着即使没有将 <code>SecurityContext</code> 作为这些方法的参数显式传递,<code>SecurityContext</code> 始终可用于同一执行线程中的方法.
只要记得在处理完当前主体的请求以后,把这个线程清除就行了. 则以这种方式使用 <code>ThreadLocal</code> 是非常安全的. 当然,Spring Security 的 <a href="#servlet-filterchainproxy">FilterChainProxy</a> 自动帮你管理这一切了, 你就不用担心什么了.</p>
</div>
<div class="paragraph">
<p>有些程序并不适合使用 <code>ThreadLocal</code>,因为它们处理线程的特殊方法. 比如 Swing 客户端也许希望 Java 虚拟机里所有的线程 都使用同一个安全环境. <code>SecurityContextHolder</code> 可以配置启动策略来指定你希望上下文怎么被存储.
对于一个独立的应用程序,你会使用 <code>SecurityContextHolder.MODE_GLOBAL</code> 策略.
其他程序可能也想由安全线程产生的线程也承担同样的安全标识. 这是通过使用 <code>SecurityContextHolder.MODE_INHERITABLETHREADLOCAL</code> 实现. 你可以通过两种方式更改默认的 <code>SecurityContextHolder.MODE_THREADLOCAL</code> 模式. 第一个是设置系统属性,
第二个是调用 <code>SecurityContextHolder</code> 的静态方法. 大多数应用程序不需要修改默认值,但是如果你想要修改,可以看一下 <code>SecurityContextHolder</code> 的 JavaDocs 中的详细信息了解更多.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-securitycontext"><a class="anchor" href="#servlet-authentication-securitycontext"></a>10.2. SecurityContext</h3>
<div class="paragraph">
<p>从 SecurityContextHolder 获得 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/context/SecurityContext.html"><code>SecurityContext</code></a> .  <code>SecurityContext</code> 包含一个 <a href="#servlet-authentication-authentication">Authentication</a> 对象.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-authentication"><a class="anchor" href="#servlet-authentication-authentication"></a>10.3. Authentication</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/Authentication.html"><code>Authentication</code></a>  在 Spring Security 中有两个主要用途:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a>  的输入,用于提供用户提供的用于身份验证的凭据.  在这种情况下使用时, <code>isAuthenticated()</code> 返回 <code>false</code>.</p>
</li>
<li>
<p>代表当前经过身份验证的用户.  可以从 <a href="#servlet-authentication-securitycontext">SecurityContext</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Authentication</code> 包含:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>principal</code> - 识别用户.  使用用户名/密码进行身份验证时,这通常是  <a href="#servlet-authentication-userdetails"><code>UserDetails</code></a> 的实例.</p>
</li>
<li>
<p><code>credentials</code> - 通常是密码.  在许多情况下,将在验证用户身份后清除此内容,以确保它不会泄漏.</p>
</li>
<li>
<p><code>authorities</code> - <a href="#servlet-authentication-granted-authority"><code>GrantedAuthoritys</code></a> 是授予用户的权限.  角色或范围是几个例子.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-granted-authority"><a class="anchor" href="#servlet-authentication-granted-authority"></a>10.4. GrantedAuthority</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/GrantedAuthority.html">`GrantedAuthority`s</a> 是授予用户的高级权限.  角色或范围是几个例子.</p>
</div>
<div class="paragraph">
<p><code>Authentication</code> 提供的重要方法是 <code>getAuthorities()</code>. 这个方法提供了 <code>GrantedAuthority</code> 对象数组. 毫无疑问,<code>GrantedAuthority</code> 是赋予到主体的权限.
这些权限通常使用角色表示,比如 <code>ROLE_ADMINISTRATOR</code> 或 <code>ROLE_HR_SUPERVISOR</code>. 这些角色会在后面,对 web 验证,方法验证和领域对象验证进行配置.
Spring Security 的其他部分用来拦截这些权限,期望他们被表现出现. <code>GrantedAuthority</code> 对象通常是使用  <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a> 读取的.</p>
</div>
<div class="paragraph">
<p>通常情况下,<code>GrantedAuthority</code> 对象是应用程序范围下的授权. 它们不会特意分配给一个特定的领域对象. 因此,你不能设置一个 <code>GrantedAuthority</code>,让他有权限展示编号54的 <code>Employee</code> 对象,
因为如果有成千上万的这种授权,你会很快用光内存(或者,至少,导致程序花费大量时间去验证一个用户). 当然,Spring Security 被明确设计成处理常见的需求,但是你最好别因为这个目的使用项目领 domain 安全功能.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-authenticationmanager"><a class="anchor" href="#servlet-authentication-authenticationmanager"></a>10.5. AuthenticationManager</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/AuthenticationManager.html"><code>AuthenticationManager</code></a>  是用于定义 Spring Security 的过滤器如何执行 <a href="#authentication">身份验证</a>的API.
然后,由调用 <code>AuthenticationManager</code> 的控制器(即 Spring Security 的 <a href="#servlet-security-filters">Spring Security 的过滤器</a>) 在 <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>  上设置返回的身份验证.
如果您不与 Spring Security 的过滤器集成,则可以直接设置 <code>SecurityContextHolder</code>,并且不需要使用 <code>AuthenticationManager</code>.</p>
</div>
<div class="paragraph">
<p>虽然 <code>AuthenticationManager</code> 的实现可以是任何东西,但最常见的实现是  <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-providermanager"><a class="anchor" href="#servlet-authentication-providermanager"></a>10.6. ProviderManager</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/ProviderManager.html"><code>ProviderManager</code></a> 是 <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> 的最常用实现.  <code>ProviderManager</code> 委托给 <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code>s</a> 列表.
每个 <code>AuthenticationProvider</code> 都有可能认证成功或失败,或者表明它不能做出决定并允许下一个 <code>AuthenticationProvider</code> 进行决定.  如果没有一个已配置的 <code>AuthenticationProviders</code> 可以进行身份验证,则身份验证将失败,并显示 <code>ProviderNotFoundException</code>,这是一个特殊的 <code>AuthenticationException</code>,它指示未配置 <code>ProviderManager</code> 支持传递给它的身份验证类型.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/authentication/architecture/providermanager.png" alt="providermanager">
</div>
</div>
<div class="paragraph">
<p>实际上,每个 <code>AuthenticationProvider</code> 都知道如何执行特定类型的身份验证.  例如,一个 <code>AuthenticationProvider</code> 可能能够验证用户名/密码,而另一个可能能够验证SAML断言.
这允许每个 <code>AuthenticationProvider</code> 进行非常特定类型的身份验证,同时支持多种类型的身份验证,并且仅暴露一个 <code>AuthenticationManager</code> bean.</p>
</div>
<div class="paragraph">
<p><code>ProviderManager</code> 还允许配置可选的父 <code>AuthenticationManager</code>,如果没有 <code>AuthenticationProvider</code> 可以执行身份验证,请咨询该父对象.  父级可以是任何类型的 <code>AuthenticationManager</code>,但通常是 <code>ProviderManager</code> 的实例.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/authentication/architecture/providermanager-parent.png" alt="providermanager parent">
</div>
</div>
<div class="paragraph">
<p>实际上,多个 <code>ProviderManager</code> 实例可能共享同一个父 <code>AuthenticationManager</code>.  在存在多个具有相同身份验证(共享的父 <code>AuthenticationManager</code>) 但又具有不同身份验证机制(不同 <code>ProviderManager</code> 实例) 的多个  <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> 实例的情况下,这种情况有些常见.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/authentication/architecture/providermanagers-parent.png" alt="providermanagers parent">
</div>
</div>
<div id="servlet-authentication-providermanager-erasing-credentials" class="paragraph">
<p>默认情况下,<code>ProviderManager</code> 会尝试清除身份验证对象中所有敏感的凭据信息,这些信息将返回请求成功的 Authentication .  这样可以防止密码之类的信息在 <code>HttpSession</code> 中的保留时间超过所需的时间.</p>
</div>
<div class="paragraph">
<p>例如,在使用用户对象的缓存来提高无状态应用程序的性能时,这可能会导致问题.  如果身份验证包含对缓存中对象的引用(例如 <code>UserDetails</code> 实例) ,并且已删除其凭据,则将无法再对缓存的值进行身份验证.
 如果使用缓存,则需要考虑到这一点.  一个明显的解决方案是首先在缓存实现中或在创建返回的 <code>Authentication</code> 对象的 <code>AuthenticationProvider</code> 中创建对象的副本.
  或者,您可以在 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/ProviderManager.html">Javadoc</a> 上禁用 <code>deleteCredentialsAfterAuthentication</code> 属性.  有关更多信息,请参见 Javadoc.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-authenticationprovider"><a class="anchor" href="#servlet-authentication-authenticationprovider"></a>10.7. AuthenticationProvider</h3>
<div class="paragraph">
<p>可以将多个  <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/AuthenticationProvider.html"><code>AuthenticationProvider</code>s</a>  注入  <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.
 每个 <code>AuthenticationProvider</code> 执行特定类型的身份验证.  例如,<a href="#servlet-authentication-daoauthenticationprovider"><code>DaoAuthenticationProvider</code></a>  支持基于用户名/密码的身份验证,而 <code>JwtAuthenticationProvider</code> 支持对 JWT 令牌的身份验证.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-authenticationentrypoint"><a class="anchor" href="#servlet-authentication-authenticationentrypoint"></a>10.8. 使用 <code>AuthenticationEntryPoint</code> 请求凭据</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/AuthenticationEntryPoint.html"><code>AuthenticationEntryPoint</code></a>  用于发送 HTTP 响应,以从客户端请求凭据.</p>
</div>
<div class="paragraph">
<p>有时,客户端会主动包含凭据 (例如用户名/密码) 以请求资源.  在这些情况下,Spring Security 不需要提供 HTTP 响应来从客户端请求凭据,因为它们已经包含在内.</p>
</div>
<div class="paragraph">
<p>在其他情况下,客户端将对未经授权访问的资源发出未经身份验证的请求.  在这种情况下,<code>AuthenticationEntryPoint</code> 的实现用于从客户端请求凭据.  <code>AuthenticationEntryPoint</code> 实现可能会执行<a href="#servlet-authentication-form">重定向到登录页面</a>,
使用 <a href="#servlet-authentication-basic">WWW-Authenticate</a>  header 进行响应等.</p>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-abstractprocessingfilter"><a class="anchor" href="#servlet-authentication-abstractprocessingfilter"></a>10.9. AbstractAuthenticationProcessingFilter</h3>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/AbstractAuthenticationProcessingFilter.html"><code>AbstractAuthenticationProcessingFilter</code></a> 用作验证用户凭据的基本过滤器.
 在对凭证进行身份验证之前,Spring Security 通常使用 <code>AuthenticationEntryPoint</code> 请求凭证.</p>
</div>
<div class="paragraph">
<p>接下来,<code>AbstractAuthenticationProcessingFilter</code> 可以对提交给它的任何身份验证请求进行身份验证.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/authentication/architecture/abstractauthenticationprocessingfilter.png" alt="abstractauthenticationprocessingfilter">
</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> 当用户提交其凭据时,<code>AbstractAuthenticationProcessingFilter</code> 从要验证的 HttpServletRequest 创建一个  <a href="#servlet-authentication-authentication"><code>Authentication</code></a> .
创建的身份验证类型取决于 <code>AbstractAuthenticationProcessingFilter</code> 的子类.  例如, <a href="#servlet-authentication-usernamepasswordauthenticationfilter"><code>UsernamePasswordAuthenticationFilter</code></a>
根据在 <code>HttpServletRequest</code> 中提交的用户名和密码来创建 <code>UsernamePasswordAuthenticationToken</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> 接下来,将 . <a href="#servlet-authentication-authentication"><code>Authentication</code></a> 传递到 <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> 进行身份验证</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> 如果身份验证失败,则失败</p>
</div>
<div class="ulist">
<ul>
<li>
<p>已清除 <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.</p>
</li>
<li>
<p><code>RememberMeServices.loginFail</code> 被调用.  如果 RememberMeServices 未配置,则为空.</p>
</li>
<li>
<p><code>AuthenticationFailureHandler</code> 被调用.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_4.png" alt="number 4"></span> 如果身份验证成功,则为成功.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>新的登录通知 <code>SessionAuthenticationStrategy</code>.</p>
</li>
<li>
<p><a href="#servlet-authentication-authentication">Authentication </a> 是在 <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> 上设置的.  之后,<code>SecurityContextPersistenceFilter</code> 将 <code>SecurityContext</code> 保存到 <code>HttpSession</code> 中.</p>
</li>
<li>
<p><code>RememberMeServices.loginSuccess</code> 被调用.  如果 RememberMeServices 未配置,则为空.</p>
</li>
<li>
<p><code>ApplicationEventPublisher</code> 发布一个 <code>InteractiveAuthenticationSuccessEvent</code>.</p>
</li>
<li>
<p><code>AuthenticationSuccessHandler</code> 被调用.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authentication-unpwd"><a class="anchor" href="#servlet-authentication-unpwd"></a>10.10. Username/Password 认证</h3>
<div class="paragraph">
<p>验证用户身份的最常见方法之一是验证用户名和密码. Spring Security 为使用用户名和密码进行身份验证提供了全面的支持.</p>
</div>
<div id="servlet-authentication-unpwd-input" class="paragraph">
<p><strong>获取 Username &amp; Password</strong></p>
</div>
<div class="paragraph">
<p>Spring Security 提供了以下内置机制,用于从 <code>HttpServletRequest</code> 中读取用户名和密码:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-form">表单登录</a></p>
</li>
<li>
<p><a href="#servlet-authentication-basic">Basic Authentication</a></p>
</li>
<li>
<p><a href="#servlet-authentication-digest">Digest Authentication</a></p>
</li>
</ul>
</div>
<div id="servlet-authentication-unpwd-storage" class="paragraph">
<p><strong>存储机制</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-inmemory">基于简单内存存储的身份验证</a></p>
</li>
<li>
<p><a href="#servlet-authentication-jdbc">JDBC 关系型数据库的身份验证</a></p>
</li>
<li>
<p><a href="#servlet-authentication-userdetailsservice">使用 <code>UserDetailsService</code> 的自定义数据存储</a></p>
</li>
<li>
<p><a href="#servlet-authentication-ldap">LDAP 认证的 LDAP 存储</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="servlet-authentication-form"><a class="anchor" href="#servlet-authentication-form"></a>10.10.1. 表单登录</h4>
<div class="paragraph">
<p>Spring Security 支持通过 html 表单提供的用户名和密码.  本节详细介绍了基于表单的身份验证在 Spring Security 中的工作方式.</p>
</div>
<div class="paragraph">
<p>让我们看看基于表单的登录在 Spring Security 中如何工作.  首先,我们了解如何将用户重定向到登录表单.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/authentication/unpwd/loginurlauthenticationentrypoint.png" alt="loginurlauthenticationentrypoint">
</div>
<div class="title">Figure 6. 重定向到登录页</div>
</div>
<div class="paragraph">
<p>该图基于  <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> 首先,未经过身份验证和授权的用户向 <code>/private</code> 资源发起请求.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> Spring Security 的 <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> 通过抛出 <code>AccessDeniedException</code> 来指示未经身份验证的请求被拒绝.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> 由于未对用户进行身份验证,因此 <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a>  会启动 "开始身份验证",并使用配置的  <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> 将重定向发送到登录页面.  在大多数情况下, <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.html"><code>LoginUrlAuthenticationEntryPoint</code></a>  是 <code>AuthenticationEntryPoint</code>  的实例.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_4.png" alt="number 4"></span> 然后,浏览器将请求将其重定向到的登录页面.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_5.png" alt="number 5"></span> 应用程序中的某些内容必须<a href="#servlet-authentication-form-custom">呈现登录页面</a>.  .</p>
</div>
<div id="servlet-authentication-usernamepasswordauthenticationfilter" class="paragraph">
<p>提交用户名和密码后,<code>UsernamePasswordAuthenticationFilter</code> 会对用户名和密码进行身份验证.  <code>UsernamePasswordAuthenticationFilter</code> 扩展了 <a href="#servlet-authentication-abstractprocessingfilter">AbstractAuthenticationProcessingFilter</a>,因此此图看起来应该非常相似.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/authentication/unpwd/usernamepasswordauthenticationfilter.png" alt="usernamepasswordauthenticationfilter">
</div>
<div class="title">Figure 7. Authenticating Username and Password</div>
</div>
<div class="paragraph">
<p>该图基于 <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> 当用户提交其用户名和密码时,<code>UsernamePasswordAuthenticationFilter</code> 通过从 <code>HttpServletRequest</code> 中提取用户名和密码来创建 <code>UsernamePasswordAuthenticationToken</code>,这是一种 <a href="#servlet-authentication-authentication"><code>Authentication</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> 接下来,将 <code>UsernamePasswordAuthenticationToken</code> 传递到 <code>AuthenticationManager</code> 进行身份验证.  <code>AuthenticationManager</code> 外观的详细信息取决于 <a href="#servlet-authentication-unpwd-storage">用户信息的存储方式</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> 如果身份验证失败,则失败</p>
</div>
<div class="ulist">
<ul>
<li>
<p>已清除 <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>.</p>
</li>
<li>
<p><code>RememberMeServices.loginFail</code> 被调用.  如果记住我未配置,则为空.</p>
</li>
<li>
<p><code>AuthenticationFailureHandler</code> 被调用.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_4.png" alt="number 4"></span> 如果身份验证成功,则为成功.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>新的登录通知 <code>SessionAuthenticationStrategy</code>.</p>
</li>
<li>
<p><a href="#servlet-authentication-authentication">Authentication </a> 是在 <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> 上设置的.  之后,<code>SecurityContextPersistenceFilter</code> 将 <code>SecurityContext</code> 保存到 <code>HttpSession</code> 中.</p>
</li>
<li>
<p><code>RememberMeServices.loginSuccess</code> 被调用.  如果记住我未配置,则为空.</p>
</li>
<li>
<p><code>ApplicationEventPublisher</code> 发布一个 <code>InteractiveAuthenticationSuccessEvent</code>.</p>
</li>
<li>
<p><code>AuthenticationSuccessHandler</code> 被调用.  通常,这是一个 <code>SimpleUrlAuthenticationSuccessHandler</code>,当我们重定向到登录页面时,它将重定向到  <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a>  保存的请求.</p>
</li>
</ul>
</div>
<div id="servlet-authentication-form-min" class="paragraph">
<p>默认情况下,Spring Security 表单登录处于启用状态.  但是,一旦提供了任何基于 servlet 的配置,就必须显式提供基于表单的登录.  可以在下面找到最小的显式Java配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 53. Form Log In</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) {
    http
        // ...
        .formLogin(withDefaults());
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;
    &lt;form-login /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        // ...
        formLogin { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种配置中,Spring Security 将呈现一个默认的登录页面.  大多数生产应用程序将需要自定义登录表单.</p>
</div>
<div id="servlet-authentication-form-custom" class="paragraph">
<p>下面的配置演示了如何提供自定义登录表单.
.Custom Log In Form Configuration</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
    http
        // ...
        .formLogin(form -&gt; form
            .loginPage("/login")
            .permitAll()
        );
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;
    &lt;intercept-url pattern="/login" access="permitAll" /&gt;
    &lt;form-login login-page="/login" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        // ...
        formLogin {
            loginPage = "/login"
            permitAll()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div id="servlet-authentication-form-custom-html" class="paragraph">
<p>在 Spring Security 配置中指定登录页面后,您将负责呈现该页面.  以下是 <a href="https://www.thymeleaf.org/">Thymeleaf</a>  模板,该模板生成符合 <code>/login</code> 登录页面的HTML登录表单.</p>
</div>
<div class="exampleblock">
<div class="title">Example 54. Log In Form</div>
<div class="content">
<div class="listingblock">
<div class="title">src/main/resources/templates/login.html</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="https://www.thymeleaf.org"&gt;
    &lt;head&gt;
        &lt;title&gt;Please Log In&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Please Log In&lt;/h1&gt;
        &lt;div th:if="${param.error}"&gt;
            Invalid username and password.&lt;/div&gt;
        &lt;div th:if="${param.logout}"&gt;
            You have been logged out.&lt;/div&gt;
        &lt;form th:action="@{/login}" method="post"&gt;
            &lt;div&gt;
            &lt;input type="text" name="username" placeholder="Username"/&gt;
            &lt;/div&gt;
            &lt;div&gt;
            &lt;input type="password" name="password" placeholder="Password"/&gt;
            &lt;/div&gt;
            &lt;input type="submit" value="Log in" /&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>关于默认HTML表单,有一些关键点:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个 POST 请求到 <code>/login</code> 用来验证用户</p>
</li>
<li>
<p>该表格将需要包含一个由Thymeleaf  <a href="#servlet-csrf-include-form-auto">自动包含</a>的 <a href="#servlet-csrf">CSRF Token</a>.</p>
</li>
<li>
<p>该表单 <code>username</code> 参数为 username</p>
</li>
<li>
<p>该表单 <code>password</code> 参数为 password</p>
</li>
<li>
<p>如果HTTP参数错误,则表明用户未能提供有效的 username/password</p>
</li>
<li>
<p>如果HTTP参数存在 logout 参数,则表明用户已成功注销</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>自定义页面这些参数已经够用了.  但是,如果需要,可以使用其他配置自定义以上所有内容.</p>
</div>
<div id="servlet-authentication-form-custom-controller" class="paragraph">
<p>如果您使用的是 Spring MVC,则需要一个将  <code>GET /login</code>   映射到我们创建的登录模板的控制器.  下面是最小的 LoginController示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 55. LoginController</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
class LoginController {
    @GetMapping("/login")
    String login() {
        return "login";
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class LoginController {
    @GetMapping("/login")
    fun login(): String {
        return "login"
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-basic"><a class="anchor" href="#servlet-authentication-basic"></a>10.10.2. Basic Authentication</h4>
<div class="paragraph">
<p>本节详细介绍了 Spring Security 如何为基于 servlet 的应用程序提供对 <a href="https://tools.ietf.org/html/rfc7617">Basic HTTP Authentication</a>  的支持.</p>
</div>
<div class="paragraph">
<p>让我们看一下 HTTP 基本身份验证在 Spring Security 中如何工作.  首先,我们看到  <a href="https://tools.ietf.org/html/rfc7235#section-4.1">WWW-Authenticate</a>  header 被发送回未经身份验证的客户端.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/authentication/unpwd/basicauthenticationentrypoint.png" alt="basicauthenticationentrypoint">
</div>
<div class="title">Figure 8. Sending WWW-Authenticate Header</div>
</div>
<div class="paragraph">
<p>该图基于 <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> 图.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> 首先,用户向未经身份验证和授权的  <code>/private</code> 资源发出请求.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> Spring Security 的 <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a>  通过抛出 <code>AccessDeniedException</code> 来指示未经身份验证的请求被拒绝.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> 由于用户未通过身份验证,因此 <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a>  会启动 "开始身份验证".
配置的 <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a>  是  <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/www/BasicAuthenticationEntryPoint.html"><code>BasicAuthenticationEntryPoint</code></a>  的实例,该实例发送 WWW-Authenticate  header .
<code>RequestCache</code> 通常是一个 <code>NullRequestCache</code>,它不保存请求,因为客户端能够重播它最初请求的请求.</p>
</div>
<div class="paragraph">
<p>当客户端收到 WWW-Authenticate  header 时,它知道应该使用用户名和密码重试.  以下是正在处理的用户名和密码的流程.</p>
</div>
<div id="servlet-authentication-basicauthenticationfilter" class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/authentication/unpwd/basicauthenticationfilter.png" alt="basicauthenticationfilter">
</div>
<div class="title">Figure 9. Authenticating Username and Password</div>
</div>
<div class="paragraph">
<p>该图基于 <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> 图.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> 当用户提交其用户名和密码时,<code>BasicAuthenticationFilter</code> 通过从 <code>HttpServletRequest</code> 中提取用户名和密码来创建 <code>UsernamePasswordAuthenticationToken</code>,这是一种  <a href="#servlet-authentication-authentication"><code>Authentication</code></a>  类型.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> 接下来,将 <code>UsernamePasswordAuthenticationToken</code> 传递到 <code>AuthenticationManager</code> 进行身份验证.  AuthenticationManager 详细信息取决于 <a href="#servlet-authentication-unpwd-storage">用户信息的存储方式</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> 如果身份验证失败,则为失败.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>清除 <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a></p>
</li>
<li>
<p><code>RememberMeServices.loginFail</code> 被调用.如果记住我未配置,则为空.</p>
</li>
<li>
<p>调用 <code>AuthenticationEntryPoint</code> 触发 WWW-Authenticate 重新发送.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_4.png" alt="number 4"></span> 如果身份验证成功,则为成功.</p>
</div>
<div class="paragraph">
<p>身份验证是在 <code>SecurityContextHolder</code> 上设置的.</p>
</div>
<div class="paragraph">
<p><code>RememberMeServices.loginSuccess</code> 被调用.  如果记住我未配置,则为空.</p>
</div>
<div class="paragraph">
<p><code>BasicAuthenticationFilter</code> 调用 <code>FilterChain.doFilter(request,response)</code> 继续进行其余的应用程序逻辑.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> 上设置  <a href="#servlet-authentication-authentication">Authentication</a></p>
</li>
<li>
<p><code>RememberMeServices.loginSuccess</code> 被调用.  如果记住我未配置,则为空.</p>
</li>
<li>
<p><code>BasicAuthenticationFilter</code> 调用  <code>FilterChain.doFilter(request,response)</code> 继续进行其余的应用程序逻辑.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Spring Security 的 HTTP 基本身份验证支持默认为启用.  但是,一旦提供了任何基于 servlet 的配置,就必须显式提供 HTTP Basic.</p>
</div>
<div class="paragraph">
<p>最小的显式配置可以在下面找到:</p>
</div>
<div class="exampleblock">
<div class="title">Example 56. Explicit HTTP Basic Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) {
    http
        // ...
        .httpBasic(withDefaults());
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;
    &lt;http-basic /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        // ...
        httpBasic { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-digest"><a class="anchor" href="#servlet-authentication-digest"></a>10.10.3. Digest Authentication</h4>
<div class="paragraph">
<p>本节详细介绍了 Spring Security 如何为 <a href="https://tools.ietf.org/html/rfc2617">Digest Authentication</a>   提供的 <code>DigestAuthenticationFilter</code> 支持.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您不应该在现代应用程序中使用摘要式身份验证,因为它不安全.  最明显的问题是,您必须以纯文本,加密或 MD5 格式存储密码.  所有这些存储格式都被认为是不安全的.  相反,您应该使用摘要身份验证不支持的单向自适应密码哈希(即 bCrypt,PBKDF2,SCrypt 等) 存储凭据.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>摘要身份验证试图解决  <a href="#servlet-authentication-basic">Basic authentication</a> 的许多弱点,特别是通过确保凭据不会以明文形式通过网络发送来解决.  许多浏览器支持 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Digest#Browser_compatibility">browsers support Digest Authentication</a>.</p>
</div>
<div class="paragraph">
<p>HTTP摘要认证的标准由  <a href="https://tools.ietf.org/html/rfc2617">RFC 2617</a> 定义,该标准更新了  <a href="https://tools.ietf.org/html/rfc2069">RFC 2069</a> 规定的摘要认证标准的早期版本.
大多数用户代理实现 RFC2617. Spring Security 的摘要认证支持与 "auth" 保护质量兼容( qop) 是由 RFC 2617 规定的,它还提供了与 RFC 2069 的向后兼容性.
如果您需要使用未加密的 HTTP (即没有 TLS/HTTPS) 并且希望最大程度地提高身份验证过程的安全性,则摘要身份验证被视为一种更具吸引力的选择.  但是,每个人都应该使用 <a href="#http">HTTPS</a>.</p>
</div>
<div class="paragraph">
<p>摘要式身份验证的核心是 "一次性".  这是服务器生成的值.  Spring Security 的随机数采用以下格式:</p>
</div>
<div class="exampleblock">
<div class="title">Example 57. Digest Syntax</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">base64(expirationTime + ":" + md5Hex(expirationTime + ":" + key))
expirationTime:   The date and time when the nonce expires, expressed in milliseconds
key:              A private key to prevent modification of the nonce token</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您将需要确保使用 <code>NoOpPasswordEncoder</code> <a href="#authentication-password-storage-configuration">配置</a>不安全的纯文本 <a href="#authentication-password-storage">密码存储</a>.  以下提供了使用 Java 配置摘要式身份验证的示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 58. Digest Authentication</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowired
UserDetailsService userDetailsService;

DigestAuthenticationEntryPoint entryPoint() {
    DigestAuthenticationEntryPoint result = new DigestAuthenticationEntryPoint();
    result.setRealmName("My App Relam");
    result.setKey("3028472b-da34-4501-bfd8-a355c42bdf92");
}

DigestAuthenticationFilter digestAuthenticationFilter() {
    DigestAuthenticationFilter result = new DigestAuthenticationFilter();
    result.setUserDetailsService(userDetailsService);
    result.setAuthenticationEntryPoint(entryPoint());
}

protected void configure(HttpSecurity http) throws Exception {
    http
        // ...
        .exceptionHandling(e -&gt; e.authenticationEntryPoint(authenticationEntryPoint()))
        .addFilterBefore(digestFilter());
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;b:bean id="digestFilter"
        class="org.springframework.security.web.authentication.www.DigestAuthenticationFilter"
    p:userDetailsService-ref="jdbcDaoImpl"
    p:authenticationEntryPoint-ref="digestEntryPoint"
/&gt;

&lt;b:bean id="digestEntryPoint"
        class="org.springframework.security.web.authentication.www.DigestAuthenticationEntryPoint"
    p:realmName="My App Realm"
    p:key="3028472b-da34-4501-bfd8-a355c42bdf92"
/&gt;

&lt;http&gt;
    &lt;!-- ... --&gt;
    &lt;custom-filter ref="userFilter" position="DIGEST_AUTH_FILTER"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-inmemory"><a class="anchor" href="#servlet-authentication-inmemory"></a>10.10.4. In-Memory Authentication</h4>
<div class="paragraph">
<p>Spring Security 的 <code>InMemoryUserDetailsManager</code> 实现了  <a href="#servlet-authentication-userdetailsservice">UserDetailsService</a>,以支持对在内存中检索到的基于用户名/密码的身份验证.
 <code>InMemoryUserDetailsManager</code> 通过实现 <code>UserDetailsManager</code> 接口来提供对 <code>UserDetails</code> 的管理.  当配置为<a href="#servlet-authentication-unpwd-input">接受用户名/密码</a>进行身份验证时,Spring Security 使用基于 <code>UserDetails</code> 的身份验证.</p>
</div>
<div class="paragraph">
<p>在此示例中,我们使用 <a href="#authentication-password-storage-boot-cli">Spring Boot CLI</a>  对 password 的密码进行编码,并获得  <code>{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 59. InMemoryUserDetailsManager Java 配置</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public UserDetailsService users() {
    UserDetails user = User.builder()
        .username("user")
        .password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER")
        .build();
    UserDetails admin = User.builder()
        .username("admin")
        .password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER", "ADMIN")
        .build();
    return new InMemoryUserDetailsManager(user, admin);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;user-service&gt;
    &lt;user name="user"
        password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
        authorities="ROLE_USER" /&gt;
    &lt;user name="admin"
        password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
        authorities="ROLE_USER,ROLE_ADMIN" /&gt;
&lt;/user-service&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun users(): UserDetailsService {
    val user = User.builder()
        .username("user")
        .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER")
        .build()
    val admin = User.builder()
        .username("admin")
        .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER", "ADMIN")
        .build()
    return InMemoryUserDetailsManager(user, admin)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的示例以安全格式存储密码,但是在入门经验方面还有很多不足.</p>
</div>
<div class="paragraph">
<p>在下面的示例中,我们利用  <a href="#authentication-password-storage-dep-getting-started">User.withDefaultPasswordEncoder</a>  来确保存储在内存中的密码受到保护.  但是,它不能防止通过反编译源代码来获取密码.  因此,<code>User.withDefaultPasswordEncoder</code> 仅应用于  "入门" ,而不应用于生产.</p>
</div>
<div class="exampleblock">
<div class="title">Example 60. InMemoryUserDetailsManager with User.withDefaultPasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public UserDetailsService users() {
    // The builder will ensure the passwords are encoded before saving in memory
    UserBuilder users = User.withDefaultPasswordEncoder();
    UserDetails user = users
        .username("user")
        .password("password")
        .roles("USER")
        .build();
    UserDetails admin = users
        .username("admin")
        .password("password")
        .roles("USER", "ADMIN")
        .build();
    return new InMemoryUserDetailsManager(user, admin);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun users(): UserDetailsService {
    // The builder will ensure the passwords are encoded before saving in memory
    val users = User.withDefaultPasswordEncoder()
    val user = users
        .username("user")
        .password("password")
        .roles("USER")
        .build()
    val admin = users
        .username("admin")
        .password("password")
        .roles("USER", "ADMIN")
        .build()
    return InMemoryUserDetailsManager(user, admin)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>没有简单的方法可以将 <code>User.withDefaultPasswordEncoder</code> 与基于 XML 的配置一起使用.  对于演示或刚刚入门,您可以选择在密码前加上  <code>{noop}</code>  前缀,以指示 <a href="#authentication-password-storage-dpe-format">不应使用任何编码</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 61. &lt;user-service&gt; <code>{noop}</code> XML Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;user-service&gt;
    &lt;user name="user"
        password="{noop}password"
        authorities="ROLE_USER" /&gt;
    &lt;user name="admin"
        password="{noop}password"
        authorities="ROLE_USER,ROLE_ADMIN" /&gt;
&lt;/user-service&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-jdbc"><a class="anchor" href="#servlet-authentication-jdbc"></a>10.10.5. JDBC Authentication</h4>
<div class="paragraph">
<p>Spring Security 的 <code>JdbcDaoImpl</code> 实现了  <a href="#servlet-authentication-userdetailsservice">UserDetailsService</a> ,以提供对使用 JDBC 检索的基于用户名/密码的身份验证的支持.
 <code>JdbcUserDetailsManager</code> 扩展了 <code>JdbcDaoImpl</code> 以通过 <code>UserDetailsManager</code> 接口提供对 <code>UserDetails</code> 的管理.  当配置为  <a href="#servlet-authentication-unpwd-input">接受 username/password</a>进行身份验证时,Spring Security 使用基于 <code>UserDetails</code> 的身份验证.</p>
</div>
<div class="paragraph">
<p>在以下各节中,我们将讨论:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Security JDBC 身份验证使用的默认 <a href="#servlet-authentication-jdbc-schema">架构</a></p>
</li>
<li>
<p><a href="#servlet-authentication-jdbc-datasource">设置数据源</a></p>
</li>
<li>
<p><a href="#servlet-authentication-jdbc-bean">JdbcUserDetailsManager Bean</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="servlet-authentication-jdbc-schema"><a class="anchor" href="#servlet-authentication-jdbc-schema"></a>默认架构</h5>
<div class="paragraph">
<p>Spring Security 为基于 JDBC 的身份验证提供默认查询.  本节提供了与默认查询一起使用的相应默认架构.  您将需要调整架构,以将所有自定义项与查询和正在使用的数据库方言进行匹配.</p>
</div>
<div class="sect5">
<h6 id="servlet-authentication-jdbc-schema-user"><a class="anchor" href="#servlet-authentication-jdbc-schema-user"></a>User Schema</h6>
<div class="paragraph">
<p><code>JdbcDaoImpl</code> 需要使用表来加载用户的密码,帐户状态(启用或禁用) 和权限列表(角色) .  所需的默认架构可以在下面找到.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认架构也作为名为 <code>org/springframework/security/core/userdetails/jdbc/users.ddl</code> 的类路径资源暴露 .</p>
</div>
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 62. Default User Schema</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">create table users(
    username varchar_ignorecase(50) not null primary key,
    password varchar_ignorecase(500) not null,
    enabled boolean not null
);

create table authorities (
    username varchar_ignorecase(50) not null,
    authority varchar_ignorecase(50) not null,
    constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Oracle 是一种流行的数据库选择,但是需要稍微不同的架构.  您可以在下面找到用户的默认 Oracle 模式.</p>
</div>
<div class="exampleblock">
<div class="title">Example 63. Default User Schema for Oracle Databases</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">CREATE TABLE USERS (
    USERNAME NVARCHAR2(128) PRIMARY KEY,
    PASSWORD NVARCHAR2(128) NOT NULL,
    ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL
);


CREATE TABLE AUTHORITIES (
    USERNAME NVARCHAR2(128) NOT NULL,
    AUTHORITY NVARCHAR2(128) NOT NULL
);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="servlet-authentication-jdbc-schema-group"><a class="anchor" href="#servlet-authentication-jdbc-schema-group"></a>Group Schema</h6>
<div class="paragraph">
<p>如果您的应用程序利用组,则需要提供组架构.  组的默认架构可以在下面找到.</p>
</div>
<div class="exampleblock">
<div class="title">Example 64. Default Group Schema</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-sql" data-lang="sql">create table groups (
    id bigint generated by default as identity(start with 0) primary key,
    group_name varchar_ignorecase(50) not null
);

create table group_authorities (
    group_id bigint not null,
    authority varchar(50) not null,
    constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
    id bigint generated by default as identity(start with 0) primary key,
    username varchar(50) not null,
    group_id bigint not null,
    constraint fk_group_members_group foreign key(group_id) references groups(id)
);</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-jdbc-datasource"><a class="anchor" href="#servlet-authentication-jdbc-datasource"></a>设置数据源</h5>
<div class="paragraph">
<p>在配置 <code>JdbcUserDetailsManager</code> 之前,我们必须创建一个数据源.  在我们的示例中,我们将设置一个使用 <a href="#servlet-authentication-jdbc-schema">默认用户架构</a> 初始化的 <a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/data-access.html#jdbc-embedded-database-support">嵌入式 DataSource</a>  .</p>
</div>
<div class="exampleblock">
<div class="title">Example 65. Embedded Data Source</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
DataSource dataSource() {
    return new EmbeddedDatabaseBuilder()
        .setType(H2)
        .addScript("classpath:org/springframework/security/core/userdetails/jdbc/users.ddl")
        .build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;jdbc:embedded-database&gt;
    &lt;jdbc:script location="classpath:org/springframework/security/core/userdetails/jdbc/users.ddl"/&gt;
&lt;/jdbc:embedded-database&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun dataSource(): DataSource {
    return EmbeddedDatabaseBuilder()
        .setType(H2)
        .addScript("classpath:org/springframework/security/core/userdetails/jdbc/users.ddl")
        .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在生产环境中,您将要确保设置与外部数据库的连接.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-jdbc-bean"><a class="anchor" href="#servlet-authentication-jdbc-bean"></a>JdbcUserDetailsManager Bean</h5>
<div class="paragraph">
<p>在此示例中,我们使用  <a href="#authentication-password-storage-boot-cli">Spring Boot CLI</a> 对 <code>password</code> 的密码进行编码,并获得  <code>{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW</code> 密码.  有关如何存储密码的更多详细信息,请参见 <a href="#authentication-password-storage">PasswordEncoder</a> 部分.</p>
</div>
<div class="exampleblock">
<div class="title">Example 66. JdbcUserDetailsManager</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
UserDetailsManager users(DataSource dataSource) {
    UserDetails user = User.builder()
        .username("user")
        .password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER")
        .build();
    UserDetails admin = User.builder()
        .username("admin")
        .password("{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
        .roles("USER", "ADMIN")
        .build();
    JdbcUserDetailsManager users = new JdbcUserDetailsManager(dataSource);
    users.createUser(user);
    users.createUser(admin);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;jdbc-user-service&gt;
    &lt;user name="user"
        password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
        authorities="ROLE_USER" /&gt;
    &lt;user name="admin"
        password="{bcrypt}$2a$10$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW"
        authorities="ROLE_USER,ROLE_ADMIN" /&gt;
&lt;/jdbc-user-service&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun users(dataSource: DataSource): UserDetailsManager {
    val user = User.builder()
            .username("user")
            .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER")
            .build();
    val admin = User.builder()
            .username("admin")
            .password("{bcrypt}$2a$10\$GRLdNijSQMUvl/au9ofL.eDwmoohzzS7.rmNSJZ.0FxO/BTk76klW")
            .roles("USER", "ADMIN")
            .build();
    val users = JdbcUserDetailsManager(dataSource)
    users.createUser(user)
    users.createUser(admin)
    return users
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-userdetails"><a class="anchor" href="#servlet-authentication-userdetails"></a>10.10.6. UserDetails</h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/UserDetails.html"><code>UserDetails</code></a>  由 <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a> 返回.
 <a href="#servlet-authentication-daoauthenticationprovider"><code>DaoAuthenticationProvider</code></a>  验证 UserDetails,然后返回 <a href="#servlet-authentication-authentication"><code>Authentication</code></a> ,该身份验证的主体是已配置的 <code>UserDetailsService</code> 返回的 <code>UserDetails</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-userdetailsservice"><a class="anchor" href="#servlet-authentication-userdetailsservice"></a>10.10.7. UserDetailsService</h4>
<div class="paragraph">
<p><a href="#servlet-authentication-daoauthenticationprovider"><code>DaoAuthenticationProvider</code></a>  使用 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/userdetails/UserDetailsService.html"><code>UserDetailsService</code></a>  检索用户名,密码和其他用于使用用户名和密码进行身份验证的属性.
Spring Security 提供 <code>UserDetailsService</code> 的 <a href="#servlet-authentication-inmemory">内存中</a>  和  <a href="#servlet-authentication-jdbc">JDBC</a> 实现.</p>
</div>
<div class="paragraph">
<p>您可以通过将自定义 <code>UserDetailsService</code> 暴露为 bean 来定义自定义身份验证.  例如,下面的示例将假设 <code>CustomUserDetailsService</code> 实现 <code>UserDetailsService</code> 来自定义身份验证:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
仅当尚未填充 <code>AuthenticationManagerBuilder</code> 且未定义 <code>AuthenticationProviderBean</code> 时,才使用此方法.
</td>
</tr>
</table>
</div>
<div class="exampleblock">
<div class="title">Example 67. Custom UserDetailsService Bean</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
CustomUserDetailsService customUserDetailsService() {
    return new CustomUserDetailsService();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">&lt;b:bean class="example.CustomUserDetailsService"/&gt;
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun customUserDetailsService() = CustomUserDetailsService()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-password-storage"><a class="anchor" href="#servlet-authentication-password-storage"></a>10.10.8. PasswordEncoder</h4>
<div class="paragraph">
<p>Spring Security 的 servlet 支持与 <a href="#authentication-password-storage"><code>PasswordEncoder</code></a> 集成来安全地存储密码.  可以通过  <a href="#authentication-password-storage-configuration">暴露一个 <code>PasswordEncoder</code> Bean</a> 来定制 Spring Security 使用的 <code>PasswordEncoder</code> 实现.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-daoauthenticationprovider"><a class="anchor" href="#servlet-authentication-daoauthenticationprovider"></a>10.10.9. DaoAuthenticationProvider</h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/dao/DaoAuthenticationProvider.html"><code>DaoAuthenticationProvider</code></a> 是  <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code></a> 实现,它利用  <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a>  和 <a href="#servlet-authentication-password-storage"><code>PasswordEncoder</code></a> 对用户名和密码进行身份验证.</p>
</div>
<div class="paragraph">
<p>让我们看一下 <code>DaoAuthenticationProvider</code> 在 Spring Security 中的工作方式.  该图详细说明了 <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a>  如何  <a href="#servlet-authentication-unpwd-input">读取 Username &amp; Password</a> .</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/authentication/unpwd/daoauthenticationprovider.png" alt="daoauthenticationprovider">
</div>
<div class="title">Figure 10. <code>DaoAuthenticationProvider</code> 使用</div>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> <a href="#servlet-authentication-unpwd-input">读取用户名和密码</a>后的身份验证过滤器会将 <code>UsernamePasswordAuthenticationToken</code> 传递给实现了 <code>AuthenticationManager</code> 的 <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a> .</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> <code>ProviderManager</code> 配置  <a href="#servlet-authentication-authenticationprovider">AuthenticationProvider</a> 类型的实现 <code>DaoAuthenticationProvider</code> 类型.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> <code>DaoAuthenticationProvider</code> 从 <code>UserDetailsService</code> 查找 <code>UserDetails</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_4.png" alt="number 4"></span> 然后 <code>DaoAuthenticationProvider</code> 使用 <a href="#servlet-authentication-password-storage"><code>PasswordEncoder</code></a>  来验证上一步返回的 <code>UserDetails</code> 上的密码.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_5.png" alt="number 5"></span> 身份验证成功后,返回的 <a href="#servlet-authentication-authentication"><code>Authentication</code></a>  类型为 <code>UsernamePasswordAuthenticationToken</code>,其主体为配置的 <code>UserDetailsService</code> 返回的 <code>UserDetails</code>.  最终,将通过身份验证过滤器在 <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a>  上设置返回的 <code>UsernamePasswordAuthenticationToken</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-authentication-ldap"><a class="anchor" href="#servlet-authentication-ldap"></a>10.10.10. LDAP 认证</h4>
<div class="paragraph">
<p>LDAP 通常被组织用作用户信息的中央存储库和身份验证服务.  它还可以用于存储应用程序用户的角色信息.</p>
</div>
<div class="paragraph">
<p>当 Spring Security 配置为 <a href="#servlet-authentication-unpwd-input">接受用户名/密码</a> 进行身份验证时,将使用 Spring Security 的基于 LDAP 的身份验证.  但是,尽管利用了用户名/密码进行身份验证,它也无法使用 <code>UserDetailsService</code> 集成,
因为在 <a href="#servlet-authentication-ldap-bind">绑定身份验证</a> 中 LDAP 服务器不会返回密码,因此应用程序无法执行密码验证.</p>
</div>
<div class="paragraph">
<p>关于如何配置 LDAP 服务器,有许多不同的方案,以便 Spring Security 的 LDAP 提供程序是完全可配置的.  它使用单独的策略接口进行身份验证和角色检索,并提供可配置为处理各种情况的默认实现.</p>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-prerequisites"><a class="anchor" href="#servlet-authentication-ldap-prerequisites"></a>前提条件</h5>
<div class="paragraph">
<p>在尝试将其与 Spring Security 结合使用之前,您应该熟悉 LDAP.  以下链接很好地介绍了相关概念,并提供了使用免费 LDAP 服务器 OpenLDAP 设置目录的指南:  <a href="http://www.zytrax.com/books/ldap/">http://www.zytrax.com/books/ldap/</a>.
熟悉用于从 Java 访问 LDAP 的 JNDI API 可能也很有用.  我们在 LDAP 提供程序中未使用任何第三方 LDAP 库(Mozilla,JLDAP 等) ,但是 Spring LDAP 被广泛使用,因此如果您计划添加自己的自定义项,则对该项目有些熟悉可能会很有用.</p>
</div>
<div class="paragraph">
<p>使用 LDAP 身份验证时,重要的是要确保正确配置 LDAP 连接池.  如果您不熟悉该操作,可以参考 <a href="https://docs.oracle.com/javase/jndi/tutorial/ldap/connect/config.html">Java LDAP 文档</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-embedded"><a class="anchor" href="#servlet-authentication-ldap-embedded"></a>设置嵌入式LDAP服务器</h5>
<div class="paragraph">
<p>您需要做的第一件事是确保您有一个 LDAP 服务器来指向您的配置.  为简单起见,通常最好从嵌入式 LDAP 服务器开始.  Spring Security 支持使用以下任一方法:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-ldap-unboundid">嵌入式 UnboundID 服务器</a></p>
</li>
<li>
<p><a href="#servlet-authentication-ldap-apacheds">嵌入式 ApacheDS 服务器</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在下面的示例中,我们将以下内容作为  <code>users.ldif</code>  暴露为类路径资源,以使用用户 <code>user</code> 和 <code>admin</code> 来初始化嵌入式 LDAP 服务器,这两个用户的密码均为 <code>password</code>.</p>
</div>
<div class="listingblock">
<div class="title">users.ldif</div>
<div class="content">
<pre class="highlight"><code class="language-ldif" data-lang="ldif">dn: ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: groups

dn: ou=people,dc=springframework,dc=org
objectclass: top
objectclass: organizationalUnit
ou: people

dn: uid=admin,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Rod Johnson
sn: Johnson
uid: admin
userPassword: password

dn: uid=user,ou=people,dc=springframework,dc=org
objectclass: top
objectclass: person
objectclass: organizationalPerson
objectclass: inetOrgPerson
cn: Dianne Emu
sn: Emu
uid: user
userPassword: password

dn: cn=user,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: user
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org
uniqueMember: uid=user,ou=people,dc=springframework,dc=org

dn: cn=admin,ou=groups,dc=springframework,dc=org
objectclass: top
objectclass: groupOfNames
cn: admin
uniqueMember: uid=admin,ou=people,dc=springframework,dc=org</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="servlet-authentication-ldap-unboundid"><a class="anchor" href="#servlet-authentication-ldap-unboundid"></a>嵌入式 UnboundID 服务器</h6>
<div class="paragraph">
<p>如果您希望使用 <a href="https://ldap.com/unboundid-ldap-sdk-for-java/">UnboundID</a>,请指定以下依赖:</p>
</div>
<div class="exampleblock">
<div class="title">Example 68. UnboundID Dependencies</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.unboundid&lt;/groupId&gt;
    &lt;artifactId&gt;unboundid-ldapsdk&lt;/artifactId&gt;
    &lt;version&gt;{unboundid-ldapsdk-version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">depenendencies {
    runtimeOnly "com.unboundid:unboundid-ldapsdk:{unboundid-ldapsdk-version}"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后,您可以配置嵌入式 LDAP 服务器</p>
</div>
<div class="exampleblock">
<div class="title">Example 69. 嵌入式 LDAP 服务器配置</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
UnboundIdContainer ldapContainer() {
    return new UnboundIdContainer("dc=springframework,dc=org",
                "classpath:users.ldif");
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;b:bean class="org.springframework.security.ldap.server.UnboundIdContainer"
    c:defaultPartitionSuffix="dc=springframework,dc=org"
    c:ldif="classpath:users.ldif"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun ldapContainer(): UnboundIdContainer {
    return UnboundIdContainer("dc=springframework,dc=org","classpath:users.ldif")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="servlet-authentication-ldap-apacheds"><a class="anchor" href="#servlet-authentication-ldap-apacheds"></a>嵌入式 ApacheDS 服务器</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Security 使用不再维护的 ApacheDS1.x.  不幸的是,ApacheDS 2.x 仅发布了里程碑版本,没有稳定版本.  一旦有稳定的ApacheDS 2.x 版本可用,我们将考虑进行更新.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果希望使用 <a href="https://directory.apache.org/apacheds/">Apache DS</a>,请指定以下依赖:</p>
</div>
<div class="exampleblock">
<div class="title">Example 70. ApacheDS Dependencies</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Maven</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.directory.server&lt;/groupId&gt;
    &lt;artifactId&gt;apacheds-core&lt;/artifactId&gt;
    &lt;version&gt;{apacheds-core-version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.directory.server&lt;/groupId&gt;
    &lt;artifactId&gt;apacheds-server-jndi&lt;/artifactId&gt;
    &lt;version&gt;{apacheds-core-version}&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Gradle</div>
<div class="content">
<pre class="highlight"><code class="language-groovy" data-lang="groovy">depenendencies {
    runtimeOnly "org.apache.directory.server:apacheds-core:{apacheds-core-version}"
    runtimeOnly "org.apache.directory.server:apacheds-server-jndi:{apacheds-core-version}"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后,您可以配置嵌入式 LDAP 服务器</p>
</div>
<div class="exampleblock">
<div class="title">Example 71. Embedded LDAP Server Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ApacheDSContainer ldapContainer() {
    return new ApacheDSContainer("dc=springframework,dc=org",
                "classpath:users.ldif");
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;b:bean class="org.springframework.security.ldap.server.ApacheDSContainer"
    c:defaultPartitionSuffix="dc=springframework,dc=org"
    c:ldif="classpath:users.ldif"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun ldapContainer(): ApacheDSContainer {
    return ApacheDSContainer("dc=springframework,dc=org", "classpath:users.ldif")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-contextsource"><a class="anchor" href="#servlet-authentication-ldap-contextsource"></a>LDAP ContextSource</h5>
<div class="paragraph">
<p>一旦有了 LDAP 服务器来将您的配置指向,就需要配置 Spring Security 来指向应该用于认证用户的 LDAP 服务器.  这是通过创建 LDAP  <code>ContextSource</code> 来完成的,该 LDAP <code>ContextSource</code> 等效于 JDBC <code>DataSource</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 72. LDAP Context Source</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ContextSource contextSource(UnboundIdContainer container) {
    return new DefaultSpringSecurityContextSource("ldap://localhost:53389/dc=springframework,dc=org");
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;ldap-server
    url="ldap://localhost:53389/dc=springframework,dc=org" /&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun contextSource(container: UnboundIdContainer): ContextSource {
    return DefaultSpringSecurityContextSource("ldap://localhost:53389/dc=springframework,dc=org")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-authentication"><a class="anchor" href="#servlet-authentication-ldap-authentication"></a>认证</h5>
<div class="paragraph">
<p>Spring Security 的 LDAP 不支持使用 <a href="#servlet-authentication-userdetailsservice">UserDetailsService</a>,因为 LDAP 绑定身份验证不允许客户端读取密码,甚至不允许散列密码.  这意味着 Spring Security 无法读取密码然后对其进行身份验证.</p>
</div>
<div class="paragraph">
<p>因此,使用 <code>LdapAuthenticator</code> 接口实现了对 LDAP 支持.  <code>LdapAuthenticator</code> 还负责检索任何必需的用户属性.  这是因为对属性的权限可能取决于所使用的身份验证类型.  例如,如果以用户身份进行绑定,则可能有必要在用户自己的权限下阅读它们.</p>
</div>
<div class="paragraph">
<p>Spring Security 提供了两个 <code>LdapAuthenticator</code> 实现:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-ldap-bind">使用绑定身份验证</a></p>
</li>
<li>
<p><a href="#servlet-authentication-ldap-pwd">使用密码认证</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-bind"><a class="anchor" href="#servlet-authentication-ldap-bind"></a>使用绑定身份验证</h5>
<div class="paragraph">
<p><a href="https://ldap.com/the-ldap-bind-operation/">绑定身份验证</a> 是使用 LDAP 身份验证用户的最常用机制.  在绑定身份验证中,用户凭据(即用户名/密码) 将提交给LDAP服务器以对其进行身份验证.
使用绑定身份验证的优点是不需要将用户的机密信息(即密码) 暴露给客户端,这有助于防止客户端泄露.</p>
</div>
<div class="paragraph">
<p>绑定身份验证配置的示例可以在下面找到.</p>
</div>
<div class="exampleblock">
<div class="title">Example 73. Bind Authentication</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
BindAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
    BindAuthenticator authenticator = new BindAuthenticator(contextSource);
    authenticator.setUserDnPatterns(new String[] { "uid={0},ou=people" });
    return authenticator;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
    return new LdapAuthenticationProvider(authenticator);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;ldap-authentication-provider
    user-dn-pattern="uid={0},ou=people"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): BindAuthenticator {
    val authenticator = BindAuthenticator(contextSource)
    authenticator.setUserDnPatterns(arrayOf("uid={0},ou=people"))
    return authenticator
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个简单的示例将通过使用提供的模式替换用户登录名并尝试使用该登录密码将该用户绑定来获取该用户的DN.  如果所有用户都存储在目录中的单个节点下,这样做是可以的.  相反,如果您希望配置 LDAP 搜索过滤器来定位用户,则可以使用以下方法:</p>
</div>
<div class="exampleblock">
<div class="title">Example 74. Bind Authentication with Search Filter</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
BindAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
    String searchBase = "ou=people";
    String filter = "(uid={0})";
    FilterBasedLdapUserSearch search =
        new FilterBasedLdapUserSearch(searchBase, filter, contextSource);
    BindAuthenticator authenticator = new BindAuthenticator(contextSource);
    authenticator.setUserSearch(search);
    return authenticator;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
    return new LdapAuthenticationProvider(authenticator);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;ldap-authentication-provider
        user-search-filter="(uid={0})"
    user-search-base="ou=people"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): BindAuthenticator {
    val searchBase = "ou=people"
    val filter = "(uid={0})"
    val search = FilterBasedLdapUserSearch(searchBase, filter, contextSource)
    val authenticator = BindAuthenticator(contextSource)
    authenticator.setUserSearch(search)
    return authenticator
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果与上面的 <code>ContextSource</code> <a href="#servlet-authentication-ldap-contextsource">定义</a> 一起使用,它将使用  <code>(uid={0})</code> 作为过滤器在DN <code>ou=people,dc=springframework,dc=org</code> 下执行搜索.
再次用用户登录名代替过滤器名称中的参数,因此它将搜索 <code>uid</code> 属性等于用户名的条目.  如果未提供用户搜索库,则将从根目录执行搜索.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-authentication-ldap-pwd"><a class="anchor" href="#servlet-authentication-ldap-pwd"></a>使用密码认证</h5>
<div class="paragraph">
<p>密码比较是将用户提供的密码与存储库中存储的密码进行比较.  可以通过检索 password 属性的值并在本地对其进行检查来完成此操作,也可以通过执行 LDAP "比较" 操作来完成,在该操作中,将提供的密码传递给服务器进行比较,并且永远不会检索到真实的密码值.  如果使用随机盐正确地对密码进行了哈希处理,则无法进行 LDAP 比较.</p>
</div>
<div class="exampleblock">
<div class="title">Example 75. Minimal Password Compare Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
PasswordComparisonAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
    return new PasswordComparisonAuthenticator(contextSource);
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
    return new LdapAuthenticationProvider(authenticator);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;ldap-authentication-provider
        user-dn-pattern="uid={0},ou=people"&gt;
    &lt;password-compare /&gt;
&lt;/ldap-authentication-provider&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): PasswordComparisonAuthenticator {
    return PasswordComparisonAuthenticator(contextSource)
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以在下面找到带有一些自定义设置的更高级的配置.</p>
</div>
<div class="exampleblock">
<div class="title">Example 76. Password Compare Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
PasswordComparisonAuthenticator authenticator(BaseLdapPathContextSource contextSource) {
    PasswordComparisonAuthenticator authenticator =
        new PasswordComparisonAuthenticator(contextSource);
    authenticator.setPasswordAttributeName("pwd"); <i class="conum" data-value="1"></i><b>(1)</b>
    authenticator.setPasswordEncoder(new BCryptPasswordEncoder()); <i class="conum" data-value="2"></i><b>(2)</b>
    return authenticator;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator) {
    return new LdapAuthenticationProvider(authenticator);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;ldap-authentication-provider
        user-dn-pattern="uid={0},ou=people"&gt;
    &lt;password-compare password-attribute="pwd"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        &lt;password-encoder ref="passwordEncoder" /&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;/password-compare&gt;
&lt;/ldap-authentication-provider&gt;
&lt;b:bean id="passwordEncoder"
    class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder" /&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authenticator(contextSource: BaseLdapPathContextSource): PasswordComparisonAuthenticator {
    val authenticator = PasswordComparisonAuthenticator(contextSource)
    authenticator.setPasswordAttributeName("pwd") <i class="conum" data-value="1"></i><b>(1)</b>
    authenticator.setPasswordEncoder(BCryptPasswordEncoder()) <i class="conum" data-value="2"></i><b>(2)</b>
    return authenticator
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将密码属性指定为 <code>pwd</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>使用 <code>BCryptPasswordEncoder</code></td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ldapauthoritiespopulator"><a class="anchor" href="#ldapauthoritiespopulator"></a>LdapAuthoritiesPopulator</h5>
<div class="paragraph">
<p>Spring Security 的 <code>LdapAuthoritiesPopulator</code> 用于确定返回给用户的授权.</p>
</div>
<div class="exampleblock">
<div class="title">Example 77. LdapAuthoritiesPopulator Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
LdapAuthoritiesPopulator authorities(BaseLdapPathContextSource contextSource) {
    String groupSearchBase = "";
    DefaultLdapAuthoritiesPopulator authorities =
        new DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase);
    authorities.setGroupSearchFilter("member={0}");
    return authorities;
}

@Bean
LdapAuthenticationProvider authenticationProvider(LdapAuthenticator authenticator, LdapAuthoritiesPopulator authorities) {
    return new LdapAuthenticationProvider(authenticator, authorities);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;ldap-authentication-provider
    user-dn-pattern="uid={0},ou=people"
    group-search-filter="member={0}"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authorities(contextSource: BaseLdapPathContextSource): LdapAuthoritiesPopulator {
    val groupSearchBase = ""
    val authorities = DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase)
    authorities.setGroupSearchFilter("member={0}")
    return authorities
}

@Bean
fun authenticationProvider(authenticator: LdapAuthenticator, authorities: LdapAuthoritiesPopulator): LdapAuthenticationProvider {
    return LdapAuthenticationProvider(authenticator, authorities)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="激活目录"><a class="anchor" href="#激活目录"></a>激活目录</h5>
<div class="paragraph">
<p>Active Directory 支持其自己的非标准身份验证选项,并且正常使用模式与标准 <code>LdapAuthenticationProvider</code> 不太吻合.
通常,身份验证是使用域用户名(格式为 <code>user@domain</code>) 而不是使用 LDAP 可分辨名称来执行的.  为了简化此操作,Spring Security 3.1 具有一个身份验证提供程序,该身份验证提供程序是针对典型的 Active Directory 设置而定制的.</p>
</div>
<div class="paragraph">
<p>配置 <code>ActiveDirectoryLdapAuthenticationProvider</code> 非常简单.  您只需要提供域名和提供服务器地址的 LDAP URL <sup class="footnote">[<a id="_footnoteref_2" class="footnote" href="#_footnotedef_2" title="View footnote.">2</a>]</sup>.  配置示例如下所示:</p>
</div>
<div class="paragraph">
<p>下面是一个示例配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 78. Example Active Directory Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ActiveDirectoryLdapAuthenticationProvider authenticationProvider() {
    return new ActiveDirectoryLdapAuthenticationProvider("example.com", "ldap://company.example.com/");
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="authenticationProvider"
        class="org.springframework.security.ldap.authentication.ad.ActiveDirectoryLdapAuthenticationProvider"&gt;
    &lt;constructor-arg value="example.com" /&gt;
    &lt;constructor-arg value="ldap://company.example.com/" /&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authenticationProvider(): ActiveDirectoryLdapAuthenticationProvider {
    return ActiveDirectoryLdapAuthenticationProvider("example.com", "ldap://company.example.com/")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="session-mgmt"><a class="anchor" href="#session-mgmt"></a>10.11. Session 管理器</h3>
<div class="paragraph">
<p>与 HTTP 会话相关的功能由 <code>SessionManagementFilter</code> 和 <code>SessionAuthenticationStrategy</code> 接口的组合处理,过滤器委托该接口.  典型的用法包括 防止会话固定保护攻击,检测会话超时以及限制已认证用户可以同时打开多少个会话.</p>
</div>
<div class="sect3">
<h4 id="检测超时"><a class="anchor" href="#检测超时"></a>10.11.1. 检测超时</h4>
<div class="paragraph">
<p>您可以配置 Spring Security 来检测无效会话 ID,并将用户重定向到适当的 URL.  这是通过 <code>session-management</code> 元素实现的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
&lt;session-management invalid-session-url="/invalidSession.htm" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意,如果使用此机制来检测会话超时时,在不关闭浏览器的情况下,用户注销然后重新登录,它可能会错误地报告错误.
这是因为在使会话无效时不会清除会话 cookie,即使用户已注销,会话 cookie 也会重新提交.  您可以在注销时显式删除 <code>JSESSIONID</code> cookie,例如通过在注销处理程序中使用以下语法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;logout delete-cookies="JSESSIONID" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不幸的是,不能保证它可以与每个 servlet 容器一起使用,因此您需要在您的环境中对其进行测试</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果您在代理服务器后运行应用程序,则还可以通过配置代理服务器来删除会话 cookie.  例如,使用 Apache HTTPD 的 mod_headers,以下指令会通过在注销请求的响应中将其过期而删除 <code>JSESSIONID</code> cookie (假设应用程序已部署在 <code>/tutorial</code> 路径下) :
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;LocationMatch "/tutorial/logout"&gt;
Header always set Set-Cookie "JSESSIONID=;Path=/tutorial;Expires=Thu, 01 Jan 1970 00:00:00 GMT"
&lt;/LocationMatch&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ns-concurrent-sessions"><a class="anchor" href="#ns-concurrent-sessions"></a>10.11.2. 并发会话控制</h4>
<div class="paragraph">
<p>如果您希望限制单个用户登录到您的应用程序的能力,Spring Security 可以通过以下简单的补充来支持此功能.  首先,您需要将以下监听器添加到您的 <code>web.xml</code> 文件中,以使 Spring Security 更新有关会话生命周期事件的信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;listener&gt;
&lt;listener-class&gt;
    org.springframework.security.web.session.HttpSessionEventPublisher
&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后将以下行添加到您的应用程序上下文:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
&lt;session-management&gt;
    &lt;concurrency-control max-sessions="1" /&gt;
&lt;/session-management&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将防止用户多次登录-第二次登录将使第一次登录无效.  通常,您希望避免再次登录,在这种情况下,您可以使用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
&lt;session-management&gt;
    &lt;concurrency-control max-sessions="1" error-if-maximum-exceeded="true" /&gt;
&lt;/session-management&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后,第二次登录将被拒绝.  "拒绝" 是指如果使用基于表单的登录名,则会将用户发送到 <code>authentication-failure-url</code>.
如果第二次身份验证是通过另一个非交互机制 (例如 <code>remember-me</code>) 进行的,则 "unauthorized"  (401) 错误将发送给客户端.  相反,如果要使用错误页面,则可以将属性 <code>session-authentication-error-url</code> 添加到 <code>session-management</code> 元素中.</p>
</div>
<div class="paragraph">
<p>如果使用定制的身份验证过滤器进行基于表单的登录,则必须显式配置并发会话控制支持.  更多细节可以在 <a href="#session-mgmt">会话管理一章</a> 中找到.</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-session-fixation"><a class="anchor" href="#ns-session-fixation"></a>10.11.3. 会话固定攻击防护</h4>
<div class="paragraph">
<p><a href="https://en.wikipedia.org/wiki/Session_fixation">会话固定</a> 攻击是一种潜在的风险,恶意攻击者有可能通过访问站点来创建会话,然后诱使另一个用户以相同的会话登录 (例如: 通过向他们发送包含会话标识符作为参数的链接) .
Spring Security 通过创建新会话或在用户登录时更改会话ID来自动防止这种情况的发生. 如果您不需要此保护,或者与其他要求冲突,则可以使用会话固定来控制行为 <code>&lt;session-management&gt;</code> 上的 <code>session-fixation-protection</code> 属性,它具有四个选项</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>none</code> - 什么都不要做 原始会话将保留.</p>
</li>
<li>
<p><code>newSession</code> - 创建一个新的 "干净" 会话,而不复制现有会话数据 (仍将复制与Spring Security相关的属性) .</p>
</li>
<li>
<p><code>migrateSession</code> - 创建一个新会话,并将所有现有会话属性复制到新会话.  这是Servlet 3.0或更早版本的容器中的默认值.</p>
</li>
<li>
<p><code>changeSessionId</code> - 不要创建新的会话.  而是使用 Servlet 容器提供的(<code>HttpServletRequest#changeSessionId()</code>) 会话固定保护 .
此选项仅在 Servlet 3.1 (Java EE 7) 和更高版本的容器中可用.  在较旧的容器中指定它会导致异常.  这是 Servlet 3.1 和更高版本容器中的默认设置.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>发生会话固定保护时,它将导致 <code>SessionFixationProtectionEvent</code> 在应用程序上下文中发布.  如果使用 <code>changeSessionId</code>,则此保护还将导致任何 <code>javax.servlet.http.HttpSessionIdListener</code> 收到通知,因此,如果您的代码监听这两个事件,请务必谨慎.  有关其他信息,请参见<a href="#session-mgmt">会话管理</a>一章.</p>
</div>
</div>
<div class="sect3">
<h4 id="sessionmanagementfilter"><a class="anchor" href="#sessionmanagementfilter"></a>10.11.4. SessionManagementFilter</h4>
<div class="paragraph">
<p><code>SessionManagementFilter</code> 根据 <code>SecurityContextHolder</code> 的当前内容检查 <code>SecurityContextRepository</code> 的内容,以确定用户是否已在当前请求期间进行了身份验证,通常是通过非交互式身份验证机制进行的,例如预身份验证或 remember-me <sup class="footnote">[<a id="_footnoteref_3" class="footnote" href="#_footnotedef_3" title="View footnote.">3</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>如果用户当前未通过身份验证,则过滤器将检查是否已请求了无效的会话ID (例如,由于超时) ,并且将调用已配置的 <code>InvalidSessionStrategy</code> (如果已设置) .
最常见的行为就是重定向到固定 URL,并将其封装在标准实现 <code>SimpleRedirectInvalidSessionStrategy</code> 中.  <a href="#session-mgmt">如前所述</a>,在通过命名空间配置无效的会话 URL 时,也会使用后者.</p>
</div>
</div>
<div class="sect3">
<h4 id="sessionauthenticationstrategy"><a class="anchor" href="#sessionauthenticationstrategy"></a>10.11.5. SessionAuthenticationStrategy</h4>
<div class="paragraph">
<p>由于 <code>SessionManagementFilter</code> 和 <code>AbstractAuthenticationProcessingFilter</code> 都使用 <code>SessionAuthenticationStrategy</code>,因此,例如,如果使用自定义的表单登录类,则需要将其注入到这两个类中.  在这种情况下,将命名空间和自定义 bean 结合起来的典型配置如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;
&lt;session-management session-authentication-strategy-ref="sas"/&gt;
&lt;/http&gt;

&lt;beans:bean id="myAuthFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
    &lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
    ...
&lt;/beans:bean&gt;

&lt;beans:bean id="sas" class=
"org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意,如果您在实现 <code>HttpSessionBindingListener</code> 的会话中存储 bean (包括 Spring 会话范围的 bean) ,则使用默认的 <code>SessionFixationProtectionStrategy</code> 可能会导致问题.  有关更多信息,请参见 Javadoc.</p>
</div>
</div>
<div class="sect3">
<h4 id="concurrent-sessions"><a class="anchor" href="#concurrent-sessions"></a>10.11.6. 并发控制</h4>
<div class="paragraph">
<p>Spring Security 可以防止主体同时向同一应用程序进行身份验证超过指定次数.  许多 ISV 都利用此功能来实施许可,而网络管理员喜欢此功能,因为它有助于防止人们共享登录名.  例如,您可以阻止用户 "蝙蝠侠" 从两个不同的会话登录到 Web 应用程序.
您可以使他们的先前登录到期,也可以在他们再次尝试登录时报告错误,从而阻止第二次登录.  请注意,如果您使用第二种方法,则未明确注销的用户 (例如,刚刚关闭浏览器的用户) 将无法再次登录,直到他们的原始会话期满为止.</p>
</div>
<div class="paragraph">
<p>命名空间支持并发控制,因此,请查阅前面的命名空间一章以获取最简单的配置.  有时您需要自定义内容.</p>
</div>
<div class="paragraph">
<p>该实现使用 <code>SessionAuthenticationStrategy</code> 的专用版本,称为 <code>ConcurrentSessionControlAuthenticationStrategy</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以前,并发身份验证检查是由 <code>ProviderManager</code> 进行的,可以通过 <code>ConcurrentSessionController</code> 进行注入.  后者将检查用户是否试图超过允许的会话数.
但是,这种方法要求预先创建 HTTP 会话,这是不希望的.  在 Spring Security 3 中,首先通过 <code>AuthenticationManager</code> 对用户进行身份验证,一旦成功对用户进行身份验证,就会创建一个会话,并检查是否允许他们打开另一个会话.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要使用并发会话支持,您需要在 <code>web.xml</code> 中添加以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;listener&gt;
    &lt;listener-class&gt;
    org.springframework.security.web.session.HttpSessionEventPublisher
    &lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>另外,您需要将 <code>ConcurrentSessionFilter</code> 添加到 <code>FilterChainProxy</code> 中.  <code>ConcurrentSessionFilter</code> 需要两个构造函数参数: <code>sessionRegistry</code> (通常指向 <code>SessionRegistryImpl</code> 的一个实例) 和 <code>sessionInformationExpiredStrategy</code>,用于定义会话过期时要应用的策略.
使用命名空间创建 <code>FilterChainProxy</code> 和其他默认 Bean 的配置如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="CONCURRENT_SESSION_FILTER" ref="concurrencyFilter" /&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myAuthFilter" /&gt;

&lt;session-management session-authentication-strategy-ref="sas"/&gt;
&lt;/http&gt;

&lt;beans:bean id="redirectSessionInformationExpiredStrategy"
class="org.springframework.security.web.session.SimpleRedirectSessionInformationExpiredStrategy"&gt;
&lt;beans:constructor-arg name="invalidSessionUrl" value="/session-expired.htm" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="concurrencyFilter"
class="org.springframework.security.web.session.ConcurrentSessionFilter"&gt;
&lt;beans:constructor-arg name="sessionRegistry" ref="sessionRegistry" /&gt;
&lt;beans:constructor-arg name="sessionInformationExpiredStrategy" ref="redirectSessionInformationExpiredStrategy" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="myAuthFilter" class=
"org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter"&gt;
&lt;beans:property name="sessionAuthenticationStrategy" ref="sas" /&gt;
&lt;beans:property name="authenticationManager" ref="authenticationManager" /&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="sas" class="org.springframework.security.web.authentication.session.CompositeSessionAuthenticationStrategy"&gt;
&lt;beans:constructor-arg&gt;
    &lt;beans:list&gt;
    &lt;beans:bean class="org.springframework.security.web.authentication.session.ConcurrentSessionControlAuthenticationStrategy"&gt;
        &lt;beans:constructor-arg ref="sessionRegistry"/&gt;
        &lt;beans:property name="maximumSessions" value="1" /&gt;
        &lt;beans:property name="exceptionIfMaximumExceeded" value="true" /&gt;
    &lt;/beans:bean&gt;
    &lt;beans:bean class="org.springframework.security.web.authentication.session.SessionFixationProtectionStrategy"&gt;
    &lt;/beans:bean&gt;
    &lt;beans:bean class="org.springframework.security.web.authentication.session.RegisterSessionAuthenticationStrategy"&gt;
        &lt;beans:constructor-arg ref="sessionRegistry"/&gt;
    &lt;/beans:bean&gt;
    &lt;/beans:list&gt;
&lt;/beans:constructor-arg&gt;
&lt;/beans:bean&gt;

&lt;beans:bean id="sessionRegistry"
    class="org.springframework.security.core.session.SessionRegistryImpl" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>将监听器添加到 <code>web.xml</code> 中后,每次 <code>HttpSession</code> 开始或终止时,都会将 <code>ApplicationEvent</code> 发布到Spring <code>ApplicationContext</code>.
这很关键,因为它允许在会话结束时通知 <code>SessionRegistryImpl</code>.  如果没有它,即使用户退出另一个会话或超时,一旦超出会话允许量,用户将永远无法再次登录.</p>
</div>
<div class="sect4">
<h5 id="list-authenticated-principals"><a class="anchor" href="#list-authenticated-principals"></a>查询 SessionRegistry 中当前经过身份验证的用户及其会话</h5>
<div class="paragraph">
<p>通过命名空间或使用普通 bean 设置并发控制具有有益的副作用,即为您提供对 <code>SessionRegistry</code> 的引用,您可以在应用程序中直接使用它,因此即使您不想限制它的数量.  用户可能拥有的会话,无论如何都值得建立基础架构.
您可以将 <code>maximumSession</code> 属性设置为 <code>-1</code>,以允许无限制的会话.  如果您使用的是命名空间,则可以使用 <code>session-registry-alias</code> 属性为内部创建的 <code>SessionRegistry</code> 设置别名,并提供一个可以注入到您自己的 bean 中的参考.</p>
</div>
<div class="paragraph">
<p><code>getAllPrincipals()</code> 方法为您提供了当前经过身份验证的用户的列表.  您可以通过调用 <code>getAllSessions(ObjectPrincipal,boolean includeExpiredSessions)</code> 方法列出用户的会话,该方法返回 <code>SessionInformation</code> 对象的列表.
您还可以通过在 <code>SessionInformation</code> 实例上调用 <code>expireNow()</code> 来使用户会话失效.  当用户返回到应用程序时,将阻止他们继续操作.  例如,您可能会发现这些方法在管理应用程序中很有用.  看看 Javadoc 了解更多信息.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-rememberme"><a class="anchor" href="#servlet-rememberme"></a>10.12. Remember-Me 认证</h3>
<div class="sect3">
<h4 id="remember-me-overview"><a class="anchor" href="#remember-me-overview"></a>10.12.1. 概述</h4>
<div class="paragraph">
<p>Remember-me (记住我)或 persistent-login (持久登录)身份验证是指网站能够记住一个主体的身份之间的会话. 通常,这是通过向浏览器发送一个 cookie 来实现的,该 cookie 在以后的会话中被检测到并导致自动登录. Spring Security 提供了进行这些操作所需的钩子,并具有两个具体的 Remember-me 实现.
一种使用散列来保留基于 cookie 的令牌的安全性,另一种使用数据库或其他持久性存储机制来存储生成的令牌.</p>
</div>
<div class="paragraph">
<p>请注意,这两种实现都需要 <code>UserDetailsService</code>.  如果您使用的身份验证提供程序不使用 <code>UserDetailsService</code> (例如 LDAP 提供程序) ,那么它将不起作用,除非您在应用程序上下文中还具有 <code>UserDetailsService</code> Bean.</p>
</div>
</div>
<div class="sect3">
<h4 id="remember-me-hash-token"><a class="anchor" href="#remember-me-hash-token"></a>10.12.2. 简单的基于哈希的令牌方法</h4>
<div class="paragraph">
<p>这种方法使用哈希来实现有用的 "记住我" 策略.  本质上,在成功进行交互式身份验证后,会将 cookie 发送到浏览器,该 cookie 的组成如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">base64(username + ":" + expirationTime + ":" +
md5Hex(username + ":" + expirationTime + ":" password + ":" + key))

username:          对UserDetailsService而言是可识别的
password:          与检索到的UserDetails中的匹配
expirationTime:    "记住我" 令牌过期的日期和时间,以毫秒为单位
key:               防止修改 "记住我" 令牌的私钥</code></pre>
</div>
</div>
<div class="paragraph">
<p>因此,"记住我" 令牌仅在指定的期限内有效,并且前提是用户名,密码和密钥不变.  值得注意的是,这存在潜在的安全问题,因为可从任何用户代理使用获取到的 "记住我" 令牌,直到令牌到期为止.
这与摘要身份验证相同.  如果有人获取到了令牌,则他们可以轻松更改密码,并立即注销所有的 remember-me 标记. 如果需要更显著的安全性,你应该使用在下一节中描述的方法.  另外,根本不应该使用 "记住我" 服务.</p>
</div>
<div class="paragraph">
<p>如果您熟悉 <a href="#ns-config">命名空间配置</a>一章中讨论的主题,则只需添加 <code>&lt;remember-me&gt;</code> 元素即可启用 "记住我" 身份验证:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
&lt;remember-me key="myAppKey"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常将自动选择 <code>UserDetailsService</code>.  如果您的应用程序上下文中有多个,则需要指定与 <code>user-service-ref</code> 属性一起使用的属性,其中值是 <code>UserDetailsService</code> bean的名称.</p>
</div>
</div>
<div class="sect3">
<h4 id="remember-me-persistent-token"><a class="anchor" href="#remember-me-persistent-token"></a>10.12.3. 持久令牌方法</h4>
<div class="paragraph">
<p>这种方法是基于 <a href="http://jaspan.com/improved_persistent_login_cookie_best_practice">http://jaspan.com/improved_persistent_login_cookie_best_practice</a> 文章进行的一些细微修改 <sup class="footnote">[<a id="_footnoteref_4" class="footnote" href="#_footnotedef_4" title="View footnote.">4</a>]</sup>.  要将这种方法与命名空间配置一起使用,您将提供一个数据源参考:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
&lt;remember-me data-source-ref="someDataSource"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>该数据库应包含一个使用以下SQL (或等效SQL) 创建的 <code>persistent_logins</code> 表:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ddl" data-lang="ddl">create table persistent_logins (username varchar(64) not null,
                                series varchar(64) primary key,
                                token varchar(64) not null,
                                last_used timestamp not null)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="remember-me-impls"><a class="anchor" href="#remember-me-impls"></a>10.12.4. Remember-Me 接口和实现</h4>
<div class="paragraph">
<p>记住我与 <code>UsernamePasswordAuthenticationFilter</code> 一起使用,并通过 <code>AbstractAuthenticationProcessingFilter</code> 超类中的钩子实现.  它还在 <code>BasicAuthenticationFilter</code> 中使用.  钩子将在适当的时间调用具体的 <code>RememberMeServices</code>.  该界面如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Authentication autoLogin(HttpServletRequest request, HttpServletResponse response);

void loginFail(HttpServletRequest request, HttpServletResponse response);

void loginSuccess(HttpServletRequest request, HttpServletResponse response,
    Authentication successfulAuthentication);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅 Javadoc,以获取有关方法用途的完整讨论,请注意,在此阶段,<code>AbstractAuthenticationProcessingFilter</code> 仅调用 <code>loginFail()</code> 和 <code>loginSuccess()</code> 方法.  每当 <code>SecurityContextHolder</code> 不包含 <code>Authentication</code> 时,<code>RememberMeAuthenticationFilter</code> 都会调用 <code>autoLogin()</code> 方法.
因此,此接口提供了基本的 remember-me 的实现与认证相关的事件的充分通知,和代表的执行情况时,一个候选Web请求可能包含一个 cookie 并希望被记住. 这种设计允许任何数目的 remember-me 实现策略. 上面我们已经看到,Spring Security 提供了两种实现.  我们将依次介绍这些内容.</p>
</div>
<div class="sect4">
<h5 id="tokenbasedremembermeservices"><a class="anchor" href="#tokenbasedremembermeservices"></a>TokenBasedRememberMeServices</h5>
<div class="paragraph">
<p>此实现支持中<a href="#remember-me-hash-token">第10.13.2节 "基于简单哈希的令牌方法"</a>描述的更简单方法.
<code>TokenBasedRememberMeServices</code> 生成一个 <code>RememberMeAuthenticationToken</code>,由 <code>RememberMeAuthenticationProvider</code> 处理.  在此身份验证提供程序和 <code>TokenBasedRememberMeServices</code> 之间共享密钥.  另外,<code>TokenBasedRememberMeServices</code> 需要一个 <code>UserDetailsService</code>,从中可以检索用户名和密码以进行签名比较,并生成 <code>RememberMeAuthenticationToken</code> 以包含正确的 <code>GrantedAuthority</code>.
应用程序应提供某种注销命令,如果用户请求,该命令会使 cookie 无效.  <code>TokenBasedRememberMeServices</code> 还实现了 Spring Security 的 <code>LogoutHandler</code> 接口,因此可以与 <code>LogoutFilter</code> 一起使用以自动清除 cookie.</p>
</div>
<div class="paragraph">
<p>在应用程序上下文中启用 "记住我" 服务所需的bean如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="rememberMeFilter" class=
"org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter"&gt;
&lt;property name="rememberMeServices" ref="rememberMeServices"/&gt;
&lt;property name="authenticationManager" ref="theAuthenticationManager" /&gt;
&lt;/bean&gt;

&lt;bean id="rememberMeServices" class=
"org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices"&gt;
&lt;property name="userDetailsService" ref="myUserDetailsService"/&gt;
&lt;property name="key" value="springRocks"/&gt;
&lt;/bean&gt;

&lt;bean id="rememberMeAuthenticationProvider" class=
"org.springframework.security.authentication.RememberMeAuthenticationProvider"&gt;
&lt;property name="key" value="springRocks"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>不要忘记将 <code>RememberMeServices</code> 实现添加到 <code>UsernamePasswordAuthenticationFilter.setRememberMeServices()</code> 属性中,将 <code>RememberMeAuthenticationProvider</code> 包含在 <code>AuthenticationManager.setProviders()</code> 列表中,并将 <code>RememberMeAuthenticationFilter</code> 添加到 <code>FilterChainProxy</code> 中 (通常紧接在 <code>UsernamePasswordAuthenticationFilter</code> 之后) .</p>
</div>
</div>
<div class="sect4">
<h5 id="persistenttokenbasedremembermeservices"><a class="anchor" href="#persistenttokenbasedremembermeservices"></a>PersistentTokenBasedRememberMeServices</h5>
<div class="paragraph">
<p>可以使用与 <code>TokenBasedRememberMeServices</code> 相同的方式使用此类,但还需要使用 <code>PersistentTokenRepository</code> 配置该类来存储令牌.  有两种标准实现.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>InMemoryTokenRepositoryImpl</code> 仅用于测试.</p>
</li>
<li>
<p><code>JdbcTokenRepositoryImpl</code> 将令牌存储在数据库中.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>上面的<a href="#remember-me-persistent-token">第10.13.3节 "持久令牌方法"</a>描述了数据库模式. .</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-openid"><a class="anchor" href="#servlet-openid"></a>10.13. OpenID 支持</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
已弃用 OpenID 1.0 和 2.0 协议， 并鼓励用户迁移到 Spring-security-oauth2 支持的 OpenID Connect.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>命名空间支持 <a href="https://openid.net/">OpenID</a>  登录,而不是普通的基于表单的登录,或者除了常规的基于表单的登录之外,还支持 OpenID 登录,只需简单的更改即可:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;intercept-url pattern="/**" access="ROLE_USER" /&gt;
&lt;openid-login /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后,您应该向 OpenID 提供程序注册自己(例如 myopenid.com) ,并将用户信息添加到内存中的 <code>&lt;user-service&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;user name="https://jimi.hendrix.myopenid.com/" authorities="ROLE_USER" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您应该可以使用 <code>myopenid.com</code> 网站登录进行身份验证.  通过在 <code>openid-login</code> 元素上设置 <code>user-service-ref</code> 属性,还可以选择特定的 <code>UserDetailsService</code> bean 来使用 OpenID.
请注意,我们已从上述用户配置中省略了 <code>password</code> 属性,因为这组用户数据仅用于加载用户的权限.  系统会在内部生成一个随机密码,以防止您意外地将此用户数据用作配置中其他位置的身份验证源.</p>
</div>
<div class="sect3">
<h4 id="属性交换"><a class="anchor" href="#属性交换"></a>10.13.1. 属性交换</h4>
<div class="paragraph">
<p>支持 OpenID <a href="https://openid.net/specs/openid-attribute-exchange-1_0.html">属性交换</a>..  例如,以下配置将尝试从OpenID 提供程序中检索电子邮件和全名,以供应用程序使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;openid-login&gt;
&lt;attribute-exchange&gt;
    &lt;openid-attribute name="email" type="https://axschema.org/contact/email" required="true"/&gt;
    &lt;openid-attribute name="name" type="https://axschema.org/namePerson"/&gt;
&lt;/attribute-exchange&gt;
&lt;/openid-login&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个 OpenID 属性的 "type" 是一个URI,有一种特定的模式来确定,这个例子中是 <a href="https://axschema.org/">https://axschema.org/</a> . 如果属性必须在成功认证后接收,可以设置 <code>required</code> 属性. 确切的模式和属性的支持将取决于你的 OpenID 提供商. 该属性值返回作为认证过程的一部分,随后可以使用下面的代码访问:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OpenIDAuthenticationToken token =
    (OpenIDAuthenticationToken)SecurityContextHolder.getContext().getAuthentication();
List&lt;OpenIDAttribute&gt; attributes = token.getAttributes();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以从 <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> 获取 <code>OpenIDAuthenticationToken</code>.
<code>OpenIDAttribute</code> 包含了属性类型和接收到的值(在有多个属性值的情况下包含多个值)
你可以提供多个 <code>attribute-exchange</code> 元素. 在每个上面使用 <code>identifier-matcher</code> 属性. 它包含一个正则表达式,会匹配由用户提供的 OpenID 标识符. 查看代码库的 OpenID 示例应用的一个示例配置. 对 Google, Yahoo 和 MyOpenID 提供了不同的属性列表.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="anonymous"><a class="anchor" href="#anonymous"></a>10.14. 匿名认证</h3>
<div class="sect3">
<h4 id="anonymous-overview"><a class="anchor" href="#anonymous-overview"></a>10.14.1. 概述</h4>
<div class="paragraph">
<p>通常,采用 "默认拒绝" 的做法被认为是一种良好的安全做法,您可以在其中明确指定允许的内容,并禁止其他所有内容. 定义未经身份验证的用户可以访问的内容的情况与此类似,尤其是对于 Web 应用程序.  许多站点要求用户必须通过身份验证才能使用少数几个 URL(例如,主页和登录页面) .  在这种情况下,最简单的是为这些特定的 URL 定义访问配置属性,而不是为每个受保护的资源定义访问配置属性.
换句话说,有时很高兴地说默认情况下需要 <code>ROLE_SOMETHING</code>,并且只允许该规则的某些例外,例如应用程序的登录,注销和主页. 您也可以从过滤器链中完全忽略这些页面,从而绕过访问控制检查,但是由于其他原因,这可能是不可取的,特别是如果这些页面对于经过身份验证的用户而言行为不同.</p>
</div>
<div class="paragraph">
<p>这就是我们所说的匿名身份验证.  请注意,"匿名身份验证" 的用户和未经身份验证的用户之间没有真正的概念差异.  Spring Security 的匿名身份验证只是为您提供了一种更便捷的方式来配置访问控制属性.
即使在 <code>SecurityContextHolder</code> 中实际上存在一个匿名身份验证对象,对诸如 <code>getCallerPrincipal</code> 之类的 Servlet API 调用的调用仍将返回 <code>null</code>.</p>
</div>
<div class="paragraph">
<p>在其他情况下,匿名身份验证很有用,例如当审核拦截器查询 <code>SecurityContextHolder</code> 以确定哪个主体负责给定操作时.  如果类知道 <code>SecurityContextHolder</code> 始终包含 <code>Authentication</code> 对象并且从不为 <code>null</code>,则可以更强大地编写类.</p>
</div>
</div>
<div class="sect3">
<h4 id="anonymous-config"><a class="anchor" href="#anonymous-config"></a>10.14.2. 配置</h4>
<div class="paragraph">
<p>使用HTTP配置 Spring Security 3.0 时会自动提供匿名身份验证支持,并且可以使用 <code>&lt;anonymous&gt;</code> 元素自定义(或禁用) 匿名身份验证支持.  除非您使用的是传统的 Bean 配置,否则无需配置此处描述的 Bean.</p>
</div>
<div class="paragraph">
<p>三个类共同提供了匿名身份验证功能.
<code>AnonymousAuthenticationToken</code> 是 <code>Authentication</code> 的实现,并存储适用于匿名主体的 <code>GrantedAuthority</code>.  有一个对应的 <code>AnonymousAuthenticationProvider</code>,它已链接到 <code>ProviderManager</code> 中,因此可以接受 <code>AnonymousAuthenticationToken</code>.
最后,有一个 <code>AnonymousAuthenticationFilter</code>,它在常规身份验证机制之后链接,如果那里没有现有的身份验证,则会自动将 <code>AnonymousAuthenticationToken</code> 添加到 <code>SecurityContextHolder</code>.  过滤器和身份验证提供程序的定义如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="anonymousAuthFilter"
    class="org.springframework.security.web.authentication.AnonymousAuthenticationFilter"&gt;
&lt;property name="key" value="foobar"/&gt;
&lt;property name="userAttribute" value="anonymousUser,ROLE_ANONYMOUS"/&gt;
&lt;/bean&gt;

&lt;bean id="anonymousAuthenticationProvider"
    class="org.springframework.security.authentication.AnonymousAuthenticationProvider"&gt;
&lt;property name="key" value="foobar"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>密钥在过滤器和身份验证提供程序之间共享,因此前者创建的令牌将被后者[6]接受.</p>
</div>
<div class="paragraph">
<p><code>userAttribute</code> 以 <code>usernameInTheAuthenticationToken</code>, <code>usernameInTheAuthenticationToken,grantedAuthority[,grantedAuthority]</code> 的形式表示.  这与 <code>InMemoryDaoImpl</code> 的 <code>userMap</code> 属性的等号后使用的语法相同. <sup class="footnote">[<a id="_footnoteref_5" class="footnote" href="#_footnotedef_5" title="View footnote.">5</a>]</sup>.</p>
</div>
<div class="paragraph">
<p>如前所述,匿名身份验证的好处是所有URI模式都可以应用安全性.
例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="filterSecurityInterceptor"
    class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="httpRequestAccessDecisionManager"/&gt;
&lt;property name="securityMetadata"&gt;
    &lt;security:filter-security-metadata-source&gt;
    &lt;security:intercept-url pattern='/index.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
    &lt;security:intercept-url pattern='/hello.htm' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
    &lt;security:intercept-url pattern='/logoff.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
    &lt;security:intercept-url pattern='/login.jsp' access='ROLE_ANONYMOUS,ROLE_USER'/&gt;
    &lt;security:intercept-url pattern='/**' access='ROLE_USER'/&gt;
    &lt;/security:filter-security-metadata-source&gt;" +
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="anonymous-auth-trust-resolver"><a class="anchor" href="#anonymous-auth-trust-resolver"></a>10.14.3. AuthenticationTrustResolver</h4>
<div class="paragraph">
<p>完善匿名身份验证讨论的是 <code>AuthenticationTrustResolver</code> 接口及其相应的 <code>AuthenticationTrustResolverImpl</code> 实现.  该接口提供了 <code>isAnonymous(Authentication)</code> 方法,该方法允许感兴趣的类将这种特殊类型的身份验证状态考虑在内.  <code>ExceptionTranslationFilter</code> 在处理 <code>AccessDeniedException</code> 时使用此接口.  如果抛出 <code>AccessDeniedException</code> 且身份验证为匿名类型,则过滤器将代替启动 <code>AuthenticationEntryPoint</code>,而不引发 403 (禁止) 响应,以便主体可以正确地进行身份验证.
这是必要的区别,否则主体将始终被视为 "已认证",并且永远不会获得通过表单,基本,摘要或某些其他常规认证机制登录的机会.</p>
</div>
<div class="paragraph">
<p>您经常会在上述拦截器配置中看到 <code>ROLE_ANONYMOUS</code> 属性被 <code>IS_AUTHENTICATED_ANONYMOUSLY</code> 替换,这在定义访问控制时实际上是相同的.  这是使用 <code>AuthenticatedVoter</code> 的示例,我们将在<a href="#authz-authenticated-voter">授权章节</a>中看到.  它使用 <code>AuthenticationTrustResolver</code> 来处理此特定配置属性,并将访问权限授予匿名用户.
<code>AuthenticatedVoter</code> 方法更强大,因为它使您可以区分匿名用户,记住我的用户和经过完全认证的用户.  如果您不需要此功能,则可以坚持使用 <code>ROLE_ANONYMOUS</code>,它将由 Spring Security 的标准 <code>RoleVoter</code> 处理.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-preauth"><a class="anchor" href="#servlet-preauth"></a>10.15. Pre-Authentication 场景</h3>
<div class="paragraph">
<p>在某些情况下,您想使用 Spring Security 进行授权,但是在访问该应用程序之前,某些外部系统已经对该用户进行了可靠的身份验证.  我们将这些情况称为 "预身份验证" 方案.  示例包括 X.509,Siteminder 和运行应用程序的 Java EE 容器进行的身份验证.  使用预身份验证时,Spring Security 必须</p>
</div>
<div class="ulist">
<ul>
<li>
<p>识别用户的请求</p>
</li>
<li>
<p>获取用户权限.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>详细信息将取决于外部身份验证机制.  如果是 X.509,则可以通过其证书信息来标识用户; 如果是 Siteminder,则可以通过HTTP请求头来标识用户.  如果依赖于容器身份验证,将通过在传入的 HTTP 请求上调用 <code>getUserPrincipal()</code> 方法来标识用户.
在某些情况下,外部机制可能会为用户提供角色/权限信息,但在其他情况下,必须从单独的来源 (如 <code>UserDetailsService</code> ) 获得权限.</p>
</div>
<div class="sect3">
<h4 id="pre-authentication-框架类"><a class="anchor" href="#pre-authentication-框架类"></a>10.15.1. Pre-Authentication 框架类</h4>
<div class="paragraph">
<p>因为大多数 pre-authentication 机制遵循相同的模式,Spring Security 一组类,提供一个内部框架实现 pre-authenticated 身份验证提供者.
这消除了重复,并允许以结构化的方式添加新的实现,而不必从头开始编写所有内容.  如果您想使用  <a href="#servlet-x509">X.509 身份验证</a> 之类的东西,则无需了解这些类,因为它已经具有一个命名空间配置选项,该选项更易于使用和入门.
如果您需要使用显式的 bean 配置或计划编写自己的实现,那么对提供的实现如何工作的理解将很有用.  您将在 <code>org.springframework.security.web.authentication.preauth</code> 下找到类.  我们仅在此处提供概述,因此您应该在适当的地方查阅 Javadoc 和源代码.</p>
</div>
<div class="sect4">
<h5 id="abstractpreauthenticatedprocessingfilter"><a class="anchor" href="#abstractpreauthenticatedprocessingfilter"></a>AbstractPreAuthenticatedProcessingFilter</h5>
<div class="paragraph">
<p>此类将检查安全性上下文的当前内容,如果为空,它将尝试从 HTTP 请求中提取用户信息并将其提交给 <code>AuthenticationManager</code>.  子类重写以下方法来获取此信息:</p>
</div>
<div class="exampleblock">
<div class="title">Example 79. Override AbstractPreAuthenticatedProcessingFilter</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected abstract Object getPreAuthenticatedPrincipal(HttpServletRequest request);

protected abstract Object getPreAuthenticatedCredentials(HttpServletRequest request);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">protected abstract fun getPreAuthenticatedPrincipal(request: HttpServletRequest): Any?

protected abstract fun getPreAuthenticatedCredentials(request: HttpServletRequest): Any?</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>调用完这些之后,过滤器将创建一个包含返回数据的 <code>PreAuthenticatedAuthenticationToken</code> 并将其提交进行身份验证.  这里的 "身份验证" 实际上是指进一步处理以加载用户的权限,但是遵循标准的 Spring Security 身份验证体系结构.</p>
</div>
<div class="paragraph">
<p>像其他 Spring Security 身份验证过滤器一样,预身份验证过滤器具有 <code>authenticationDetailsSource</code> 属性,默认情况下,它将创建 <code>WebAuthenticationDetails</code> 对象以在 <code>Authentication</code> 对象的 <code>details</code> 属性中存储其他信息,例如会话标识符和原始IP地址.
如果可以从预身份验证机制获取用户角色信息,则数据也将存储在此属性中,其详细信息实现了 <code>GrantedAuthoritiesContainer</code> 接口.  这使身份验证提供程序可以读取从外部分配给用户的权限.  接下来,我们将看一个具体示例.</p>
</div>
<div class="sect5">
<h6 id="j2ee-preauth-details"><a class="anchor" href="#j2ee-preauth-details"></a>基于J2ee的Web预身份验证细节</h6>
<div class="paragraph">
<p>如果过滤器配置了一个 <code>authenticationDetailsSource</code> 这类的一个实例,,则通过为每个 "映射角色" 的预定集合调用 <code>isUserInRole(String role)</code> 方法来获取权限信息.
该类从已配置的 <code>MappableAttributesRetriever</code> 中获取它们.  可能的实现包括在应用程序上下文中对列表进行硬编码,以及从 <code>web.xml</code> 文件中的 <code>&lt;security-role&gt;</code> 信息中读取角色信息.  预认证示例应用程序使用后一种方法.</p>
</div>
<div class="paragraph">
<p>在另一个阶段,使用已配置的 <code>Attributes2GrantedAuthoritiesMapper</code> 将角色 (或属性) 映射到 Spring Security <code>GrantedAuthority</code> 对象.  默认值只是在名称中添加通常的 <code>ROLE_</code> 前缀,但是它使您可以完全控制行为.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="预身份验证提供者"><a class="anchor" href="#预身份验证提供者"></a>预身份验证提供者</h5>
<div class="paragraph">
<p>经过预身份验证的提供程序除了为用户加载 <code>UserDetails</code> 对象外,仅需执行其他操作.  它通过委派给 <code>AuthenticationUserDetailsService</code> 来实现.  后者与标准 <code>UserDetailsService</code> 相似,但采用 <code>Authentication</code> 对象,而不仅仅是用户名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface AuthenticationUserDetailsService {
    UserDetails loadUserDetails(Authentication token) throws UsernameNotFoundException;
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>该接口可能还有其他用途,但是具有预身份验证功能,它允许访问打包在 <code>Authentication</code> 对象中的授权机构,如上一节所述.  <code>PreAuthenticatedGrantedAuthoritiesUserDetailsService</code> 类可以执行此操作.  或者,它可以通过 <code>UserDetailsByNameServiceWrapper</code> 实现委派给标准的 <code>UserDetailsService</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="http403-禁止入口点"><a class="anchor" href="#http403-禁止入口点"></a>Http403 禁止入口点</h5>
<div class="paragraph">
<p><a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a>  它负责启动未经身份验证的用户的身份验证过程 (当他们尝试访问受保护的资源时) ,但是在经过预先身份验证的情况下,这并不适用.
如果您未将预身份验证与其他身份验证机制结合使用,则只能使用此类的实例配置 <code>ExceptionTranslationFilter</code>.  如果 <code>AbstractPreAuthenticatedProcessingFilter</code> 拒绝了用户,从而导致身份验证为空,则将调用此方法.  如果被调用,它将始终返回 403 禁止响应代码.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="具体实现"><a class="anchor" href="#具体实现"></a>10.15.2. 具体实现</h4>
<div class="paragraph">
<p>X.509 身份验证在<a href="#servlet-x509">其单独的章节中</a>介绍.  在这里,我们将介绍一些类,这些类为其他预先认证的场景提供支持.</p>
</div>
<div class="sect4">
<h5 id="请求头身份验证-siteminder"><a class="anchor" href="#请求头身份验证-siteminder"></a>请求头身份验证 (Siteminder)</h5>
<div class="paragraph">
<p>外部认证系统可以通过在 HTTP 请求头来向应用程序提供信息.  一个著名的例子是 Siteminder,它在名为 <code>SM_USER</code> 的 header 中传递用户名.
<code>RequestHeaderAuthenticationFilter</code> 类支持此机制,该类仅从头部中提取用户名.  默认情况下,使用名称 <code>SM_USER</code> 作为标题名称.  有关更多详细信息,请参见Javadoc.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意,当使用这样的系统时,框架完全不执行身份验证检查,并且正确配置外部系统并保护对应用程序的所有访问非常重要.  如果攻击者能够在不检测到原始请求的情况下伪造 header ,则他们可能会选择所需的任何用户名.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="siteminder-示例配置"><a class="anchor" href="#siteminder-示例配置"></a>Siteminder 示例配置</h6>
<div class="paragraph">
<p>一个典型的配置使用这个过滤器看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;security:http&gt;
&lt;!-- Additional http configuration omitted --&gt;
&lt;security:custom-filter position="PRE_AUTH_FILTER" ref="siteminderFilter" /&gt;
&lt;/security:http&gt;

&lt;bean id="siteminderFilter" class="org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter"&gt;
&lt;property name="principalRequestHeader" value="SM_USER"/&gt;
&lt;property name="authenticationManager" ref="authenticationManager" /&gt;
&lt;/bean&gt;

&lt;bean id="preauthAuthProvider" class="org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationProvider"&gt;
&lt;property name="preAuthenticatedUserDetailsService"&gt;
    &lt;bean id="userDetailsServiceWrapper"
        class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt;
    &lt;property name="userDetailsService" ref="userDetailsService"/&gt;
    &lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;

&lt;security:authentication-manager alias="authenticationManager"&gt;
&lt;security:authentication-provider ref="preauthAuthProvider" /&gt;
&lt;/security:authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们认为这里 <a href="#ns-config">security namespace</a> 是用于配置. 还假定您已经添加了一个 <code>UserDetailsService</code> (称为 "userDetailsService" )到您的配置加载用户的角色.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="java-ee-容器认证"><a class="anchor" href="#java-ee-容器认证"></a>Java EE 容器认证</h5>
<div class="paragraph">
<p><code>J2eePreAuthenticatedProcessingFilter</code> 类将从 <code>HttpServletRequest</code> 的 <code>userPrincipal</code> 属性提取用户名.  如上面在<a href="#j2ee-preauth-details">基于 J2ee 的 Web 预身份验证细节</a>部分中所述,此过滤器的使用通常会与 Java EE 角色的使用结合起来.</p>
</div>
<div class="paragraph">
<p>代码库中有一个使用此方法的示例应用程序,因此如果您有兴趣,可以从 github 上获取代码,并查看应用程序上下文文件.  该代码在 <code>samples/xml/preauth</code> 目录中.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-jaas"><a class="anchor" href="#servlet-jaas"></a>10.16. Java Authentication Authorization Service(JAAS,Java验证和授权API)  提供者</h3>
<div class="sect3">
<h4 id="概述"><a class="anchor" href="#概述"></a>10.16.1. 概述</h4>
<div class="paragraph">
<p>Spring Security 提供一个包可以将身份验证请求委托给 Java 身份验证和授权服务(JAAS).这个包是在下面详细讨论.</p>
</div>
</div>
<div class="sect3">
<h4 id="jaas-abstractjaasauthenticationprovider"><a class="anchor" href="#jaas-abstractjaasauthenticationprovider"></a>10.16.2. AbstractJaasAuthenticationProvider</h4>
<div class="paragraph">
<p><code>AbstractJaasAuthenticationProvider</code> 提供了 JAAS <code>AuthenticationProvider</code> 实现的基础.  子类实现必须创建 <code>LoginContext</code> 的方法.  <code>AbstractJaasAuthenticationProvider</code> 具有许多可以注入其中的依赖,下面将对其进行讨论.</p>
</div>
<div class="sect4">
<h5 id="jaas-callbackhandler"><a class="anchor" href="#jaas-callbackhandler"></a>JAAS 回调处理</h5>
<div class="paragraph">
<p>大多数 JAAS <code>LoginModule</code> 都需要某种回调.  这些回调通常用于从用户中获取用户名和密码.</p>
</div>
<div class="paragraph">
<p>在 Spring Security 部署中,Spring Security 负责此用户交互(通过身份验证机制) .  因此,在将身份验证请求委派给 JAAS 时,Spring Security 的身份验证机制将已经完全填充了 <code>Authentication</code> 对象,其中包含 JAAS <code>LoginModule</code> 所需的所有信息.</p>
</div>
<div class="paragraph">
<p>因此,Spring Security 的 JAAS 包提供了两个默认的回调处理程序,<code>JaasNameCallbackHandler</code> 和 <code>JaasPasswordCallbackHandler</code>.  这些回调处理程序中的每一个都实现 <code>JaasAuthenticationCallbackHandler</code>.  在大多数情况下,无需了解内部机制即可简单地使用这些回调处理程序.</p>
</div>
<div class="paragraph">
<p>对于那些需要完全控制回调行为的用户,内部 <code>AbstractJaasAuthenticationProvider</code> 将这些 <code>JaasAuthenticationCallbackHandler</code> 封装为 <code>InternalCallbackHandler</code>.  <code>InternalCallbackHandler</code> 是实际实现JAAS常规 <code>CallbackHandler</code> 接口的类.
每当使用JAAS <code>LoginModule</code> 时,都会向其传递配置了 <code>InternalCallbackHandler</code> 的应用程序上下文列表.  如果 <code>LoginModule</code> 请求针对 <code>InternalCallbackHandler</code> 的回调,则该回调又传递给正在包装的 <code>JaasAuthenticationCallbackHandler</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="jaas-authoritygranter"><a class="anchor" href="#jaas-authoritygranter"></a>JAAS 授权者</h5>
<div class="paragraph">
<p>JAAS 与主体合作.  JAAS 中甚至将 "roles" 表示为主体.  另一方面,Spring Security 与 <code>Authentication</code> 对象一起使用.
每个 <code>Authentication</code> 对象都包含一个主体和多个 <code>GrantedAuthority</code>.  为了促进这些不同概念之间的映射,Spring Security 的 JAAS 软件包包含了 <code>AuthorityGranter</code> 接口.</p>
</div>
<div class="paragraph">
<p><code>AuthorityGranter</code> 负责检查 JAAS 主体并返回一组 <code>String</code>,它们代表分配给主体的授权.  对于每个返回的授权字符串,<code>AbstractJaasAuthenticationProvider</code> 创建一个 <code>JaasGrantedAuthority</code>(它实现 Spring Security 的 <code>GrantedAuthority</code> 接口) ,其中包含授权字符串和已通过 <code>AuthorityGranter</code> 的JAAS主体.
<code>AbstractJaasAuthenticationProvider</code> 通过首先使用 JAAS <code>LoginModule</code> 成功验证用户的凭据,然后访问它返回的 <code>LoginContext</code> 来获取 JAAS 主体.  调用 <code>LoginContext.getSubject().getPrincipals()</code>,并将每个结果主体传递给针对 <code>AbstractJaasAuthenticationProvider.setAuthorityGranters(List)</code> 属性定义的每个 <code>AuthorityGranter</code>.</p>
</div>
<div class="paragraph">
<p>鉴于每个 JAAS 主体都具有特定于实现的含义,因此 Spring Security 不包含任何生产 <code>AuthorityGranter</code>.  但是,单元测试中有一个 <code>TestAuthorityGranter</code>,它演示了一个简单的 <code>AuthorityGranter</code> 实现.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jaas-defaultjaasauthenticationprovider"><a class="anchor" href="#jaas-defaultjaasauthenticationprovider"></a>10.16.3. DefaultJaasAuthenticationProvider</h4>
<div class="paragraph">
<p><code>DefaultJaasAuthenticationProvider</code> 允许将 JAAS 配置对象作为依赖注入到该对象中.  然后,它使用注入的 JAAS 配置创建 <code>LoginContext</code>.  这意味着 <code>DefaultJaasAuthenticationProvider</code> 不像 <code>JaasAuthenticationProvider</code> 那样绑定任何特定的 <code>Configuration</code> 实现.</p>
</div>
<div class="sect4">
<h5 id="jaas-inmemoryconfiguration"><a class="anchor" href="#jaas-inmemoryconfiguration"></a>InMemoryConfiguration</h5>
<div class="paragraph">
<p>为了易于将配置注入 <code>DefaultJaasAuthenticationProvider</code>,提供了一个名为 <code>InMemoryConfiguration</code> 的默认内存实现.
实现构造函数接受 Map,其中每个键代表一个登录配置名称,该值代表一个 <code>AppConfigurationEntry</code> 数组.  <code>InMemoryConfiguration</code> 还支持默认的 <code>AppConfigurationEntry</code> 对象数组,如果在提供的 Map 中找不到映射,则将使用该对象.  有关详细信息,请参阅 <code>InMemoryConfiguration</code> 的类级别 javadoc.</p>
</div>
</div>
<div class="sect4">
<h5 id="jaas-djap-config"><a class="anchor" href="#jaas-djap-config"></a>DefaultJaasAuthenticationProvider 示例配置</h5>
<div class="paragraph">
<p>尽管 <code>InMemoryConfiguration</code> 的 Spring 配置比标准 JAAS 配置文件更冗长,但与 <code>DefaultJaasAuthenticationProvider</code> 结合使用时,它比 <code>JaasAuthenticationProvider</code> 更灵活,因为它不依赖于默认的 <code>Configuration</code> 实现.</p>
</div>
<div class="paragraph">
<p>下面提供了使用 <code>InMemoryConfiguration</code> 的 <code>DefaultJaasAuthenticationProvider</code> 配置示例.  请注意,配置的自定义实现也可以轻松地注入到 <code>DefaultJaasAuthenticationProvider</code> 中.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="jaasAuthProvider"
class="org.springframework.security.authentication.jaas.DefaultJaasAuthenticationProvider"&gt;
&lt;property name="configuration"&gt;
&lt;bean class="org.springframework.security.authentication.jaas.memory.InMemoryConfiguration"&gt;
&lt;constructor-arg&gt;
    &lt;map&gt;
    &lt;!--
    SPRINGSECURITY is the default loginContextName
    for AbstractJaasAuthenticationProvider
    --&gt;
    &lt;entry key="SPRINGSECURITY"&gt;
    &lt;array&gt;
    &lt;bean class="javax.security.auth.login.AppConfigurationEntry"&gt;
        &lt;constructor-arg value="sample.SampleLoginModule" /&gt;
        &lt;constructor-arg&gt;
        &lt;util:constant static-field=
            "javax.security.auth.login.AppConfigurationEntry$LoginModuleControlFlag.REQUIRED"/&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg&gt;
        &lt;map&gt;&lt;/map&gt;
        &lt;/constructor-arg&gt;
        &lt;/bean&gt;
    &lt;/array&gt;
    &lt;/entry&gt;
    &lt;/map&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;
&lt;/property&gt;
&lt;property name="authorityGranters"&gt;
&lt;list&gt;
    &lt;!-- You will need to write your own implementation of AuthorityGranter --&gt;
    &lt;bean class="org.springframework.security.authentication.jaas.TestAuthorityGranter"/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jaas-jaasauthenticationprovider"><a class="anchor" href="#jaas-jaasauthenticationprovider"></a>10.16.4. JaasAuthenticationProvider</h4>
<div class="paragraph">
<p><code>JaasAuthenticationProvider</code> 假定默认配置是 ConfigFile 的实例.  进行此假设是为了尝试更新配置.  然后,<code>JaasAuthenticationProvider</code> 使用默认的 <code>Configuration</code> 创建 <a href="https://download.oracle.com/javase/1.4.2/docs/guide/security/jaas/spec/com/sun/security/auth/login/ConfigFile.html"> ConfigFile</a>.</p>
</div>
<div class="paragraph">
<p>假设我们有一个 JAAS 登录配置文件 <code>/WEB-INF/login.conf</code>,其内容如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-txt" data-lang="txt">JAASTest {
    sample.SampleLoginModule required;
};</code></pre>
</div>
</div>
<div class="paragraph">
<p>像所有 Spring Security bean 一样,<code>JaasAuthenticationProvider</code> 是通过应用程序上下文配置的.  以下定义将对应于上述 JAAS 登录配置文件:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="jaasAuthenticationProvider"
class="org.springframework.security.authentication.jaas.JaasAuthenticationProvider"&gt;
&lt;property name="loginConfig" value="/WEB-INF/login.conf"/&gt;
&lt;property name="loginContextName" value="JAASTest"/&gt;
&lt;property name="callbackHandlers"&gt;
&lt;list&gt;
&lt;bean
    class="org.springframework.security.authentication.jaas.JaasNameCallbackHandler"/&gt;
&lt;bean
    class="org.springframework.security.authentication.jaas.JaasPasswordCallbackHandler"/&gt;
&lt;/list&gt;
&lt;/property&gt;
&lt;property name="authorityGranters"&gt;
    &lt;list&gt;
    &lt;bean class="org.springframework.security.authentication.jaas.TestAuthorityGranter"/&gt;
    &lt;/list&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jaas-apiprovision"><a class="anchor" href="#jaas-apiprovision"></a>10.16.5. Subject 运行</h4>
<div class="paragraph">
<p>如果配置, <code>JaasApiIntegrationFilter</code> 将试图运行 <code>JaasAuthenticationToken</code> 上的 <code>Subject</code>. 这意味着可以使用访问 <code>Subject</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Subject subject = Subject.getSubject(AccessController.getContext());
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这种集成可以很容易地使用<a href="#nsa-http-jaas-api-provision">jaas-api-provision</a>配置属性. 当集成遗留或外部依赖 JAAS Subject API 被填充,这个特性很有用</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-cas"><a class="anchor" href="#servlet-cas"></a>10.17. CAS 认证</h3>
<div class="sect3">
<h4 id="cas-overview"><a class="anchor" href="#cas-overview"></a>10.17.1. 概述</h4>
<div class="paragraph">
<p>JA-SIG 产生了企业范围的单点登录系统,称为 CAS.
与其他计划不同,JA-SIG 的中央身份验证服务是开源的,广泛使用,易于理解,独立于平台并支持代理功能.  Spring Security 完全支持 CAS,并提供了从 Spring Security 的单应用程序部署到由企业范围的 CAS 服务器保护的多应用程序部署的简便迁移路径.</p>
</div>
<div class="paragraph">
<p>您可以在 <a href="https://www.apereo.org" class="bare">www.apereo.org</a>. 上了解有关 CAS 的更多信息.  您还需要访问此站点以下载 CAS Server 文件.</p>
</div>
</div>
<div class="sect3">
<h4 id="cas-how-it-works"><a class="anchor" href="#cas-how-it-works"></a>10.17.2. CAS 如何工作?</h4>
<div class="paragraph">
<p>尽管 CAS 网站包含详细介绍 CAS 体系结构的文档,但我们还是在 Spring Security 的上下文中再次介绍了总体概述.  Spring Security 3.x 支持 CAS3. 在撰写本文时,CAS 服务器的版本为 3.4.</p>
</div>
<div class="paragraph">
<p>您需要在企业中的某个位置设置 CAS 服务器.  CAS 服务器只是一个标准的 WAR 文件,因此设置服务器没有任何困难.  在 WAR 文件中,您将自定义显示给用户的登录页面和其他单一登录页面.</p>
</div>
<div class="paragraph">
<p>部署 CAS 3.4 服务器时,还需要在 CAS 随附的 <code>deployerConfigContext.xml</code> 中指定 <code>AuthenticationHandler</code>. <code>AuthenticationHandler</code> 有一个简单的方法,该方法返回有关给定凭据集是否有效的布尔值.
您的 <code>AuthenticationHandler</code> 实现将需要链接到某种类型的后端身份验证仓库,例如 LDAP 服务器或数据库. CAS 本身提供了许多 <code>AuthenticationHandler</code> 来提供帮助.  在下载和部署服务器 war 文件时,该文件将设置为成功验证输入与用户名匹配的密码的用户的身份,这对于测试非常有用.</p>
</div>
<div class="paragraph">
<p>除了 CAS 服务器本身之外,其他关键参与者当然是整个企业中部署的安全 Web 应用程序.  这些 Web 应用程序称为 "服务".  有三种类型的服务.
那些对服务票证进行身份验证的人,那些可以获取代理票证的人以及那些对代理票证进行身份验证的人.  验证代理票证的方式有所不同,因为必须验证代理列表,并且通常可以重复使用代理票证.</p>
</div>
<div class="sect4">
<h5 id="cas-sequence"><a class="anchor" href="#cas-sequence"></a>Spring Security 和 CAS 交互序列</h5>
<div class="paragraph">
<p>Web 浏览器,CAS 服务器和受 Spring Security 保护的服务之间的基本交互如下:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>网络用户正在浏览服务的公共页面.  不涉及 CAS 或 Spring Security.</p>
</li>
<li>
<p>用户最终请求的页面是安全的,或者它使用的其中一个 bean 是安全的.  Spring Security 的 <code>ExceptionTranslationFilter</code> 将检测 <code>AccessDeniedException</code> 或 <code>AuthenticationException</code>.</p>
</li>
<li>
<p>由于用户的 <code>Authentication</code> 对象 (或缺少该对象) 导致 <code>AuthenticationException</code>,因此 <code>ExceptionTranslationFilter</code> 将调用已配置的 <code>AuthenticationEntryPoint</code>.  如果使用 CAS,则为 <code>CasAuthenticationEntryPoint</code> 类.</p>
</li>
<li>
<p><code>CasAuthenticationEntryPoint</code> 会将用户的浏览器重定向到 CAS 服务器.  它还将指示一个服务参数,它是 Spring Security 服务 (您的应用程序) 的回调 URL.  例如,浏览器重定向到的 URL 可能是 <a href="https://my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas" class="bare">my.company.com/cas/login?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas</a>.</p>
</li>
<li>
<p>用户的浏览器重定向到 CAS 后,将提示他们输入用户名和密码.  如果用户提供的会话 cookie 指示他们先前已登录,则不会提示他们再次登录 (此过程有一个例外,我们将在后面介绍) .  CAS 将使用上面讨论的 <code>PasswordHandler</code> (如果使用 CAS 3.0,则使用 <code>AuthenticationHandler</code>) 来确定用户名和密码是否有效.</p>
</li>
<li>
<p>成功登录后,CAS 会将用户的浏览器重定向回原始服务.  它还将包含一个 <code>ticket</code> 参数,它是代表 "service ticket" 的不透明字符串.  继续前面的示例,浏览器重定向到的 URL 可能是 <a href="https://server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ" class="bare">server3.company.com/webapp/login/cas?ticket=ST-0-ER94xMJmn6pha35CQRoZ</a>.</p>
</li>
<li>
<p>回到服务 Web 应用程序中,<code>CasAuthenticationFilter</code> 始终在监听对 <code>/login/cas</code> 的请求 (这是可配置的,但在本简介中将使用默认值) .  处理过滤器将构造一个代表服务票证的 <code>UsernamePasswordAuthenticationToken</code>.  主体将等于 <code>CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER</code>,而凭据将是服务凭单的不透明值.  然后,此身份验证请求将移交给已配置的 <code>AuthenticationManager</code>.</p>
</li>
<li>
<p><code>AuthenticationManager</code> 实现将是 <code>ProviderManager</code>,后者又由 <code>CasAuthenticationProvider</code> 配置.  <code>CasAuthenticationProvider</code> 仅响应包含特定于 CAS 的主体的 <code>UsernamePasswordAuthenticationToken</code> (如 <code>CasAuthenticationFilter.CAS_STATEFUL_IDENTIFIER</code>) 和 <code>CasAuthenticationToken</code> (稍后讨论) .</p>
</li>
<li>
<p><code>CasAuthenticationProvider</code> 将使用 <code>TicketValidator</code> 实现来验证服务票证.  这通常是 <code>Cas20ServiceTicketValidator</code>,它是CAS客户端库中包含的类之一.  如果应用程序需要验证代理票证,则使用 <code>Cas20ProxyTicketValidator</code>.  <code>TicketValidator</code> 向 CAS 服务器发出 HTTPS 请求,以验证服务票证.
它还可能包含此示例中包含的代理回调 URL: <a href="https://my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&amp;ticket=ST-0-ER94xMJmn6pha35CQRoZ＆pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor" class="bare">my.company.com/cas/proxyValidate?service=https%3A%2F%2Fserver3.company.com%2Fwebapp%2Flogin/cas&amp;ticket=ST-0-ER94xMJmn6pha35CQRoZ＆pgtUrl=https://server3.company.com/webapp/login/cas/proxyreceptor</a>.</p>
</li>
<li>
<p>返回 CAS 服务器,将收到验证请求.  如果提供的服务票证与票证签发到的服务 URL 相匹配,则 CAS 将以 XML 的形式提供肯定的响应,指示用户名.  如果身份验证中涉及任何代理 (如下所述) ,则代理列表也包含在 XML 响应中.</p>
</li>
<li>
<p>[可选]如果对 CAS 验证服务的请求包括代理回调 URL (在 pgtUrl 参数中) ,则 CAS 将在 XML 响应中包括 pgtIou 字符串.  此 <code>pgtIou</code> 表示授予代理的票证 IOU.  然后,CAS 服务器将创建自己的 HTTPS 连接回到 <code>pgtUrl</code>.  这是为了相互认证 CAS 服务器和要求保护的服务 URL.  HTTPS 连接将用于将代理授予票证发送到原始 Web 应用程序.  例如,https://server3.company.com/webapp/login/cas/proxyreceptor?</p>
</li>
<li>
<p><code>Cas20TicketValidator</code> 将解析从 CAS 服务器接收到的 XML.  它将把票证响应返回给 <code>CasAuthenticationProvider</code>,其中包括用户名 (强制性) ,代理列表 (如果涉及) 和授予代理票证的 IOU (如果请求了代理回调) .</p>
</li>
<li>
<p>接下来,<code>CasAuthenticationProvider</code> 将调用已配置的 <code>CasProxyDecider</code>.  <code>CasProxyDecider</code> 指示 <code>TicketResponse</code> 中的代理列表是否对服务可接受.  Spring Security 提供了几种实现: <code>RejectProxyTickets</code>,<code>AcceptAnyCasProxy</code> 和 <code>NamedCasProxyDecider</code>.  这些名称在很大程度上是不言自明的,但 <code>NamedCasProxyDecider</code> 除外,该名称允许提供受信任代理的列表.</p>
</li>
<li>
<p>接下来,<code>CasAuthenticationProvider</code> 将请求 <code>AuthenticationUserDetailsService</code> 来加载应用于断言中包含的用户的 <code>GrantedAuthority</code> 对象.</p>
</li>
<li>
<p>如果没有问题,<code>CasAuthenticationProvider</code> 会构造一个 <code>CasAuthenticationToken</code>,其中包括 <code>TicketResponse</code> 和 <code>GrantedAuthoritys</code> 中包含的详细信息.</p>
</li>
<li>
<p>然后,控制权返回到 <code>CasAuthenticationFilter</code>,它将创建的 <code>CasAuthenticationToken</code> 放在安全上下文中.</p>
</li>
<li>
<p>用户的浏览器被重定向到导致 <code>AuthenticationException</code> 的原始页面 (或自定义目标,具体取决于配置) .</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>很高兴您还在这里！ 现在来看一下它的配置方式</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cas-client"><a class="anchor" href="#cas-client"></a>10.17.3. CAS 客户端配置</h4>
<div class="paragraph">
<p>由于 Spring Security 使 CAS 的 Web 应用程序端变得容易.  假定您已经知道使用 Spring Security 的基础知识,因此下面不再赘述.  我们假设正在使用基于命名空间的配置,并根据需要添加 CAS Bean.  每个部分都基于上一部分.  完整的示例应用程序可以在 Spring Security <a href="#samples">Samples</a> 中找到.</p>
</div>
<div class="sect4">
<h5 id="cas-st"><a class="anchor" href="#cas-st"></a>Service Ticket 认证</h5>
<div class="paragraph">
<p>本节描述如何设置 Spring Security 来认证 Service Ticket.  通常,这是 Web 应用程序所需的全部.  您将需要在应用程序上下文中添加 <code>ServiceProperties</code> bean.  这代表您的 CAS 服务:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="serviceProperties"
    class="org.springframework.security.cas.ServiceProperties"&gt;
&lt;property name="service"
    value="https://localhost:8443/cas-sample/login/cas"/&gt;
&lt;property name="sendRenew" value="false"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>service</code> 必须等于由 <code>CasAuthenticationFilter</code> 监视的 URL.  <code>sendRenew</code> 默认为 <code>false</code>,但如果您的应用程序特别敏感,则应将其设置为 <code>true</code>.  该参数的作用是告诉 CAS 登录服务单次登录是不可接受的.  而是,用户将需要重新输入其用户名和密码才能访问该服务.</p>
</div>
<div class="paragraph">
<p>应该配置以下 bean 以启动 CAS 身份验证过程 (假设您使用的是命名空间配置) :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;security:http entry-point-ref="casEntryPoint"&gt;
...
&lt;security:custom-filter position="CAS_FILTER" ref="casFilter" /&gt;
&lt;/security:http&gt;

&lt;bean id="casFilter"
    class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;/bean&gt;

&lt;bean id="casEntryPoint"
    class="org.springframework.security.cas.web.CasAuthenticationEntryPoint"&gt;
&lt;property name="loginUrl" value="https://localhost:9443/cas/login"/&gt;
&lt;property name="serviceProperties" ref="serviceProperties"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使 CAS 能够运行,<code>ExceptionTranslationFilter</code> 必须将其 <code>authenticationEntryPoint</code> 属性设置为 <code>CasAuthenticationEntryPoint</code> bean.
可以像上面的示例一样使用 <a href="#nsa-http-entry-point-ref">entry-point-ref</a> 轻松完成此操作.  <code>CasAuthenticationEntryPoint</code> 必须引用 <code>ServiceProperties</code> Bean (如上所述) ,该 bean 提供企业 CAS 登录服务器的URL.  这是重定向用户浏览器的地方.</p>
</div>
<div class="paragraph">
<p><code>CasAuthenticationFilter</code> 具有与 <code>UsernamePasswordAuthenticationFilter</code> (用于基于表单的登录名) 非常相似的属性.  您可以使用这些属性来自定义行为,例如验证成功和失败的行为.</p>
</div>
<div class="paragraph">
<p>接下来,您需要添加一个 <code>CasAuthenticationProvider</code> 及其合作者:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;security:authentication-manager alias="authenticationManager"&gt;
&lt;security:authentication-provider ref="casAuthenticationProvider" /&gt;
&lt;/security:authentication-manager&gt;

&lt;bean id="casAuthenticationProvider"
    class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
&lt;property name="authenticationUserDetailsService"&gt;
    &lt;bean class="org.springframework.security.core.userdetails.UserDetailsByNameServiceWrapper"&gt;
    &lt;constructor-arg ref="userService" /&gt;
    &lt;/bean&gt;
&lt;/property&gt;
&lt;property name="serviceProperties" ref="serviceProperties" /&gt;
&lt;property name="ticketValidator"&gt;
    &lt;bean class="org.jasig.cas.client.validation.Cas20ServiceTicketValidator"&gt;
    &lt;constructor-arg index="0" value="https://localhost:9443/cas" /&gt;
    &lt;/bean&gt;
&lt;/property&gt;
&lt;property name="key" value="an_id_for_this_auth_provider_only"/&gt;
&lt;/bean&gt;

&lt;security:user-service id="userService"&gt;
&lt;!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that
NoOpPasswordEncoder should be used.
This is not safe for production, but makes reading
in samples easier.
Normally passwords should be hashed using BCrypt --&gt;
&lt;security:user name="joe" password="{noop}joe" authorities="ROLE_USER" /&gt;
...
&lt;/security:user-service&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦 CAS 验证了用户的授权,<code>CasAuthenticationProvider</code> 就会使用 <code>UserDetailsService</code> 实例为用户加载授权.  我们在这里显示了一个简单的内存设置.  请注意,<code>CasAuthenticationProvider</code> 实际上并未使用密码进行身份验证,但确实使用了权限.</p>
</div>
<div class="paragraph">
<p>如果您参考<a href="#cas-how-it-works">CAS 的工作原理</a>部分,那么所有这些 bean 都是不言自明的.</p>
</div>
<div class="paragraph">
<p>这样就完成了 CAS 的最基本配置.  如果您没有犯任何错误,则您的网络应用程序应该可以在 CAS 单点登录框架内愉快地工作.  Spring Security 的其他部分无需关心 CAS 处理的身份验证这一事实.  在以下各节中,我们将讨论一些 (可选) 更高级的配置.</p>
</div>
</div>
<div class="sect4">
<h5 id="cas-singlelogout"><a class="anchor" href="#cas-singlelogout"></a>单点注销</h5>
<div class="paragraph">
<p>CAS 协议支持单点注销,可以轻松添加到您的 Spring Security 配置中.  以下是处理单点注销的 Spring Security 配置的更新</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;security:http entry-point-ref="casEntryPoint"&gt;
...
&lt;security:logout logout-success-url="/cas-logout.jsp"/&gt;
&lt;security:custom-filter ref="requestSingleLogoutFilter" before="LOGOUT_FILTER"/&gt;
&lt;security:custom-filter ref="singleLogoutFilter" before="CAS_FILTER"/&gt;
&lt;/security:http&gt;

&lt;!-- This filter handles a Single Logout Request from the CAS Server --&gt;
&lt;bean id="singleLogoutFilter" class="org.jasig.cas.client.session.SingleSignOutFilter"/&gt;

&lt;!-- This filter redirects to the CAS Server to signal Single Logout should be performed --&gt;
&lt;bean id="requestSingleLogoutFilter"
    class="org.springframework.security.web.authentication.logout.LogoutFilter"&gt;
&lt;constructor-arg value="https://localhost:9443/cas/logout"/&gt;
&lt;constructor-arg&gt;
    &lt;bean class=
        "org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"/&gt;
&lt;/constructor-arg&gt;
&lt;property name="filterProcessesUrl" value="/logout/cas"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>logout</code> 元素将用户从本地应用程序注销,但不会终止与 CAS 服务器或已登录的任何其他应用程序的会话.  <code>requestSingleLogoutFilter</code> 过滤器将允许请求 <code>/spring_security_cas_logout</code> 的 URL,以将应用程序重定向到配置的 CAS Server 注销 URL.
然后,CAS 服务器将向已登录的所有服务发送 "单一注销" 请求.  <code>singleLogoutFilter</code> 通过在静态 Map 中查找 <code>HttpSession</code> 并使其无效来处理 Single Logout 请求.</p>
</div>
<div class="paragraph">
<p>为什么同时需要 <code>logout</code> 元素和 <code>singleLogoutFilter</code> 可能令人困惑.  最好先在本地注销,因为 <code>SingleSignOutFilter</code> 只是将 <code>HttpSession</code> 存储在静态 Map 中,以便对其调用无效.  使用上述配置,注销流程为:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用户请求 <code>/logout</code>,这将使用户退出本地应用程序,并将用户发送到注销成功页面.</p>
</li>
<li>
<p>注销成功页面 <code>/cas-logout.jsp</code> 应该指示用户单击指向 <code>/logout/cas</code> 的链接,以便注销所有应用程序.</p>
</li>
<li>
<p>当用户单击链接时,用户将被重定向到 CAS 单一注销 URL (<code><a href="https://localhost:9443/cas/logout" class="bare">localhost:9443/cas/logout</a></code>) .</p>
</li>
<li>
<p>然后,在 CAS 服务器端,CAS 单一注销 URL 向所有 CAS 服务提交单一注销请求.  在 CAS 服务方面,JASIG 的 <code>SingleSignOutFilter</code> 通过使原始会话无效来处理注销请求.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下一步是将以下内容添加到您的 web.xml 中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
&lt;filter-class&gt;
    org.springframework.web.filter.CharacterEncodingFilter
&lt;/filter-class&gt;
&lt;init-param&gt;
    &lt;param-name&gt;encoding&lt;/param-name&gt;
    &lt;param-value&gt;UTF-8&lt;/param-value&gt;
&lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;listener&gt;
&lt;listener-class&gt;
    org.jasig.cas.client.session.SingleSignOutHttpSessionListener
&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>SingleSignOutFilter</code> 时,您可能会遇到一些编码问题.  因此,建议添加 <code>CharacterEncodingFilter</code> 以确保使用 <code>SingleSignOutFilter</code> 时字符编码正确.  同样,请参阅 JASIG 的文档以了解详细信息.  <code>SingleSignOutHttpSessionListener</code> 确保 <code>HttpSession</code> 过期时,将删除用于单次注销的映射.</p>
</div>
</div>
<div class="sect4">
<h5 id="cas-pt-client"><a class="anchor" href="#cas-pt-client"></a>通过CAS向无状态服务进行身份验证</h5>
<div class="paragraph">
<p>本节介绍如何使用 CAS 对服务进行身份验证.  换句话说,本节讨论如何设置使用通过 CAS 认证的服务的客户端.  下一节将介绍如何设置无状态服务以使用 CAS 进行身份验证.</p>
</div>
<div class="sect5">
<h6 id="cas-pt-client-config"><a class="anchor" href="#cas-pt-client-config"></a>配置CAS以获取代理授予票证</h6>
<div class="paragraph">
<p>为了向无状态服务进行身份验证,应用程序需要获取代理授予票证 (PGT) .  本节描述了如何配置 Spring Security 以获得基于 thencas-st[Service Ticket Authentication] 配置的PGT.</p>
</div>
<div class="paragraph">
<p>第一步是在 Spring Security 配置中包括 <code>ProxyGrantingTicketStorage</code>.  这用于存储由 <code>CasAuthenticationFilter</code> 获得的 PGT,以便可以将其用于获取代理凭单.  配置示例如下所示</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;!--
NOTE: In a real application you should not use an in memory implementation.
You will also want to ensure to clean up expired tickets by calling
ProxyGrantingTicketStorage.cleanup()
--&gt;
&lt;bean id="pgtStorage" class="org.jasig.cas.client.proxy.ProxyGrantingTicketStorageImpl"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步是更新 <code>CasAuthenticationProvider</code>,使其能够获取代理票证.  为此,将 <code>Cas20ServiceTicketValidator</code> 替换为 <code>Cas20ProxyTicketValidator</code>.  应该将 <code>proxyCallbackUrl</code> 设置为应用程序将在其上接收 PGT 的 URL.  最后,配置还应该引用 <code>ProxyGrantingTicketStorage</code>,以便它可以使用 PGT 获取代理票证.  您可以在下面找到配置更改的示例.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="casAuthenticationProvider"
    class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
...
&lt;property name="ticketValidator"&gt;
    &lt;bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator"&gt;
    &lt;constructor-arg value="https://localhost:9443/cas"/&gt;
        &lt;property name="proxyCallbackUrl"
        value="https://localhost:8443/cas-sample/login/cas/proxyreceptor"/&gt;
    &lt;property name="proxyGrantingTicketStorage" ref="pgtStorage"/&gt;
    &lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一步是更新 <code>CasAuthenticationFilter</code> 以接受 PGT 并将它们存储在 <code>ProxyGrantingTicketStorage</code> 中.  重要的是 <code>proxyReceptorUrl</code> 与 <code>Cas20ProxyTicketValidator</code> 的 <code>proxyCallbackUrl</code> 相匹配.  配置示例如下所示.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="casFilter"
        class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
    ...
    &lt;property name="proxyGrantingTicketStorage" ref="pgtStorage"/&gt;
    &lt;property name="proxyReceptorUrl" value="/login/cas/proxyreceptor"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="cas-pt-client-sample"><a class="anchor" href="#cas-pt-client-sample"></a>使用代理票证调用无状态服务</h6>
<div class="paragraph">
<p>现在,Spring Security 获得了 PGT,您可以使用它们创建代理票证,该票证可用于对无状态服务进行身份验证.  <a href="#samples">sample 应用程序</a> 在 <code>ProxyTicketSampleServlet</code> 中包含一个工作示例.  示例代码可以在下面找到:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected void doGet(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException {
// NOTE: The CasAuthenticationToken can also be obtained using
// SecurityContextHolder.getContext().getAuthentication()
final CasAuthenticationToken token = (CasAuthenticationToken) request.getUserPrincipal();
// proxyTicket could be reused to make calls to the CAS service even if the
// target url differs
final String proxyTicket = token.getAssertion().getPrincipal().getProxyTicketFor(targetUrl);

// Make a remote call using the proxy ticket
final String serviceUrl = targetUrl+"?ticket="+URLEncoder.encode(proxyTicket, "UTF-8");
String proxyResponse = CommonUtils.getResponseFromServer(serviceUrl, "UTF-8");
...
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="cas-pt"><a class="anchor" href="#cas-pt"></a>代理票证认证</h5>
<div class="paragraph">
<p><code>CasAuthenticationProvider</code> 区分有状态客户端和无状态客户端.  有状态客户端被认为是任何提交给 <code>CasAuthenticationFilter</code> 的 <code>filterProcessUrl</code> 的客户端.  无状态客户端是指在 <code>filterProcessUrl</code> 之外的 URL 上向 <code>CasAuthenticationFilter</code> 提出身份验证请求的客户端.</p>
</div>
<div class="paragraph">
<p>由于远程协议无法在 <code>HttpSession</code> 的上下文中展示自己,因此无法依靠默认做法将安全上下文存储在请求之间的会话中.  此外,由于CAS服务器在票证已由 <code>TicketValidator</code> 验证后使票证失效,因此无法在后续请求中显示相同的代理票证.</p>
</div>
<div class="paragraph">
<p>一个明显的选择是根本不使用 CAS 远程协议客户端.  但是,这将消除 CAS 的许多理想功能.  作为中间立场,<code>CasAuthenticationProvider</code> 使用 <code>StatelessTicketCache</code>.  这仅用于使用等于 <code>CasAuthenticationFilter.CAS_STATELESS_IDENTIFIER</code> 的主体的无状态客户端.
发生的情况是,<code>CasAuthenticationProvider</code> 会将生成的 <code>CasAuthenticationToken</code> 存储在 <code>StatelessTicketCache</code> 中,该密钥在代理凭单上输入.  因此,远程协议客户端可以提供相同的代理票证,并且 <code>CasAuthenticationProvider</code> 无需联系 CAS 服务器进行验证 (除了第一个请求) .  一旦通过身份验证,代理票证就可以用于原始目标服务以外的 URL.</p>
</div>
<div class="paragraph">
<p>本部分以前面的部分为基础,以适应代理票证身份验证.  第一步是指定对所有 artifacts 进行身份验证,如下所示.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="serviceProperties"
    class="org.springframework.security.cas.ServiceProperties"&gt;
...
&lt;property name="authenticateAllArtifacts" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步是为 <code>CasAuthenticationFilter</code> 指定 <code>serviceProperties</code> 和 <code>authenticationDetailsSource</code>.  <code>serviceProperties</code> 属性指示 <code>CasAuthenticationFilter</code> 尝试认证所有 artifacts ,而不是仅对 <code>filterProcessUrl</code> 中存在的 artifacts 进行认证.
<code>ServiceAuthenticationDetailsSource</code> 创建一个 <code>ServiceAuthenticationDetails</code>,以确保在验证票证时将基于 <code>HttpServletRequest</code> 的当前 URL 用作服务 URL.  可以通过注入返回返回自定义 <code>ServiceAuthenticationDetails</code> 的自定义 <code>AuthenticationDetailsSource</code> 来自定义生成服务 URL 的方法.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="casFilter"
    class="org.springframework.security.cas.web.CasAuthenticationFilter"&gt;
...
&lt;property name="serviceProperties" ref="serviceProperties"/&gt;
&lt;property name="authenticationDetailsSource"&gt;
    &lt;bean class=
    "org.springframework.security.cas.web.authentication.ServiceAuthenticationDetailsSource"&gt;
    &lt;constructor-arg ref="serviceProperties"/&gt;
    &lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还需要更新 <code>CasAuthenticationProvider</code> 来处理代理票证.  为此,将 <code>Cas20ServiceTicketValidator</code> 替换为 <code>Cas20ProxyTicketValidator</code>.  您将需要配置 <code>statelessTicketCache</code> 以及要接受的代理.  您可以在下面找到接受所有代理所需的更新示例.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="casAuthenticationProvider"
    class="org.springframework.security.cas.authentication.CasAuthenticationProvider"&gt;
...
&lt;property name="ticketValidator"&gt;
    &lt;bean class="org.jasig.cas.client.validation.Cas20ProxyTicketValidator"&gt;
    &lt;constructor-arg value="https://localhost:9443/cas"/&gt;
    &lt;property name="acceptAnyProxy" value="true"/&gt;
    &lt;/bean&gt;
&lt;/property&gt;
&lt;property name="statelessTicketCache"&gt;
    &lt;bean class="org.springframework.security.cas.authentication.EhCacheBasedTicketCache"&gt;
    &lt;property name="cache"&gt;
        &lt;bean class="net.sf.ehcache.Cache"
            init-method="initialise" destroy-method="dispose"&gt;
        &lt;constructor-arg value="casTickets"/&gt;
        &lt;constructor-arg value="50"/&gt;
        &lt;constructor-arg value="true"/&gt;
        &lt;constructor-arg value="false"/&gt;
        &lt;constructor-arg value="3600"/&gt;
        &lt;constructor-arg value="900"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;/bean&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-x509"><a class="anchor" href="#servlet-x509"></a>10.18. X.509 认证</h3>
<div class="sect3">
<h4 id="x509-overview"><a class="anchor" href="#x509-overview"></a>10.18.1. 概述</h4>
<div class="paragraph">
<p>最常用的 X.509 证书身份验证是验证服务器在使用 SSL 的身份,从浏览器通常在使用 HTTPS. 浏览器会自动检查服务器证书的已发布(即数字签名)的一个受信任的证书颁发机构的列表维护.</p>
</div>
<div class="paragraph">
<p>您还可以使用 SSL 与 "mutual authentication";服务器将请求从客户端作为一个有效的证书的 SSL 握手. 服务器将验证客户端通过检查其签署的证书是一个可接受的权威. 如果提供了一个有效的证书,它可以通过 servlet API 的应用程序. Spring Security X.509 模块提取证书使用一个过滤器. 它将证书映射到一个应用程序用户和加载用户的组授予机关使用标准的 Spring Security 基础设施.</p>
</div>
<div class="paragraph">
<p>在尝试将其与 Spring Security 结合使用之前,您应该熟悉使用证书并为 Servlet 容器设置客户端身份验证.  大多数工作是在创建和安装合适的证书和密钥.
例如,如果您使用的是 Tomcat,请阅读 <a href="https://tomcat.apache.org/tomcat-9.0-doc/ssl-howto.html">https://tomcat.apache.org/tomcat-9.0-doc/ssl-howto.html</a> 上的说明.  在使用 Spring Security 进行尝试之前,一定要先做好这项工作,这一点很重要</p>
</div>
</div>
<div class="sect3">
<h4 id="向您的web应用程序添加x-509身份验证"><a class="anchor" href="#向您的web应用程序添加x-509身份验证"></a>10.18.2. 向您的Web应用程序添加X.509身份验证</h4>
<div class="paragraph">
<p>启用 X.509 客户端身份验证非常简单.  只需将 <code>&lt;x509/&gt;</code> 元素添加到您的 http 安全命名空间配置中即可.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
...
    &lt;x509 subject-principal-regex="CN=(.*?)," user-service-ref="userService"/&gt;;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>元素具有两个可选属性:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>subject-principal-regex</code>.
用于从证书主题名称中提取用户名的正则表达式.  默认值如上所示.  这是用户名,该用户名将传递给 <code>UserDetailsService</code> 以加载用户的权限.</p>
</li>
<li>
<p><code>user-service-ref</code>.
这是与X.509一起使用的 <code>UserDetailsService</code> 的 bean ID.  如果您的应用程序上下文中仅定义了一个,则不需要.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>subject-principal-regex</code> 应该包含一个组.  例如,默认表达式 "CN=(.*?)," 与通用名称字段匹配.  因此,如果证书中的使用者名称为 "CN=Jimi Hendrix, OU=&#8230;&#8203;",则用户名称为 "Jimi Hendrix".
匹配不区分大小写.  因此,"emailAddress=(.*?),"  将与 "EMAILADDRESS=<a href="mailto:jimi@hendrix.org">jimi@hendrix.org</a>,CN=&#8230;&#8203;" 匹配,并给出用户名 "<a href="mailto:jimi@hendrix.org">jimi@hendrix.org</a>".  如果客户端出示证书并且成功提取了有效的用户名,则安全上下文中应该有一个有效的 <code>Authentication</code> 对象.  如果找不到证书,或者找不到相应的用户,则安全上下文将保持为空.  这意味着您可以轻松地将 X.509 身份验证与其他选项 (例如基于表单的登录名) 一起使用.</p>
</div>
</div>
<div class="sect3">
<h4 id="x509-ssl-config"><a class="anchor" href="#x509-ssl-config"></a>10.18.3. 在Tomcat中设置SSL</h4>
<div class="paragraph">
<p>Spring Security 项目的 <code>samples/certificate</code> 目录中有一些预先生成的证书.  如果您不想生成自己的SSL,可以使用它们启用SSL进行测试.  文件 <code>server.jks</code> 包含服务器证书,私钥和颁发证书颁发机构的证书.  示例应用程序中还为用户提供了一些客户端证书文件.  您可以将它们安装在浏览器中以启用 SSL 客户端身份验证.</p>
</div>
<div class="paragraph">
<p>要运行具有 SSL 支持的 tomcat,请将 <code>server.jks</code> 文件拖放到tomcat <code>conf</code> 目录中,并将以下连接器添加到 <code>server.xml</code> 文件中</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;Connector port="8443" protocol="HTTP/1.1" SSLEnabled="true" scheme="https" secure="true"
            clientAuth="true" sslProtocol="TLS"
            keystoreFile="${catalina.home}/conf/server.jks"
            keystoreType="JKS" keystorePass="password"
            truststoreFile="${catalina.home}/conf/server.jks"
            truststoreType="JKS" truststorePass="password"
/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您仍然希望 SSL 连接成功,即使客户端不提供证书,也可以将 <code>clientAuth</code> 设置为 <code>want</code>.  除非您使用非 X.509 身份验证机制 (例如表单身份验证) ,否则没有证书的客户端将无法访问 Spring Security 保护的任何对象.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="runas"><a class="anchor" href="#runas"></a>10.19. Run-As 验证替换</h3>
<div class="sect3">
<h4 id="runas-overview"><a class="anchor" href="#runas-overview"></a>10.19.1. 概述</h4>
<div class="paragraph">
<p><code>AbstractSecurityInterceptor</code> 能够暂时取代 <code>Authentication</code> 对象在 <code>SecurityContext</code> 和 <code>SecurityContextHolder</code> 安全对象回调阶段.
这只发生如果最初的 <code>Authentication</code> 对象是成功处理的 <code>AuthenticationManager</code> 和 <code>AccessDecisionManager.RunAsManager</code> 将指示更换 <code>Authentication</code> 对象,如果有的话,应该使用在 <code>SecurityInterceptorCallback</code>.</p>
</div>
<div class="paragraph">
<p>通过在安全对象回调阶段临时替换 <code>Authentication</code> 对象,安全调用将能够调用需要不同身份验证和授权凭证的其他对象.  它还将能够对特定的 <code>GrantedAuthority</code> 对象执行任何内部安全检查.
由于 Spring Security 提供了许多帮助程序类,这些类根据 <code>SecurityContextHolder</code> 的内容自动配置远程协议,因此这些运行方式替换在调用远程 Web 服务时特别有用</p>
</div>
</div>
<div class="sect3">
<h4 id="runas-config"><a class="anchor" href="#runas-config"></a>10.19.2. 配置</h4>
<div class="paragraph">
<p>Spring Security 提供 <code>RunAsManager</code> 接口:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Authentication buildRunAs(Authentication authentication, Object object,
    List&lt;ConfigAttribute&gt; config);

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个方法返回 <code>Authentication</code> 对象应该取代现有的身份验证的对象方法调用的持续时间.
如果方法返回 <code>null</code>,它表明你没有更换. 第二种方法是使用 <code>AbstractSecurityInterceptor</code> 启动验证配置属性的一部分.  <code>supports(Class)</code> 的方法被调用以确保安全拦截器将安全对象实现配置的 <code>RunAsManager</code> 支持的类型安全拦截器.</p>
</div>
<div class="paragraph">
<p>Spring Security 提供了 <code>RunAsManager</code> 的一种具体实现.  如果任何 <code>ConfigAttribute以RUN_AS_</code> 开头,则 <code>RunAsManagerImpl</code> 类将返回替换 <code>RunAsUserToken</code>.  如果找到任何这样的 <code>ConfigAttribute</code>,
则替换的 <code>RunAsUserToken</code> 将包含与原始 <code>Authentication</code> 对象相同的主体,凭据和授予的权限,以及每个 RUN_AS_ <code>ConfigAttribute</code> 的新 <code>SimpleGrantedAuthority</code>.  每个新的 <code>SimpleGrantedAuthority</code> 将以 <code>ROLE_</code> 为前缀,后跟 <code>RUN_AS</code> <code>ConfigAttribute</code>.  例如,<code>RUN_AS_SERVER</code> 将导致替换的 <code>RunAsUserToken</code> 包含 <code>ROLE_RUN_AS_SERVER</code> 授予的权限.</p>
</div>
<div class="paragraph">
<p>替换 <code>RunAsUserToken</code> 就像其他任何 <code>Authentication</code> 对象一样.  它需要由 <code>AuthenticationManager</code> 进行身份验证,可能需要通过委派给合适的 <code>AuthenticationProvider</code> 来进行.  <code>RunAsImplAuthenticationProvider</code> 执行此类身份验证.  它只是简单地接受任何出现的 <code>RunAsUserToken</code>.</p>
</div>
<div class="paragraph">
<p>为了确保恶意代码不会创建 <code>RunAsUserToken</code> 并将其提供给 <code>RunAsImplAuthenticationProvider</code> 保证接受,密钥的哈希存储在所有生成的令牌中.  使用相同的密钥在 Bean 上下文中创建 <code>RunAsManagerImpl</code> 和 <code>RunAsImplAuthenticationProvider</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="runAsManager"
    class="org.springframework.security.access.intercept.RunAsManagerImpl"&gt;
&lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;

&lt;bean id="runAsAuthenticationProvider"
    class="org.springframework.security.access.intercept.RunAsImplAuthenticationProvider"&gt;
&lt;property name="key" value="my_run_as_password"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使用相同的密钥,可以验证每个 <code>RunAsUserToken</code> 是否由批准的 <code>RunAsManagerImpl</code> 创建.  出于安全原因,<code>RunAsUserToken</code> 在创建后是不可变的</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jc-logout"><a class="anchor" href="#jc-logout"></a>10.20. Logout 处理</h3>
<div class="sect3">
<h4 id="logout-java-configuration"><a class="anchor" href="#logout-java-configuration"></a>10.20.1. Logout Java/Kotlin 配置</h4>
<div class="paragraph">
<p>使用 <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.html">WebSecurityConfigurerAdapter</a></code> 时,将自动应用注销功能.  默认是访问 URL <code>/logout</code> 将通过以下方式注销用户:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使HTTP会话无效</p>
</li>
<li>
<p>清理配置的所有RememberMe身份验证</p>
</li>
<li>
<p>清除 <code>SecurityContextHolder</code></p>
</li>
<li>
<p>重定向 <code>/login?logout</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>但是,与配置登录功能相似,您还可以使用各种选项来进一步自定义注销要求:</p>
</div>
<div class="exampleblock">
<div class="title">Example 80. Logout Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
    http
        .logout(logout -&gt; logout                                                <i class="conum" data-value="1"></i><b>(1)</b>
            .logoutUrl("/my/logout")                                            <i class="conum" data-value="2"></i><b>(2)</b>
            .logoutSuccessUrl("/my/index")                                      <i class="conum" data-value="3"></i><b>(3)</b>
            .logoutSuccessHandler(logoutSuccessHandler)                         <i class="conum" data-value="4"></i><b>(4)</b>
            .invalidateHttpSession(true)                                        <i class="conum" data-value="5"></i><b>(5)</b>
            .addLogoutHandler(logoutHandler)                                    <i class="conum" data-value="6"></i><b>(6)</b>
            .deleteCookies(cookieNamesToClear)                                  <i class="conum" data-value="7"></i><b>(7)</b>
        )
        ...
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">override fun configure(http: HttpSecurity) {
    http {
        logout {
            logoutUrl = "/my/logout"                              <i class="conum" data-value="1"></i><b>(1)</b>
            logoutSuccessUrl = "/my/index"                        <i class="conum" data-value="2"></i><b>(2)</b>
            logoutSuccessHandler = customLogoutSuccessHandler     <i class="conum" data-value="3"></i><b>(3)</b>
            invalidateHttpSession = true                          <i class="conum" data-value="4"></i><b>(4)</b>
            addLogoutHandler(logoutHandler)                       <i class="conum" data-value="5"></i><b>(5)</b>
            deleteCookies(cookieNamesToClear)                     <i class="conum" data-value="6"></i><b>(6)</b>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>提供注销支持.  当使用 <code>WebSecurityConfigurerAdapter</code> 时会自动应用.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>触发注销发生的URL(默认为 <code>/logout</code>) . 如果启用了 CSRF 保护(默认) ,则请求必须是 POST.  有关更多信息,请查阅 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutUrl-java.lang.String-">JavaDoc</a> .</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>注销发生后重定向到的 URL. 默认 <code>/login?logout</code>. 有关更多信息,请查阅 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessUrl-java.lang.String-">JavaDoc</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>让我们指定一个自定义的 <code>LogoutSuccessHandler</code>. 如果指定了此项,<code>logoutSuccessUrl()</code> 将被忽略.  有关更多信息,请查阅 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#logoutSuccessHandler-org.springframework.security.web.authentication.logout.LogoutSuccessHandler-">JavaDoc</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>指定在注销时是否使 <code>HttpSession</code> 无效. 默认为 <code>true</code>. 在幕后配置 <code>SecurityContextLogoutHandler</code>.  有关更多信息,请查阅 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/config/annotation/web/configurers/LogoutConfigurer.html#invalidateHttpSession-boolean-">JavaDoc</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>添加 <code>LogoutHandler</code>. 默认情况下,<code>SecurityContextLogoutHandler</code> 被添加为最后一个 <code>LogoutHandler</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>允许指定成功注销后将删除的 cookie 名称. 这是显式添加 <code>CookieClearingLogoutHandler</code> 的快捷方式.</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当然,也可以使用 XML 命名空间配置注销.  请参阅 Spring Security XML 命名空间部分中 <a href="#nsa-logout">logout element</a> 的文档以获取更多详细信息.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>通常,为了自定义注销功能,可以添加 <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/LogoutHandler.html">LogoutHandler</a></code> 和/或 <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/LogoutSuccessHandler.html">LogoutSuccessHandler</a></code> 实现.  对于许多常见方案,使用流式的API时会在后台应用这些处理程序.</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-logout"><a class="anchor" href="#ns-logout"></a>10.20.2. Logout XML 配置</h4>
<div class="paragraph">
<p><code>logout</code> 元素通过导航到特定 URL 来添加对注销的支持.  默认注销URL为 <code>/logout</code>,但是您可以使用 <code>logout-url</code> 属性将其设置为其他名称.  有关其他可用属性的更多信息,请参见命名空间附录.</p>
</div>
</div>
<div class="sect3">
<h4 id="jc-logout-handler"><a class="anchor" href="#jc-logout-handler"></a>10.20.3. LogoutHandler</h4>
<div class="paragraph">
<p>通常,<code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/LogoutHandler.html">LogoutHandler</a></code> 实现指示能够参与注销处理的类.  预计将调用它们以执行必要的清理.  因此,它们不应引发异常.  提供了各种实现:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.html">PersistentTokenBasedRememberMeServices</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/rememberme/TokenBasedRememberMeServices.html">TokenBasedRememberMeServices</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/CookieClearingLogoutHandler.html">CookieClearingLogoutHandler</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfLogoutHandler.html">CsrfLogoutHandler</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.html">SecurityContextLogoutHandler</a></p>
</li>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/HeaderWriterLogoutHandler.html">HeaderWriterLogoutHandler</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关详细信息,请参见<a href="#remember-me-impls">第10.13.4节 "记住我的接口和实现"</a>.</p>
</div>
<div class="paragraph">
<p>除了直接提供 <code>LogoutHandler</code> 实现之外,fluent API 还提供了快捷方式,这些快捷方式在幕后提供了各自的 <code>LogoutHandler</code> 实现.
例如.  <code>deleteCookies()</code> 允许指定成功注销后要删除的一个或多个 cookie 的名称.  与添加 <code>CookieClearingLogoutHandler</code> 相比,这是一种快捷方式.</p>
</div>
</div>
<div class="sect3">
<h4 id="jc-logout-success-handler"><a class="anchor" href="#jc-logout-success-handler"></a>10.20.4. LogoutSuccessHandler</h4>
<div class="paragraph">
<p><code>LogoutFilter</code> 成功注销后,将调用 <code>LogoutSuccessHandler</code> 来处理例如 重定向或转发到适当的目的地.  请注意,该接口与 <code>LogoutHandler</code> 几乎相同,但可能会引发异常.</p>
</div>
<div class="paragraph">
<p>提供以下实现:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/logout/SimpleUrlLogoutSuccessHandler.html">SimpleUrlLogoutSuccessHandler</a></p>
</li>
<li>
<p>HttpStatusReturningLogoutSuccessHandler</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如上所述,您无需直接指定 <code>SimpleUrlLogoutSuccessHandler</code>.  相反,fluent API 通过设置 <code>logoutSuccessUrl()</code> 提供了快捷方式.  这将在幕后设置 <code>SimpleUrlLogoutSuccessHandler</code>.  提供的 URL 将在注销后重定向到.  默认值为 <code>/login?logout</code>.</p>
</div>
<div class="paragraph">
<p>在 REST API 类型的场景中,<code>HttpStatusReturningLogoutSuccessHandler</code> 可能很有趣.  通过 <code>LogoutSuccessHandler</code>,您不必提供在成功注销后重定向到 URL 的方法,而是可以提供要返回的纯HTTP状态代码.  如果未配置,默认情况下将返回状态码200.</p>
</div>
</div>
<div class="sect3">
<h4 id="jc-logout-references"><a class="anchor" href="#jc-logout-references"></a>10.20.5. 其他注销相关参考</h4>
<div class="ulist">
<ul>
<li>
<p><a href="#ns-logout">Logout 处理</a></p>
</li>
<li>
<p><a href="#test-logout">测试 Logout</a></p>
</li>
<li>
<p><a href="#servletapi-logout">HttpServletRequest.logout()</a></p>
</li>
<li>
<p><a href="#remember-me-impls">"记住我的接口和实现"</a></p>
</li>
<li>
<p>在CSRF警告<a href="#servlet-considerations-csrf-logout">Logging Out</a></p>
</li>
<li>
<p><a href="#cas-singlelogout">单点注销</a> (CAS protocol)</p>
</li>
<li>
<p>Spring Security XML 命名空间 <a href="#nsa-logout">logout element</a> 的文档</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-events"><a class="anchor" href="#servlet-events"></a>10.21. 认证事件</h3>
<div class="paragraph">
<p>对于成功或失败的每个身份验证,分别触发 <code>AuthenticationSuccessEvent</code> 或 <code>AuthenticationFailureEvent</code>.</p>
</div>
<div class="paragraph">
<p>若要监听这些事件,必须首先发布 <code>AuthenticationEventPublisher</code>. Spring Security 的 <code>DefaultAuthenticationEventPublisher</code> 会做的很好:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    return new DefaultAuthenticationEventPublisher(applicationEventPublisher);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    return DefaultAuthenticationEventPublisher(applicationEventPublisher)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后,您可以使用 Spring 的 <code>@EventListener</code> 支持:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
public class AuthenticationEvents {
    @EventListener
    public void onSuccess(AuthenticationSuccessEvent success) {
        // ...
    }

    @EventListener
    public void onFailure(AuthenticationFailureEvent failures) {
        // ...
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class AuthenticationEvents {
    @EventListener
    fun onSuccess(success: AuthenticationSuccessEvent?) {
        // ...
    }

    @EventListener
    fun onFailure(failures: AbstractAuthenticationFailureEvent?) {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>尽管与 <code>AuthenticationSuccessHandler</code> 和 <code>AuthenticationFailureHandler</code> 相似,但它们的优点在于可以独立于 Servlet API 使用.</p>
</div>
<div class="sect3">
<h4 id="添加异常映射"><a class="anchor" href="#添加异常映射"></a>10.21.1. 添加异常映射</h4>
<div class="paragraph">
<p>默认情况下,<code>DefaultAuthenticationEventPublisher</code> 将为以下事件发布 <code>AuthenticationFailureEvent</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Exception</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Event</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BadCredentialsException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UsernameNotFoundException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AccountExpiredException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureExpiredEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ProviderNotFoundException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureProviderNotFoundEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>DisabledException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureDisabledEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LockedException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureLockedEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationServiceException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureServiceExceptionEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CredentialsExpiredException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureCredentialsExpiredEvent</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>InvalidBearerTokenException</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AuthenticationFailureBadCredentialsEvent</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>发布者会进行精确的 <code>Exception</code> 匹配,这意味着这些异常的子类也不会产生事件.</p>
</div>
<div class="paragraph">
<p>为此,您可能希望通过 <code>setAdditionalExceptionMappings</code> 方法向发布者提供其他映射:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    Map&lt;Class&lt;? extends AuthenticationException&gt;,
        Class&lt;? extends AuthenticationFailureEvent&gt;&gt; mapping =
            Collections.singletonMap(FooException.class, FooEvent.class);
    AuthenticationEventPublisher authenticationEventPublisher =
        new DefaultAuthenticationEventPublisher(applicationEventPublisher);
    authenticationEventPublisher.setAdditionalExceptionMappings(mapping);
    return authenticationEventPublisher;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    val mapping: Map&lt;Class&lt;out AuthenticationException&gt;, Class&lt;out AbstractAuthenticationFailureEvent&gt;&gt; =
            mapOf(Pair(FooException::class.java, FooEvent::class.java))
    val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher)
    authenticationEventPublisher.setAdditionalExceptionMappings(mapping)
    return authenticationEventPublisher
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="默认事件"><a class="anchor" href="#默认事件"></a>10.21.2. 默认事件</h4>
<div class="paragraph">
<p>并且,您可以提供在发生任何 <code>AuthenticationException</code> 情况下触发的全部捕获事件:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public AuthenticationEventPublisher authenticationEventPublisher
        (ApplicationEventPublisher applicationEventPublisher) {
    AuthenticationEventPublisher authenticationEventPublisher =
        new DefaultAuthenticationEventPublisher(applicationEventPublisher);
    authenticationEventPublisher.setDefaultAuthenticationFailureEvent
        (GenericAuthenticationFailureEvent.class);
    return authenticationEventPublisher;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authenticationEventPublisher
        (applicationEventPublisher: ApplicationEventPublisher?): AuthenticationEventPublisher {
    val authenticationEventPublisher = DefaultAuthenticationEventPublisher(applicationEventPublisher)
    authenticationEventPublisher.setDefaultAuthenticationFailureEvent(GenericAuthenticationFailureEvent::class.java)
    return authenticationEventPublisher
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-authorization"><a class="anchor" href="#servlet-authorization"></a>11. 授权</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 中的高级授权功能代表了其受欢迎程度的最令人信服的原因之一.
无论选择哪种身份验证方式(使用 Spring Security 提供的机制和程序,还是与容器或其他非 Spring Security 身份验证机构集成) ,您都会发现可以在应用程序中以一致且简单的方式使用授权服务.</p>
</div>
<div class="paragraph">
<p>在这一部分中,我们将探讨在第I部分中介绍的不同 <code>AbstractSecurityInterceptor</code> 实现. 然后,我们将继续探讨如何通过使用 domain 访问控制列表来微调授权.</p>
</div>
<div class="sect2">
<h3 id="authz-arch"><a class="anchor" href="#authz-arch"></a>11.1. 授权体系结构</h3>
<div class="sect3">
<h4 id="authz-authorities"><a class="anchor" href="#authz-authorities"></a>11.1.1. Authorities</h4>
<div class="paragraph">
<p>正如我们在 <a href="#servlet-authentication-authentication"><code>Authentication</code></a> 所看到,所有的 <code>Authentication</code> 实现都存储了 <code>GrantedAuthority</code> 列表. 这些代表已授予主体的权限.  <code>GrantedAuthority</code> 对象由 <code>AuthenticationManager</code> 插入 <code>Authentication</code> 对象,并在以后做出授权决策时由 <code>AccessDecisionManager</code> 读取.</p>
</div>
<div class="paragraph">
<p><code>GrantedAuthority</code> 接口只有一个方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String getAuthority();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>此方法使 <code>AccessDecisionManager</code> 可以获取 <code>GrantedAuthority</code> 的精确 <code>String</code> 表示形式.
通过以字符串形式返回,大多数 <code>AccessDecisionManager</code> 都可以轻松地读取 <code>GrantedAuthority</code>.  如果 <code>GrantedAuthority</code> 无法精确地表示为 <code>String</code>,则 <code>GrantedAuthority</code> 被视为 "complex" ,并且 <code>getAuthority()</code> 必须返回 <code>null</code>.</p>
</div>
<div class="paragraph">
<p>"complex" <code>GrantedAuthority的</code> 示例将是一种实现,该实现存储适用于不同客户帐号的一系列操作和权限阈值.
将复杂的 <code>GrantedAuthority</code> 表示为 String 会非常困难,因此 <code>getAuthority()</code> 方法应返回 <code>null</code>.  这将向任何 <code>AccessDecisionManager</code> 指示它将需要特别支持 <code>GrantedAuthority</code> 实现,以便理解其内容.</p>
</div>
<div class="paragraph">
<p>Spring Security 包含一个具体的 <code>GrantedAuthority</code> 实现,即 <code>SimpleGrantedAuthority</code>.  这允许将任何用户指定的 <code>String</code> 转换为 <code>GrantedAuthority</code>.  安全体系结构中包含的所有 <code>AuthenticationProvider</code> 都使用 <code>SimpleGrantedAuthority</code> 来填充 <code>Authentication</code> 对象.</p>
</div>
</div>
<div class="sect3">
<h4 id="authz-pre-invocation"><a class="anchor" href="#authz-pre-invocation"></a>11.1.2. 调用处理前</h4>
<div class="paragraph">
<p>Spring Security 提供了拦截器,用于控制对安全对象的访问,例如方法调用或 Web 请求.  <code>AccessDecisionManager</code> 会判断是否允许进行调用.</p>
</div>
<div class="sect4">
<h5 id="authz-access-decision-manager"><a class="anchor" href="#authz-access-decision-manager"></a>AccessDecisionManager</h5>
<div class="paragraph">
<p><code>AccessDecisionManager</code> 由 <code>AbstractSecurityInterceptor</code> 调用,并负责做出最终的访问决策控制.  <code>AccessDecisionManager</code> 接口包含三种方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">void decide(Authentication authentication, Object secureObject,
    Collection&lt;ConfigAttribute&gt; attrs) throws AccessDeniedException;

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);
</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>AccessDecisionManager</code> 的 <code>decide</code> 方法是判定是否拥有访问权限的决策方法,.  特别是,通过传递安全对象,可以检查实际安全对象调用中包含的那些参数.
例如,假设安全对象是 <code>MethodInvocation</code>.  在 <code>MethodInvocation</code> 中查询 <code>Customer</code> 参数,然后在 <code>AccessDecisionManager</code> 中实现某种安全性逻辑允许主体对该客户进行操作.  如果访问被拒绝,则将引发 <code>AccessDeniedException</code>.</p>
</div>
<div class="paragraph">
<p>在启动时,<code>AbstractSecurityInterceptor</code> 将调用 <code>support (ConfigAttribute)</code> 方法,以确定 <code>AccessDecisionManager</code> 是否可以处理传递的 <code>ConfigAttribute</code>.   Security 拦截器实现调用 <code>support (Class)</code> 方法,以确保配置的 <code>AccessDecisionManager</code> 支持 Security 拦截器显示的安全对象的类型.</p>
</div>
</div>
<div class="sect4">
<h5 id="authz-voting-based"><a class="anchor" href="#authz-voting-based"></a>基于 <code>AccessDecisionManager</code> 实现</h5>
<div class="paragraph">
<p>尽管用户可以实现自己的 <code>AccessDecisionManager</code> 来控制授权的各个方面,但是 Spring Security 包括几种基于投票策略的 <code>AccessDecisionManager</code> 实现.  图11.1 <a href="#authz-access-voting">访问决策管理器</a> 说明了相关的类.</p>
</div>
<div id="authz-access-voting" class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/access-decision-voting.png" alt="access decision voting">
</div>
<div class="title">Figure 11. Voting Decision Manager</div>
</div>
<div class="paragraph">
<p>使用此方法,将根据授权决策轮询一系列 <code>AccessDecisionVoter</code> 实现.  然后,<code>AccessDecisionManager</code> 根据对投票的结果来决定是否引发 <code>AccessDeniedException</code>.</p>
</div>
<div class="paragraph">
<p><code>AccessDecisionVoter</code> 接口具有三种方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">int vote(Authentication authentication, Object object, Collection&lt;ConfigAttribute&gt; attrs);

boolean supports(ConfigAttribute attribute);

boolean supports(Class clazz);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>具体的实现返回一个 <code>int</code>,可能的值在 <code>AccessDecisionVoter</code> 的静态字段 <code>ACCESS_ABSTAIN</code>,<code>ACCESS_DENIED</code> 和 <code>ACCESS_GRANTED</code> 中.  如果对授权决定没有意见,则将返回 <code>ACCESS_ABSTAIN</code>.  如果确实有意见,则必须返回 <code>ACCESS_DENIED</code> 或 <code>ACCESS_GRANTED</code>.</p>
</div>
<div class="paragraph">
<p>Spring Security 提供了三个具体的 <code>AccessDecisionManager</code> 来对选票进行汇总.  基于 <code>ConsensusBased</code> 的实现将根据没有弃权的总数来决定授权或者拒绝访问.  可以提供一个参数控制在票数相等或所有票都弃权的情况下的行为.
如果收到一个或多个 <code>ACCESS_GRANTED</code> 投票,则 <code>AffirmativeBased</code> 实现将授予访问权限 (即,如果至少有一个授予投票,则拒绝投票将被忽略) .  像基于 <code>ConsensusBased</code> 的实现一样,有一个参数可以控制所有投票者弃权时的行为.
<code>UnanimousBased</code> 提供程序希望获得一致的 <code>ACCESS_GRANTED</code> 投票才能授予访问权限,而忽略弃权.  如果有任何 <code>ACCESS_DENIED</code> 投票,它将拒绝访问.  像其他实现一样,如果所有投票者都弃权,则有一个控制行为的参数.</p>
</div>
<div class="paragraph">
<p>可以实现自定义 <code>AccessDecisionManager</code>,以不同方式计算票数.  例如,来自特定 <code>AccessDecisionVoter</code> 的投票可能会获得其他权重,而来自特定选民的拒绝投票可能会产生否决权.</p>
</div>
<div class="sect5">
<h6 id="authz-role-voter"><a class="anchor" href="#authz-role-voter"></a>RoleVoter</h6>
<div class="paragraph">
<p>Spring Security 提供的最常用的 <code>AccessDecisionVoter</code> 是 <code>RoleVoter</code>,它将配置属性视为简单的角色名称和投票,在授予了用户角色后才授予访问权限.</p>
</div>
<div class="paragraph">
<p>如果任何 <code>ConfigAttribute</code> 以前缀 <code>ROLE_</code> 开头,它将进行投票.  如果存在 <code>GrantedAuthority</code> 可以返回一个字符串表示形式 (通过 <code>getAuthority()</code> 方法) ,如果  <code>ConfigAttributes</code>  匹配该字符串有一个或者多个以前缀 <code>ROLE_</code> 开头的,则它将投票授予访问权限.  如果任何的 <code>ConfigAttribute</code> 不是以 <code>ROLE_</code> 开头的,则 <code>RoleVoter</code> 会投票拒绝访问.  如果没有 <code>ConfigAttribute</code> 以 <code>ROLE_</code> 开头,则投票者将弃权.</p>
</div>
</div>
<div class="sect5">
<h6 id="authz-authenticated-voter"><a class="anchor" href="#authz-authenticated-voter"></a>AuthenticatedVoter</h6>
<div class="paragraph">
<p>我们暗中看到的另一个投票者是 <code>AuthenticatedVoter</code>,它可用于区分匿名,完全认证和记住我的认证用户.  许多站点允许使用 "记住我" 身份验证进行某些受限访问,但是要求用户通过登录以进行完全访问来确认其身份.</p>
</div>
<div class="paragraph">
<p>当我们使用属性 <code>IS_AUTHENTICATED_ANONYMOUSLY</code> 授予匿名访问权限时,此属性已由 <code>AuthenticatedVoter</code> 处理.  有关更多信息,请参见Javadoc.</p>
</div>
</div>
<div class="sect5">
<h6 id="authz-custom-voter"><a class="anchor" href="#authz-custom-voter"></a>自定义投票者</h6>
<div class="paragraph">
<p>显然,您还可以实现一个自定义的 <code>AccessDecisionVoter</code>,并且可以将几乎任何所需的访问控制逻辑放入其中.
它可能特定于您的应用程序 (与业务逻辑相关) ,也可能实现某些安全管理逻辑.  例如,您会在Spring网站上找到一篇 <a href="https://spring.io/blog/2009/01/03/spring-security-customization-part-2-adjusting-secured-session-in-real-time">博客文章</a>,其中描述了如何使用投票器实时拒绝帐户被暂停的用户的实时访问.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="authz-after-invocation-handling"><a class="anchor" href="#authz-after-invocation-handling"></a>11.1.3. 调用处理后</h4>
<div class="paragraph">
<p>虽然在进行安全对象调用之前 <code>AbstractSecurityInterceptor</code> 会调用 <code>AccessDecisionManager</code>,但某些应用程序需要调用实际返回的对象修改安全对象.
尽管您可以使用 AOP 来解决这个文问题,但 Spring Security 提供了一个方便的钩子,该钩子具有几种与其 ACL 功能集成的具体实现.</p>
</div>
<div class="paragraph">
<p><a href="#authz-after-invocation">图11.2 "调用后实现"</a> 说明了 Spring Security 的 <code>AfterInvocationManager</code> 及其具体实现.</p>
</div>
<div id="authz-after-invocation" class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/after-invocation.png" alt="after invocation">
</div>
<div class="title">Figure 12. 调用后实现</div>
</div>
<div class="paragraph">
<p>像 Spring Security 的许多其他部分一样,<code>AfterInvocationManager</code> 具有一个具体的实现 <code>AfterInvocationProviderManager</code>,它轮询 <code>AfterInvocationProvider</code> 的列表.
每个 <code>AfterInvocationProvider</code> 都可以修改返回对象或引发 <code>AccessDeniedException</code>.  实际上,由于前一个提供程序的结果将传递到列表中的下一个,因此多个提供程序可以修改对象.</p>
</div>
<div class="paragraph">
<p>请注意,如果您使用的是 <code>AfterInvocationManager</code>,则仍然需要允许 <code>MethodSecurityInterceptor</code> 的 <code>AccessDecisionManager</code> 进行操作的配置属性.
如果您使用的是典型的 Spring Security 随附的 <code>AccessDecisionManager</code> 实现,则未为特定的安全方法调用定义配置属性,这将导致每个 <code>AccessDecisionVoter</code> 放弃投票.
反过来,如果 <code>AccessDecisionManager</code> 属性 "allowIfAllAbstainDecisions" 为 <code>false</code>,则将引发 <code>AccessDeniedException</code>.  您可以通过
 (i) 将 "allowIfAllAbstainDecisions" 设置为 <code>true</code> (尽管通常不建议这样做) 或
 (ii) 仅确保至少有一个 <code>AccessDecisionVoter</code> 将投票批准授予访问权限的配置属性来避免此潜在问题.  后一种 (推荐) 方法通常是通过 <code>ROLE_USER或ROLE_AUTHENTICATED</code> 配置属性来实现的.</p>
</div>
</div>
<div class="sect3">
<h4 id="authz-hierarchical-roles"><a class="anchor" href="#authz-hierarchical-roles"></a>11.1.4. 角色层次</h4>
<div class="paragraph">
<p>通常要求应用程序中的特定角色应自动 "包括" 其他角色.  例如,在具有 "管理员" 和 "用户" 角色概念的应用程序中,您可能希望管理员能够执行普通用户可以执行的所有操作.
为此,您可以确保还为所有管理员用户分配了 "用户" 角色.  或者,您可以修改每个需要 "用户" 角色也要包括 "管理员" 角色的访问约束.  如果您的应用程序中有很多不同的角色,这可能会变得非常复杂.</p>
</div>
<div class="paragraph">
<p>使用角色层次结构,可以配置哪些角色 (或权限) 应包括其他角色.  Spring Security 的  <a href="#authz-role-voter">RoleVoter</a> 的扩展版本 <code>RoleHierarchyVoter</code> 配置有 <code>RoleHierarchy</code>,从中可以获取分配给用户的所有 "可访问权限".
典型的配置可能如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="roleVoter" class="org.springframework.security.access.vote.RoleHierarchyVoter"&gt;
    &lt;constructor-arg ref="roleHierarchy" /&gt;
&lt;/bean&gt;
&lt;bean id="roleHierarchy"
        class="org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl"&gt;
    &lt;property name="hierarchy"&gt;
        &lt;value&gt;
            ROLE_ADMIN &gt; ROLE_STAFF
            ROLE_STAFF &gt; ROLE_USER
            ROLE_USER &gt; ROLE_GUEST
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里,我们在层次结构 <code>ROLE_ADMIN⇒ROLE_STAFF⇒ROLE_USER⇒ROLE_GUEST</code> 中具有四个角色.  在对使用上述 <code>RoleHierarchyVoter</code> 配置的 <code>AccessDecisionManager</code> 评估安全约束时,使用 <code>ROLE_ADMIN</code> 进行身份验证的用户将表现为具有所有四个角色.  可以将 <code>&gt;</code> 符号视为 "includes".</p>
</div>
<div class="paragraph">
<p>角色层次结构为简化应用程序的访问控制配置数据 和/或 减少需要分配给用户的权限数量提供了一种方便的方法.  对于更复杂的要求,您可能希望在应用程序需要的特定访问权限与分配给用户的角色之间定义逻辑映射,并在加载用户信息时在两者之间进行转换.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-authorization-filtersecurityinterceptor"><a class="anchor" href="#servlet-authorization-filtersecurityinterceptor"></a>11.2. 使用 <code>FilterSecurityInterceptor</code> 授权 <code>HttpServletRequest</code></h3>
<div class="paragraph">
<p>本节通过深入研究 <a href="#servlet-authorization">authorization</a> 在基于 Servlet 的应用程序中的工作方式,以 <a href="#servlet-architecture">Servlet 体系结构和实现</a>为基础.</p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/access/intercept/FilterSecurityInterceptor.html"><code>FilterSecurityInterceptor</code></a>  为 <code>HttpServletRequests</code> 提供 <a href="#servlet-authorization">authorization</a>  .  它作为  <a href="#servlet-security-filters">Security Filters</a> 之一插入到 <a href="#servlet-filterchainproxy">FilterChainProxy</a> 中.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/authorization/filtersecurityinterceptor.png" alt="filtersecurityinterceptor">
</div>
<div class="title">Figure 13. Authorize HttpServletRequest</div>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> 首先,<code>FilterSecurityInterceptor</code> 从 <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a>  获得<a href="#servlet-authentication-authentication">Authentication</a>.</p>
</li>
<li>
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> 第二步,<code>FilterSecurityInterceptor</code> 根据传递到 <code>FilterSecurityInterceptor</code> 中的 <code>HttpServletRequest</code>,<code>HttpServletResponse</code> 和 <code>FilterChain</code> 创建一个 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/FilterInvocation.html"><code>FilterInvocation</code></a>.</p>
</li>
<li>
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> 接下来,它将 <code>FilterInvocation</code> 传递给 <code>SecurityMetadataSource</code> 以获取 <code>ConfigAttributes</code>.</p>
</li>
<li>
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_4.png" alt="number 4"></span> 最后,它将 <code>Authentication</code>,<code>FilterInvocation</code> 和 <code>ConfigAttributes</code> 传递给 <code>AccessDecisionManager</code>.</p>
<div class="ulist">
<ul>
<li>
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_5.png" alt="number 5"></span> 如果授权被拒绝,则抛出 <code>AccessDeniedException</code>.  在这种情况下,<a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> 处理 <code>AccessDeniedException</code>.</p>
</li>
<li>
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_6.png" alt="number 6"></span> 如果授予访问权限,<code>FilterSecurityInterceptor</code> 继续执行 <a href="#servlet-filters-review">FilterChain</a>,该链接可允许应用程序正常处理.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下,Spring Security 的授权将要求对所有请求进行身份验证.  显式配置如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 81. Every Request Must be Authenticated</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
    http
        // ...
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
        );
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;
    &lt;intercept-url pattern="/**" access="authenticated"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        // ...
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过按优先级添加更多规则,我们可以将 Spring Security 配置为具有不同的规则.</p>
</div>
<div class="exampleblock">
<div class="title">Example 82. Authorize Requests</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
    http
        // ...
        .authorizeRequests(authorize -&gt; authorize                                  <i class="conum" data-value="1"></i><b>(1)</b>
            .mvcMatchers("/resources/**", "/signup", "/about").permitAll()         <i class="conum" data-value="2"></i><b>(2)</b>
            .mvcMatchers("/admin/**").hasRole("ADMIN")                             <i class="conum" data-value="3"></i><b>(3)</b>
            .mvcMatchers("/db/**").access("hasRole('ADMIN') and hasRole('DBA')")   <i class="conum" data-value="4"></i><b>(4)</b>
            .anyRequest().denyAll()                                                <i class="conum" data-value="5"></i><b>(5)</b>
        );
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt; <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;!-- ... --&gt;
    <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;intercept-url pattern="/resources/**" access="permitAll"/&gt;
    &lt;intercept-url pattern="/signup" access="permitAll"/&gt;
    &lt;intercept-url pattern="/about" access="permitAll"/&gt;

    &lt;intercept-url pattern="/admin/**" access="hasRole('ADMIN')"/&gt; <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;intercept-url pattern="/db/**" access="hasRole('ADMIN') and hasRole('DBA')"/&gt; <i class="conum" data-value="4"></i><b>(4)</b>
    &lt;intercept-url pattern="/**" access="denyAll"/&gt; <i class="conum" data-value="5"></i><b>(5)</b>
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun configure(http: HttpSecurity) {
   http {
        authorizeRequests { <i class="conum" data-value="1"></i><b>(1)</b>
            authorize("/resources/**", permitAll) <i class="conum" data-value="2"></i><b>(2)</b>
            authorize("/signup", permitAll)
            authorize("/about", permitAll)

            authorize("/admin/**", hasRole("ADMIN")) <i class="conum" data-value="3"></i><b>(3)</b>
            authorize("/db/**", "hasRole('ADMIN') and hasRole('DBA')") <i class="conum" data-value="4"></i><b>(4)</b>
            authorize(anyRequest, denyAll) <i class="conum" data-value="5"></i><b>(5)</b>
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>指定了多个授权规则.  每个规则均按其声明顺序进行考虑.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>我们指定了任何用户都可以访问的多个 URL 模式.  具体来说,如果URL以 "/resources/" 开头,等于 "/signup" 或等于 "/about",则任何用户都可以访问请求.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>以 <code>"/admin/"</code> 开头的任何 URL 都将限于角色为 <code>ROLE_ADMIN</code> 的用户.  您将注意到,由于我们正在调用 <code>hasRole</code> 方法,因此无需指定 <code>ROLE_</code> 前缀.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>任何以 "/db/" 开头的 URL 都要求用户同时具有 "ROLE_ADMIN" 和 "ROLE_DBA".  您会注意到,由于我们使用的是 <code>hasRole</code> 表达式,因此不需要指定 "ROLE_" 前缀.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>任何尚未匹配的 URL 都会被拒绝访问.  如果您不想意外忘记更新授权规则,这是一个很好的策略.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="el-access"><a class="anchor" href="#el-access"></a>11.3. 基于表达式的访问控制</h3>
<div class="paragraph">
<p>Spring Security 3.0 引入了使用 Spring EL 表达式作为授权机制的能力,此外还可以简单地使用配置属性和访问决定投票器.  基于表达式的访问控制基于相同的体系结构,但允许将复杂的布尔逻辑封装在单个表达式中.</p>
</div>
<div class="sect3">
<h4 id="概述-2"><a class="anchor" href="#概述-2"></a>11.3.1. 概述</h4>
<div class="paragraph">
<p>Spring Security 使用 Spring EL 来支持表达式,如果您想更深入地了解该主题,则应该看看它的工作方式.  使用 "根对象" 评估表达式作为评估上下文的一部分.  Spring Security 使用特定的类将 Web 和方法的安全性用作根对象,以提供内置的表达式并访问诸如当前主体的值.</p>
</div>
<div class="sect4">
<h5 id="el-common-built-in"><a class="anchor" href="#el-common-built-in"></a>常见的内置表达式</h5>
<div class="paragraph">
<p>表达式根对象的基类是 <code>SecurityExpressionRoot</code>.  这提供了 Web 和方法安全性中都可用的一些常用表达式.</p>
</div>
<table id="common-expressions" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 10. 常见的内置表达式</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">表达式</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasRole(String role)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前主体具有指定角色,则返回 <code>true</code>.
例如, <code>hasRole('admin')</code>
默认情况下,如果提供的角色不是以 <code>ROLE_</code> 开头,则会添加该角色.  这可以通过修改 <code>DefaultWebSecurityExpressionHandler</code> 上的 <code>defaultRolePrefix</code> 进行自定义.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAnyRole(String&#8230;&#8203; roles)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前主体具有提供的任何角色(以逗号分隔的字符串列表形式) ,则返回 <code>true</code>.
例如, <code>hasAnyRole('admin', 'user')</code>
默认情况下,如果提供的角色不是以 <code>ROLE_</code> 开头,则会添加该角色.  这可以通过修改 <code>DefaultWebSecurityExpressionHandler</code> 上的 <code>defaultRolePrefix</code> 进行自定义.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAuthority(String authority)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前主体具有指定的权限,则返回 <code>true</code>.
例如, <code>hasAuthority('read')</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasAnyAuthority(String&#8230;&#8203; authorities)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前主体具有任何提供的授权(以逗号分隔的字符串列表形式) ,则返回 <code>true</code>
例如, <code>hasAnyAuthority('read', 'write')</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>principal</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许直接访问代表当前用户的主体对象</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>authentication</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">允许直接访问从 <code>SecurityContext</code> 获得的当前 <code>Authentication</code> 对象</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>permitAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">始终评估为 <code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>denyAll</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">总是评估为 <code>false</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isAnonymous()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前主体是匿名用户,则返回 <code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isRememberMe()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果当前主体是 "记住我" 用户,则返回 <code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isAuthenticated()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果用户不是匿名的,则返回 <code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>isFullyAuthenticated()</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果用户不是匿名用户或 "记住我" 用户,则返回 <code>true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasPermission(Object target, Object permission)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果用户可以访问给定权限的给定目标,则返回 <code>true</code>.  例如, <code>hasPermission(domainObject, 'read')</code>
For example,</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hasPermission(Object targetId, String targetType, Object permission)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果用户可以访问给定权限的给定目标,则返回 <code>true</code>.  例如,<code>hasPermission(1, 'com.example.domain.Message', 'read')</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="el-access-web"><a class="anchor" href="#el-access-web"></a>11.3.2. Web Security 表达式</h4>
<div class="paragraph">
<p>要使用表达式保护单个URL,首先需要将 <code>&lt;http&gt;</code> 元素中的 <code>use-expressions</code> 属性设置为 <code>true</code>.  然后,Spring Security将期望 <code>&lt;intercept-url&gt;</code> 元素的访问属性包含 Spring EL 表达式.  表达式的计算结果应为布尔值,定义是否应允许访问.  例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-url pattern="/admin*"
        access="hasRole('admin') and hasIpAddress('192.168.1.0/24')"/&gt;
    ...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里,我们定义了应用程序的 "admin" 区域(由URL模式定义) 仅对拥有授予权限 "admin" 并且其 IP 地址与本地子网匹配的用户可用.  在上一节中,我们已经看到了内置的 <code>hasRole</code> 表达式.  表达式 <code>hasIpAddress</code> 是特定于 Web 安全性的附加内置表达式.
它由 <code>WebSecurityExpressionRoot</code> 类定义,在评估 Web 访问表达式时,将其实例用作表达式根对象.  该对象还直接在名称请求下暴露 <code>HttpServletRequest</code> 对象,因此您可以直接在表达式中调用该请求.  如果使用表达式,则将 <code>WebExpressionVoter</code> 添加到命名空间使用的 <code>AccessDecisionManager</code> 中.  因此,如果您不使用命名空间而想使用表达式,则必须在配置中添加其中之一.</p>
</div>
<div class="sect4">
<h5 id="el-access-web-beans"><a class="anchor" href="#el-access-web-beans"></a>在Web安全表达式中引用Bean</h5>
<div class="paragraph">
<p>如果您希望扩展可用的表达式,则可以轻松地引用您暴露的任何 Spring Bean.  例如,假设您有一个名称为 <code>webSecurity</code> 的 Bean,其中包含以下方法签名:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WebSecurity {
        public boolean check(Authentication authentication, HttpServletRequest request) {
                ...
        }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class WebSecurity {
    fun check(authentication: Authentication?, request: HttpServletRequest?): Boolean {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用以下方法引用该方法:</p>
</div>
<div class="exampleblock">
<div class="title">Example 83. Refer to method</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">http
    .authorizeRequests(authorize -&gt; authorize
        .antMatchers("/user/**").access("@webSecurity.check(authentication,request)")
        ...
    )
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-url pattern="/user/**"
        access="@webSecurity.check(authentication,request)"/&gt;
    ...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">http {
    authorizeRequests {
        authorize("/user/**", "@webSecurity.check(authentication,request)")
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="el-access-web-path-variables"><a class="anchor" href="#el-access-web-path-variables"></a>Web安全表达式中的路径变量</h5>
<div class="paragraph">
<p>有时能够引用 URL 中的路径变量是很好的.  例如,考虑一个 RESTful 应用程序,该应用程序通过URL路径  <code>/user/{userId}</code> 的ID通过 ID 查找用户.</p>
</div>
<div class="paragraph">
<p>您可以通过将路径变量放在模式中来轻松地引用它.  例如,如果您有一个名称为 <code>webSecurity</code> 的 Bean,其中包含以下方法签名:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WebSecurity {
        public boolean checkUserId(Authentication authentication, int id) {
                ...
        }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class WebSecurity {
    fun checkUserId(authentication: Authentication?, id: Int): Boolean {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用以下方法引用该方法:</p>
</div>
<div class="exampleblock">
<div class="title">Example 84. Path Variables</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">http
    .authorizeRequests(authorize -&gt; authorize
        .antMatchers("/user/{userId}/**").access("@webSecurity.checkUserId(authentication,#userId)")
        ...
    );
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-url pattern="/user/{userId}/**"
        access="@webSecurity.checkUserId(authentication,#userId)"/&gt;
    ...
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">http {
    authorizeRequests {
        authorize("/user/{userId}/**", "@webSecurity.checkUserId(authentication,#userId)")
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通过这种配置,匹配的 URL 会将路径变量传递(并将其转换) 为 checkUserId 方法.  例如,如果 URL 为 <code>/user/123/resource</code>,则传入的 ID 为 <code>123</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="方法安全性表达式"><a class="anchor" href="#方法安全性表达式"></a>11.3.3. 方法安全性表达式</h4>
<div class="paragraph">
<p>方法安全性比简单的允许或拒绝规则要复杂一些.  为了提供对表达式使用的全面支持,Spring Security 3.0 引入了一些新的注解.</p>
</div>
<div class="sect4">
<h5 id="el-pre-post-annotations"><a class="anchor" href="#el-pre-post-annotations"></a>@Pre 和 @Post 注解</h5>
<div class="paragraph">
<p>有四个注解支持表达式属性,以允许调用前和调用后的授权检查,还支持过滤提交的集合参数或返回值.  它们是 <code>@PreAuthorize</code>,<code>@PreFilter</code>,<code>@PostAuthorize</code> 和 <code>@PostFilter</code>.  通过 <code>global-method-security</code> 命名空间元素启用它们的使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security pre-post-annotations="enabled"/&gt;</code></pre>
</div>
</div>
<div class="sect5">
<h6 id="使用-preauthorize-和-postauthorize-的访问控制"><a class="anchor" href="#使用-preauthorize-和-postauthorize-的访问控制"></a>使用 <code>@PreAuthorize</code> 和 <code>@PostAuthorize</code> 的访问控制</h6>
<div class="paragraph">
<p>最明显有用的注解是 <code>@PreAuthorize</code>,它决定是否可以实际调用方法.
例如(来自 "Contacts" 示例应用程序)</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasRole('USER')")
public void create(Contact contact);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@PreAuthorize("hasRole('USER')")
fun create(contact: Contact?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这意味着只有角色为 "ROLE_USER" 的用户才能访问.  显然,使用传统配置和所需角色的简单配置属性可以轻松实现同一目标.  但是关于:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasPermission(#contact, 'admin')")
public void deletePermission(Contact contact, Sid recipient, Permission permission);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@PreAuthorize("hasPermission(#contact, 'admin')")
fun deletePermission(contact: Contact?, recipient: Sid?, permission: Permission?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里,我们实际上是使用方法参数作为表达式的一部分,以确定当前用户是否具有给定联系人的 "admin" 权限.  内置的 <code>hasPermission()</code> 表达式通过应用程序上下文链接到 Spring Security ACL模块,<a href="#el-permission-evaluator">如下所示</a>.  您可以按名称作为表达式变量访问任何方法参数.</p>
</div>
<div class="paragraph">
<p>Spring Security 可以通过多种方式来解析方法参数.  Spring Security 使用 <code>DefaultSecurityParameterNameDiscoverer</code> 发现参数名称.  默认情况下,将对整个方法尝试以下选项.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>I如果Spring Security 的 <code>@P</code> 注解出现在方法的单个参数上,则将使用该值.  这对于使用 JDK 8 之前的 JDK 编译的接口非常有用,该接口不包含有关参数名称的任何信息.  例如:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.security.access.method.P;

</span><span class="fold-block">...

@PreAuthorize("#c.name == authentication.name")
public void doSomething(@P("c") Contact contact);
</span></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.security.access.method.P

...

@PreAuthorize("#c.name == authentication.name")
fun doSomething(@P("c") contact: Contact?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在后台使用 <code>AnnotationParameterNameDiscoverer</code> 实现此用法,可以对它进行自定义以支持任何指定注解的 <code>value</code> 属性.</p>
</div>
</li>
<li>
<p>如果该方法的至少一个参数上存在 Spring Data 的 <code>@Param</code> 注解,则将使用该值.  这对于使用 JDK 8 之前的 JDK 编译的接口非常有用,该接口不包含有关参数名称的任何信息.  例如:</p>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.data.repository.query.Param;

</span><span class="fold-block">...

@PreAuthorize("#n == authentication.name")
Contact findContactByName(@Param("n") String name);
</span></code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">import org.springframework.data.repository.query.Param

...

@PreAuthorize("#n == authentication.name")
fun findContactByName(@Param("n") name: String?): Contact?</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在后台使用 <code>AnnotationParameterNameDiscoverer</code> 实现此用法,可以对它进行自定义以支持任何指定注解的 <code>value</code> 属性.</p>
</div>
</li>
<li>
<p>如果使用 JDK 8 和 -parameters 参数来编译源代码,并且使用 Spring 4+,那么将使用标准 JDK 反射 API 来发现参数名称.
这适用于类和接口.</p>
</li>
<li>
<p>最后,如果代码是使用调试符号编译的,则将使用调试符号发现参数名称.  这对于接口不起作用,因为它们没有有关参数名称的调试信息.  对于接口,必须使用注解或 JDK 8 方法.</p>
</li>
</ul>
</div>
<div class="openblock">
<div class="title"><a id="el-pre-post-annotations-spel"></a></div>
<div class="content">
<div class="paragraph">
<p>表达式中提供了任何 Spring-EL 功能,因此您也可以访问参数的属性.  例如,如果您想要一种特定的方法仅允许访问其用户名与联系人的用户名匹配的用户,则可以编写</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("#contact.name == authentication.name")
public void doSomething(Contact contact);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@PreAuthorize("#contact.name == authentication.name")
fun doSomething(contact: Contact?)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这里,我们访问另一个内置表达式 <code>authentication</code>,这是存储在安全上下文中的 <code>Authentication</code>.  您也可以使用表达式 "principal" 直接访问其 <code>principal</code> 属性.  该值通常是 <code>UserDetails</code> 实例,因此您可以使用诸如 <code>principal.username</code> 或 <code>principal.enabled</code> 之类的表达式.</p>
</div>
<div class="openblock">
<div class="title"><a id="el-pre-post-annotations-post"></a></div>
<div class="content">
<div class="paragraph">
<p>不太常见的是,您可能希望在调用该方法之后执行访问控制检查.  这可以使用 <code>@PostAuthorize</code> 注解来实现.  要从方法访问返回值,请在表达式中使用内置名称 <code>returnObject</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="使用-prefilter-和-postfilter-过滤器"><a class="anchor" href="#使用-prefilter-和-postfilter-过滤器"></a>使用 @PreFilter 和 @PostFilter 过滤器</h6>
<div class="paragraph">
<p>您可能已经知道,Spring Security 支持 collections, arrays, maps 和 streams 的过滤,现在可以使用表达式来实现.  这通常在方法的返回值上执行.  例如:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasRole('USER')")
@PostFilter("hasPermission(filterObject, 'read') or hasPermission(filterObject, 'admin')")
public List&lt;Contact&gt; getAll();
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@PreAuthorize("hasRole('USER')")
@PostFilter("hasPermission(filterObject, 'read') or hasPermission(filterObject, 'admin')")
fun getAll(): List&lt;Contact?&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>@PostFilter</code> 注解时,Spring Security 迭代返回的集合,并删除提供的表达式为 <code>false</code> 的所有元素.对于数组， 将返回一个包含已过滤元素的新数组实例,名为 <code>filterObject</code> 引用集合中的当前对象.如果使用 Map， 它将引用当前的 <code>Map.Entry</code> 对象， 该对象允许在表达式中使用 <code>filterObject.key</code> 或  <code>filterObject.value</code>.
您也可以使用 <code>@PreFilter</code> 进行方法调用之前的过滤,尽管这种要求不太常见.  语法是一样的,但是如果有多个参数是集合类型,则必须使用此注解的 <code>filterTarget</code> 属性按名称选择一个.</p>
</div>
<div class="paragraph">
<p>请注意,过滤显然不能替代调整数据检索查询.  如果要过滤大型集合并删除许多条目,则效率可能很低.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="el-method-built-in"><a class="anchor" href="#el-method-built-in"></a>内置表达式</h5>
<div class="paragraph">
<p>有一些特定于方法安全性的内置表达式,我们已经在上面使用过.  <code>filterTarget</code> 和 <code>returnValue</code> 值很简单,但是使用 <code>hasPermission()</code> 表达式需要仔细观察.</p>
</div>
<div class="sect5">
<h6 id="el-permission-evaluator"><a class="anchor" href="#el-permission-evaluator"></a>PermissionEvaluator 接口</h6>
<div class="paragraph">
<p><code>hasPermission()</code> 表达式委托给 <code>PermissionEvaluator</code> 的实例.  它旨在在表达式系统和 Spring Security 的 ACL 系统之间架起桥梁,使您可以基于抽象权限在域对象上指定授权约束.  它对 ACL 模块没有明确的依赖,因此如果需要,您可以将其换成其他实现.  该接口有两种方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean hasPermission(Authentication authentication, Object targetDomainObject,
                            Object permission);

boolean hasPermission(Authentication authentication, Serializable targetId,
                            String targetType, Object permission);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>它直接映射到表达式的可用版本,但不提供第一个参数(<code>Authentication</code> 对象) .  第一种方法用于已经控制访问的域对象已经加载的情况.  如果当前用户对该对象具有给定的权限,则 expression 将返回 <code>true</code>.
第二种版本用于未加载对象但已知其标识符的情况.  还需要域对象的抽象 "type" 说明符,以允许加载正确的 ACL 权限.  传统上,这是对象的Java 类,但是不必与对象的权限加载方式一致.</p>
</div>
<div class="paragraph">
<p>要使用 <code>hasPermission()</code> 表达式,必须在应用程序上下文中显式配置 <code>PermissionEvaluator</code>.  看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;security:global-method-security pre-post-annotations="enabled"&gt;
&lt;security:expression-handler ref="expressionHandler"/&gt;
&lt;/security:global-method-security&gt;

&lt;bean id="expressionHandler" class=
"org.springframework.security.access.expression.method.DefaultMethodSecurityExpressionHandler"&gt;
    &lt;property name="permissionEvaluator" ref="myPermissionEvaluator"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>myPermissionEvaluator</code> 是实现 <code>PermissionEvaluator</code> 的bean.  通常,这将是来自 ACL 模块(称为 <code>AclPermissionEvaluator</code>) 的实现.  有关更多详细信息,请参见 "联系人" 示例应用程序配置.</p>
</div>
</div>
<div class="sect5">
<h6 id="方法安全性元注解"><a class="anchor" href="#方法安全性元注解"></a>方法安全性元注解</h6>
<div class="paragraph">
<p>您可以使用元注解来保证方法的安全性,以使代码更具可读性.  如果发现在整个代码库中重复相同的复杂表达式,这将特别方便.  例如,考虑以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("#contact.name == authentication.name")
</code></pre>
</div>
</div>
<div class="paragraph">
<p>无需在所有地方重复此操作,我们可以创建可以使用的元注解.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@PreAuthorize("#contact.name == authentication.name")
public @interface ContactPermission {}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Retention(AnnotationRetention.RUNTIME)
@PreAuthorize("#contact.name == authentication.name")
annotation class ContactPermission</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>元注解可以用于任何 Spring Security 方法安全注解.  为了保持符合规范,JSR-250 注解不支持元注解.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="secure-object-impls"><a class="anchor" href="#secure-object-impls"></a>11.4. 安全对象实现</h3>
<div class="sect3">
<h4 id="aop-alliance"><a class="anchor" href="#aop-alliance"></a>11.4.1. AOP 联盟 (MethodInvocation) 安全拦截器</h4>
<div class="paragraph">
<p>在 Spring Security 2.0 之前,确保 <code>MethodInvocation</code> 的安全需要大量样板配置.  现在,推荐的安全性方法是使用 <a href="#ns-method-security">命名空间配置</a>.  这样,方法安全性基础结构 bean 将自动为您配置,因此您实际上不需要了解实现类.  我们将仅简要介绍此处涉及的课程.</p>
</div>
<div class="paragraph">
<p>方法安全性是使用 <code>MethodSecurityInterceptor</code> 实施的,该方法可以保护 <code>MethodInvocation</code>.  根据配置方法,拦截器可能特定于单个 bean,也可能在多个bean之间共享.
拦截器使用 <code>MethodSecurityMetadataSource</code> 实例获取适用于特定方法调用的配置属性.  <code>MapBasedMethodSecurityMetadataSource</code> 用于存储以方法名称作为关键字的配置属性(可以使用通配符) ,
当使用 <code>&lt;intercept-methods&gt;</code> 或 <code>&lt;protect-point&gt;</code> 元素在应用程序上下文中定义属性时,将在内部使用该属性.  其他实现将用于处理基于注解的配置.</p>
</div>
<div class="sect4">
<h5 id="显式配置-securityinterceptor-方法"><a class="anchor" href="#显式配置-securityinterceptor-方法"></a>显式配置 <code>SecurityInterceptor</code> 方法</h5>
<div class="paragraph">
<p>当然,您可以直接在应用程序上下文中配置 <code>MethodSecurityInterceptor</code>,以与 Spring AOP 的代理机制之一配合使用:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="bankManagerSecurity" class=
    "org.springframework.security.access.intercept.aopalliance.MethodSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
&lt;property name="afterInvocationManager" ref="afterInvocationManager"/&gt;
&lt;property name="securityMetadataSource"&gt;
    &lt;sec:method-security-metadata-source&gt;
    &lt;sec:protect method="com.mycompany.BankManager.delete*" access="ROLE_SUPERVISOR"/&gt;
    &lt;sec:protect method="com.mycompany.BankManager.getBalance" access="ROLE_TELLER,ROLE_SUPERVISOR"/&gt;
    &lt;/sec:method-security-metadata-source&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="aspectj"><a class="anchor" href="#aspectj"></a>11.4.2. AspectJ (JoinPoint) 安全拦截器</h4>
<div class="paragraph">
<p>AspectJ 安全拦截器与上一节中讨论的 AOP Alliance 安全拦截器非常相似.
实际上,我们只会讨论本节中的区别.</p>
</div>
<div class="paragraph">
<p>AspectJ 拦截器被命名为 <code>AspectJSecurityInterceptor</code>.  与依赖于 Spring 应用程序上下文通过代理编织在安全拦截器中的 AOP Alliance 安全拦截器不同,<code>AspectJSecurityInterceptor</code> 通过 AspectJ 编译器进行编织.
在同一个应用程序中同时使用两种类型的安全拦截器并不少见,其中 <code>AspectJSecurityInterceptor</code> 用于域对象实例安全,而 AOP Alliance <code>MethodSecurityInterceptor</code> 用于服务层安全.</p>
</div>
<div class="paragraph">
<p>首先,让我们考虑如何在 Spring 应用程序上下文中配置 <code>AspectJSecurityInterceptor</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="bankManagerSecurity" class=
    "org.springframework.security.access.intercept.aspectj.AspectJMethodSecurityInterceptor"&gt;
&lt;property name="authenticationManager" ref="authenticationManager"/&gt;
&lt;property name="accessDecisionManager" ref="accessDecisionManager"/&gt;
&lt;property name="afterInvocationManager" ref="afterInvocationManager"/&gt;
&lt;property name="securityMetadataSource"&gt;
    &lt;sec:method-security-metadata-source&gt;
    &lt;sec:protect method="com.mycompany.BankManager.delete*" access="ROLE_SUPERVISOR"/&gt;
    &lt;sec:protect method="com.mycompany.BankManager.getBalance" access="ROLE_TELLER,ROLE_SUPERVISOR"/&gt;
    &lt;/sec:method-security-metadata-source&gt;
&lt;/property&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如您所见,除了类名之外,<code>AspectJSecurityInterceptor</code> 与 AOP Alliance 安全拦截器完全相同.  实际上,这两个拦截器可以共享相同的 <code>securityMetadataSource</code>,因为 <code>SecurityMetadataSource</code> 与 <code>java.lang.reflect.Method</code> 一起使用,而不是与AOP 库特定的类一起使用.
当然,您的访问决策可以访问相关的 AOP 库特定的调用(即 <code>MethodInvocation</code> 或 <code>JoinPoint</code>) ,因此在制定访问决策(例如方法参数) 时可以考虑一系列附加条件.</p>
</div>
<div class="paragraph">
<p>接下来,您需要定义 AspectJ <code>aspect</code>.  例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block">package org.springframework.security.samples.aspectj;

</span><span class="fold-block hide-when-folded">import org.springframework.security.access.intercept.aspectj.AspectJSecurityInterceptor;
import org.springframework.security.access.intercept.aspectj.AspectJCallback;
import org.springframework.beans.factory.InitializingBean;

</span><span class="fold-block">public aspect DomainObjectInstanceSecurityAspect implements InitializingBean {

    private AspectJSecurityInterceptor securityInterceptor;

    pointcut domainObjectInstanceExecution(): target(PersistableEntity)
        &amp;&amp; execution(public * *(..)) &amp;&amp; !within(DomainObjectInstanceSecurityAspect);

    Object around(): domainObjectInstanceExecution() {
        if (this.securityInterceptor == null) {
            return proceed();
        }

        AspectJCallback callback = new AspectJCallback() {
            public Object proceedWithObject() {
                return proceed();
            }
        };

        return this.securityInterceptor.invoke(thisJoinPoint, callback);
    }

    public AspectJSecurityInterceptor getSecurityInterceptor() {
        return securityInterceptor;
    }

    public void setSecurityInterceptor(AspectJSecurityInterceptor securityInterceptor) {
        this.securityInterceptor = securityInterceptor;
    }

    public void afterPropertiesSet() throws Exception {
        if (this.securityInterceptor == null)
            throw new IllegalArgumentException("securityInterceptor required");
        }
    }
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中,安全拦截器将应用于 <code>PersistableEntity</code> 的每个实例,这是一个未显示的抽象类(您可以使用喜欢的任何其他类或切入点表达式) .  对于那些好奇的人,需要使用 <code>AspectJCallback</code>,因为 <code>proced()</code>; 语句仅在 <code>around()</code> 主体内具有特殊含义.  当希望目标对象继续时,<code>AspectJSecurityInterceptor</code> 会调用此匿名 <code>AspectJCallback</code> 类.</p>
</div>
<div class="paragraph">
<p>您将需要配置 Spring 以加载方面并将其与 <code>AspectJSecurityInterceptor</code> 关联.  实现此目的的 bean 声明如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="domainObjectInstanceSecurityAspect"
    class="security.samples.aspectj.DomainObjectInstanceSecurityAspect"
    factory-method="aspectOf"&gt;
&lt;property name="securityInterceptor" ref="bankManagerSecurity"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>而已！ 现在,您可以使用自己认为合适的任何方式(例如 <code>new Person();</code>) 从应用程序中的任何位置创建 bean,并且将应用安全拦截器.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jc-method"><a class="anchor" href="#jc-method"></a>11.5. 方法的安全</h3>
<div class="paragraph">
<p>从 2.0 版开始,Spring Security 大大改进了对为服务层方法增加安全性的支持.
它提供对 JSR-250 注解安全性以及框架原始 <code>@Secured</code> 注解的支持.  从 3.0 开始,您还可以使用新的基于表达式的<a href="#el-access">基于表达式的注解</a>.  您可以使用 <code>intercept-methods</code> 元素来修饰 bean 声明,从而将安全性应用于单个 bean,或者可以使用 AspectJ 样式切入点在整个服务层中保护多个 bean.</p>
</div>
<div class="sect3">
<h4 id="enableglobalmethodsecurity"><a class="anchor" href="#enableglobalmethodsecurity"></a>11.5.1. EnableGlobalMethodSecurity</h4>
<div class="paragraph">
<p>我们可以在任何 <code>@Configuration</code> 实例上使用 <code>@EnableGlobalMethodSecurity</code> 注解启用基于注解的安全性.  例如,以下将启用Spring Security的 <code>@Secured</code> 注解.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableGlobalMethodSecurity(securedEnabled = true)
public class MethodSecurityConfig {
// ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>向方法(在类或接口上) 添加注解将相应地限制对该方法的访问.  Spring Security 的内置注解支持为该方法定义了一组属性.  这些将被传递给 <code>AccessDecisionManager</code> 做出实际决定:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用以下命令启用对 JSR-250 注解的支持</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableGlobalMethodSecurity(jsr250Enabled = true)
public class MethodSecurityConfig {
// ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些是基于标准的,并允许应用基于角色的简单约束,但是没有 Spring Security 的内置注解的强大功能.
要使用新的基于表达式的语法,可以使用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig {
// ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>而等效的Java代码将是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="globalmethodsecurityconfiguration"><a class="anchor" href="#globalmethodsecurityconfiguration"></a>11.5.2. GlobalMethodSecurityConfiguration</h4>
<div class="paragraph">
<p>有时您可能需要执行比 <code>@EnableGlobalMethodSecurity</code> 注解允许的操作更复杂的操作.  对于这些实例,可以扩展 <code>GlobalMethodSecurityConfiguration</code>,以确保 <code>@EnableGlobalMethodSecurity</code> 注解出现在子类中.
例如,如果您想提供一个自定义的 <code>MethodSecurityExpressionHandler</code>,则可以使用以下配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
    @Override
    protected MethodSecurityExpressionHandler createExpressionHandler() {
        // ... create and return custom MethodSecurityExpressionHandler ...
        return expressionHandler;
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关可以覆盖的方法的其他信息,请参考 <code>GlobalMethodSecurityConfiguration</code> Javadoc.</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-global-method"><a class="anchor" href="#ns-global-method"></a>11.5.3. &lt;global-method-security&gt; 元素</h4>
<div class="paragraph">
<p>此元素用于在您的应用程序中启用基于注解的安全性(通过在该元素上设置适当的属性) ,并将用于整个应用程序上下文的安全性切入点声明组合在一起.  您只应声明一个 <code>&lt;global-method-security&gt;</code> 元素.  以下声明将启用对 Spring Security 的 <code>@Secured</code> 的支持:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security secured-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>向方法(在类或接口上) 添加注解将相应地限制对该方法的访问.  Spring Security 的内置注解支持为该方法定义了一组属性.  这些将被传递给 <code>AccessDecisionManager</code> 做出实际决定:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface BankService {

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account readAccount(Long id);

@Secured("IS_AUTHENTICATED_ANONYMOUSLY")
public Account[] findAccounts();

@Secured("ROLE_TELLER")
public Account post(Account account, double amount);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用以下命令启用对 JSR-250 注解的支持</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security jsr250-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这些是基于标准的,并允许应用基于角色的简单约束,但是没有 Spring Security 的内置注解的强大功能.  要使用新的基于表达式的语法,可以使用</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security pre-post-annotations="enabled" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>而等效的Java代码将是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface BankService {

@PreAuthorize("isAnonymous()")
public Account readAccount(Long id);

@PreAuthorize("isAnonymous()")
public Account[] findAccounts();

@PreAuthorize("hasAuthority('ROLE_TELLER')")
public Account post(Account account, double amount);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您需要定义简单的规则,而不是根据用户的权限列表检查角色名称,则基于表达式的注解是一个不错的选择.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>带注解的方法仅对于定义为 Spring Bean 的实例(在启用方法安全性的同一应用程序上下文中) 是安全的.  如果要保护不是由 Spring 创建的实例(例如,使用 new 运算符) ,则需要使用 AspectJ.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以在同一应用程序中启用不止一种类型的注解,但是任何接口或类都只能使用一种类型的注解,否则将无法很好地定义行为.  如果找到两个适用于特定方法的注解,则将仅应用其中一个</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ns-protect-pointcut"><a class="anchor" href="#ns-protect-pointcut"></a>11.5.4. 使用  protect-pointcut 添加安全的切点</h4>
<div class="paragraph">
<p><code>protect-pointcut</code> 的使用特别强大,因为它允许您仅通过简单的声明就可以将安全性应用于许多 bean.  考虑以下示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security&gt;
&lt;protect-pointcut expression="execution(* com.mycompany.*Service.*(..))"
    access="ROLE_USER"/&gt;
&lt;/global-method-security&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将保护在应用程序上下文中声明的 bean(其类位于 <code>com.mycompany</code> 包中且其类名以 "Service" 结尾) 上的所有方法.  只有具有 <code>ROLE_USER</code> 角色的用户才能调用这些方法.  与 URL 匹配一样,最具体的匹配项必须在切入点列表中排在第一位,因为将使用第一个匹配表达式.  安全注解优先于切入点.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="domain-acls"><a class="anchor" href="#domain-acls"></a>11.6. 域对象安全 (ACLs)</h3>
<div class="sect3">
<h4 id="domain-acls-overview"><a class="anchor" href="#domain-acls-overview"></a>11.6.1. 概述</h4>
<div class="paragraph">
<p>复杂的应用程序经常会发现需要定义访问权限,而不仅仅是在 Web 请求或方法调用级别.  相反,安全决策需要同时包含谁 (<code>Authentication</code>) ,哪里 (<code>MethodInvocation</code>) 和什么 ((<code>SomeDomainObject</code>) .  换句话说,授权决策还需要考虑方法调用的实际域对象实例主题.</p>
</div>
<div class="paragraph">
<p>假设您正在设计宠物诊所的应用程序.  基于 Spring 的应用程序将有两个主要的用户组: 宠物诊所的工作人员以及宠物诊所的客户.  工作人员将有权访问所有数据,而您的客户只能看到自己的客户记录.
为了使其更具趣味性,您的客户可以允许其他用户查看其客户记录,例如其 "puppy preschool"  导师或本地 "Pony Club" 的总裁.  以 Spring Security 为基础,您可以使用几种方法:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>编写您的业务方法以增强安全性.  您可以在 <code>Customer</code>  域对象实例中查询集合,以确定哪些用户有权访问.  通过使用 <code>SecurityContextHolder.getContext().getAuthentication()</code>,您将能够访问 <code>Authentication</code> 对象.</p>
</li>
<li>
<p>编写一个 <code>AccessDecisionVoter</code> 以从存储在 <code>Authentication</code> 对象中的 <code>GrantedAuthority[]</code> 实施安全性.  这意味着您的 <code>AuthenticationManager</code> 将需要使用自定义 <code>GrantedAuthority[]</code> 填充 <code>Authentication</code>,这些 <code>GrantedAuthority[]</code> 代表主体可以访问的每个 <code>Customer</code> 域对象实例.</p>
</li>
<li>
<p>编写一个 <code>AccessDecisionVoter</code> 来增强安全性并直接打开目标客户域对象.  这意味着您的投票者需要访问 DAO,以使其能够检索 <code>Customer</code> 对象.  然后,它将访问 <code>Customer</code> 对象的已批准用户的集合,并做出适当的决定.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些方法中的每一种都是完全合法的. 但是,第一个将您的授权检查与您的业务代码结合在一起. 这样做的主要问题包括单元测试的难度增加以及在其他地方重用客户授权逻辑会更加困难. 从 <code>Authentication</code> 对象获取 <code>GrantedAuthority[]</code> 也可以,但是不能扩展到大量的 <code>Customer</code>.
如果用户可能能够访问 5000 个 <code>Customer</code> (在这种情况下不太可能,但是可以想象如果它是大型 "Pony Club" 的受欢迎的兽医！) ,那么构造 <code>Authentication</code> 对象所消耗的内存量和所需的时间将是不可取的. 最终的方法 (直接从外部代码打开客户) 可能是这三种方法中的最好方法.
它可以实现关注点分离,并且不会滥用内存或 CPU 周期,但是仍然效率低下,因为 <code>AccessDecisionVoter</code> 和最终的业务方法本身都将执行对负责检索 <code>Customer</code> 对象的 DAO 的调用. 每个方法调用两次访问显然是不可取的. 此外,列出每种方法后,
您都需要从头开始编写自己的访问控制列表 (ACL) 持久性和业务逻辑.</p>
</div>
<div class="paragraph">
<p>幸运的是,还有另一种选择,我们将在下面讨论.</p>
</div>
</div>
<div class="sect3">
<h4 id="domain-acls-key-concepts"><a class="anchor" href="#domain-acls-key-concepts"></a>11.6.2. 关键概念</h4>
<div class="paragraph">
<p>Spring Security 的 ACL 服务位于 <code>spring-security-acl-xxx.jar</code> 中.  您将需要将此 JAR 添加到类路径中,以使用 Spring Security 的域对象实例安全功能.</p>
</div>
<div class="paragraph">
<p>Spring Security 的域对象实例安全性功能以访问控制列表 (ACL) 的概念为中心.  系统中的每个域对象实例都有其自己的 ACL,并且该ACL 记录了谁可以使用该域对象以及不能使用该域对象的详细信息.  考虑到这一点,Spring Security 为您的应用程序提供了三个与 ACL 相关的主要功能:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一种有效检索所有域对象的 ACL 条目 (并修改这些 ACL) 的方法</p>
</li>
<li>
<p>确保在调用方法之前允许给定的主体处理对象的方法</p>
</li>
<li>
<p>在调用方法之后,一种确保给定的主体可用于对象 (或它们返回的对象) 的方法</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如第一个要点所示,Spring Security ACL 模块的主要功能之一就是提供了一种高性能的 ACL 检索方法.  这个 ACL 储存库功能非常重要,因为系统中的每个域对象实例都可能有多个访问控制项,并且每个 ACL 都可能以树状结构从其他 ACL 继承 (Spring 对此提供了开箱即用的支持)  安全性,并且非常常用) .
Spring Security 的 ACL 功能经过精心设计,可提供高性能的 ACL 检索,以及可插入的缓存,最小化死锁的数据库更新,与 ORM 框架的独立性 (我们直接使用JDBC) ,适当的封装以及透明的数据库更新.</p>
</div>
<div class="paragraph">
<p>给定数据库对于 ACL 模块的操作至关重要,让我们探讨一下实现中默认使用的四个主表.  下面是典型的 Spring Security ACL 部署中按大小顺序显示的表,最后列出的行数最多:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ACL_SID 允许我们唯一地标识系统中的任何主体或权限 ("SID" 代表 "安全身份") .  唯一的列是 ID,SID 的文本表示形式以及用于指示文本表示形式是引用主体名称还是 <code>GrantedAuthority</code> 的标志.  因此,每个唯一的主体或 <code>GrantedAuthority</code> 只有一行.  当在接收许可的上下文中使用 SID 时,通常将其称为 "收件人".</p>
</li>
<li>
<p>ACL_CLASS 允许我们唯一地标识系统中的任何域对象类.  唯一的列是 ID 和 Java 类名称.  因此,对于每个我们希望为其存储ACL权限的唯一类,都有一行.</p>
</li>
<li>
<p>ACL_OBJECT_IDENTITY 存储系统中每个唯一域对象实例的信息.  列包括 ID,ACL_CLASS 表的外键,唯一标识符,因此我们知道我们要为其提供信息的 ACL_CLASS 实例,父级,ACL_SID 表的外键以表示域对象实例的所有者,以及 是否允许 ACL 条目从任何父 ACL 继承.  对于要为其存储 ACL 权限的每个域对象实例,我们只有一行.</p>
</li>
<li>
<p>最后,ACL_ENTRY 存储分配给每个收件人的个人权限.  列包括 ACL_OBJECT_IDENTITY 的外键,接收者 (即 ACL_SID 的外键) ,是否进行审核以及表示授予或拒绝的实际权限的整数位掩码.  对于每个接收到使用域对象的权限的收件人,我们只有一行.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如上一段所述,ACL 系统使用整数位掩码.  不用担心,您不必了解使用 ACL 系统的位转换的优点,但是只要说我们有 32 位可以打开或关闭就可以了.
这些位中的每一个代表一个权限,默认情况下,权限为 read (bit 0), write (bit 1), create (bit 2), delete (bit 3) 和 administer (bit 4)..  如果您希望使用其他权限,则可以轻松实现自己的 <code>Permission</code> 实例,并且 ACL 框架的其余部分可以在不了解扩展程序的情况下运行.</p>
</div>
<div class="paragraph">
<p>请务必了解,系统中域对象的数量与我们选择使用整数位掩码这一事实完全无关.  尽管您有 32 位可用的权限,但您可能有数十亿个域对象实例 (这意味着 ACL_OBJECT_IDENTITY 中的数十亿行,很可能是 ACL_ENTRY) .  之所以说出这一点,是因为我们发现有时人们会误认为每个潜在的域对象都需要一点东西,事实并非如此.</p>
</div>
<div class="paragraph">
<p>现在,我们已经基本概述了 ACL 系统的功能以及它在表结构中的外观,下面我们来探讨关键界面.  关键接口是:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Acl</code>: 每个域对象只有一个 <code>Acl</code> 对象,该对象在内部保存 <code>AccessControlEntry</code>,并且知道 <code>Acl</code> 的所有者.  <code>Acl</code> 不直接引用域对象,而是引用 <code>ObjectIdentity</code>.  <code>Acl</code> 存储在 <code>ACL_OBJECT_IDENTITY</code> 表中.</p>
</li>
<li>
<p><code>AccessControlEntry</code>: 一个 <code>Acl</code> 包含多个 <code>AccessControlEntry</code>,在框架中通常缩写为 <code>ACE</code>.  每个 <code>ACE</code> 都引用 <code>Permission</code>,<code>Sid</code> 和 <code>Acl</code> 的特定元组.  <code>ACE</code> 也可以是授予或不授予的,并且包含审核设置.  <code>ACE</code> 存储在 <code>ACL_ENTRY</code> 表中.</p>
</li>
<li>
<p><code>Permission</code>: 权限表示特定的不可变位掩码,并提供用于位掩码和输出信息的便捷功能.  上面显示的基本权限 (第0位至第4位) 包含在 <code>BasePermission</code> 类中.</p>
</li>
<li>
<p><code>Sid</code>: ACL 模块需要引用主体和 <code>GrantedAuthority[]</code>.  Sid 接口提供了一个间接级别,它是 "安全身份" 的缩写.  常见的类包括 <code>PrincipalSid</code> (代表 <code>Authentication</code> 对象中的主体) 和 <code>GrantedAuthoritySid</code>.  安全标识信息存储在 ACL_SID 表中.</p>
</li>
<li>
<p><code>ObjectIdentity</code>: 每个域对象在ACL模块内部由一个ObjectIdentity表示.  默认实现为 <code>ObjectIdentityImpl</code>.</p>
</li>
<li>
<p><code>AclService</code>: 检索适用于给定 <code>ObjectIdentity</code> 的 <code>Acl</code>.  在包含的实现 (<code>JdbcAclService</code>) 中,将检索操作委托给 <code>LookupStrategy</code>.  <code>LookupStrategy</code> 提供了一种高度优化的策略,用于使用批量检索 (<code>BasicLookupStrategy</code>) 来检索 <code>ACL</code> 信息,并支持利用实例化视图,分层查询和类似的以性能为中心的非 ANSI SQL 功能的自定义实现.</p>
</li>
<li>
<p><code>MutableAclService</code>: 允许显示修改后的 <code>Acl</code> 以保持持久性.  如果您不愿意,则不必使用此界面.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意,我们现成的 AclService 和相关数据库类均使用 ANSI SQL.  因此,这应该适用于所有主要数据库.  在撰写本文时,已使用Hypersonic SQL,PostgreSQL,Microsoft SQL Server 和 Oracle 成功测试了该系统.</p>
</div>
<div class="paragraph">
<p>Spring Security附带了两个示例,它们演示了ACL模块.  第一个是联系人示例,另一个是文档管理系统 (DMS) 示例.  我们建议您看一下这些作为示例.</p>
</div>
</div>
<div class="sect3">
<h4 id="domain-acls-getting-started"><a class="anchor" href="#domain-acls-getting-started"></a>11.6.3. 入门</h4>
<div class="paragraph">
<p>要开始使用 Spring Security 的 ACL 功能,您需要将 ACL 信息存储在某处.  这需要使用 Spring 实例化 <code>DataSource</code>.  然后将 <code>DataSource</code> 注入到 <code>JdbcMutableAclService</code> 和 <code>BasicLookupStrategy</code> 实例中.
后者提供高性能的ACL检索功能,而前者提供了 mutator 功能.  有关示例配置,请参阅 Spring Security 附带的示例之一.  您还需要使用上一节中列出的四个特定于 ACL 的表格填充数据库 (有关适当的 SQL 语句,请参阅 ACL 示例) .</p>
</div>
<div class="paragraph">
<p>创建所需的架构并实例化 <code>JdbcMutableAclService</code> 之后,接下来需要确保您的 domain 模型支持与 Spring Security ACL 软件包的互操作性.  希望 <code>ObjectIdentityImpl</code> 将证明是足够的,因为它提供了多种使用方式.
大多数人将拥有包含公共 <code>Serializable getId()</code> 方法的域对象.  如果返回类型为 long 或与 long 兼容 (例如 int) ,则将发现不需要进一步考虑 <code>ObjectIdentity</code> 问题.  ACL 模块的许多部分都依赖长标识符.
如果您使用的不是 long 型 (或 int,byte 等) ,则很有可能需要重新实现许多类.  我们不打算在 Spring Security 的 ACL 模块中支持非长标识符,因为长已经与所有数据库序列 (最常见的标识符数据类型) 兼容,并且长度足以容纳所有常见的使用情况.</p>
</div>
<div class="paragraph">
<p>以下代码片段显示了如何创建 <code>Acl</code> 或修改现有的 <code>Acl</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Prepare the information we'd like in our access control entry (ACE)
ObjectIdentity oi = new ObjectIdentityImpl(Foo.class, new Long(44));
Sid sid = new PrincipalSid("Samantha");
Permission p = BasePermission.ADMINISTRATION;

// Create or update the relevant ACL
MutableAcl acl = null;
try {
acl = (MutableAcl) aclService.readAclById(oi);
} catch (NotFoundException nfe) {
acl = aclService.createAcl(oi);
}

// Now grant some permissions via an access control entry (ACE)
acl.insertAce(acl.getEntries().length, p, sid, true);
aclService.updateAcl(acl);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中,我们检索了与标识符为 44 的 "Foo" 域对象相关联的 ACL. 然后,我们添加了 ACE,以便名为 "Samantha" 的主体可以 "管理" 该对象.
除了 insertAce 方法外,该代码段是相对不言自明的.  insertAce 方法的第一个参数是确定新条目将在 Acl 中的哪个位置插入.  在上面的示例中,我们只是将新的 ACE 放在现有 ACE 的末尾.  最后一个参数是布尔值,指示 ACE 是授予还是拒绝.  在大多数情况下,它会被授予 (true) ,但是如果它被拒绝 (false) ,则实际上会阻止该权限.</p>
</div>
<div class="paragraph">
<p>Spring Security 没有提供任何特殊的集成来自动创建,更新或删除 ACL,这是 DAO 或存储库操作的一部分.  相反,您将需要为单个域对象编写如上所示的代码.  值得考虑的是在服务层上使用 AOP 来自动将 ACL 信息与服务层操作集成在一起.  过去,我们发现这种方法非常有效.</p>
</div>
<div class="paragraph">
<p>使用上述技术在数据库中存储一些 ACL 信息后,下一步就是实际将 ACL 信息用作授权决策逻辑的一部分.  您在这里有很多选择.  您可以编写自己的 <code>AccessDecisionVoter</code> 或 <code>AfterInvocationProvider</code>,它们分别在方法调用之前或之后触发.
这样的类将使用 <code>AclService</code> 来检索相关的 ACL,然后调用 <code>Acl.isGranted(Permission[] permission, Sid[] sids, boolean administrativeMode)</code>  来确定是否授予权限.  或者,
您可以使用我们的 <code>AclEntryVoter</code>,<code>AclEntryAfterInvocationProvider</code> 或 <code>AclEntryAfterInvocationCollectionFilteringProvider</code> 类.
所有这些类都提供了一种基于声明的方法,用于在运行时评估 ACL 信息,使您无需编写任何代码.  请参考示例应用程序以了解如何使用这些类.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="oauth2"><a class="anchor" href="#oauth2"></a>12. OAuth2</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="oauth2login"><a class="anchor" href="#oauth2login"></a>12.1. OAuth 2.0 登录</h3>
<div class="paragraph">
<p>OAuth 2.0 登录功能为应用程序提供了让用户可以在提供了 OAuth 2.0 (例如 GitHub) 或 OpenID Connect 1.0 (例如 Google) 协议的第三方平台,使用平台现有帐户登录该应用程序的功能.  OAuth 2.0 登录实现了以下用例: "使用 Google 登录" 或 "使用 GitHub 登录".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
OAuth 2.0 登录是通过使用 <a href="https://tools.ietf.org/html/rfc6748#section-4.1">OAuth 2.0 Authorization Framework</a> 和 <a href="https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">OpenID Connect Core 1.0</a> 中指定的授权码授权来实现的.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="oauth2login-sample-boot"><a class="anchor" href="#oauth2login-sample-boot"></a>12.1.1. Spring Boot 2.x 示例</h4>
<div class="paragraph">
<p>Spring Boot 2.x 为 OAuth 2.0 登录带来了完整的自动配置功能.</p>
</div>
<div class="paragraph">
<p>本部分显示了如何使用 Google 作为身份验证提供程序来配置 <a href="https://github.com/spring-projects/spring-security/master//boot/oauth2login"><strong>OAuth 2.0 Login sample</strong></a>,并涵盖以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-sample-initial-setup">初始设置</a></p>
</li>
<li>
<p><a href="#oauth2login-sample-redirect-uri">设置重定向 URI</a></p>
</li>
<li>
<p><a href="#oauth2login-sample-application-config">配置 application.yml</a></p>
</li>
<li>
<p><a href="#oauth2login-sample-boot-application">启动应用程序</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-initial-setup"><a class="anchor" href="#oauth2login-sample-initial-setup"></a>初始设置</h5>
<div class="paragraph">
<p>要使用 Google 的 OAuth 2.0 身份验证系统登录,您必须在 Google API 控制台中设置一个项目以获得 OAuth 2.0 凭据.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://developers.google.com/identity/protocols/OpenIDConnect">Google&#8217;s OAuth 2.0 实现</a> 符合 <a href="https://openid.net/connect/">OpenID Connect 1.0</a> 规范,并且已通过 <a href="https://openid.net/certification/">OpenID Certified</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>请按照设置 <a href="https://developers.google.com/identity/protocols/OpenIDConnect">OpenID Connect</a>  (需要翻墙才能访问,链接打开是 Google 的开发者平台控制台) 部分开始的 OpenID Connect 页面上的说明进行操作.</p>
</div>
<div class="paragraph">
<p>完成 "获取 OAuth 2.0 凭据" 说明后,您应该拥有一个新的 OAuth 客户端,其凭据由 Client ID 和 Client Secret.组成.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-redirect-uri"><a class="anchor" href="#oauth2login-sample-redirect-uri"></a>设置重定向URI</h5>
<div class="paragraph">
<p>重定向URI是用户的在通过 Google 身份验证并在授权页面上同意 (<em>(<a href="#oauth2login-sample-initial-setup">在上一步中创建</a>)</em>) OAuth客户端的访问权限后,由 Google 重定向的回调链接地址</p>
</div>
<div class="paragraph">
<p>在 设置重定向 URI 子章节中,确保将  <strong>Authorized redirect URIs</strong> 字段设置为 <code><a href="http://localhost:8080/login/oauth2/code/google" class="bare">localhost:8080/login/oauth2/code/google</a></code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
默认重定向 URI 模板为 <code>{baseUrl}/login/oauth2/code/{registrationId}</code> .  <strong><em>registrationId</em></strong> 是 <a href="#oauth2Client-client-registration">ClientRegistration</a> 的唯一标识符.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
如果 OAuth 客户端在代理服务器 (例如: Nginx) 后面运行,建议检查<a href="#http-proxy-server">代理服务器配置</a>以确保正确配置了应用程序.  另外,请参阅 <code>redirect-uri</code> 支持的<a href="#oauth2Client-auth-code-redirect-uri"><code>URI</code> 模板变量</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-application-config"><a class="anchor" href="#oauth2login-sample-application-config"></a>配置application.yml</h5>
<div class="paragraph">
<p>现在,您有了 Google 的新 OAuth 客户端,您需要配置应用程序以将 OAuth 客户端用于身份验证流程.  为此:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>转到 <code>application.yml</code> 并设置以下配置:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:   <i class="conum" data-value="1"></i><b>(1)</b>
          google:   <i class="conum" data-value="2"></i><b>(2)</b>
            client-id: google-client-id
            client-secret: google-client-secret</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 85. OAuth客户端属性</div>
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>spring.security.oauth2.client.registration</code> 是 OAuth 客户端属性的基本属性前缀.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>基本属性前缀后面是<a href="#oauth2Client-client-registration">ClientRegistration</a>的 ID,例如 google</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>将 <code>client-id</code> 和 <code>client-secret</code> 属性中的值替换为您先前创建的 OAuth 2.0 凭据.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-sample-boot-application"><a class="anchor" href="#oauth2login-sample-boot-application"></a>启动应用程序</h5>
<div class="paragraph">
<p>启动 Spring Boot 2.x 示例并转到 <code><a href="http://localhost:8080" class="bare">localhost:8080</a></code>.  然后,您将会被重定向到默认自动生成的登录页面,该页面显示 Google 的链接.</p>
</div>
<div class="paragraph">
<p>单击 Google 链接,然后您将重定向到 Google 进行身份验证.</p>
</div>
<div class="paragraph">
<p>在使用您的 Google 帐户凭据进行身份验证之后,显示给您的下一页是 <strong>Allow</strong> 页面.   <strong>Allow</strong> 页面要求您允许或拒绝之前创建的 OAuth 客户端的访问权限.  点击 <strong>Allow</strong> 以授权 OAuth 客户端访问您的电子邮件地址和基本个人资料信息.</p>
</div>
<div class="paragraph">
<p>此时,OAuth 客户端将从 <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">UserInfo Endpoint</a> 检索您的电子邮件地址和基本个人资料信息,并建立经过身份验证的会话.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-boot-property-mappings"><a class="anchor" href="#oauth2login-boot-property-mappings"></a>12.1.2. Spring Boot 2.x 属性映射</h4>
<div class="paragraph">
<p>下表概述了 Spring Boot 2.x OAuth 客户端属性到 <a href="#oauth2Client-client-registration">ClientRegistration</a> 属性的映射.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Spring Boot 2.x</th>
<th class="tableblock halign-left valign-top">ClientRegistration</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>registrationId</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-id</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientId</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-secret</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientSecret</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-authentication-method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientAuthenticationMethod</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.authorization-grant-type</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>authorizationGrantType</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.redirect-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>redirectUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.scope</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>scopes</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.registration.<em>[registrationId]</em>.client-name</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>clientName</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.authorization-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.authorizationUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.token-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.tokenUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.jwk-set-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.jwkSetUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.issuer-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.issuerUri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.user-info-uri</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.userInfoEndpoint.uri</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.user-info-authentication-method</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.userInfoEndpoint.authenticationMethod</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.security.oauth2.client.provider.<em>[providerId]</em>.user-name-attribute</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>providerDetails.userInfoEndpoint.userNameAttributeName</code></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
可以通过 OpenID Connect 提供商的 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Configuration endpoint</a> 或授权服务器的 <a href="https://tools.ietf.org/html/rfc8414#section-3">Metadata endpoint</a>,来初始配置 <code>ClientRegistration</code>,指定  <code>spring.security.oauth2.client.provider.<em>[providerId]</em>.issuer-uri</code> 属性
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-common-oauth2-provider"><a class="anchor" href="#oauth2login-common-oauth2-provider"></a>12.1.3. CommonOAuth2Provider</h4>
<div class="paragraph">
<p><code>CommonOAuth2Provider</code> 为许多著名提供了 Oauth2.0 登录程序的服务商 (Google,GitHub,Facebook 和 Okta) 预定义了一组默认客户端属性.</p>
</div>
<div class="paragraph">
<p>例如,对于提供者,<code>authorization-uri</code>,<code>token-uri</code> 和 <code>user-info-uri</code> 不会经常更改.  因此,提供默认值以减少所需的配置是有意义的.</p>
</div>
<div class="paragraph">
<p>如前所述,当我们 <a href="#oauth2login-sample-application-config">配置Google客户端</a>时,仅需要 <code>client-id</code> 和 <code>client-secret</code> 属性.</p>
</div>
<div class="paragraph">
<p>以下清单显示了一个示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: google-client-id
            client-secret: google-client-secret</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
客户端属性会自动默认配置,因为 <code>registrationId</code> (google) 与 <code>CommonOAuth2Provider</code> 中的 <code>GOOGLE</code> 枚举 (不区分大小写) 匹配.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>对于您可能想要指定其他 <code>registrationId</code> 的情况 (例如 <code>google-login</code>) ,您仍然可以通过配置 <code>provider</code> 属性来利用客户端属性的自动默认设置.</p>
</div>
<div class="paragraph">
<p>以下清单显示了一个示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          google-login: <i class="conum" data-value="1"></i><b>(1)</b>
            provider: google    <i class="conum" data-value="2"></i><b>(2)</b>
            client-id: google-client-id
            client-secret: google-client-secret</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>registrationId</code> 设置为 <code>google-login</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>provider</code> 属性设置为 <code>google</code>,这将利用 <code>CommonOAuth2Provider.GOOGLE.getBuilder()</code> 中设置的客户端属性的自动默认设置.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-custom-provider-properties"><a class="anchor" href="#oauth2login-custom-provider-properties"></a>12.1.4. 配置自定义 提供者 属性</h4>
<div class="paragraph">
<p>有些 OAuth 2.0 提供程序支持多租户,这会导致每个租户 (或子域) 使用不同的 Protocol Endpoints .</p>
</div>
<div class="paragraph">
<p>例如,向 Okta 注册的 OAuth 客户端被分配给特定的子域,并拥有自己的 Protocol Endpoint.</p>
</div>
<div class="paragraph">
<p>对于这些情况,Spring Boot 2.x 提供以下用于配置自定义提供程序属性的基本属性:  <code>spring.security.oauth2.client.provider.<em>[providerId]</em></code>.</p>
</div>
<div class="paragraph">
<p>以下清单显示了一个示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
        provider:
          okta: <i class="conum" data-value="1"></i><b>(1)</b>
            authorization-uri: https://your-subdomain.oktapreview.com/oauth2/v1/authorize
            token-uri: https://your-subdomain.oktapreview.com/oauth2/v1/token
            user-info-uri: https://your-subdomain.oktapreview.com/oauth2/v1/userinfo
            user-name-attribute: sub
            jwk-set-uri: https://your-subdomain.oktapreview.com/oauth2/v1/keys</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>基本属性 (<code>spring.security.oauth2.client.provider.okta</code>) 允许自定义 Protocol Endpoint 位置的配置.</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-override-boot-autoconfig"><a class="anchor" href="#oauth2login-override-boot-autoconfig"></a>12.1.5. 覆盖Spring Boot 2.x自动配置</h4>
<div class="paragraph">
<p>用于 OAuth 客户端支持的 Spring Boot 2.x 自动配置类是 <code>OAuth2ClientAutoConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>它执行以下任务:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从配置的 OAuth 客户端属性中注册由 <code>ClientRegistration</code> 组成的 <code>ClientRegistrationRepository</code> <code>@Bean</code>.</p>
</li>
<li>
<p>提供 <code>WebSecurityConfigurerAdapter</code> <code>@Configuration</code> 并通过 <code>httpSecurity.oauth2Login()</code> 启用 OAuth 2.0 登录.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您需要根据自己的特定要求覆盖自动配置,则可以通过以下方式进行:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-register-clientregistrationrepository-bean">注册一个 <code>ClientRegistrationRepository</code> <code>@Bean</code></a></p>
</li>
<li>
<p><a href="#oauth2login-provide-websecurityconfigureradapter">提供一个 <code>WebSecurityConfigurerAdapter</code></a></p>
</li>
<li>
<p><a href="#oauth2login-completely-override-autoconfiguration">完全覆盖自动配置</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="oauth2login-register-clientregistrationrepository-bean"><a class="anchor" href="#oauth2login-register-clientregistrationrepository-bean"></a>注册一个 ClientRegistrationRepository @Bean</h5>
<div class="paragraph">
<p>下面例子展示如何注册一个 <code>ClientRegistrationRepository</code> <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class OAuth2LoginConfig {

    @Bean
    public ClientRegistrationRepository clientRegistrationRepository() {
        return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
    }

    private ClientRegistration googleClientRegistration() {
        return ClientRegistration.withRegistrationId("google")
            .clientId("google-client-id")
            .clientSecret("google-client-secret")
            .clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)
            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
            .redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
            .scope("openid", "profile", "email", "address", "phone")
            .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
            .tokenUri("https://www.googleapis.com/oauth2/v4/token")
            .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
            .userNameAttributeName(IdTokenClaimNames.SUB)
            .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
            .clientName("Google")
            .build();
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class OAuth2LoginConfig {
    @Bean
    fun clientRegistrationRepository(): ClientRegistrationRepository {
        return InMemoryClientRegistrationRepository(googleClientRegistration())
    }

    private fun googleClientRegistration(): ClientRegistration {
        return ClientRegistration.withRegistrationId("google")
                .clientId("google-client-id")
                .clientSecret("google-client-secret")
                .clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
                .scope("openid", "profile", "email", "address", "phone")
                .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
                .tokenUri("https://www.googleapis.com/oauth2/v4/token")
                .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
                .userNameAttributeName(IdTokenClaimNames.SUB)
                .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
                .clientName("Google")
                .build()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-provide-websecurityconfigureradapter"><a class="anchor" href="#oauth2login-provide-websecurityconfigureradapter"></a>Provide a WebSecurityConfigurerAdapter</h5>
<div class="paragraph">
<p>以下示例显示如何为 <code>WebSecurityConfigurerAdapter</code> 提供 <code>@EnableWebSecurity</code> 并通过 <code>httpSecurity.oauth2Login()</code> 启用 OAuth 2.0 登录:</p>
</div>
<div class="exampleblock">
<div class="title">Example 86. OAuth2 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2Login(withDefaults());
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2Login { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-completely-override-autoconfiguration"><a class="anchor" href="#oauth2login-completely-override-autoconfiguration"></a>完全覆盖自动配置</h5>
<div class="paragraph">
<p>下面的示例演示如何通过注册 <code>ClientRegistrationRepository</code> <code>@Bean</code> 并提供 <code>WebSecurityConfigurerAdapter</code> 来完全覆盖自动配置.</p>
</div>
<div class="exampleblock">
<div class="title">Example 87. Overriding the auto-configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class OAuth2LoginConfig {

    @EnableWebSecurity
    public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                .authorizeRequests(authorize -&gt; authorize
                    .anyRequest().authenticated()
                )
                .oauth2Login(withDefaults());
        }
    }

    @Bean
    public ClientRegistrationRepository clientRegistrationRepository() {
        return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
    }

    private ClientRegistration googleClientRegistration() {
        return ClientRegistration.withRegistrationId("google")
            .clientId("google-client-id")
            .clientSecret("google-client-secret")
            .clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)
            .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
            .redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
            .scope("openid", "profile", "email", "address", "phone")
            .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
            .tokenUri("https://www.googleapis.com/oauth2/v4/token")
            .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
            .userNameAttributeName(IdTokenClaimNames.SUB)
            .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
            .clientName("Google")
            .build();
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
class OAuth2LoginConfig {

    @EnableWebSecurity
    class OAuth2LoginSecurityConfig: WebSecurityConfigurerAdapter() {

        override fun configure(http: HttpSecurity) {
            http {
                authorizeRequests {
                    authorize(anyRequest, authenticated)
                }
                oauth2Login { }
            }
        }
    }

    @Bean
    fun clientRegistrationRepository(): ClientRegistrationRepository {
        return InMemoryClientRegistrationRepository(googleClientRegistration())
    }

    private fun googleClientRegistration(): ClientRegistration {
        return ClientRegistration.withRegistrationId("google")
                .clientId("google-client-id")
                .clientSecret("google-client-secret")
                .clientAuthenticationMethod(ClientAuthenticationMethod.BASIC)
                .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)
                .redirectUri("{baseUrl}/login/oauth2/code/{registrationId}")
                .scope("openid", "profile", "email", "address", "phone")
                .authorizationUri("https://accounts.google.com/o/oauth2/v2/auth")
                .tokenUri("https://www.googleapis.com/oauth2/v4/token")
                .userInfoUri("https://www.googleapis.com/oauth2/v3/userinfo")
                .userNameAttributeName(IdTokenClaimNames.SUB)
                .jwkSetUri("https://www.googleapis.com/oauth2/v3/certs")
                .clientName("Google")
                .build()
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-javaconfig-wo-boot"><a class="anchor" href="#oauth2login-javaconfig-wo-boot"></a>12.1.6. 低于 Spring Boot 2.x 使用 Java 配置</h4>
<div class="paragraph">
<p>如果您无法使用 Spring Boot 2.x,并且想在 <code>CommonOAuth2Provider</code> 中配置预定义的提供程序之一 (例如 <code>Google</code>) ,请应用以下配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 88. OAuth2 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class OAuth2LoginConfig {

    @EnableWebSecurity
    public static class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                .authorizeRequests(authorize -&gt; authorize
                    .anyRequest().authenticated()
                )
                .oauth2Login(withDefaults());
        }
    }

    @Bean
    public ClientRegistrationRepository clientRegistrationRepository() {
        return new InMemoryClientRegistrationRepository(this.googleClientRegistration());
    }

    @Bean
    public OAuth2AuthorizedClientService authorizedClientService(
            ClientRegistrationRepository clientRegistrationRepository) {
        return new InMemoryOAuth2AuthorizedClientService(clientRegistrationRepository);
    }

    @Bean
    public OAuth2AuthorizedClientRepository authorizedClientRepository(
            OAuth2AuthorizedClientService authorizedClientService) {
        return new AuthenticatedPrincipalOAuth2AuthorizedClientRepository(authorizedClientService);
    }

    private ClientRegistration googleClientRegistration() {
        return CommonOAuth2Provider.GOOGLE.getBuilder("google")
            .clientId("google-client-id")
            .clientSecret("google-client-secret")
            .build();
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http auto-config="true"&gt;
    &lt;intercept-url pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-login authorized-client-repository-ref="authorizedClientRepository"/&gt;
&lt;/http&gt;

&lt;client-registrations&gt;
    &lt;client-registration registration-id="google"
                         client-id="google-client-id"
                         client-secret="google-client-secret"
                         provider-id="google"/&gt;
&lt;/client-registrations&gt;

&lt;b:bean id="authorizedClientService"
        class="org.springframework.security.oauth2.client.InMemoryOAuth2AuthorizedClientService"
        autowire="constructor"/&gt;

&lt;b:bean id="authorizedClientRepository"
        class="org.springframework.security.oauth2.client.web.AuthenticatedPrincipalOAuth2AuthorizedClientRepository"&gt;
    &lt;b:constructor-arg ref="authorizedClientService"/&gt;
&lt;/b:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2login-advanced"><a class="anchor" href="#oauth2login-advanced"></a>12.1.7. 高级配置</h4>
<div class="paragraph">
<p><code>HttpSecurity.oauth2Login()</code> 提供了许多用于自定义 OAuth 2.0 登录的配置选项. 主要配置选项分为它们的 Protocol Endpoint 对应项.</p>
</div>
<div class="paragraph">
<p>例如, <code>oauth2Login().authorizationEndpoint()</code> 允许配置 <em>Authorization Endpoint</em>, <code>oauth2Login().tokenEndpoint()</code> 允许配置  <em>Token Endpoint</em>.</p>
</div>
<div class="paragraph">
<p>如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 89. Advanced OAuth2 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Login(oauth2 -&gt; oauth2
                .authorizationEndpoint(authorization -&gt; authorization
                        ...
                )
                .redirectionEndpoint(redirection -&gt; redirection
                        ...
                )
                .tokenEndpoint(token -&gt; token
                        ...
                )
                .userInfoEndpoint(userInfo -&gt; userInfo
                        ...
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                authorizationEndpoint {
                    ...
                }
                redirectionEndpoint {
                    ...
                }
                tokenEndpoint {
                    ...
                }
                userInfoEndpoint {
                    ...
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>oauth2Login()</code> DSL 的主要目标是与规范中定义的命名紧密一致. .</p>
</div>
<div class="paragraph">
<p>OAuth 2.0 授权框架对 <a href="https://tools.ietf.org/html/rfc6749#section-3">Protocol Endpoint</a> (协议端点) 的定义如下:</p>
</div>
<div class="paragraph">
<p>授权过程利用两个授权服务端 Endpoint (HTTP 资源) :</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Authorization Endpoint (授权端点) : 客户端用于通过用户代理重定向从资源所有者获取授权.</p>
</li>
<li>
<p>Token Endpoint (令牌端点) : 客户端用于交换访问令牌的授权授权,通常使用客户端身份验证.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以及一个客户端 Endpoint:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Redirection Endpoint (重定向端点) : 授权服务器用于通过资源所有者用户将包含授权证书的响应返回给客户端.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>OpenID Connect Core 1.0规范定义了 <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">UserInfo Endpoint</a> 如下:</p>
</div>
<div class="paragraph">
<p>UserInfo Endpoint 是 OAuth 2.0 受保护的资源,它返回有关经过身份验证的终端用户的声明.
为了获得所请求的有关终端用户的声明,客户端使用通过 OpenID Connect Authentication 获得的访问令牌向 UserInfo Endpoint 发出请求.
这些声明通常由 JSON 对象表示,该对象包含声明的名称/值对的集合.</p>
</div>
<div class="paragraph">
<p>以下代码显示了可用于 <code>oauth2Login()</code> DSL的完整配置选项:</p>
</div>
<div class="exampleblock">
<div class="title">Example 90. OAuth2 Login Configuration Options</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Login(oauth2 -&gt; oauth2
                .clientRegistrationRepository(this.clientRegistrationRepository())
                .authorizedClientRepository(this.authorizedClientRepository())
                .authorizedClientService(this.authorizedClientService())
                .loginPage("/login")
                .authorizationEndpoint(authorization -&gt; authorization
                    .baseUri(this.authorizationRequestBaseUri())
                    .authorizationRequestRepository(this.authorizationRequestRepository())
                    .authorizationRequestResolver(this.authorizationRequestResolver())
                )
                .redirectionEndpoint(redirection -&gt; redirection
                    .baseUri(this.authorizationResponseBaseUri())
                )
                .tokenEndpoint(token -&gt; token
                    .accessTokenResponseClient(this.accessTokenResponseClient())
                )
                .userInfoEndpoint(userInfo -&gt; userInfo
                    .userAuthoritiesMapper(this.userAuthoritiesMapper())
                    .userService(this.oauth2UserService())
                    .oidcUserService(this.oidcUserService())
                    .customUserType(GitHubOAuth2User.class, "github")
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                clientRegistrationRepository = clientRegistrationRepository()
                authorizedClientRepository = authorizedClientRepository()
                authorizedClientService = authorizedClientService()
                loginPage = "/login"
                authorizationEndpoint {
                    baseUri = authorizationRequestBaseUri()
                    authorizationRequestRepository = authorizationRequestRepository()
                    authorizationRequestResolver = authorizationRequestResolver()
                }
                redirectionEndpoint {
                    baseUri = authorizationResponseBaseUri()
                }
                tokenEndpoint {
                    accessTokenResponseClient = accessTokenResponseClient()
                }
                userInfoEndpoint {
                    userAuthoritiesMapper = userAuthoritiesMapper()
                    userService = oauth2UserService()
                    oidcUserService = oidcUserService()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了 <code>oauth2Login()</code> DSL 外,还支持 XML 配置.</p>
</div>
<div class="paragraph">
<p>以下代码显示了  <a href="#nsa-oauth2-login">security namespace</a> 中可用的完整配置选项:</p>
</div>
<div class="exampleblock">
<div class="title">Example 91. OAuth2 Login XML Configuration Options</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-login client-registration-repository-ref="clientRegistrationRepository"
                  authorized-client-repository-ref="authorizedClientRepository"
                  authorized-client-service-ref="authorizedClientService"
                  authorization-request-repository-ref="authorizationRequestRepository"
                  authorization-request-resolver-ref="authorizationRequestResolver"
                  access-token-response-client-ref="accessTokenResponseClient"
                  user-authorities-mapper-ref="userAuthoritiesMapper"
                  user-service-ref="oauth2UserService"
                  oidc-user-service-ref="oidcUserService"
                  login-processing-url="/login/oauth2/code/*"
                  login-page="/login"
                  authentication-success-handler-ref="authenticationSuccessHandler"
                  authentication-failure-handler-ref="authenticationFailureHandler"
                  jwt-decoder-factory-ref="jwtDecoderFactory"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下各节详细介绍了每个可用的配置选项:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-advanced-login-page">OAuth 2.0 登录页</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-redirection-endpoint">重定向 Endpoint</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-userinfo-endpoint">UserInfo Endpoint</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-login-page"><a class="anchor" href="#oauth2login-advanced-login-page"></a>OAuth 2.0 Login Page</h5>
<div class="paragraph">
<p>默认情况下,OAuth 2.0 登录页面由 <code>DefaultLoginPageGeneratingFilter</code> 自动生成.  默认登录页面显示每个配置的 OAuth 客户端及其 <code>ClientRegistration.clientName</code> 作为链接,该客户端能够启动授权请求 (或 OAuth 2.0 登录) .</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
为了使 <code>DefaultLoginPageGeneratingFilter</code> 显示已配置的OAuth客户端的链接,注册的 <code>ClientRegistrationRepository</code> 还需要实现  <code>Iterable&lt;ClientRegistration&gt;</code>..  请参阅 <code>InMemoryClientRegistrationRepository</code> 以获取参考.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>每个OAuth客户端的链接目标默认为以下位置:</p>
</div>
<div class="paragraph">
<p><code>OAuth2AuthorizationRequestRedirectFilter.DEFAULT_AUTHORIZATION_REQUEST_BASE_URI</code> + "/{registrationId}"</p>
</div>
<div class="paragraph">
<p>下面的行显示了一个示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;a href="/oauth2/authorization/google"&gt;Google&lt;/a&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要覆盖默认登录页面,请配置 <code>oauth2Login().loginPage()</code> 和 <code>oauth2Login().authorizationEndpoint().baseUri()</code>  (可选) .</p>
</div>
<div class="paragraph">
<p>以下清单显示了一个示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 92. OAuth2 Login Page Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Login(oauth2 -&gt; oauth2
                .loginPage("/login/oauth2")
                ...
                .authorizationEndpoint(authorization -&gt; authorization
                    .baseUri("/login/oauth2/authorization")
                    ...
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                loginPage = "/login/oauth2"
                authorizationEndpoint {
                    baseUri = "/login/oauth2/authorization"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-login login-page="/login/oauth2"
                  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
您需要提供一个  <code>@RequestMapping("/login/oauth2")</code> 的 <code>@Controller</code>,该渲染器能够呈现自定义登录页面.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如前所述,配置 <code>oauth2Login().authorizationEndpoint().baseUri()</code>  是可选的.  但是,如果选择自定义它,请确保到每个 OAuth 客户端的链接都与 <code>authorizationEndpoint().baseUri()</code> 相匹配.</p>
</div>
<div class="paragraph">
<p>下面的行显示了一个示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;a href="/login/oauth2/authorization/google"&gt;Google&lt;/a&gt;</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-redirection-endpoint"><a class="anchor" href="#oauth2login-advanced-redirection-endpoint"></a>重定向端点</h5>
<div class="paragraph">
<p>重定向端点是授权服务器通过资源所有者用户将授权响应 (包含授权凭证) 返回给客户端.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
OAuth 2.0 登录利用授权码授权.  因此,授权凭证是授权码.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认的授权响应 <code>baseUri</code> (重定向端点) 是 <code><strong>/login/oauth2/code/</strong>*</code>,在 <code>OAuth2LoginAuthenticationFilter.DEFAULT_FILTER_PROCESSES_URI</code> 中定义.</p>
</div>
<div class="paragraph">
<p>如果要自定义 授权响应 <code>baseUri</code>,请按以下示例所示进行配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 93. Redirection Endpoint Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Login(oauth2 -&gt; oauth2
                .redirectionEndpoint(redirection -&gt; redirection
                    .baseUri("/login/oauth2/callback/*")
                    ...
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                redirectionEndpoint {
                    baseUri = "/login/oauth2/callback/*"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-login login-processing-url="/login/oauth2/callback/*"
                  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您还需要确保 <code>ClientRegistration.redirectUri</code> 与自定义的授权响应 <code>baseUri</code> 匹配.</p>
</div>
<div class="paragraph">
<p>以下清单显示了一个示例:</p>
</div>
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">return CommonOAuth2Provider.GOOGLE.getBuilder("google")
    .clientId("google-client-id")
    .clientSecret("google-client-secret")
    .redirectUri("{baseUrl}/login/oauth2/callback/{registrationId}")
    .build();
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">return CommonOAuth2Provider.GOOGLE.getBuilder("google")
    .clientId("google-client-id")
    .clientSecret("google-client-secret")
    .redirectUri("{baseUrl}/login/oauth2/callback/{registrationId}")
    .build()</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-userinfo-endpoint"><a class="anchor" href="#oauth2login-advanced-userinfo-endpoint"></a>UserInfo Endpoint</h5>
<div class="paragraph">
<p>UserInfo 端点包括许多配置选项,如以下小节所述:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-advanced-map-authorities">用户权限映射</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-oauth2-user-service">OAuth 2.0 UserService</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-oidc-user-service">OpenID Connect 1.0 UserService</a></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="oauth2login-advanced-map-authorities"><a class="anchor" href="#oauth2login-advanced-map-authorities"></a>用户权限映射</h6>
<div class="paragraph">
<p>用户成功通过 OAuth 2.0 提供者进行身份验证之后,可以将 <code>OAuth2User.getAuthorities()</code>  (或 <code>OidcUser.getAuthorities()</code>) 映射到一组新的 <code>GrantedAuthority</code> 实例,这些实例将在完成身份验证时提供给 <code>OAuth2AuthenticationToken</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>OAuth2AuthenticationToken.getAuthorities()</code> 用于请求授权,例如 <code>hasRole('USER')</code> 或 <code>hasRole('ADMIN')</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>映射用户权限时,有两个选项可供选择:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2login-advanced-map-authorities-grantedauthoritiesmapper">使用 GrantedAuthoritiesMapper</a></p>
</li>
<li>
<p><a href="#oauth2login-advanced-map-authorities-oauth2userservice">OAuth2UserService 使用委托机制 </a></p>
</li>
</ul>
</div>
<div class="sect6">
<h7 id="oauth2login-advanced-map-authorities-grantedauthoritiesmapper"><a class="anchor" href="#oauth2login-advanced-map-authorities-grantedauthoritiesmapper"></a>使用 GrantedAuthoritiesMapper</h7>
<div class="paragraph">
<p>提供 <code>GrantedAuthoritiesMapper</code> 的实现,并按以下示例所示进行配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 94. Granted Authorities Mapper Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Login(oauth2 -&gt; oauth2
                .userInfoEndpoint(userInfo -&gt; userInfo
                    .userAuthoritiesMapper(this.userAuthoritiesMapper())
                    ...
                )
            );
    }

    private GrantedAuthoritiesMapper userAuthoritiesMapper() {
        return (authorities) -&gt; {
            Set&lt;GrantedAuthority&gt; mappedAuthorities = new HashSet&lt;&gt;();

            authorities.forEach(authority -&gt; {
                if (OidcUserAuthority.class.isInstance(authority)) {
                    OidcUserAuthority oidcUserAuthority = (OidcUserAuthority)authority;

                    OidcIdToken idToken = oidcUserAuthority.getIdToken();
                    OidcUserInfo userInfo = oidcUserAuthority.getUserInfo();

                    // Map the claims found in idToken and/or userInfo
                    // to one or more GrantedAuthority's and add it to mappedAuthorities

                } else if (OAuth2UserAuthority.class.isInstance(authority)) {
                    OAuth2UserAuthority oauth2UserAuthority = (OAuth2UserAuthority)authority;

                    Map&lt;String, Object&gt; userAttributes = oauth2UserAuthority.getAttributes();

                    // Map the attributes found in userAttributes
                    // to one or more GrantedAuthority's and add it to mappedAuthorities

                }
            });

            return mappedAuthorities;
        };
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    userAuthoritiesMapper = userAuthoritiesMapper()
                }
            }
        }
    }

    private fun userAuthoritiesMapper(): GrantedAuthoritiesMapper = GrantedAuthoritiesMapper { authorities: Collection&lt;GrantedAuthority&gt; -&gt;
        val mappedAuthorities = emptySet&lt;GrantedAuthority&gt;()

        authorities.forEach { authority -&gt;
            if (authority is OidcUserAuthority) {
                val idToken = authority.idToken
                val userInfo = authority.userInfo
                // Map the claims found in idToken and/or userInfo
                // to one or more GrantedAuthority's and add it to mappedAuthorities
            } else if (authority is OAuth2UserAuthority) {
                val userAttributes = authority.attributes
                // Map the attributes found in userAttributes
                // to one or more GrantedAuthority's and add it to mappedAuthorities
            }
        }

        mappedAuthorities
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-login user-authorities-mapper-ref="userAuthoritiesMapper"
                  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者,您可以注册 <code>GrantedAuthoritiesMapper</code> <code>@Bean</code> 使其自动应用于配置,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 95. Granted Authorities Mapper Bean Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Login(withDefaults());
    }

    @Bean
    public GrantedAuthoritiesMapper userAuthoritiesMapper() {
        ...
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login { }
        }
    }

    @Bean
    fun userAuthoritiesMapper(): GrantedAuthoritiesMapper {
        ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect6">
<h7 id="oauth2login-advanced-map-authorities-oauth2userservice"><a class="anchor" href="#oauth2login-advanced-map-authorities-oauth2userservice"></a>OAuth2UserService 使用委托机制</h7>
<div class="paragraph">
<p>与使用 <code>GrantedAuthoritiesMapper</code> 相比,这是一种高级策略,也更灵活,因为它使您可以访问 <code>OAuth2UserRequest</code> 和 <code>OAuth2User</code> (使用OAuth 2.0 UserService 时) 或 <code>OidcUserRequest</code> 和 <code>OidcUser</code> (使用 OpenID Connect 1.0 UserService 时) .</p>
</div>
<div class="paragraph">
<p><code>OAuth2UserRequest</code> (和 <code>OidcUserRequest</code>) 为您提供了对关联的 <code>OAuth2AccessToken</code> 的访问权限,这在委托者需要从受保护的资源中获取权限信息才能为其映射用户的自定义权限时非常有用.</p>
</div>
<div class="paragraph">
<p>以下示例显示如何使用 OpenID Connect 1.0 UserService  实现和配置基于委派的策略:</p>
</div>
<div class="exampleblock">
<div class="title">Example 96. OAuth2UserService Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Login(oauth2 -&gt; oauth2
                .userInfoEndpoint(userInfo -&gt; userInfo
                    .oidcUserService(this.oidcUserService())
                    ...
                )
            );
    }

    private OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; oidcUserService() {
        final OidcUserService delegate = new OidcUserService();

        return (userRequest) -&gt; {
            // Delegate to the default implementation for loading a user
            OidcUser oidcUser = delegate.loadUser(userRequest);

            OAuth2AccessToken accessToken = userRequest.getAccessToken();
            Set&lt;GrantedAuthority&gt; mappedAuthorities = new HashSet&lt;&gt;();

            // TODO
            // 1) Fetch the authority information from the protected resource using accessToken
            // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities

            // 3) Create a copy of oidcUser but use the mappedAuthorities instead
            oidcUser = new DefaultOidcUser(mappedAuthorities, oidcUser.getIdToken(), oidcUser.getUserInfo());

            return oidcUser;
        };
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    oidcUserService = oidcUserService()
                }
            }
        }
    }

    @Bean
    fun oidcUserService(): OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; {
        val delegate = OidcUserService()

        return OAuth2UserService { userRequest -&gt;
            // Delegate to the default implementation for loading a user
            var oidcUser = delegate.loadUser(userRequest)

            val accessToken = userRequest.accessToken
            val mappedAuthorities = HashSet&lt;GrantedAuthority&gt;()

            // TODO
            // 1) Fetch the authority information from the protected resource using accessToken
            // 2) Map the authority information to one or more GrantedAuthority's and add it to mappedAuthorities
            // 3) Create a copy of oidcUser but use the mappedAuthorities instead
            oidcUser = DefaultOidcUser(mappedAuthorities, oidcUser.idToken, oidcUser.userInfo)

            oidcUser
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-login oidc-user-service-ref="oidcUserService"
                  ...
    /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="oauth2login-advanced-oauth2-user-service"><a class="anchor" href="#oauth2login-advanced-oauth2-user-service"></a>OAuth 2.0 UserService</h6>
<div class="paragraph">
<p><code>DefaultOAuth2UserService</code> 是支持标准 OAuth 2.0 提供程序的 <code>OAuth2UserService</code> 的实现.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2UserService</code> (通过使用授权流程中授权客户端的访问令牌) 从 UserInfo 端点获取最终用户 (资源所有者) 的用户属性,并以 <code>OAuth2User</code> 的形式返回 <code>AuthenticatedPrincipal</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当在 UserInfo 端点上请求用户属性时,<code>DefaultOAuth2UserService</code> 使用 <code>RestOperations</code>.</p>
</div>
<div class="paragraph">
<p>如果需要自定义 UserInfo 请求的预处理,则可以为 <code>DefaultOAuth2UserService.setRequestEntityConverter()</code> 提供自定义 <code>Converter&lt;OAuth2UserRequest, RequestEntity&lt;?&gt;&gt;</code>..
默认实现 <code>OAuth2UserRequestEntityConverter</code> 构建 UserInfo 请求的 <code>RequestEntity</code> 表示形式,默认情况下在 <code>Authorization</code> 头中设置 <code>OAuth2AccessToken</code>.</p>
</div>
<div class="paragraph">
<p>另一方面,如果您需要自定义 UserInfo Response 的后处理,则需要向 <code>DefaultOAuth2UserService.setRestOperations()</code> 提供一个自定义配置的 <code>RestOperations</code>.  默认的 <code>RestOperations</code> 配置如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RestTemplate restTemplate = new RestTemplate();
restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());
</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> 是一个 <code>ResponseErrorHandler</code>,可以处理 OAuth 2.0 错误 (400 错误请求) .  它使用 <code>OAuth2ErrorHttpMessageConverter</code> 将 OAuth 2.0 错误参数转换为 <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>无论您是自定义 <code>DefaultOAuth2UserService</code> 还是提供自己的 <code>OAuth2UserService</code> 的实现,都需要按以下示例所示进行配置:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Login(oauth2 -&gt; oauth2
                .userInfoEndpoint(userInfo -&gt; userInfo
                    .userService(this.oauth2UserService())
                    ...
                )
            );
    }

    private OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; oauth2UserService() {
        ...
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    userService = oauth2UserService()
                    // ...
                }
            }
        }
    }

    private fun oauth2UserService(): OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="oauth2login-advanced-oidc-user-service"><a class="anchor" href="#oauth2login-advanced-oidc-user-service"></a>OpenID Connect 1.0 UserService</h6>
<div class="paragraph">
<p><code>OidcUserService</code> 是 <code>OAuth2UserService</code> 的实现,它支持OpenID Connect 1.0.</p>
</div>
<div class="paragraph">
<p>当在 UserInfo 端点请求用户属性时,<code>OidcUserService</code> 利用 <code>DefaultOAuth2UserService</code>.</p>
</div>
<div class="paragraph">
<p>如果需要自定义 UserInfo 请求的预处理 and/or UserInfo 响应的后处理,则需要为  <code>OidcUserService.setOauth2UserService()</code>  提供一个自定义配置的 <code>DefaultOAuth2UserService</code>.</p>
</div>
<div class="paragraph">
<p>无论您是自定义 <code>OidcUserService</code> 还是为 OpenID Connect 1.0 自己提供 <code>OAuth2UserService</code> 的实现,都需要对其进行配置,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Login(oauth2 -&gt; oauth2
                .userInfoEndpoint(userInfo -&gt; userInfo
                    .oidcUserService(this.oidcUserService())
                    ...
                )
            );
    }

    private OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; oidcUserService() {
        ...
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Login {
                userInfoEndpoint {
                    oidcUserService = oidcUserService()
                    // ...
                }
            }
        }
    }

    private fun oidcUserService(): OAuth2UserService&lt;OidcUserRequest, OidcUser&gt; {
        // ...
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-idtoken-verify"><a class="anchor" href="#oauth2login-advanced-idtoken-verify"></a>ID令牌签名验证</h5>
<div class="paragraph">
<p>OpenID Connect 1.0 身份验证引入了 <a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken">ID Token</a>,它是一种安全令牌,其中包含有关由客户端使用授权服务器进行的终端用户身份验证的声明.</p>
</div>
<div class="paragraph">
<p>ID令牌表示为JSON Web令牌( <a href="https://tools.ietf.org/html/rfc7519">JSON Web Token</a>(JWT)),并且必须使用JSON Web签名( <a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature</a>(JWS))进行签名.</p>
</div>
<div class="paragraph">
<p><code>OidcIdTokenDecoderFactory</code> 提供了一个 <code>JwtDecoder</code> 用于 <code>OidcIdToken</code> 签名验证.  默认算法为 RS256,但是在客户端注册期间分配时可能会有所不同.  对于这些情况,可以将解析程序配置为返回分配给特定客户端的预期JWS算法.</p>
</div>
<div class="paragraph">
<p>JWS 算法解析器是一个接受 <code>ClientRegistration</code> 并返回客户端期望的 <code>JwsAlgorithm</code> 的函数,例如.  <code>SignatureAlgorithm.RS256</code> 或 <code>MacAlgorithm.HS256</code></p>
</div>
<div class="paragraph">
<p>以下代码显示了如何针对所有 <code>ClientRegistration</code> 将 <code>OidcIdTokenDecoderFactory</code>  <code>@Bean</code> 配置为默认为 <code>MacAlgorithm.HS256</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JwtDecoderFactory&lt;ClientRegistration&gt; idTokenDecoderFactory() {
    OidcIdTokenDecoderFactory idTokenDecoderFactory = new OidcIdTokenDecoderFactory();
    idTokenDecoderFactory.setJwsAlgorithmResolver(clientRegistration -&gt; MacAlgorithm.HS256);
    return idTokenDecoderFactory;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun idTokenDecoderFactory(): JwtDecoderFactory&lt;ClientRegistration?&gt; {
    val idTokenDecoderFactory = OidcIdTokenDecoderFactory()
    idTokenDecoderFactory.setJwsAlgorithmResolver { MacAlgorithm.HS256 }
    return idTokenDecoderFactory
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
对于基于 MAC 的算法 (例如 <code>HS256</code>,<code>HS384</code> 或 <code>HS512</code>) ,将与 <code>client-id</code> 对应的 <code>client-secret</code> 用作对称密钥以进行签名验证.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
如果为 OpenID Connect 1.0 身份验证配置了多个 <code>ClientRegistration</code>,则 JWS 算法解析器可以评估提供的 <code>ClientRegistration</code> 以确定要返回的算法.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2login-advanced-oidc-logout"><a class="anchor" href="#oauth2login-advanced-oidc-logout"></a>OpenID Connect 1.0 注销</h5>
<div class="paragraph">
<p>OpenID Connect 会话管理 1.0 允许使用客户端在提供商处注销最终用户.  可用的策略之一是 <a href="https://openid.net/specs/openid-connect-session-1_0.html#RPLogout">RP-Initiated Logout</a>.</p>
</div>
<div class="paragraph">
<p>如果 OpenID 提供程序同时支持会话管理和 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">发现</a>,则客户端可以从 OpenID 提供程序的发现 <a href="https://openid.net/specs/openid-connect-session-1_0.html#OPMetadata">发现元数据</a> 中获取 <code>end_session_endpoint</code> <code>URL</code>.  可以通过使用 <code>issuer-uri</code> 配置 <code>ClientRegistration</code> 来实现,如以下示例所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            ...
        provider:
          okta:
            issuer-uri: https://dev-1234.oktapreview.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>…和实现 RP-Initiated 注销的 <code>OidcClientInitiatedLogoutSuccessHandler</code> 可以配置如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private ClientRegistrationRepository clientRegistrationRepository;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2Login(withDefaults())
            .logout(logout -&gt; logout
                .logoutSuccessHandler(oidcLogoutSuccessHandler())
            );
    }

    private LogoutSuccessHandler oidcLogoutSuccessHandler() {
        OidcClientInitiatedLogoutSuccessHandler oidcLogoutSuccessHandler =
                new OidcClientInitiatedLogoutSuccessHandler(this.clientRegistrationRepository);

        // Sets the location that the End-User's User Agent will be redirected to
        // after the logout has been performed at the Provider
        oidcLogoutSuccessHandler.setPostLogoutRedirectUri("{baseUrl}");

        return oidcLogoutSuccessHandler;
    }
}

NOTE: `OidcClientInitiatedLogoutSuccessHandler` 支持 `{baseUrl}` 占位符.
如果使用,则应用程序的基本URL (例如, `https://app.example.org`) 将在请求时替换它.
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2LoginSecurityConfig : WebSecurityConfigurerAdapter() {
    @Autowired
    private lateinit var clientRegistrationRepository: ClientRegistrationRepository

    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2Login { }
            logout {
                logoutSuccessHandler = oidcLogoutSuccessHandler()
            }
        }
    }

    private fun oidcLogoutSuccessHandler(): LogoutSuccessHandler {
        val oidcLogoutSuccessHandler = OidcClientInitiatedLogoutSuccessHandler(clientRegistrationRepository)

        // Sets the location that the End-User's User Agent will be redirected to
        // after the logout has been performed at the Provider
        oidcLogoutSuccessHandler.setPostLogoutRedirectUri("{baseUrl}")
        return oidcLogoutSuccessHandler
    }
}

NOTE: `OidcClientInitiatedLogoutSuccessHandler` 支持 `{baseUrl}` 占位符.
如果使用,则应用程序的基本 URL (例如, `https://app.example.org`) 将在请求时替换它.</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oauth2client"><a class="anchor" href="#oauth2client"></a>12.2. OAuth 2.0 客户端</h3>
<div class="paragraph">
<p>OAuth 2.0 客户端功能提供了对 <a href="https://tools.ietf.org/html/rfc6749#section-1.1">OAuth 2.0 授权框架</a>中定义的客户端角色的支持.</p>
</div>
<div class="paragraph">
<p>在较高级别,可用的核心功能包括:</p>
</div>
<div class="ulist">
<div class="title">授权支持</div>
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-1.3.1">授权码</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-6">刷新令牌</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-1.3.4">客户端凭证</a></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc6749#section-1.3.3">资源所有者密码凭证</a></p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">HTTP 客户端支持</div>
<ul>
<li>
<p><a href="#oauth2Client-webclient-servlet">在 Servlet 环境中集成 <code>WebClient</code></a> (用于请求受保护的资源)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>HttpSecurity.oauth2Client()</code> DSL 提供了许多配置选项,用于自定义 OAuth 2.0 客户端使用的核心组件.  另外, <code>HttpSecurity.oauth2Client().authorizationCodeGrant()</code> 启用自定义授权码授权.</p>
</div>
<div class="paragraph">
<p>以下代码显示了 <code>HttpSecurity.oauth2Client()</code> DSL 提供的完整配置选项:</p>
</div>
<div class="exampleblock">
<div class="title">Example 97. OAuth2 Client Configuration Options</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Client(oauth2 -&gt; oauth2
                .clientRegistrationRepository(this.clientRegistrationRepository())
                .authorizedClientRepository(this.authorizedClientRepository())
                .authorizedClientService(this.authorizedClientService())
                .authorizationCodeGrant(codeGrant -&gt; codeGrant
                    .authorizationRequestRepository(this.authorizationRequestRepository())
                    .authorizationRequestResolver(this.authorizationRequestResolver())
                    .accessTokenResponseClient(this.accessTokenResponseClient())
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                clientRegistrationRepository = clientRegistrationRepository()
                authorizedClientRepository = authorizedClientRepository()
                authorizedClientService = authorizedClientService()
                authorizationCodeGrant {
                    authorizationRequestRepository = authorizationRequestRepository()
                    authorizationRequestResolver = authorizationRequestResolver()
                    accessTokenResponseClient = accessTokenResponseClient()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>除了 <code>HttpSecurity.oauth2Client()</code> DSL 外,还支持 XML 配置.</p>
</div>
<div class="paragraph">
<p>以下代码显示了 <a href="#nsa-oauth2-client">security namespace</a> 中可用的完整配置选项:</p>
</div>
<div class="exampleblock">
<div class="title">Example 98. OAuth2 Client XML Configuration Options</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-client client-registration-repository-ref="clientRegistrationRepository"
                   authorized-client-repository-ref="authorizedClientRepository"
                   authorized-client-service-ref="authorizedClientService"&gt;
        &lt;authorization-code-grant
                authorization-request-repository-ref="authorizationRequestRepository"
                authorization-request-resolver-ref="authorizationRequestResolver"
                access-token-response-client-ref="accessTokenResponseClient"/&gt;
    &lt;/oauth2-client&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>OAuth2AuthorizedClientManager</code> 负责与一个或多个 <code>OAuth2AuthorizedClientProvider</code> 协作管理 OAuth 2.0 客户端的授权 (或重新授权) .</p>
</div>
<div class="paragraph">
<p>以下代码显示了一个示例,该示例说明如何注册 <code>OAuth2AuthorizedClientManager</code> <code>@Bean</code> 并将其与 <code>OAuth2AuthorizedClientProvider</code> 组合关联,该组合提供对 <code>authorization_code</code>,<code>refresh_token</code>,<code>client_credentials</code> 和  <code>password</code>  授权类型的支持:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
        ClientRegistrationRepository clientRegistrationRepository,
        OAuth2AuthorizedClientRepository authorizedClientRepository) {

    OAuth2AuthorizedClientProvider authorizedClientProvider =
            OAuth2AuthorizedClientProviderBuilder.builder()
                    .authorizationCode()
                    .refreshToken()
                    .clientCredentials()
                    .password()
                    .build();

    DefaultOAuth2AuthorizedClientManager authorizedClientManager =
            new DefaultOAuth2AuthorizedClientManager(
                    clientRegistrationRepository, authorizedClientRepository);
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

    return authorizedClientManager;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider: OAuth2AuthorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .authorizationCode()
            .refreshToken()
            .clientCredentials()
            .password()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下各节将详细介绍 OAuth 2.0 客户端使用的核心组件以及可用的配置选项:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-core-interface-class">核心 "类和接口"</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-client-registration">ClientRegistration</a></p>
</li>
<li>
<p><a href="#oauth2Client-client-registration-repo">ClientRegistrationRepository</a></p>
</li>
<li>
<p><a href="#oauth2Client-authorized-client">OAuth2AuthorizedClient</a></p>
</li>
<li>
<p><a href="#oauth2Client-authorized-repo-service">OAuth2AuthorizedClientRepository / OAuth2AuthorizedClientService</a></p>
</li>
<li>
<p><a href="#oauth2Client-authorized-manager-provider">OAuth2AuthorizedClientManager / OAuth2AuthorizedClientProvider</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#oauth2Client-auth-grant-support">授权类型支持</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-auth-code-grant">Authorization Code</a></p>
</li>
<li>
<p><a href="#oauth2Client-refresh-token-grant">Refresh Token</a></p>
</li>
<li>
<p><a href="#oauth2Client-client-creds-grant">Client Credentials</a></p>
</li>
<li>
<p><a href="#oauth2Client-password-grant">Resource Owner Password Credentials</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#oauth2Client-additional-features">其他功能</a></p>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2Client-registered-authorized-client">解决客户端授权</a></p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#oauth2Client-webclient-servlet">在 Servlet 环境中集成 WebClient</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="oauth2Client-core-interface-class"><a class="anchor" href="#oauth2Client-core-interface-class"></a>12.2.1. 核心 "类和接口"</h4>
<div class="sect4">
<h5 id="oauth2Client-client-registration"><a class="anchor" href="#oauth2Client-client-registration"></a>ClientRegistration</h5>
<div class="paragraph">
<p><code>ClientRegistration</code> 是向 OAuth 2.0 或 OpenID Connect 1.0 提供程序注册的客户端的表示.</p>
</div>
<div class="paragraph">
<p>客户端注册包含信息,例如客户端 ID,客户端密钥,授权类型,重定向URI,作用域,授权 URI,令牌 URI 和其他详细信息.</p>
</div>
<div class="paragraph">
<p><code>ClientRegistration</code> 及其属性定义如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public final class ClientRegistration {
    private String registrationId;  <i class="conum" data-value="1"></i><b>(1)</b>
    private String clientId;    <i class="conum" data-value="2"></i><b>(2)</b>
    private String clientSecret;    <i class="conum" data-value="3"></i><b>(3)</b>
    private ClientAuthenticationMethod clientAuthenticationMethod;  <i class="conum" data-value="4"></i><b>(4)</b>
    private AuthorizationGrantType authorizationGrantType;  <i class="conum" data-value="5"></i><b>(5)</b>
    private String redirectUri; <i class="conum" data-value="6"></i><b>(6)</b>
    private Set&lt;String&gt; scopes; <i class="conum" data-value="7"></i><b>(7)</b>
    private ProviderDetails providerDetails;
    private String clientName;  <i class="conum" data-value="8"></i><b>(8)</b>

    public class ProviderDetails {
        private String authorizationUri;    <i class="conum" data-value="9"></i><b>(9)</b>
        private String tokenUri;    <i class="conum" data-value="10"></i><b>(10)</b>
        private UserInfoEndpoint userInfoEndpoint;
        private String jwkSetUri;   <i class="conum" data-value="11"></i><b>(11)</b>
        private String issuerUri;   <i class="conum" data-value="12"></i><b>(12)</b>
        private Map&lt;String, Object&gt; configurationMetadata;  <i class="conum" data-value="13"></i><b>(13)</b>

        public class UserInfoEndpoint {
            private String uri; <i class="conum" data-value="14"></i><b>(14)</b>
            private AuthenticationMethod authenticationMethod;  <i class="conum" data-value="15"></i><b>(15)</b>
            private String userNameAttributeName;   <i class="conum" data-value="16"></i><b>(16)</b>

        }
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>registrationId</code>: 唯一标识 <code>ClientRegistration</code> 的ID. .</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>clientId</code>: 客户端标识符.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>clientSecret</code>: 客户端密钥.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>clientAuthenticationMethod</code>: 提供者对客户端进行身份验证的方法.  支持的值为 <strong>basic</strong>,<strong>post</strong> 和 <strong>none</strong> <a href="https://tools.ietf.org/html/rfc6749#section-2.1">(public clients)</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>authorizationGrantType</code>: OAuth 2.0 授权框架定义了四种 <a href="https://tools.ietf.org/html/rfc6749#section-1.3">授权类型</a> .  支持的值是 <code>authorization_code</code>,<code>client_credentials</code>,<code>password</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>redirectUri</code>: 终端用户对客户端进行身份验证和授权访问后,授权服务器会将终端用户重定向到该客户的注册重定向URI.</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>scopes</code>: 客户在授权请求流程中请求的范围,例如 openid,电子邮件或配置文件.</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>clientName</code>: 用于客户端的描述性名称.  该名称可能在某些情况下使用,例如在自动生成的登录页面中显示客户端名称时.</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td><code>authorizationUri</code>: 授权服务器的授权端点 URI.</td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td><code>tokenUri</code>: 授权服务器的令牌端点 URI.</td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td><code>jwkSetUri</code>: 用于从授权服务器检索 JSON Web 密钥( <a href="https://tools.ietf.org/html/rfc7517">JSON Web Key (JWK)</a>)集的URI,其中包含用于验证 ID 令牌的 JSON Web 签名( <a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a>) 以及用户信息响应 (可选) 的加密密钥.</td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td><code>issuerUri</code>: 返回 OpenID Connect 1.0 provider 或 OAuth 2.0 授权服务器的 issuer 标识 uri.</td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td><code>configurationMetadata</code>:  <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">OpenID Provider 配置信息</a>. 仅当配置了 Spring Boot 2.x 属性 <code>spring.security.oauth2.client.provider.[providerId].issuerUri</code>  时,此信息才可用.</td>
</tr>
<tr>
<td><i class="conum" data-value="14"></i><b>14</b></td>
<td><code>(userInfoEndpoint)uri</code>: UserInfo 端点 URI,用于访问经过身份验证的最终用户的声明/属性.</td>
</tr>
<tr>
<td><i class="conum" data-value="15"></i><b>15</b></td>
<td><code>(userInfoEndpoint)authenticationMethod</code>: 将访问令牌发送到 UserInfo 端点时使用的身份验证方法. 支持  <strong>header</strong>, <strong>form</strong> 和 <strong>query</strong> 值</td>
</tr>
<tr>
<td><i class="conum" data-value="16"></i><b>16</b></td>
<td><code>userNameAttributeName</code>: 在 UserInfo 响应中返回的属性名称,该属性引用了最终用户的名称或标识符.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以使用发现 OpenID Connect 提供者的 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Configuration endpoint</a> 或授权服务器的 <a href="https://tools.ietf.org/html/rfc8414#section-3">元数据端点</a> 来初始配置 <code>ClientRegistration</code>.</p>
</div>
<div class="paragraph">
<p><code>ClientRegistrations</code> 提供了以这种方式配置 <code>ClientRegistration</code> 的便捷方法,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ClientRegistration clientRegistration =
    ClientRegistrations.fromIssuerLocation("https://idp.example.com/issuer").build();
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val clientRegistration = ClientRegistrations.fromIssuerLocation("https://idp.example.com/issuer").build()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的代码将依次查询 <code><a href="https://idp.example.com/issuer/.well-known/openid-configuration" class="bare">idp.example.com/issuer/.well-known/openid-configuration</a></code> ,然后依次查询 <code><a href="https://idp.example.com/.well-known/openid-configuration/issuer" class="bare">idp.example.com/.well-known/openid-configuration/issuer</a></code>,
最后是  <code><a href="https://idp.example.com/.well-known/oauth-authorization-server/issuer" class="bare">idp.example.com/.well-known/oauth-authorization-server/issuer</a></code> ,从第一个停止返回200响应.</p>
</div>
<div class="paragraph">
<p>或者,您可以使用 <code>ClientRegistrations.fromOidcIssuerLocation()</code>  仅查询 OpenID Connect 提供程序的配置端点.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-client-registration-repo"><a class="anchor" href="#oauth2Client-client-registration-repo"></a>ClientRegistrationRepository</h5>
<div class="paragraph">
<p><code>ClientRegistrationRepository</code> 充当 OAuth 2.0/OpenID Connect 1.0  <code>ClientRegistration</code> 的存储库.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
客户端注册信息最终由关联的授权服务器存储和拥有.  此存储库提供了检索与授权服务器一起存储的主要客户端注册信息的子集的功能.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Boot 2.x 自动配置将 <code>spring.security.oauth2.client.registration.<em>[registrationId]</em></code>  下的每个属性绑定到 <code>ClientRegistration</code> 的实例,然后在 <code>ClientRegistrationRepository</code> 中组成每个 <code>ClientRegistration</code> 实例.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>ClientRegistrationRepository</code> 的默认实现是 <code>InMemoryClientRegistrationRepository</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>自动配置还会在 <code>ApplicationContext</code> 中将 <code>ClientRegistrationRepository</code> 注册为 <code>@Bean</code>,以便在应用程序需要时可用于依赖注入.</p>
</div>
<div class="paragraph">
<p>以下清单显示了一个示例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
public class OAuth2ClientController {

    @Autowired
    private ClientRegistrationRepository clientRegistrationRepository;

    @GetMapping("/")
    public String index() {
        ClientRegistration oktaRegistration =
            this.clientRegistrationRepository.findByRegistrationId("okta");

        ...

        return "index";
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class OAuth2ClientController {

    @Autowired
    private lateinit var clientRegistrationRepository: ClientRegistrationRepository

    @GetMapping("/")
    fun index(): String {
        val oktaRegistration =
                this.clientRegistrationRepository.findByRegistrationId("okta")

        //...

        return "index";
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-authorized-client"><a class="anchor" href="#oauth2Client-authorized-client"></a>OAuth2AuthorizedClient</h5>
<div class="paragraph">
<p><code>OAuth2AuthorizedClient</code> 是授权客户端的表示.  当终端用户 (资源所有者) 已向客户端授权访问其受保护资源的权限时,则认为该客户端已被授权.</p>
</div>
<div class="paragraph">
<p><code>OAuth2AuthorizedClient</code> 的目的是将 <code>OAuth2AccessToken</code> (和可选的 <code>OAuth2RefreshToken</code>) 与 <code>ClientRegistration</code> (客户端) 和资源所有者相关联,<code>ClientRegistration</code> 和资源所有者是授权的主要最终用户.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-authorized-repo-service"><a class="anchor" href="#oauth2Client-authorized-repo-service"></a>OAuth2AuthorizedClientRepository / OAuth2AuthorizedClientService</h5>
<div class="paragraph">
<p><code>OAuth2AuthorizedClientRepository</code> 负责在 Web 请求之间持久保存 <code>OAuth2AuthorizedClient</code>.  而 <code>OAuth2AuthorizedClientService</code> 的主要作用是在应用程序级别管理 <code>OAuth2AuthorizedClient</code>.</p>
</div>
<div class="paragraph">
<p>从开发人员的角度来看,<code>OAuth2AuthorizedClientRepository</code> 或 <code>OAuth2AuthorizedClientService</code> 提供了查找与客户端关联的 <code>OAuth2AccessToken</code> 的功能,以便可以将其用于发起受保护的资源请求.</p>
</div>
<div class="paragraph">
<p>以下清单显示了一个示例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
public class OAuth2ClientController {

    @Autowired
    private OAuth2AuthorizedClientService authorizedClientService;

    @GetMapping("/")
    public String index(Authentication authentication) {
        OAuth2AuthorizedClient authorizedClient =
            this.authorizedClientService.loadAuthorizedClient("okta", authentication.getName());

        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

        ...

        return "index";
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class OAuth2ClientController {

    @Autowired
    private lateinit var authorizedClientService: OAuth2AuthorizedClientService

    @GetMapping("/")
    fun index(authentication: Authentication): String {
        val authorizedClient: OAuth2AuthorizedClient =
            this.authorizedClientService.loadAuthorizedClient("okta", authentication.getName());
        val accessToken = authorizedClient.accessToken

        ...

        return "index";
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Boot 2.x 自动配置在 <code>ApplicationContext</code> 中注册了 <code>OAuth2AuthorizedClientRepository</code> 和/或 <code>OAuth2AuthorizedClientService</code> <code>@Bean</code>.  但是,应用程序可以选择覆盖并注册自定义 <code>OAuth2AuthorizedClientRepository</code> 或 <code>OAuth2AuthorizedClientService</code> <code>@Bean</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AuthorizedClientService</code> 的默认实现是 <code>InMemoryOAuth2AuthorizedClientService</code>,它在内存中存储 <code>OAuth2AuthorizedClient</code>.</p>
</div>
<div class="paragraph">
<p>或者,可以将 JDBC 实现 <code>JdbcOAuth2AuthorizedClientService</code> 配置为将 <code>OAuth2AuthorizedClient</code> 持久存储在数据库中.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>JdbcOAuth2AuthorizedClientService</code> 取决于<a href="#dbschema-oauth2-client">OAuth 2.0 客户端架构</a>中描述的表定义.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-authorized-manager-provider"><a class="anchor" href="#oauth2Client-authorized-manager-provider"></a>OAuth2AuthorizedClientManager / OAuth2AuthorizedClientProvider</h5>
<div class="paragraph">
<p><code>OAuth2AuthorizedClientManager</code> 负责 <code>OAuth2AuthorizedClient</code> 的整体管理.</p>
</div>
<div class="paragraph">
<p>主要职责包括:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 <code>OAuth2AuthorizedClientProvider</code> 授权 (或重新授权) OAuth 2.0 客户端.</p>
</li>
<li>
<p>通常使用 <code>OAuth2AuthorizedClientService</code> 或 <code>OAuth2AuthorizedClientRepository</code> 委托 <code>OAuth2AuthorizedClient</code> 的持久性.</p>
</li>
<li>
<p>成功授权(或重新授权) OAuth 2.0 客户端后,委派给 <code>OAuth2AuthorizationSuccessHandler</code></p>
</li>
<li>
<p>当 OAuth 2.0 客户端无法授权(或重新授权)时,委派给 <code>OAuth2AuthorizationFailureHandler</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>OAuth2AuthorizedClientProvider</code> 实施用于授权 (或重新授权) OAuth 2.0 客户端的策略.  实施通常将实施授权类型,例如.  <code>authorization_code</code>, <code>client_credentials</code> 等.</p>
</div>
<div class="paragraph">
<p><code>OAuth2AuthorizedClientManager</code> 的默认实现是 <code>DefaultOAuth2AuthorizedClientManager</code>,它与 <code>OAuth2AuthorizedClientProvider</code> 关联,
该 <code>OAuth2AuthorizedClientProvider</code> 可以使用基于委托的组合来支持多种授权授权类型.  <code>OAuth2AuthorizedClientProviderBuilder</code> 可以用于配置和构建基于委托的组合.</p>
</div>
<div class="paragraph">
<p>以下代码显示了如何配置和构建 <code>OAuth2AuthorizedClientProvider</code> 组合的示例,该组合提供对  <code>authorization_code</code>,<code>refresh_token</code>,<code>client_credentials</code> 和 <code>password</code> 授权类型的支持:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
        ClientRegistrationRepository clientRegistrationRepository,
        OAuth2AuthorizedClientRepository authorizedClientRepository) {

    OAuth2AuthorizedClientProvider authorizedClientProvider =
            OAuth2AuthorizedClientProviderBuilder.builder()
                    .authorizationCode()
                    .refreshToken()
                    .clientCredentials()
                    .password()
                    .build();

    DefaultOAuth2AuthorizedClientManager authorizedClientManager =
            new DefaultOAuth2AuthorizedClientManager(
                    clientRegistrationRepository, authorizedClientRepository);
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

    return authorizedClientManager;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .authorizationCode()
            .refreshToken()
            .clientCredentials()
            .password()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当尝试授权成功时,<code>DefaultOAuth2AuthorizedClientManager</code> 将委派给 <code>OAuth2AuthorizationSuccessHandler</code>,后者(默认情况下)将通过 <code>OAuth2AuthorizedClientRepository</code> 保存 <code>OAuth2AuthorizedClient</code>.
在重新授权失败的情况下,例如 刷新令牌不再有效,先前保存的 <code>OAuth2AuthorizedClient</code> 将通过 <code>RemoveAuthorizedClientOAuth2AuthorizationFailureHandler</code> 从 <code>OAuth2AuthorizedClientRepository</code> 中删除.
可以通过 <code>setAuthorizationSuccessHandler(OAuth2AuthorizationSuccessHandler)</code>  和  <code>setAuthorizationFailureHandler(OAuth2AuthorizationFailureHandler)</code> 自定义默认行为.</p>
</div>
<div class="paragraph">
<p><code>DefaultOAuth2AuthorizedClientManager</code> 也与类型为 <code>Function&lt;OAuth2AuthorizeRequest, Map&lt;String, Object&gt;&gt;</code> 的 <code>contextAttributesMapper</code> 关联,后者负责将属性从 <code>OAuth2AuthorizeRequest</code> 映射到要与 <code>OAuth2AuthorizationContext</code> 关联的属性的映射.
当您需要为 <code>OAuth2AuthorizedClientProvider</code> 提供必需的 (受支持的) 属性时,这很有用.  <code>PasswordOAuth2AuthorizedClientProvider</code> 要求资源所有者的用户名和密码在 <code>OAuth2AuthorizationContext.getAttributes()</code> 中可用.</p>
</div>
<div class="paragraph">
<p>以下代码显示了 <code>contextAttributesMapper</code> 的示例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
        ClientRegistrationRepository clientRegistrationRepository,
        OAuth2AuthorizedClientRepository authorizedClientRepository) {

    OAuth2AuthorizedClientProvider authorizedClientProvider =
            OAuth2AuthorizedClientProviderBuilder.builder()
                    .password()
                    .refreshToken()
                    .build();

    DefaultOAuth2AuthorizedClientManager authorizedClientManager =
            new DefaultOAuth2AuthorizedClientManager(
                    clientRegistrationRepository, authorizedClientRepository);
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

    // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
    // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
    authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());

    return authorizedClientManager;
}

private Function&lt;OAuth2AuthorizeRequest, Map&lt;String, Object&gt;&gt; contextAttributesMapper() {
    return authorizeRequest -&gt; {
        Map&lt;String, Object&gt; contextAttributes = Collections.emptyMap();
        HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName());
        String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME);
        String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD);
        if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
            contextAttributes = new HashMap&lt;&gt;();

            // `PasswordOAuth2AuthorizedClientProvider` requires both attributes
            contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
            contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
        }
        return contextAttributes;
    };
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .password()
            .refreshToken()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)

    // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
    // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
    authorizedClientManager.setContextAttributesMapper(contextAttributesMapper())
    return authorizedClientManager
}

private fun contextAttributesMapper(): Function&lt;OAuth2AuthorizeRequest, MutableMap&lt;String, Any&gt;&gt; {
    return Function { authorizeRequest -&gt;
        var contextAttributes: MutableMap&lt;String, Any&gt; = mutableMapOf()
        val servletRequest: HttpServletRequest = authorizeRequest.getAttribute(HttpServletRequest::class.java.name)
        val username: String = servletRequest.getParameter(OAuth2ParameterNames.USERNAME)
        val password: String = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD)
        if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
            contextAttributes = hashMapOf()

            // `PasswordOAuth2AuthorizedClientProvider` requires both attributes
            contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username
            contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password
        }
        contextAttributes
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>DefaultOAuth2AuthorizedClientManager</code> 设计为在 <code>HttpServletRequest</code> 上下文中使用. 在 <code>HttpServletRequest</code> 上下文之外进行操作时,请改用 <code>AuthorizedClientServiceOAuth2AuthorizedClientManager</code>.</p>
</div>
<div class="paragraph">
<p>服务应用程序是何时使用 <code>AuthorizedClientServiceOAuth2AuthorizedClientManager</code> 的常见用例. 服务应用程序通常在后台运行,没有任何用户交互,并且通常在系统级帐户而不是用户帐户下运行. 配置为 <code>client_credentials</code> 授予类型的 OAuth 2.0 客户端可以视为服务应用程序的类型.</p>
</div>
<div class="paragraph">
<p>下面的代码显示了一个示例如何配置 <code>AuthorizedClientServiceOAuth2AuthorizedClientManager</code> 的示例,该 <code>ManagerManager</code> 提供对 <code>client_credentials</code> 授予类型的支持:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
        ClientRegistrationRepository clientRegistrationRepository,
        OAuth2AuthorizedClientService authorizedClientService) {

    OAuth2AuthorizedClientProvider authorizedClientProvider =
            OAuth2AuthorizedClientProviderBuilder.builder()
                    .clientCredentials()
                    .build();

    AuthorizedClientServiceOAuth2AuthorizedClientManager authorizedClientManager =
            new AuthorizedClientServiceOAuth2AuthorizedClientManager(
                    clientRegistrationRepository, authorizedClientService);
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

    return authorizedClientManager;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientService: OAuth2AuthorizedClientService): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .clientCredentials()
            .build()
    val authorizedClientManager = AuthorizedClientServiceOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientService)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2Client-auth-grant-support"><a class="anchor" href="#oauth2Client-auth-grant-support"></a>12.2.2. 授权类型支持</h4>
<div class="sect4">
<h5 id="oauth2Client-auth-code-grant"><a class="anchor" href="#oauth2Client-auth-code-grant"></a>Authorization Code  (授权码)</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
有关 <a href="https://tools.ietf.org/html/rfc6749#section-1.3.1">Authorization Code</a> 的更多详细信息,请参考 OAuth 2.0 授权框架.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="获取授权"><a class="anchor" href="#获取授权"></a>获取授权</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请参阅 <a href="https://tools.ietf.org/html/rfc6749#section-4.1.1">Authorization Request/Response</a>  协议流程以获取授权码.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="发起授权请求"><a class="anchor" href="#发起授权请求"></a>发起授权请求</h6>
<div class="paragraph">
<p><code>OAuth2AuthorizationRequestRedirectFilter</code> 使用 <code>OAuth2AuthorizationRequestResolver</code> 来解析 <code>OAuth2AuthorizationRequest</code> 并通过将终端用户重定向到授权服务器的授权端点来开始授权码授权流程.</p>
</div>
<div class="paragraph">
<p><code>OAuth2AuthorizationRequestResolver</code> 的主要作用是从提供的 Web 请求中解析 <code>OAuth2AuthorizationRequest</code>.  默认实现 <code>DefaultOAuth2AuthorizationRequestResolver</code> 在 (默认) 路径 <code>/oauth2/authorization/{registrationId}</code> 上进行匹配,
以提取 <code>registrationId</code> 并使用其关联的 <code>ClientRegistration</code> 构建 <code>OAuth2AuthorizationRequest</code>.</p>
</div>
<div class="paragraph">
<p>为 OAuth 2.0 客户端注册提供以下 Spring Boot 2.x 属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/authorized/okta"
            scope: read, write
        provider:
          okta:
            authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token</code></pre>
</div>
</div>
<div class="paragraph">
<p>基本路径为 <code>/oauth2/authorization/okta</code> 的请求将通过 <code>OAuth2AuthorizationRequestRedirectFilter</code> 发起授权请求重定向,并最终启动授权码授权流程.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>AuthorizationCodeOAuth2AuthorizedClientProvider</code> 是用于授权码认证的 <code>OAuth2AuthorizedClientProvider</code> 的实现,该授权码还通过 <code>OAuth2AuthorizationRequestRedirectFilter</code> 发起授权请求重定向.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果 OAuth 2.0 客户端是 <a href="https://tools.ietf.org/html/rfc6749#section-2.1">Public Client</a>,则按以下方式配置 OAuth 2.0 客户端注册:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-authentication-method: none
            authorization-grant-type: authorization_code
            redirect-uri: "{baseUrl}/authorized/okta"
            ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <a href="https://tools.ietf.org/html/rfc7636">Proof Key for Code Exchange</a> (PKCE)支持公共客户端.  如果客户端在不受信任的环境 (例如,本地应用程序或基于Web浏览器的应用程序) 中运行,因此无法维护其凭据的机密性,则在满足以下条件时将自动使用 PKCE:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>client-secret</code> 被省略 (或为空)</p>
</li>
<li>
<p><code>client-authentication-method</code> 设置为 "none" (<code>ClientAuthenticationMethod.NONE</code>)</p>
</li>
</ol>
</div>
<div id="oauth2Client-auth-code-redirect-uri" class="paragraph">
<p><code>DefaultOAuth2AuthorizationRequestResolver</code> 还使用 <code>UriComponentsBuilder</code> 支持 <code>redirect-uri</code> 的 <code>URI</code> 模板变量.</p>
</div>
<div class="paragraph">
<p>以下配置使用所有受支持的 <code>URI</code> 模板变量:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            ...
            redirect-uri: "{baseScheme}://{baseHost}{basePort}{basePath}/authorized/{registrationId}"
            ...</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>{baseUrl}</code> 解析为 <code>{baseScheme}://{baseHost}{basePort}{basePath}</code>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>当 OAuth 2.0 客户端在<a href="#http-proxy-server">代理服务器</a>后面运行时,使用 <code>URI</code> 模板变量配置 <code>redirect-uri</code> 尤其有用.  这样可以确保在扩展 <code>redirect-uri</code> 时使用 <code>X-Forwarded-*</code> 头.</p>
</div>
</div>
<div class="sect5">
<h6 id="自定义授权请求"><a class="anchor" href="#自定义授权请求"></a>自定义授权请求</h6>
<div class="paragraph">
<p><code>OAuth2AuthorizationRequestResolver</code> 可以实现的主要用例之一是能够使用 OAuth 2.0 授权框架中定义的标准参数之外的其他参数自定义授权请求.</p>
</div>
<div class="paragraph">
<p>例如,OpenID Connect 从 <a href="https://tools.ietf.org/html/rfc6749#section-4.1.1">OAuth 2.0 Authorization Framework</a> 中定义的标准参数开始,为 <a href="https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest">Authorization Code Flow</a> 定义其他 OAuth 2.0 请求参数.  这些扩展参数之一是提示参数.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
可选的.  用空格分隔的,区分大小写的 ASCII 字符串值列表,用于指定授权服务器是否提示终端用户进行重新认证和同意.  定义的值是: none, login, consent, select_account
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示如何通过使用 <code>Consumer&lt;OAuth2AuthorizationRequest.Builder&gt;</code> 来配置 <code>DefaultOAuth2AuthorizationRequestResolver</code>,该 <code>Consumer&lt;OAuth2AuthorizationRequest.Builder&gt;</code> 通过包括请求参数  <code>prompt=consent</code> 来定制  <code>oauth2Login()</code> 的授权请求.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private ClientRegistrationRepository clientRegistrationRepository;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2Login(oauth2 -&gt; oauth2
                .authorizationEndpoint(authorization -&gt; authorization
                    .authorizationRequestResolver(
                        authorizationRequestResolver(this.clientRegistrationRepository)
                    )
                )
            );
    }

    private OAuth2AuthorizationRequestResolver authorizationRequestResolver(
            ClientRegistrationRepository clientRegistrationRepository) {

        DefaultOAuth2AuthorizationRequestResolver authorizationRequestResolver =
                new DefaultOAuth2AuthorizationRequestResolver(
                        clientRegistrationRepository, "/oauth2/authorization");
        authorizationRequestResolver.setAuthorizationRequestCustomizer(
                authorizationRequestCustomizer());

        return  authorizationRequestResolver;
    }

    private Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; authorizationRequestCustomizer() {
        return customizer -&gt; customizer
                    .additionalParameters(params -&gt; params.put("prompt", "consent"));
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    @Autowired
    private lateinit var customClientRegistrationRepository: ClientRegistrationRepository

    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2Login {
                authorizationEndpoint {
                    authorizationRequestResolver = authorizationRequestResolver(customClientRegistrationRepository)
                }
            }
        }
    }

    private fun authorizationRequestResolver(
            clientRegistrationRepository: ClientRegistrationRepository?): OAuth2AuthorizationRequestResolver? {
        val authorizationRequestResolver = DefaultOAuth2AuthorizationRequestResolver(
                clientRegistrationRepository, "/oauth2/authorization")
        authorizationRequestResolver.setAuthorizationRequestCustomizer(
                authorizationRequestCustomizer())
        return authorizationRequestResolver
    }

    private fun authorizationRequestCustomizer(): Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; {
        return Consumer { customizer -&gt;
            customizer
                    .additionalParameters { params -&gt; params["prompt"] = "consent" }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于简单的用例,对于特定的提供者,附加请求参数始终相同,可以将其直接添加到 <code>authorization-uri</code> 中.</p>
</div>
<div class="paragraph">
<p>例如,如果请求参数 <code>prompt</code> 的值始终是提供者 okta 的 <code>consent</code> ,则可以简单地进行如下配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        provider:
          okta:
            authorization-uri: https://dev-1234.oktapreview.com/oauth2/v1/authorize?prompt=consent</code></pre>
</div>
</div>
<div class="paragraph">
<p>前面的示例显示了在标准参数之上添加自定义参数的常见用例.  或者,如果您的要求更高,则可以通过简单地覆盖 <code>OAuth2AuthorizationRequest.authorizationRequestUri</code> 属性来完全控制构建授权请求 <code>URI</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>OAuth2AuthorizationRequest.Builder.build()</code> 构造 <code>OAuth2AuthorizationRequest.authorizationRequestUri</code>,它表示完整的授权请求 <code>URI</code>,包括使用 <code>application/x-www-form-urlencoded</code> 格式的所有查询参数.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下示例显示了 <code>authorizationRequestCustomizer()</code> 方法与上一示例的不同形式,而是覆盖了 <code>OAuth2AuthorizationRequest.authorizationRequestUri</code> 属性.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; authorizationRequestCustomizer() {
    return customizer -&gt; customizer
                .authorizationRequestUri(uriBuilder -&gt; uriBuilder
                    .queryParam("prompt", "consent").build());
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">private fun authorizationRequestCustomizer(): Consumer&lt;OAuth2AuthorizationRequest.Builder&gt; {
    return Consumer { customizer: OAuth2AuthorizationRequest.Builder -&gt;
        customizer
                .authorizationRequestUri { uriBuilder: UriBuilder -&gt;
                    uriBuilder
                            .queryParam("prompt", "consent").build()
                }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="保存授权请求"><a class="anchor" href="#保存授权请求"></a>保存授权请求</h6>
<div class="paragraph">
<p><code>AuthorizationRequestRepository</code> 负责从发起授权请求到接收到授权响应 (回调) 之间的 <code>OAuth2AuthorizationRequest</code> 的持久性.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>OAuth2AuthorizationRequest</code> 用于关联和验证授权响应.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>AuthorizationRequestRepository</code> 的默认实现是 <code>HttpSessionOAuth2AuthorizationRequestRepository</code>,它将 <code>OAuth2AuthorizationRequest</code> 存储在 <code>HttpSession</code> 中.</p>
</div>
<div class="paragraph">
<p>如果您具有 <code>AuthorizationRequestRepository</code> 的自定义实现,则可以如以下示例所示对其进行配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 99. AuthorizationRequestRepository Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Client(oauth2 -&gt; oauth2
                .authorizationCodeGrant(codeGrant -&gt; codeGrant
                    .authorizationRequestRepository(this.authorizationRequestRepository())
                    ...
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                authorizationCodeGrant {
                    authorizationRequestRepository = authorizationRequestRepository()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-client&gt;
        &lt;authorization-code-grant authorization-request-repository-ref="authorizationRequestRepository"/&gt;
    &lt;/oauth2-client&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="访问令牌请求"><a class="anchor" href="#访问令牌请求"></a>访问令牌请求</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请参阅 <a href="https://tools.ietf.org/html/rfc6749#section-4.1.3">Access Token Request/Response</a>  协议流程以获取授权码.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>用于授权码授权的 <code>OAuth2AccessTokenResponseClient</code> 的默认实现是 <code>DefaultAuthorizationCodeTokenResponseClient</code>,它使用 <code>RestOperations</code> 在授权服务器的令牌端点交换访问令牌的授权码.</p>
</div>
<div class="paragraph">
<p><code>DefaultAuthorizationCodeTokenResponseClient</code> 非常灵活,因为它允许您自定义令牌请求的预处理和/或令牌响应的后处理.</p>
</div>
</div>
<div class="sect5">
<h6 id="自定义访问令牌请求"><a class="anchor" href="#自定义访问令牌请求"></a>自定义访问令牌请求</h6>
<div class="paragraph">
<p>如果需要自定义令牌请求的预处理,则可以为 <code>DefaultAuthorizationCodeTokenResponseClient.setRequestEntityConverter()</code> 提供自定义 <code>Converter&lt;OAuth2AuthorizationCodeGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
默认实现 <code>OAuth2AuthorizationCodeGrantRequestEntityConverter</code> 构建标准 <a href="https://tools.ietf.org/html/rfc6749#section-4.1.3">OAuth 2.0 Access Token Request</a> 的 <code>RequestEntity</code> 表示形式.  但是,提供自定义转换器将允许您扩展标准令牌请求并添加自定义参数.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
自定义 <code>Converter</code> 必须返回预期的 OAuth 2.0 提供者可以理解的 OAuth 2.0 访问令牌请求的有效 <code>RequestEntity</code> 表示形式.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="自定义访问令牌响应"><a class="anchor" href="#自定义访问令牌响应"></a>自定义访问令牌响应</h6>
<div class="paragraph">
<p>另一方面,如果您需要自定义令牌响应的后处理,则需要为  <code>DefaultAuthorizationCodeTokenResponseClient.setRestOperations()</code> 提供一个自定义配置的 <code>RestOperations</code>.  默认的 <code>RestOperations</code> 配置如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
        new FormHttpMessageConverter(),
        new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
发送 OAuth 2.0 访问令牌请求时,需要使用 Spring MVC <code>FormHttpMessageConverter</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> 是 OAuth 2.0 访问令牌响应的 <code>HttpMessageConverter</code>.  您可以为 <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> 提供一个自定义 <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code>,
该转换器用于将 OAuth 2.0 访问令牌响应参数转换为 <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> 是一个 <code>ResponseErrorHandler</code>,可以处理 OAuth 2.0 错误,例如.  400 错误的请求.  它使用 <code>OAuth2ErrorHttpMessageConverter</code> 将 OAuth 2.0 错误参数转换为 <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>无论您是自定义 <code>DefaultAuthorizationCodeTokenResponseClient</code> 还是提供自己的 <code>OAuth2AccessTokenResponseClient</code> 实现,都需要按以下示例所示进行配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 100. Access Token Response Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class OAuth2ClientSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .oauth2Client(oauth2 -&gt; oauth2
                .authorizationCodeGrant(codeGrant -&gt; codeGrant
                    .accessTokenResponseClient(this.accessTokenResponseClient())
                    ...
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class OAuth2ClientSecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            oauth2Client {
                authorizationCodeGrant {
                    accessTokenResponseClient = accessTokenResponseClient()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-client&gt;
        &lt;authorization-code-grant access-token-response-client-ref="accessTokenResponseClient"/&gt;
    &lt;/oauth2-client&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-refresh-token-grant"><a class="anchor" href="#oauth2Client-refresh-token-grant"></a>刷新 Token</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
有关以下内容的更多详细信息,请参阅 OAuth 2.0 授权框架 <a href="https://tools.ietf.org/html/rfc6749#section-1.5">Refresh Token</a>.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="刷新访问令牌"><a class="anchor" href="#刷新访问令牌"></a>刷新访问令牌</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请参阅 <a href="https://tools.ietf.org/html/rfc6749#section-6">Access Token Request/Response</a> 协议流程以获取刷新令牌授权.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>用于刷新令牌授权的 <code>OAuth2AccessTokenResponseClient</code> 的默认实现是 <code>DefaultRefreshTokenTokenResponseClient</code>,当在授权服务器的令牌端点刷新访问令牌时使用 <code>RestOperations</code>.</p>
</div>
<div class="paragraph">
<p><code>DefaultRefreshTokenTokenResponseClient</code> 非常灵活,因为它允许您自定义令牌请求的预处理和/或令牌响应的后处理</p>
</div>
</div>
<div class="sect5">
<h6 id="自定义刷新令牌请求"><a class="anchor" href="#自定义刷新令牌请求"></a>自定义刷新令牌请求</h6>
<div class="paragraph">
<p>如果需要自定义令牌请求的预处理,则可以为 <code>DefaultRefreshTokenTokenResponseClient.setRequestEntityConverter()</code> 提供自定义 <code>Converter&lt;OAuth2RefreshTokenGrantRequest, RequestEntity&lt;?&gt;&gt;</code>
默认实现 <code>OAuth2RefreshTokenGrantRequestEntityConverter</code> 构建标准 <a href="https://tools.ietf.org/html/rfc6749#section-6">OAuth 2.0 Access Token Request</a>的 <code>RequestEntity</code> 表示.  但是,提供自定义 <code>Converter</code> 将允许您扩展标准令牌请求并添加自定义参数.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
自定义 <code>Converter</code> 必须返回预期的 OAuth 2.0 提供程序可以理解的 OAuth 2.0 访问令牌请求的有效 <code>RequestEntity</code> 表示形式.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="自定义刷新令牌响应"><a class="anchor" href="#自定义刷新令牌响应"></a>自定义刷新令牌响应</h6>
<div class="paragraph">
<p>另一方面,如果您需要自定义令牌响应的后处理,则需要为  <code>DefaultRefreshTokenTokenResponseClient.setRestOperations()</code> 提供一个自定义配置的 <code>RestOperations</code>.  默认的 <code>RestOperations</code> 配置如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
        new FormHttpMessageConverter(),
        new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
发送 OAuth 2.0 访问令牌请求时,需要使用 Spring MVC <code>FormHttpMessageConverter</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> 是 OAuth 2.0 访问令牌响应的 <code>HttpMessageConverter</code>.  您可以为  <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> 提供一个自定义 <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code>,该转换器用于将 OAuth 2.0 访问令牌响应参数转换为 <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> 是一个 <code>ResponseErrorHandler</code>,可以处理 OAuth 2.0 错误,例如.  400 错误的请求.  它使用 <code>OAuth2ErrorHttpMessageConverter</code> 将 OAuth 2.0 错误参数转换为 <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>无论您是自定义 <code>DefaultRefreshTokenTokenResponseClient</code> 还是提供自己的 <code>OAuth2AccessTokenResponseClient</code> 实现,都需要按以下示例所示进行配置:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Customize
OAuth2AccessTokenResponseClient&lt;OAuth2RefreshTokenGrantRequest&gt; refreshTokenTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
        OAuth2AuthorizedClientProviderBuilder.builder()
                .authorizationCode()
                .refreshToken(configurer -&gt; configurer.accessTokenResponseClient(refreshTokenTokenResponseClient))
                .build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Customize
val refreshTokenTokenResponseClient: OAuth2AccessTokenResponseClient&lt;OAuth2RefreshTokenGrantRequest&gt; = ...

val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
        .authorizationCode()
        .refreshToken { it.accessTokenResponseClient(refreshTokenTokenResponseClient) }
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2AuthorizedClientProviderBuilder.builder().refreshToken()</code> 配置一个 <code>RefreshTokenOAuth2AuthorizedClientProvider</code>,它是 <code>OAuth2AuthorizedClientProvider</code> 的实现,用于刷新令牌授权.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2RefreshToken</code> 可以选择在访问令牌响应中返回 <code>authorization_code</code> 和 <code>password</code> 授权类型.  如果 <code>OAuth2AuthorizedClient.getRefreshToken()</code> 可用且 <code>OAuth2AuthorizedClient.getAccessToken()</code> 过期,则 <code>RefreshTokenOAuth2AuthorizedClientProvider</code> 将自动刷新它.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-client-creds-grant"><a class="anchor" href="#oauth2Client-client-creds-grant"></a>Client Credentials(客户端凭证)</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
有关 <a href="https://tools.ietf.org/html/rfc6749#section-1.3.4">Client Credentials</a> 授权的更多详细信息,请参考 OAuth 2.0 授权框架.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="访问令牌请求-2"><a class="anchor" href="#访问令牌请求-2"></a>访问令牌请求</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请参阅 <a href="https://tools.ietf.org/html/rfc6749#section-4.4.2">Access Token Request/Response</a>  协议流以获取 "客户端凭证" 授权.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>客户端凭据授权的 <code>OAuth2AccessTokenResponseClient</code> 的默认实现是 <code>DefaultClientCredentialsTokenResponseClient</code>,当在授权服务器的令牌端点请求访问令牌时,它会使用 <code>RestOperations</code>.</p>
</div>
<div class="paragraph">
<p><code>DefaultClientCredentialsTokenResponseClient</code> 非常灵活,因为它允许您自定义令牌请求的预处理和/或令牌响应的后处理.</p>
</div>
</div>
<div class="sect5">
<h6 id="自定义访问令牌请求-2"><a class="anchor" href="#自定义访问令牌请求-2"></a>自定义访问令牌请求</h6>
<div class="paragraph">
<p>如果需要自定义令牌请求的预处理,则可以为 <code>DefaultClientCredentialsTokenResponseClient.setRequestEntityConverter()</code>  提供自定义 <code>Converter&lt;OAuth2ClientCredentialsGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
默认实现 <code>OAuth2ClientCredentialsGrantRequestEntityConverter</code> 构建标准 <a href="https://tools.ietf.org/html/rfc6749#section-4.4.2">OAuth 2.0 Access Token Request</a> 的 <code>RequestEntity</code> 表示.  但是,提供自定义转换器将允许您扩展标准令牌请求并添加自定义参数.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
自定义 <code>Converter</code> 必须返回预期的 OAuth 2.0 提供程序可以理解的 OAuth 2.0 访问令牌请求的有效 <code>RequestEntity</code> 表示形式.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="自定义访问令牌响应-2"><a class="anchor" href="#自定义访问令牌响应-2"></a>自定义访问令牌响应</h6>
<div class="paragraph">
<p>另一方面,如果您需要自定义令牌响应的后处理,则需要为 <code>DefaultClientCredentialsTokenResponseClient.setRestOperations()</code> 提供一个自定义配置的 <code>RestOperations</code>.  默认的 <code>RestOperations</code> 配置如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
        new FormHttpMessageConverter(),
        new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
发送 OAuth 2.0 访问令牌请求时,需要使用 Spring MVC <code>FormHttpMessageConverter</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> 是 OAuth 2.0 访问令牌响应的 <code>HttpMessageConverter</code>.  您可以为 <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code>  提供一个自定义 <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code> ,
该转换器用于将 OAuth 2.0 访问令牌响应参数转换为 <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> 是一个 <code>ResponseErrorHandler</code>,可以处理 OAuth 2.0 错误,例如.  400 错误的请求.  它使用 <code>OAuth2ErrorHttpMessageConverter</code> 将 OAuth 2.0 错误参数转换为 <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>无论您是自定义 <code>DefaultClientCredentialsTokenResponseClient</code> 还是提供自己的 <code>OAuth2AccessTokenResponseClient</code> 实现,都需要按以下示例所示进行配置:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Customize
OAuth2AccessTokenResponseClient&lt;OAuth2ClientCredentialsGrantRequest&gt; clientCredentialsTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
        OAuth2AuthorizedClientProviderBuilder.builder()
                .clientCredentials(configurer -&gt; configurer.accessTokenResponseClient(clientCredentialsTokenResponseClient))
                .build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Customize
val clientCredentialsTokenResponseClient: OAuth2AccessTokenResponseClient&lt;OAuth2ClientCredentialsGrantRequest&gt; = ...

val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
        .clientCredentials { it.accessTokenResponseClient(clientCredentialsTokenResponseClient) }
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2AuthorizedClientProviderBuilder.builder().clientCredentials()</code> 配置 <code>ClientCredentialsOAuth2AuthorizedClientProvider</code>,这是 <code>OAuth2AuthorizedClientProvider</code> 的实现,用于 Client Credentials 授权.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="使用访问令牌"><a class="anchor" href="#使用访问令牌"></a>使用访问令牌</h6>
<div class="paragraph">
<p>为 OAuth 2.0 客户端注册提供以下 Spring Boot 2.x 属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: client_credentials
            scope: read, write
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;&#8230;&#8203;以及 <code>OAuth2AuthorizedClientManager</code> <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
        ClientRegistrationRepository clientRegistrationRepository,
        OAuth2AuthorizedClientRepository authorizedClientRepository) {

    OAuth2AuthorizedClientProvider authorizedClientProvider =
            OAuth2AuthorizedClientProviderBuilder.builder()
                    .clientCredentials()
                    .build();

    DefaultOAuth2AuthorizedClientManager authorizedClientManager =
            new DefaultOAuth2AuthorizedClientManager(
                    clientRegistrationRepository, authorizedClientRepository);
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

    return authorizedClientManager;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .clientCredentials()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)
    return authorizedClientManager
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以按以下方式获取 <code>OAuth2AccessToken</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
public class OAuth2ClientController {

    @Autowired
    private OAuth2AuthorizedClientManager authorizedClientManager;

    @GetMapping("/")
    public String index(Authentication authentication,
                        HttpServletRequest servletRequest,
                        HttpServletResponse servletResponse) {

        OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(authentication)
                .attributes(attrs -&gt; {
                    attrs.put(HttpServletRequest.class.getName(), servletRequest);
                    attrs.put(HttpServletResponse.class.getName(), servletResponse);
                })
                .build();
        OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);

        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

        ...

        return "index";
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class OAuth2ClientController {

    @Autowired
    private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager

    @GetMapping("/")
    fun index(authentication: Authentication?,
              servletRequest: HttpServletRequest,
              servletResponse: HttpServletResponse): String {
        val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(authentication)
                .attributes(Consumer { attrs: MutableMap&lt;String, Any&gt; -&gt;
                    attrs[HttpServletRequest::class.java.name] = servletRequest
                    attrs[HttpServletResponse::class.java.name] = servletResponse
                })
                .build()
        val authorizedClient = authorizedClientManager.authorize(authorizeRequest)
        val accessToken: OAuth2AccessToken = authorizedClient.accessToken

        ...

        return "index"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 都是可选属性.  如果未提供,它将使用 <code>RequestContextHolder.getRequestAttributes()</code> 默认为 <code>ServletRequestAttributes</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2Client-password-grant"><a class="anchor" href="#oauth2Client-password-grant"></a>资源所有者密码凭证</h5>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
有关资源所有者密码凭据授权的更多详细信息,请参考 <a href="https://tools.ietf.org/html/rfc6749#section-1.3.3">Resource Owner Password Credentials</a>.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="访问令牌请求-3"><a class="anchor" href="#访问令牌请求-3"></a>访问令牌请求</h6>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请参阅 <a href="https://tools.ietf.org/html/rfc6749#section-4.3.2">Access Token Request/Response</a>  协议流,以获取 "资源所有者密码凭据" 授权.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>用于资源所有者密码凭据授权的 <code>OAuth2AccessTokenResponseClient</code> 的默认实现是 <code>DefaultPasswordTokenResponseClient</code>,当在授权服务器的令牌端点请求访问令牌时,它将使用 <code>RestOperations</code>.</p>
</div>
<div class="paragraph">
<p><code>DefaultPasswordTokenResponseClient</code> 非常灵活,因为它允许您自定义令牌请求的预处理和/或令牌响应的后处理.</p>
</div>
</div>
<div class="sect5">
<h6 id="自定义访问令牌请求-3"><a class="anchor" href="#自定义访问令牌请求-3"></a>自定义访问令牌请求</h6>
<div class="paragraph">
<p>如果需要自定义令牌请求的预处理,则可以为 <code>DefaultPasswordTokenResponseClient.setRequestEntityConverter()</code> 提供自定义 <code>Converter&lt;OAuth2PasswordGrantRequest, RequestEntity&lt;?&gt;&gt;</code>.
默认实现 <code>OAuth2PasswordGrantRequestEntityConverter</code> 构建标准 <a href="https://tools.ietf.org/html/rfc6749#section-4.3.2">OAuth 2.0 Access Token Request</a>的 <code>RequestEntity</code> 表示形式.  但是,提供自定义 <code>Converter</code> 将允许您扩展标准令牌请求并添加自定义参数.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
自定义 <code>Converter</code> 必须返回预期的 OAuth 2.0 提供程序可以理解的 OAuth 2.0 访问令牌请求的有效 <code>RequestEntity</code> 表示形式.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="自定义访问令牌响应-3"><a class="anchor" href="#自定义访问令牌响应-3"></a>自定义访问令牌响应</h6>
<div class="paragraph">
<p>另一方面,如果您需要自定义令牌响应的后处理,则需要为 <code>DefaultPasswordTokenResponseClient.setRestOperations()</code> 提供一个自定义配置的 <code>RestOperations</code>.  默认的 <code>RestOperations</code> 配置如下:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RestTemplate restTemplate = new RestTemplate(Arrays.asList(
        new FormHttpMessageConverter(),
        new OAuth2AccessTokenResponseHttpMessageConverter()));

restTemplate.setErrorHandler(new OAuth2ErrorResponseErrorHandler());
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val restTemplate = RestTemplate(listOf(
        FormHttpMessageConverter(),
        OAuth2AccessTokenResponseHttpMessageConverter()))

restTemplate.errorHandler = OAuth2ErrorResponseErrorHandler()</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
发送 OAuth 2.0 访问令牌请求时,需要使用 Spring MVC <code>FormHttpMessageConverter</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>OAuth2AccessTokenResponseHttpMessageConverter</code> 是OAuth 2.0访问令牌响应的 <code>HttpMessageConverter</code>.  您可以为 <code>OAuth2AccessTokenResponseHttpMessageConverter.setTokenResponseConverter()</code> 提供一个自定义 <code>Converter&lt;Map&lt;String, String&gt;, OAuth2AccessTokenResponse&gt;</code>,该转换器用于将OAuth 2.0访问令牌响应参数转换为 <code>OAuth2AccessTokenResponse</code>.</p>
</div>
<div class="paragraph">
<p><code>OAuth2ErrorResponseErrorHandler</code> 是一个 <code>ResponseErrorHandler</code>,可以处理OAuth 2.0错误,例如.  400错误的请求.  它使用 <code>OAuth2ErrorHttpMessageConverter</code> 将OAuth 2.0错误参数转换为 <code>OAuth2Error</code>.</p>
</div>
<div class="paragraph">
<p>无论您是自定义 <code>DefaultPasswordTokenResponseClient</code> 还是提供自己的 <code>OAuth2AccessTokenResponseClient</code> 实现,都需要按以下示例所示进行配置:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Customize
OAuth2AccessTokenResponseClient&lt;OAuth2PasswordGrantRequest&gt; passwordTokenResponseClient = ...

OAuth2AuthorizedClientProvider authorizedClientProvider =
        OAuth2AuthorizedClientProviderBuilder.builder()
                .password(configurer -&gt; configurer.accessTokenResponseClient(passwordTokenResponseClient))
                .refreshToken()
                .build();

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val passwordTokenResponseClient: OAuth2AccessTokenResponseClient&lt;OAuth2PasswordGrantRequest&gt; = ...

val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
        .password { it.accessTokenResponseClient(passwordTokenResponseClient) }
        .refreshToken()
        .build()

...

authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>OAuth2AuthorizedClientProviderBuilder.builder().password()</code> 配置 <code>PasswordOAuth2AuthorizedClientProvider</code>,它是 <code>OAuth2AuthorizedClientProvider</code> 的实现,用于资源所有者密码证书授权.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="使用访问令牌-2"><a class="anchor" href="#使用访问令牌-2"></a>使用访问令牌</h6>
<div class="paragraph">
<p>为OAuth 2.0客户端注册提供以下Spring Boot 2.x属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          okta:
            client-id: okta-client-id
            client-secret: okta-client-secret
            authorization-grant-type: password
            scope: read, write
        provider:
          okta:
            token-uri: https://dev-1234.oktapreview.com/oauth2/v1/token</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#8230;&#8203;&#8230;&#8203;以及 <code>OAuth2AuthorizedClientManager</code> <code>@Bean</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public OAuth2AuthorizedClientManager authorizedClientManager(
        ClientRegistrationRepository clientRegistrationRepository,
        OAuth2AuthorizedClientRepository authorizedClientRepository) {

    OAuth2AuthorizedClientProvider authorizedClientProvider =
            OAuth2AuthorizedClientProviderBuilder.builder()
                    .password()
                    .refreshToken()
                    .build();

    DefaultOAuth2AuthorizedClientManager authorizedClientManager =
            new DefaultOAuth2AuthorizedClientManager(
                    clientRegistrationRepository, authorizedClientRepository);
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider);

    // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
    // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
    authorizedClientManager.setContextAttributesMapper(contextAttributesMapper());

    return authorizedClientManager;
}

private Function&lt;OAuth2AuthorizeRequest, Map&lt;String, Object&gt;&gt; contextAttributesMapper() {
    return authorizeRequest -&gt; {
        Map&lt;String, Object&gt; contextAttributes = Collections.emptyMap();
        HttpServletRequest servletRequest = authorizeRequest.getAttribute(HttpServletRequest.class.getName());
        String username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME);
        String password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD);
        if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
            contextAttributes = new HashMap&lt;&gt;();

            // `PasswordOAuth2AuthorizedClientProvider` requires both attributes
            contextAttributes.put(OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME, username);
            contextAttributes.put(OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME, password);
        }
        return contextAttributes;
    };
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun authorizedClientManager(
        clientRegistrationRepository: ClientRegistrationRepository,
        authorizedClientRepository: OAuth2AuthorizedClientRepository): OAuth2AuthorizedClientManager {
    val authorizedClientProvider = OAuth2AuthorizedClientProviderBuilder.builder()
            .password()
            .refreshToken()
            .build()
    val authorizedClientManager = DefaultOAuth2AuthorizedClientManager(
            clientRegistrationRepository, authorizedClientRepository)
    authorizedClientManager.setAuthorizedClientProvider(authorizedClientProvider)

    // Assuming the `username` and `password` are supplied as `HttpServletRequest` parameters,
    // map the `HttpServletRequest` parameters to `OAuth2AuthorizationContext.getAttributes()`
    authorizedClientManager.setContextAttributesMapper(contextAttributesMapper())
    return authorizedClientManager
}

private fun contextAttributesMapper(): Function&lt;OAuth2AuthorizeRequest, MutableMap&lt;String, Any&gt;&gt; {
    return Function { authorizeRequest -&gt;
        var contextAttributes: MutableMap&lt;String, Any&gt; = mutableMapOf()
        val servletRequest: HttpServletRequest = authorizeRequest.getAttribute(HttpServletRequest::class.java.name)
        val username = servletRequest.getParameter(OAuth2ParameterNames.USERNAME)
        val password = servletRequest.getParameter(OAuth2ParameterNames.PASSWORD)
        if (StringUtils.hasText(username) &amp;&amp; StringUtils.hasText(password)) {
            contextAttributes = hashMapOf()

            // `PasswordOAuth2AuthorizedClientProvider` requires both attributes
            contextAttributes[OAuth2AuthorizationContext.USERNAME_ATTRIBUTE_NAME] = username
            contextAttributes[OAuth2AuthorizationContext.PASSWORD_ATTRIBUTE_NAME] = password
        }
        contextAttributes
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以按以下方式获取 <code>OAuth2AccessToken</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
public class OAuth2ClientController {

    @Autowired
    private OAuth2AuthorizedClientManager authorizedClientManager;

    @GetMapping("/")
    public String index(Authentication authentication,
                        HttpServletRequest servletRequest,
                        HttpServletResponse servletResponse) {

        OAuth2AuthorizeRequest authorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(authentication)
                .attributes(attrs -&gt; {
                    attrs.put(HttpServletRequest.class.getName(), servletRequest);
                    attrs.put(HttpServletResponse.class.getName(), servletResponse);
                })
                .build();
        OAuth2AuthorizedClient authorizedClient = this.authorizedClientManager.authorize(authorizeRequest);

        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

        ...

        return "index";
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class OAuth2ClientController {
    @Autowired
    private lateinit var authorizedClientManager: OAuth2AuthorizedClientManager

    @GetMapping("/")
    fun index(authentication: Authentication?,
              servletRequest: HttpServletRequest,
              servletResponse: HttpServletResponse): String {
        val authorizeRequest: OAuth2AuthorizeRequest = OAuth2AuthorizeRequest.withClientRegistrationId("okta")
                .principal(authentication)
                .attributes(Consumer {
                    it[HttpServletRequest::class.java.name] = servletRequest
                    it[HttpServletResponse::class.java.name] = servletResponse
                })
                .build()
        val authorizedClient = authorizedClientManager.authorize(authorizeRequest)
        val accessToken: OAuth2AccessToken = authorizedClient.accessToken

        ...

        return "index"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>HttpServletRequest</code> 和 <code>HttpServletResponse</code> 都是可选属性.  如果未提供,它将使用 <code>RequestContextHolder.getRequestAttributes()</code> 默认为 <code>ServletRequestAttributes</code>.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2Client-additional-features"><a class="anchor" href="#oauth2Client-additional-features"></a>12.2.3. 其他功能</h4>
<div class="sect4">
<h5 id="oauth2Client-registered-authorized-client"><a class="anchor" href="#oauth2Client-registered-authorized-client"></a>解析授权客户端</h5>
<div class="paragraph">
<p><code>@RegisteredOAuth2AuthorizedClient</code> 注解提供了将方法参数解析为 <code>OAuth2AuthorizedClient</code> 类型的参数值的功能.  与使用 <code>OAuth2AuthorizedClientManager</code> 或 <code>OAuth2AuthorizedClientService</code> 访问 <code>OAuth2AuthorizedClient</code> 相比,这是一种方便的选择.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
public class OAuth2ClientController {

    @GetMapping("/")
    public String index(@RegisteredOAuth2AuthorizedClient("okta") OAuth2AuthorizedClient authorizedClient) {
        OAuth2AccessToken accessToken = authorizedClient.getAccessToken();

        ...

        return "index";
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Controller
class OAuth2ClientController {
    @GetMapping("/")
    fun index(@RegisteredOAuth2AuthorizedClient("okta") authorizedClient: OAuth2AuthorizedClient): String {
        val accessToken = authorizedClient.accessToken

        ...

        return "index"
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>@RegisteredOAuth2AuthorizedClient</code> 注解由 <code>OAuth2AuthorizedClientArgumentResolver</code> 处理,该注解直接使用<a href="#oauth2Client-authorized-manager-provider">OAuth2AuthorizedClientManager</a> 并继承其功能.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2Client-webclient-servlet"><a class="anchor" href="#oauth2Client-webclient-servlet"></a>12.2.4. 在Servlet环境中集成WebClient</h4>
<div class="paragraph">
<p>OAuth 2.0客户端支持使用 <code>ExchangeFilterFunction</code> 与 <code>WebClient</code> 集成.</p>
</div>
<div class="paragraph">
<p><code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code> 提供了一种简单的机制,可以通过使用 <code>OAuth2AuthorizedClient</code> 并包括关联的 <code>OAuth2AccessToken</code> 作为承载令牌来请求受保护的资源.  它直接使用 <a href="#oauth2Client-authorized-manager-provider">OAuth2AuthorizedClientManager</a>,因此继承了以下功能:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果尚未授权客户端,则将请求 <code>OAuth2AccessToken</code>.</p>
<div class="ulist">
<ul>
<li>
<p><code>authorization_code</code> - 触发授权请求重定向以启动流程</p>
</li>
<li>
<p><code>client_credentials</code> - 访问令牌直接从令牌端点获取</p>
</li>
<li>
<p><code>password</code> - 访问令牌直接从令牌端点获取</p>
</li>
</ul>
</div>
</li>
<li>
<p>如果 <code>OAuth2AccessToken</code> 过期,则如果 <code>OAuth2AuthorizedClientProvider</code> 可用于执行授权,它将被刷新 (或更新) .</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下代码显示了如何使用 OAuth 2.0 客户端支持配置 <code>WebClient</code> 的示例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
    ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
            new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {
    val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="提供授权客户端"><a class="anchor" href="#提供授权客户端"></a>提供授权客户端</h5>
<div class="paragraph">
<p><code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code> 通过从 <code>ClientRequest.attributes()</code>  (请求属性) 解析 <code>OAuth2AuthorizedClient</code> 来确定要使用的客户端 (用于请求) .</p>
</div>
<div class="paragraph">
<p>以下代码显示了如何将 <code>OAuth2AuthorizedClient</code> 设置为请求属性:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/")
public String index(@RegisteredOAuth2AuthorizedClient("okta") OAuth2AuthorizedClient authorizedClient) {
    String resourceUri = ...

    String body = webClient
            .get()
            .uri(resourceUri)
            .attributes(oauth2AuthorizedClient(authorizedClient))   <i class="conum" data-value="1"></i><b>(1)</b>
            .retrieve()
            .bodyToMono(String.class)
            .block();

    ...

    return "index";
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/")
fun index(@RegisteredOAuth2AuthorizedClient("okta") authorizedClient: OAuth2AuthorizedClient): String {
    val resourceUri: String = ...
    val body: String = webClient
            .get()
            .uri(resourceUri)
            .attributes(oauth2AuthorizedClient(authorizedClient)) <i class="conum" data-value="1"></i><b>(1)</b>
            .retrieve()
            .bodyToMono()
            .block()

    ...

    return "index"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>oauth2AuthorizedClient()</code> 是 <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code> 中的 <code>static</code> 方法.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>以下代码显示了如何将 <code>ClientRegistration.getRegistrationId()</code> 设置为请求属性:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/")
public String index() {
    String resourceUri = ...

    String body = webClient
            .get()
            .uri(resourceUri)
            .attributes(clientRegistrationId("okta"))   <i class="conum" data-value="1"></i><b>(1)</b>
            .retrieve()
            .bodyToMono(String.class)
            .block();

    ...

    return "index";
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/")
fun index(): String {
    val resourceUri: String = ...

    val body: String = webClient
            .get()
            .uri(resourceUri)
            .attributes(clientRegistrationId("okta"))  <i class="conum" data-value="1"></i><b>(1)</b>
            .retrieve()
            .bodyToMono()
            .block()

    ...

    return "index"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>clientRegistrationId()</code> 是 <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code> 中的 <code>static</code> 方法.</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="默认授权客户端"><a class="anchor" href="#默认授权客户端"></a>默认授权客户端</h5>
<div class="paragraph">
<p>如果未提供 <code>OAuth2AuthorizedClient</code> 或 <code>ClientRegistration.getRegistrationId()</code> 作为请求属性,则 <code>ServletOAuth2AuthorizedClientExchangeFilterFunction</code> 可以根据其配置确定要使用的默认客户端.</p>
</div>
<div class="paragraph">
<p>如果配置了 <code>setDefaultOAuth2AuthorizedClient(true)</code> 且用户已使用 <code>HttpSecurity.oauth2Login()</code> 进行了身份验证,则使用与当前 <code>OAuth2AuthenticationToken</code> 关联的 <code>OAuth2AccessToken</code>.</p>
</div>
<div class="paragraph">
<p>以下代码显示了特定的配置:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
    ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
            new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
    oauth2Client.setDefaultOAuth2AuthorizedClient(true);
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {
    val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    oauth2Client.setDefaultOAuth2AuthorizedClient(true)
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
建议谨慎使用此功能,因为所有 HTTP 请求都会收到访问令牌.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>或者,如果 <code>setDefaultClientRegistrationId("okta")</code> 配置了有效的 <code>ClientRegistration</code>,则使用与 <code>OAuth2AuthorizedClient</code> 关联的 <code>OAuth2AccessToken</code>.</p>
</div>
<div class="paragraph">
<p>以下代码显示了特定的配置:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
WebClient webClient(OAuth2AuthorizedClientManager authorizedClientManager) {
    ServletOAuth2AuthorizedClientExchangeFilterFunction oauth2Client =
            new ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager);
    oauth2Client.setDefaultClientRegistrationId("okta");
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webClient(authorizedClientManager: OAuth2AuthorizedClientManager?): WebClient {
    val oauth2Client = ServletOAuth2AuthorizedClientExchangeFilterFunction(authorizedClientManager)
    oauth2Client.setDefaultClientRegistrationId("okta")
    return WebClient.builder()
            .apply(oauth2Client.oauth2Configuration())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
建议谨慎使用此功能,因为所有 HTTP 请求都会收到访问令牌.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="oauth2resourceserver"><a class="anchor" href="#oauth2resourceserver"></a>12.3. OAuth 2.0 资源服务器</h3>
<div class="paragraph">
<p>Spring Security 支持使用两种形式的 OAuth 2.0 <a href="https://tools.ietf.org/html/rfc6750.html">Bearer Tokens</a> 来保护端点:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc7519">JWT</a></p>
</li>
<li>
<p>Opaque Tokens</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在应用程序将其权限管理委派给 <a href="https://tools.ietf.org/html/rfc6749">授权服务器</a>  (例如Okta或Ping Identity) 的情况下,这很方便.  资源服务器可以咨询该授权服务器以授权请求.</p>
</div>
<div class="paragraph">
<p>本节详细介绍了 Spring Security 如何提供对 OAuth 2.0 的支持 <a href="https://tools.ietf.org/html/rfc6750.html">Bearer Tokens</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Spring Security <a href="https://github.com/spring-projects/spring-security/master/">Spring Security repository</a> 中提供了  <a href="https://github.com/spring-projects/spring-security/master//boot/oauth2resourceserver">JWTs</a> 和 <a href="https://github.com/spring-projects/spring-security/master//boot/oauth2resourceserver-opaque">Opaque Tokens</a> 的示例.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>让我们看一下 Bearer Token Authentication 在 Spring Security 中的工作方式. 首先， 我们看到， 与 <a href="#servlet-authentication-basic">Basic Authentication</a> 一样， <a href="https://tools.ietf.org/html/rfc7235#section-4.1">WWW-Authenticate</a> 头被发送回未经身份验证的客户端.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/oauth2/bearerauthenticationentrypoint.png" alt="bearerauthenticationentrypoint">
</div>
<div class="title">Figure 14. Sending WWW-Authenticate Header</div>
</div>
<div class="paragraph">
<p>上图基于我们的 <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a>  图.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> 首先， 用户向 <code>/private</code> 资源请求未经身份验证的请求.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> Spring Security 的 <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> 通过抛出 <code>AccessDeniedException</code> 异常来表示未经身份验证的请求被拒绝. .</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> 由于用户未经身份验证, <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> 启动身份验证.配置的 <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> 是 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/server/resource/authentication/BearerTokenAuthenticationEntryPoint.html"><code>BearerTokenAuthenticationEntryPoint</code></a> 的实例 它发送了一个 WWW-Authenticate header.
<code>RequestCache</code> 通常是 <code>NullRequestCache</code> 它不保存请求， 因为客户端能够重播最初请求的请求.</p>
</div>
<div class="paragraph">
<p>当客户端收到 <code>WWW-Authenticate: Bearer</code> header 时， 它知道如何重新处理 bearer token.  下面是处理的承 bearer token 的流程.</p>
</div>
<div id="oauth2resourceserver-authentication-bearertokenauthenticationfilter" class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/oauth2/bearertokenauthenticationfilter.png" alt="bearertokenauthenticationfilter">
</div>
<div class="title">Figure 15. Authenticating Bearer Token</div>
</div>
<div class="paragraph">
<p>The figure builds off our <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> diagram.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> 当用户提交他们的 bearer token 时, <code>BearerTokenAuthenticationFilter</code> 会创建一个 <code>BearerTokenAuthenticationToken</code> .它是通过从 <code>HttpServletRequest</code>  中提取令牌的一种 <a href="#servlet-authentication-authentication"><code>Authentication</code></a> .</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> 接下来, <code>HttpServletRequest</code> 将传递给 <code>AuthenticationManagerResolver</code>, 用于选择 <code>AuthenticationManager</code>.  <code>BearerTokenAuthenticationToken</code> 将被传递到已验证的 <code>AuthenticationManager</code> 中.
<code>AuthenticationManager</code> 看起来依赖与您配置的是 <a href="#oauth2resourceserver-jwt-minimalconfiguration">JWT</a> 或 <a href="#oauth2resourceserver-opaque-minimalconfiguration">opaque token</a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> 如果身份验证失败， 则失败</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> 被清除.</p>
</li>
<li>
<p>调用 <code>AuthenticationEntryPoint</code> 以触发再次发送的 WWW-Authenticate header.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_4.png" alt="number 4"></span> 如果身份验证成功， 则成功.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <a href="#servlet-authentication-securitycontextholder">SecurityContextHolder</a> 设置 <a href="#servlet-authentication-authentication">Authentication</a>.</p>
</li>
<li>
<p><code>BearerTokenAuthenticationFilter</code> 调用 <code>FilterChain.doFilter(request,response)</code> 继续应用程序逻辑的其余部分. .</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-minimalconfiguration"><a class="anchor" href="#oauth2resourceserver-jwt-minimalconfiguration"></a>12.3.1. JWT 的最小配置</h4>
<div class="paragraph">
<p>使用 <a href="https://spring.io/projects/spring-boot">Spring Boot</a> 时,将应用程序配置为资源服务器包括两个基本步骤.  首先,包括所需的依赖,其次,指示授权服务器的位置.</p>
</div>
<div class="sect4">
<h5 id="指定授权服务器"><a class="anchor" href="#指定授权服务器"></a>指定授权服务器</h5>
<div class="paragraph">
<p>在 Spring Boot 应用程序中,要指定要使用的授权服务器,只需执行以下操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com/issuer</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code><a href="https://idp.example.com/issuer" class="bare">idp.example.com/issuer</a></code> 是授权服务器将颁发的JWT令牌的 <code>iss</code> 声明中包含的值.  资源服务器将使用此属性进行进一步的自我配置,发现授权服务器的公钥,然后验证传入的JWT.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
要使用 <code>issuer-uri</code> 属性,还必须确保 <code><a href="https://idp.example.com/issuer/.well-known/openid-configuration" class="bare">idp.example.com/issuer/.well-known/openid-configuration</a></code>, <code><a href="https://idp.example.com/.well-known/openid-configuration/issuer" class="bare">idp.example.com/.well-known/openid-configuration/issuer</a></code>, 或  <code><a href="https://idp.example.com/.well-known/oauth-authorization-server/issuer" class="bare">idp.example.com/.well-known/oauth-authorization-server/issuer</a></code> 是授权服务器支持的端点.
此端点称为 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Provider Configuration</a>  端点或授权服务器 <a href="https://tools.ietf.org/html/rfc8414#section-3">Authorization Server Metadata</a> 端点.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>就是这样！</p>
</div>
</div>
<div class="sect4">
<h5 id="启动预期"><a class="anchor" href="#启动预期"></a>启动预期</h5>
<div class="paragraph">
<p>使用此属性和这些依赖时,资源服务器将自动配置自身以验证JWT编码的 Bearer 令牌.</p>
</div>
<div class="paragraph">
<p>它通过确定性的启动过程来实现:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>点击提供者配置或授权服务器元数据端点,处理 <code>jwks_url</code> 属性的响应</p>
</li>
<li>
<p>配置验证策略以查询 <code>jwks_url</code> 以获取有效的公共密钥</p>
</li>
<li>
<p>配置验证策略,以根据 <code><a href="https://idp.example.com" class="bare">idp.example.com</a></code> 验证每个JWT的 <code>iss</code> 声明.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>此过程的结果是,授权服务器必须启动并接收请求,才能成功启动资源服务器.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果在资源服务器查询授权服务器时授权服务器已关闭 (给出适当的超时) ,则启动将失败.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="运行时预期"><a class="anchor" href="#运行时预期"></a>运行时预期</h5>
<div class="paragraph">
<p>应用程序启动后,资源服务器将尝试处理任何包含 <code>Authorization: Bearer</code>  头的请求:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要指示了此方案,资源服务器就会尝试根据 Bearer Token 规范处理请求.</p>
</div>
<div class="paragraph">
<p>给定格式正确的 JWT,资源服务器将:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在启动期间根据从 <code>jwks_url</code> 端点获取并与 JWTs header 匹配的公钥验证其签名</p>
</li>
<li>
<p>验证 JWT 的 <code>exp</code> 和 <code>nbf</code> 时间戳以及 JWT 的 <code>iss</code> 声明,以及</p>
</li>
<li>
<p>将每个范围映射到具有前缀 <code>SCOPE_</code> 的权限.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当授权服务器提供新的密钥时,Spring Security 将自动旋转用于验证 JWTs 令牌的密钥.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下,生成的  <code>Authentication#getPrincipal</code> 是 Spring Security <code>Jwt</code> 对象,并且  <code>Authentication#getName</code> 映射到JWT的 <code>sub</code> 属性 (如果存在) .</p>
</div>
<div class="paragraph">
<p>从这里,考虑跳到:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2resourceserver-jwt-architecture">How JWT Authentication Works</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-jwt-jwkseturi">How to Configure without tying Resource Server startup to an authorization server&#8217;s availability</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-jwt-sansboot">How to Configure without Spring Boot</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-architecture"><a class="anchor" href="#oauth2resourceserver-jwt-architecture"></a>12.3.2. JWT Authentication 如何工作</h4>
<div class="paragraph">
<p>接下来， 让我们看看 Spring Security 用于支持基于 Servlet 的应用程序的 <a href="https://tools.ietf.org/html/rfc7519">JWT</a> 身份验证的架构组件， 如我们刚刚看到的应用程序.</p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/server/resource/authentication/JwtAuthenticationProvider.html"><code>JwtAuthenticationProvider</code></a> 是一个 <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code></a> 的进一步实现， <a href="#oauth2resourceserver-jwt-decoder"><code>JwtDecoder</code></a> 和 <a href="#oauth2resourceserver-jwt-authorization-extraction"><code>JwtAuthenticationConverter</code></a> 进行身份验证 JWT.</p>
</div>
<div class="paragraph">
<p>让我们来看看 <code>JwtAuthenticationProvider</code> 如何在 Spring Security 中工作.  该图解释了 <a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">Reading the Bearer Token</a> 中的 <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a> 的详细信息.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/oauth2/jwtauthenticationprovider.png" alt="jwtauthenticationprovider">
</div>
<div class="title">Figure 16. <code>JwtAuthenticationProvider</code> Usage</div>
</div>
<div class="paragraph">
<p>读取承载令牌的身份验证过滤器将BearerTokenauthentInceStokentToken传递给AuthenticationManager， 该验证管理器由ProviderManager实现.</p>
</div>
<div class="paragraph">
<p>ProviderManager 配置为使用 <code>jwtauthenticationProvider</code> 类型的 <code>AuthenticationProvider</code>.</p>
</div>
<div class="paragraph">
<p>使用 <code>jwtdecoder</code>， <code>jwtauthenticationProvider</code> Provide， 验证并验证 JWT.</p>
</div>
<div class="paragraph">
<p>JwtauthenticationProvider 然后使用 jwtauthenticationConverter 将 JWT 转换为授予权限的集合.</p>
</div>
<div class="paragraph">
<p>当身份验证成功时， 返回的身份验证是 jwtauthenticationToken 类型， 并且具有由配置的 jwtdecoder 返回的 jwt 的主体.  最终， 返回的jwtauthenticationtokent 将通过身份验证过滤器设置在 <code>SecurityContextholder</code> 上.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> <a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">Reading the Bearer Token</a> 的 authentication <code>Filter</code> 将 <code>BearerTokenAuthenticationToken</code> 传递给由 <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>. 实现的 <code>AuthenticationManager</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> <code>ProviderManager</code> 配置为使用 <code>JwtAuthenticationProvider</code> 类型的<a href="#servlet-authentication-authenticationprovider">AuthenticationProvider</a>.</p>
</div>
<div id="oauth2resourceserver-jwt-architecture-jwtdecoder" class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> <code>JwtAuthenticationProvider</code> 使用 <a href="#oauth2resourceserver-jwt-decoder"><code>JwtDecoder</code></a> decodes, verifies, and validates the <code>Jwt</code>.</p>
</div>
<div id="oauth2resourceserver-jwt-architecture-jwtauthenticationconverter" class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_4.png" alt="number 4"></span> 然后,<code>JwtAuthenticationProvider</code> 使用 <a href="#oauth2resourceserver-jwt-authorization-extraction"><code>JwtAuthenticationConverter</code></a> 将 <code>Jwt</code> 转换为已授予权限的集合.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_5.png" alt="number 5"></span> 当身份验证成功时， 返回的 <a href="#servlet-authentication-authentication"><code>Authentication</code></a> 类型为 <code>JwtAuthenticationToken</code> 并且具有由配置的 <code>JwtDecoder</code> 返回的 <code>Jwt</code> 主体.
最终， 返回的 <code>JwtAuthenticationToken</code> 将通过身份验证 <code>Filter</code> 设置在 <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a>上.</p>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-jwkseturi"><a class="anchor" href="#oauth2resourceserver-jwt-jwkseturi"></a>12.3.3. 直接指定授权服务器 JWK 设置 Uri</h4>
<div class="paragraph">
<p>如果授权服务器不支持任何配置端点,或者如果资源服务器必须能够独立于授权服务器启动,那么还可以提供 <code>jwk-set-uri</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com
          jwk-set-uri: https://idp.example.com/.well-known/jwks.json</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
JWK Set uri 尚未标准化,但通常可以在授权服务器的文档中找到
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>因此,资源服务器在启动时不会对授权服务器执行 ping 操作.  我们仍然指定 <code>issuer-uri</code>,以便 Resource Server 仍然验证传入 JWT 上的 <code>iss</code> 声明.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
此属性也可以直接在<a href="#oauth2resourceserver-jwt-jwkseturi-dsl">DSL</a> 上提供.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-sansboot"><a class="anchor" href="#oauth2resourceserver-jwt-sansboot"></a>12.3.4. 覆盖或替换引导自动配置</h4>
<div class="paragraph">
<p>Spring Boot 代表 Resource Server 生成了两个 <code>@Bean</code>.</p>
</div>
<div class="paragraph">
<p>第一个是将应用程序配置为资源服务器的 <code>WebSecurityConfigurerAdapter</code>.  当包含 <code>spring-security-oauth2-jose</code> 时,此 <code>WebSecurityConfigurerAdapter</code> 看起来像:</p>
</div>
<div class="exampleblock">
<div class="title">Example 101. Default JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果应用程序未暴露 <code>WebSecurityConfigurerAdapter</code> Bean,则 Spring Boot 将暴露上述默认值.</p>
</div>
<div class="paragraph">
<p>替换它就像在应用程序中暴露Bean一样简单:</p>
</div>
<div class="exampleblock">
<div class="title">Example 102. Custom JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .jwtAuthenticationConverter(myConverter())
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("SCOPE_message:read"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwtAuthenticationConverter = myConverter()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以上要求 <code>message:read</code> 的范围: 以 <code>/messages/</code> 开头的所有URL.</p>
</div>
<div class="paragraph">
<p><code>oauth2ResourceServer</code> DSL 上的方法还将覆盖或替换自动配置.</p>
</div>
<div id="oauth2resourceserver-jwt-decoder" class="paragraph">
<p>例如,第二个 <code>@Bean</code> Spring Boot 创建的是 <code>JwtDecoder</code>,它将 <code>String</code> 令牌解码为经过验证的 <code>Jwt</code> 实例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 103. JWT Decoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return JwtDecoders.fromIssuerLocation(issuerUri);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return JwtDecoders.fromIssuerLocation(issuerUri)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
调用  <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/jwt/JwtDecoders.html#fromIssuerLocation-java.lang.String-">JwtDecoders#fromIssuerLocation</a></code> 是调用提供者配置或授权服务器元数据端点以扩展 JWK 设置 Uri 的过程.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果该应用程序未暴露 <code>JwtDecoder</code> Bean,则 Spring Boot 将暴露上述默认值.</p>
</div>
<div class="paragraph">
<p>可以使用 <code>jwkSetUri()</code> 覆盖其配置,也可以使用 <code>decoder()</code> 替换其配置.</p>
</div>
<div class="paragraph">
<p>或者,如果您根本不使用 Spring Boot,那么这两个组件-过滤器链和 <code>JwtDecoder</code> 可以在 XML 中指定.</p>
</div>
<div class="paragraph">
<p>过滤器链的指定如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 104. Default JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt decoder-ref="jwtDecoder"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>And the <code>JwtDecoder</code> like so:</p>
</div>
<div class="exampleblock">
<div class="title">Example 105. JWT Decoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="jwtDecoder"
        class="org.springframework.security.oauth2.jwt.JwtDecoders"
        factory-method="fromIssuerLocation"&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-jwkseturi-dsl"><a class="anchor" href="#oauth2resourceserver-jwt-jwkseturi-dsl"></a>使用 <code>jwkSetUri()</code></h5>
<div class="paragraph">
<p>授权服务器的 JWK 设置 Uri 可以配置为<a href="#oauth2resourceserver-jwt-jwkseturi">as a configuration property</a>,也可以在 DSL 中提供:</p>
</div>
<div class="exampleblock">
<div class="title">Example 106. JWK Set Uri Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .jwkSetUri("https://idp.example.com/.well-known/jwks.json")
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredJwkSetUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwkSetUri = "https://idp.example.com/.well-known/jwks.json"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.com/.well-known/jwks.json"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>jwkSetUri()</code> 优先于任何配置属性.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-dsl"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-dsl"></a>使用 <code>decoder()</code></h5>
<div class="paragraph">
<p>比 <code>jwkSetUri()</code> 更强大的是 <code>decoder()</code>,它将完全替代 <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> 的所有 Boot 自动配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 107. JWT Decoder Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredJwtDecoder extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .decoder(myCustomDecoder())
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredJwtDecoder : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwtDecoder = myCustomDecoder()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt decoder-ref="myCustomDecoder"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当需要进行更深入的配置 (例如<a href="#oauth2resourceserver-jwt-validation">validation</a>,<a href="#oauth2resourceserver-jwt-claimsetmapping">mapping</a>或<a href="#oauth2resourceserver-jwt-timeouts">request timeouts</a>) 时,这非常方便.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-bean"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-bean"></a>暴露  <code>JwtDecoder</code> <code>@Bean</code></h5>
<div class="paragraph">
<p>或者,暴露 <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> <code>@Bean</code> 与  <code>decoder()</code> 具有相同的效果:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-decoder-algorithm"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-algorithm"></a>12.3.5. 配置可信算法</h4>
<div class="paragraph">
<p>默认情况下,<code>NimbusJwtDecoder</code> 以及资源服务器将仅使用 <code>RS256</code> 信任和验证令牌.</p>
</div>
<div class="paragraph">
<p>您可以通过 <a href="#oauth2resourceserver-jwt-boot-algorithm">Spring Boot</a>,<a href="#oauth2resourceserver-jwt-decoder-builder">NimbusJwtDecoder Builder</a>或从<a href="#oauth2resourceserver-jwt-decoder-jwk-response">JWK Set response</a>中对此进行自定义.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-boot-algorithm"><a class="anchor" href="#oauth2resourceserver-jwt-boot-algorithm"></a>通过Spring Boot</h5>
<div class="paragraph">
<p>设置算法的最简单方法是作为属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jws-algorithm: RS512
          jwk-set-uri: https://idp.example.org/.well-known/jwks.json</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-builder"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-builder"></a>使用 Builder</h5>
<div class="paragraph">
<p>但是,为了获得更大的功能,我们可以使用 <code>NimbusJwtDecoder</code> 附带的 Builder:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>多次调用 <code>jwsAlgorithm</code> 会将 <code>NimbusJwtDecoder</code> 配置为信任多个算法,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者,您可以调用 <code>jwsAlgorithms</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms(algorithms -&gt; {
                    algorithms.add(RS512);
                    algorithms.add(ES512);
            }).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms {
                it.add(RS512)
                it.add(ES512)
            }.build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-jwk-response"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-jwk-response"></a>来自 JWK Set 的回复</h5>
<div class="paragraph">
<p>由于 Spring Security 的 JWT 支持基于 Nimbus,因此您也可以使用其所有出色的功能.</p>
</div>
<div class="paragraph">
<p>例如,Nimbus 有一个 <code>JWSKeySelector</code> 实现,它将基于 JWK Set URI响应选择算法集.
您可以使用它生成 <code>NimbusJwtDecoder</code>,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    // makes a request to the JWK Set endpoint
    JWSKeySelector&lt;SecurityContext&gt; jwsKeySelector =
            JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(this.jwkSetUrl);

    DefaultJWTProcessor&lt;SecurityContext&gt; jwtProcessor =
            new DefaultJWTProcessor&lt;&gt;();
    jwtProcessor.setJWSKeySelector(jwsKeySelector);

    return new NimbusJwtDecoder(jwtProcessor);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    // makes a request to the JWK Set endpoint
    val jwsKeySelector: JWSKeySelector&lt;SecurityContext&gt; = JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL&lt;SecurityContext&gt;(this.jwkSetUrl)
    val jwtProcessor: DefaultJWTProcessor&lt;SecurityContext&gt; = DefaultJWTProcessor()
    jwtProcessor.jwsKeySelector = jwsKeySelector
    return NimbusJwtDecoder(jwtProcessor)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-decoder-public-key"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-public-key"></a>12.3.6. 信任单个非对称密钥</h4>
<div class="paragraph">
<p>比使用 JWK Set 端点备份资源服务器更简单的方法是对 RSA 公钥进行硬编码. 可以通过<a href="#oauth2resourceserver-jwt-decoder-public-key-boot">Spring Boot</a>或<a href="#oauth2resourceserver-jwt-decoder-public-key-builder">使用 Builder</a>提供公共密钥.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-public-key-boot"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-public-key-boot"></a>通过 Spring Boot</h5>
<div class="paragraph">
<p>通过 Spring Boot 指定密钥非常简单.
密钥的位置可以这样指定:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          public-key-location: classpath:my-key.pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者,为了进行更复杂的查找,可以对 <code>RsaKeyConversionServicePostProcessor</code> 进行后置处理:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
BeanFactoryPostProcessor conversionServiceCustomizer() {
    return beanFactory -&gt;
        beanFactory.getBean(RsaKeyConversionServicePostProcessor.class)
                .setResourceLoader(new CustomResourceLoader());
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun conversionServiceCustomizer(): BeanFactoryPostProcessor {
    return BeanFactoryPostProcessor { beanFactory -&gt;
        beanFactory.getBean&lt;RsaKeyConversionServicePostProcessor&gt;()
                .setResourceLoader(CustomResourceLoader())
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>指定密钥的位置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">key.location: hfds://my-key.pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后自动装配值:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Value("${key.location}")
RSAPublicKey key;
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Value("\${key.location}")
val key: RSAPublicKey? = null</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-decoder-public-key-builder"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-public-key-builder"></a>使用 Builder</h5>
<div class="paragraph">
<p>要直接连接 <code>RSAPublicKey</code>,只需使用适当的 <code>NimbusJwtDecoder</code> builder,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withPublicKey(this.key).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withPublicKey(this.key).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-decoder-secret-key"><a class="anchor" href="#oauth2resourceserver-jwt-decoder-secret-key"></a>12.3.7. 信任单个对称密钥</h4>
<div class="paragraph">
<p>使用单个对称密钥也很简单. 您可以简单地加载 <code>SecretKey</code> 并使用适当的 <code>NimbusJwtDecoder</code> 构建器,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withSecretKey(this.key).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withSecretKey(key).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-authorization"><a class="anchor" href="#oauth2resourceserver-jwt-authorization"></a>12.3.8. 配置授权</h4>
<div class="paragraph">
<p>从 OAuth 2.0 授权服务器发出的JWT通常具有 <code>scope</code> 或 <code>scp</code> 属性,指示其被授予的作用域 (或权限) ,例如:</p>
</div>
<div class="paragraph">
<p><code>{ &#8230;&#8203;, "scope" : "messages contacts"}</code></p>
</div>
<div class="paragraph">
<p>在这种情况下,资源服务器将尝试将这些作用域强制为已授予权限的列表,并为每个作用域添加字符串 "SCOPE_" 作为前缀.</p>
</div>
<div class="paragraph">
<p>这意味着为了保护具有从 JWT 扩展的作用域的端点或方法,相应的表达式应包含以下前缀:</p>
</div>
<div class="exampleblock">
<div class="title">Example 108. Authorization Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredJwkSetUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
                authorize("/messages/**", hasAuthority("SCOPE_messages"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt { }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或类似地具有方法安全性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasAuthority('SCOPE_messages')")
public List&lt;Message&gt; getMessages(...) {}
</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-authorization-extraction"><a class="anchor" href="#oauth2resourceserver-jwt-authorization-extraction"></a>手动提取权限</h5>
<div class="paragraph">
<p>但是,在许多情况下,此默认设置不足.例如,某些授权服务器不使用 <code>scope</code> 属性,而是使用自己的自定义属性.或者,在其他时候,资源服务器可能需要将属性或属性组成调整为内部化的权限.</p>
</div>
<div class="paragraph">
<p>为此， Spring Security 使用 <code>JwtAuthenticationConverter</code>， 负责 <a href="#oauth2resourceserver-jwt-architecture-jwtauthenticationconverter">将 <code>Jwt</code> 转换为 <code>Authentication</code></a>.  默认情况下， Spring Security 将使用 <code>JWTAuthenticationConverter</code> 的默认实例 <code>JwtAuthenticationProvider</code> 来引导.</p>
</div>
<div class="paragraph">
<p>作为配置 <code>JWTAuthenticationConverter</code> 的一部分， 我们可以提供一个辅助转换器,从 <code>Jwt</code> 到授权的 <code>Collection</code>.</p>
</div>
<div class="paragraph">
<p>假设您的授权服务器在称为授权的自定义声明中传达了授权， 称为权限. 在这种情况下,您可以配置 <a href="#oauth2resourceserver-jwt-architecture-jwtauthenticationconverter"><code>JwtAuthenticationConverter</code></a>  应该检查的声明,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 109. Authorities Claim Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
    grantedAuthoritiesConverter.setAuthoritiesClaimName("authorities");

    JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
    return jwtAuthenticationConverter;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
    val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter()
    grantedAuthoritiesConverter.setAuthoritiesClaimName("authorities")

    val jwtAuthenticationConverter = JwtAuthenticationConverter()
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter)
    return jwtAuthenticationConverter
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"
                jwt-authentication-converter-ref="jwtAuthenticationConverter"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;

&lt;bean id="jwtAuthenticationConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter"&gt;
    &lt;property name="jwtGrantedAuthoritiesConverter" ref="jwtGrantedAuthoritiesConverter"/&gt;
&lt;/bean&gt;

&lt;bean id="jwtGrantedAuthoritiesConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter"&gt;
    &lt;property name="authoritiesClaimName" value="authorities"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您还可以将权限前缀配置为不同. 您可以像这样将其更改为 <code>ROLE_</code> 而不是在每个权限前面加上 <code>SCOPE_</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 110. Authorities Prefix Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
    grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_");

    JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
    return jwtAuthenticationConverter;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
    val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter()
    grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_")

    val jwtAuthenticationConverter = JwtAuthenticationConverter()
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter)
    return jwtAuthenticationConverter
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"
                jwt-authentication-converter-ref="jwtAuthenticationConverter"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;

&lt;bean id="jwtAuthenticationConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter"&gt;
    &lt;property name="jwtGrantedAuthoritiesConverter" ref="jwtGrantedAuthoritiesConverter"/&gt;
&lt;/bean&gt;

&lt;bean id="jwtGrantedAuthoritiesConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter"&gt;
    &lt;property name="authorityPrefix" value="ROLE_"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者,可以通过调用 <code>JwtGrantedAuthoritiesConverter#setAuthorityPrefix("")</code> 来完全删除该前缀.</p>
</div>
<div class="paragraph">
<p>为了获得更大的灵活性,DSL 支持使用实现  <code>Converter&lt;Jwt, AbstractAuthenticationToken&gt;</code> 的任何类完全替换该转换器:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">static class CustomAuthenticationConverter implements Converter&lt;Jwt, AbstractAuthenticationToken&gt; {
    public AbstractAuthenticationToken convert(Jwt jwt) {
        return new CustomAuthenticationToken(jwt);
    }
}

// ...

@EnableWebSecurity
public class CustomAuthenticationConverterConfig extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .jwt(jwt -&gt; jwt
                    .jwtAuthenticationConverter(new CustomAuthenticationConverter())
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">internal class CustomAuthenticationConverter : Converter&lt;Jwt, AbstractAuthenticationToken&gt; {
    override fun convert(jwt: Jwt): AbstractAuthenticationToken {
        return CustomAuthenticationToken(jwt)
    }
}

// ...

@EnableWebSecurity
class CustomAuthenticationConverterConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
       http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
           oauth2ResourceServer {
               jwt {
                   jwtAuthenticationConverter = CustomAuthenticationConverter()
               }
           }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-validation"><a class="anchor" href="#oauth2resourceserver-jwt-validation"></a>12.3.9. 配置验证</h4>
<div class="paragraph">
<p>使用<a href="#oauth2resourceserver-jwt-minimalconfiguration">Spring Boot 最小配置</a> (指示授权服务器的 issuer uri) ,Resource Server将默认验证 <code>iss</code> 声明以及 <code>exp</code> 和 <code>nbf</code> 时间戳声明.</p>
</div>
<div class="paragraph">
<p>在需要自定义验证的情况下,资源服务器附带两个标准验证器,并且还接受自定义 <code>OAuth2TokenValidator</code> 实例.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-validation-clockskew"><a class="anchor" href="#oauth2resourceserver-jwt-validation-clockskew"></a>自定义时间戳验证</h5>
<div class="paragraph">
<p>JWT 通常具有有效期窗口,该窗口的开始在 <code>nbf</code> 声明中指示,而结束在 <code>exp</code> 声明中指示.</p>
</div>
<div class="paragraph">
<p>但是,每台服务器都会经历时钟漂移,这可能导致令牌在一个服务器上已经过期,而在另一台服务器上没有过期. 随着分布式系统中服务器数量的增加,这可能会导致某些实现上的不良反应.</p>
</div>
<div class="paragraph">
<p>资源服务器使用 <code>JwtTimestampValidator</code> 验证令牌的有效性窗口,并且可以将它配置为 <code>ClockSkew</code> 来缓解上述问题:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
     NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
             JwtDecoders.fromIssuerLocation(issuerUri);

     OAuth2TokenValidator&lt;Jwt&gt; withClockSkew = new DelegatingOAuth2TokenValidator&lt;&gt;(
            new JwtTimestampValidator(Duration.ofSeconds(60)),
            new JwtIssuerValidator(issuerUri));

     jwtDecoder.setJwtValidator(withClockSkew);

     return jwtDecoder;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder

    val withClockSkew: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(
            JwtTimestampValidator(Duration.ofSeconds(60)),
            JwtIssuerValidator(issuerUri))

    jwtDecoder.setJwtValidator(withClockSkew)

    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
默认情况下,资源服务器将时钟偏差配置为 30 秒.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-validation-custom"><a class="anchor" href="#oauth2resourceserver-jwt-validation-custom"></a>配置自定义验证器</h5>
<div class="paragraph">
<p>使用 <code>OAuth2TokenValidator</code> API 为 <code>aud</code> 声明添加检查很简单:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OAuth2TokenValidator&lt;Jwt&gt; audienceValidator() {
    return new JwtClaimValidator&lt;List&lt;String&gt;&gt;(AUD, aud -&gt; aud.contains("messaging"));
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun audienceValidator(): OAuth2TokenValidator&lt;Jwt?&gt; {
    return JwtClaimValidator&lt;List&lt;String&gt;&gt;(AUD) { aud -&gt; aud.contains("messaging") }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者,为了获得更多控制权,您可以实现自己的 <code>OAuth2TokenValidator</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">static class AudienceValidator implements OAuth2TokenValidator&lt;Jwt&gt; {
    OAuth2Error error = new OAuth2Error("custom_code", "Custom error message", null);

    @Override
    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        if (jwt.getAudience().contains("messaging")) {
            return OAuth2TokenValidatorResult.success();
        } else {
            return OAuth2TokenValidatorResult.failure(error);
        }
    }
}

// ...

OAuth2TokenValidator&lt;Jwt&gt; audienceValidator() {
    return new AudienceValidator();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">internal class AudienceValidator : OAuth2TokenValidator&lt;Jwt&gt; {
    var error: OAuth2Error = OAuth2Error("custom_code", "Custom error message", null)

    override fun validate(jwt: Jwt): OAuth2TokenValidatorResult {
        return if (jwt.audience.contains("messaging")) {
            OAuth2TokenValidatorResult.success()
        } else {
            OAuth2TokenValidatorResult.failure(error)
        }
    }
}

// ...

fun audienceValidator(): OAuth2TokenValidator&lt;Jwt&gt; {
    return AudienceValidator()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后,要添加到资源服务器中,只需指定 <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> 实例即可:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
        JwtDecoders.fromIssuerLocation(issuerUri);

    OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = audienceValidator();
    OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);
    OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator);

    jwtDecoder.setJwtValidator(withAudience);

    return jwtDecoder;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder

    val audienceValidator = audienceValidator()
    val withIssuer: OAuth2TokenValidator&lt;Jwt&gt; = JwtValidators.createDefaultWithIssuer(issuerUri)
    val withAudience: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(withIssuer, audienceValidator)

    jwtDecoder.setJwtValidator(withAudience)

    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-claimsetmapping"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping"></a>12.3.10. 配置 Claim (声明)集映射</h4>
<div class="paragraph">
<p>Spring Security 使用 <a href="https://bitbucket.org/connect2id/nimbus-jose-jwt/wiki/Home">Nimbus</a> 库来解析JWT并验证其签名.  因此,Spring Security 受制于 Nimbus 对每个字段值以及如何将每个字段强制转换为 Java 类型的解释.</p>
</div>
<div class="paragraph">
<p>例如,由于 Nimbus 仍与 Java 7 兼容,因此它不使用 <code>Instant</code> 来表示时间戳字段.</p>
</div>
<div class="paragraph">
<p>而且完全有可能使用其他库或进行 JWT 处理,这可能会自行做出需要调整的决定.</p>
</div>
<div class="paragraph">
<p>或者,很简单,出于特定于域的原因,资源服务器可能希望从 JWT 中添加或删除声明.</p>
</div>
<div class="paragraph">
<p>为此,资源服务器支持将 JWT 声明集与 <code>MappedJwtClaimSetConverter</code> 映射.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-singleclaim"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-singleclaim"></a>自定义单个 Claim 的转换</h5>
<div class="paragraph">
<p>默认情况下,<code>MappedJwtClaimSetConverter</code> 将尝试将 claims 强制为以下类型:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Claim</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Java Type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>aud</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Collection&lt;String&gt;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exp</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Instant</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iat</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Instant</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>iss</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>jti</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nbf</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Instant</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sub</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>String</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可以使用  <code>MappedJwtClaimSetConverter.withDefaults</code> 配置单个声明的转化策略:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();

    MappedJwtClaimSetConverter converter = MappedJwtClaimSetConverter
            .withDefaults(Collections.singletonMap("sub", this::lookupUserIdBySub));
    jwtDecoder.setClaimSetConverter(converter);

    return jwtDecoder;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()

    val converter = MappedJwtClaimSetConverter
            .withDefaults(mapOf("sub" to this::lookupUserIdBySub))
    jwtDecoder.setClaimSetConverter(converter)

    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这将保留所有默认值,除了它将覆盖 <code>sub</code> 的默认声明转换器.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-add"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-add"></a>添加一个 Claim</h5>
<div class="paragraph">
<p><code>MappedJwtClaimSetConverter</code> 也可以用于添加自定义声明,例如,以适应现有系统:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("custom", custom -&gt; "value"));
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">MappedJwtClaimSetConverter.withDefaults(mapOf("custom" to Converter&lt;Any, String&gt; { "value" }))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-remove"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-remove"></a>删除一个 Claim</h5>
<div class="paragraph">
<p>使用相同的  API 删除声明也很简单:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("legacyclaim", legacy -&gt; null));
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">MappedJwtClaimSetConverter.withDefaults(mapOf("legacyclaim" to Converter&lt;Any, Any&gt; { null }))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-jwt-claimsetmapping-rename"><a class="anchor" href="#oauth2resourceserver-jwt-claimsetmapping-rename"></a>重命名一个 Claim</h5>
<div class="paragraph">
<p>在更复杂的场景中,例如一次查询多个声明或重命名一个声明,资源服务器接受任何实现 <code>Converter&lt;Map&lt;String, Object&gt;, Map&lt;String,Object&gt;&gt;</code> 的类:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class UsernameSubClaimAdapter implements Converter&lt;Map&lt;String, Object&gt;, Map&lt;String, Object&gt;&gt; {
    private final MappedJwtClaimSetConverter delegate =
            MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap());

    public Map&lt;String, Object&gt; convert(Map&lt;String, Object&gt; claims) {
        Map&lt;String, Object&gt; convertedClaims = this.delegate.convert(claims);

        String username = (String) convertedClaims.get("user_name");
        convertedClaims.put("sub", username);

        return convertedClaims;
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class UsernameSubClaimAdapter : Converter&lt;Map&lt;String, Any?&gt;, Map&lt;String, Any?&gt;&gt; {
    private val delegate = MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap())
    override fun convert(claims: Map&lt;String, Any?&gt;): Map&lt;String, Any?&gt; {
        val convertedClaims = delegate.convert(claims)
        val username = convertedClaims["user_name"] as String
        convertedClaims["sub"] = username
        return convertedClaims
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后,可以像平常一样提供实例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
    jwtDecoder.setClaimSetConverter(new UsernameSubClaimAdapter());
    return jwtDecoder;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()
    jwtDecoder.setClaimSetConverter(UsernameSubClaimAdapter())
    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-jwt-timeouts"><a class="anchor" href="#oauth2resourceserver-jwt-timeouts"></a>12.3.11. 配置超时</h4>
<div class="paragraph">
<p>默认情况下,资源服务器使用30秒钟的连接和套接字超时来与授权服务器进行协调.</p>
</div>
<div class="paragraph">
<p>在某些情况下,这可能太短了.  此外,它没有考虑退避和发现等更复杂的模式.</p>
</div>
<div class="paragraph">
<p>为了调整资源服务器连接到授权服务器的方式,<code>NimbusJwtDecoder</code> 接受 <code>RestOperations</code> 的实例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JwtDecoder jwtDecoder(RestTemplateBuilder builder) {
    RestOperations rest = builder
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build();

    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).restOperations(rest).build();
    return jwtDecoder;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(builder: RestTemplateBuilder): JwtDecoder {
    val rest: RestOperations = builder
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build()
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).restOperations(rest).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>同样默认情况下， 资源服务器在内存中将授权服务器的 JWK 设置缓存 5 分钟， 您可能需要对其进行调整.
此外， 它没有考虑更复杂的缓存模式， 例如失效或使用共享缓存.</p>
</div>
<div class="paragraph">
<p>为了调整资源服务器缓存 JWK set 的方式， <code>NimbusJwtDecoder</code> 接受 <code>Cache</code> 的实例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public JwtDecoder jwtDecoder(CacheManager cacheManager) {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri)
            .cache(cacheManager.getCache("jwks"))
            .build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(cacheManager: CacheManager): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri)
            .cache(cacheManager.getCache("jwks"))
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当给定一个 <code>Cache</code> 时， 资源服务器将使用 JWK Set Uri 作为键， 并使用 JWK Set JSON 作为值.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring 不是缓存提供者， 因此您需要确保包括适当的依赖项， 例如 <code>spring-boot-starter-cache</code> 和您最喜欢的缓存提供者.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
无论是 socket 超时还是缓存超时， 您都可以直接使用 Nimbus.
为此， 请记住， <code>NimbusJwtDecoder</code> 附带了一个采用 Nimbus 的 <code>JWTProcessor</code> 的构造函数.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-minimaldependencies"><a class="anchor" href="#oauth2resourceserver-opaque-minimaldependencies"></a>12.3.12. Minimal Dependencies for Introspection</h4>
<div class="paragraph">
<p>如 <a href="#oauth2resourceserver-jwt-minimalconfiguration">JWT 的最小配置</a> 中所述， 大多数资源服务器支持都在 <code>spring-security-oauth2-resource-server</code> 中. 但是， 除非提供了自定义的 <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a>,否则资源服务器将回退到 <code>NimbusOpaqueTokenIntrospector</code>.  这意味着 <code>spring-security-oauth2-resource-server</code> 和 <code>oauth2-oidc-sdk</code> 都是必需的， 以使支持不透明承载令牌的最小资源服务器正常工作.  为了确定 <code>oauth2-oidc-sdk</code> 的正确版本， 请参考 <code>spring-security-oauth2-resource-server</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-minimalconfiguration"><a class="anchor" href="#oauth2resourceserver-opaque-minimalconfiguration"></a>12.3.13. Introspection 最小配置</h4>
<div class="paragraph">
<p>通常,opaque token 可以通过授权服务器托管的 <a href="https://tools.ietf.org/html/rfc7662">OAuth 2.0 Introspection Endpoint</a>进行验证. 当需要撤销时,这可能很方便.</p>
</div>
<div class="paragraph">
<p>使用 <a href="https://spring.io/projects/spring-boot">Spring Boot</a> 时,将应用程序配置为使用内省的资源服务器包括两个基本步骤. 首先,包括所需的依赖性,其次,指示内省端点详细信息.</p>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspectionuri"><a class="anchor" href="#oauth2resourceserver-opaque-introspectionuri"></a>指定授权服务器</h5>
<div class="paragraph">
<p>要指定内省端点的位置,只需执行以下操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">security:
  oauth2:
    resourceserver:
      opaque-token:
        introspection-uri: https://idp.example.com/introspect
        client-id: client
        client-secret: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code><a href="https://idp.example.com/introspect" class="bare">idp.example.com/introspect</a></code> 是授权服务器托管的内省端点,而 <code>client-id</code> 和 <code>client-secret</code> 是击中该端点所需的凭据.</p>
</div>
<div class="paragraph">
<p>资源服务器将使用这些属性进一步进行自我配置,并随后验证传入的JWT.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
使用内省时,授权服务器的字眼就是法律.  如果授权服务器响应令牌是有效的,那么令牌是有效的.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>就是这样！</p>
</div>
</div>
<div class="sect4">
<h5 id="启动时预期"><a class="anchor" href="#启动时预期"></a>启动时预期</h5>
<div class="paragraph">
<p>使用此属性和这些依赖时,资源服务器将自动配置自身以验证不透明承载令牌.</p>
</div>
<div class="paragraph">
<p>该启动过程比 JWT 的启动过程简单得多,因为不需要发现端点,也不需要添加其他验证规则.</p>
</div>
</div>
<div class="sect4">
<h5 id="运行时预期-2"><a class="anchor" href="#运行时预期-2"></a>运行时预期</h5>
<div class="paragraph">
<p>应用程序启动后,资源服务器将尝试处理任何包含 <code>Authorization: Bearer</code> 头的请求:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-http" data-lang="http">GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要指示了此方案,资源服务器就会尝试根据 Bearer Token 规范处理请求.</p>
</div>
<div class="paragraph">
<p>给定一个不透明的令牌,资源服务器将</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用提供的凭据和令牌查询提供的内省端点</p>
</li>
<li>
<p>检查响应是否为  <code>{ 'active' : true }</code>  属性</p>
</li>
<li>
<p>将每个作用域映射到具有前缀 <code>SCOPE_</code> 的权限</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>默认情况下,生成的  <code>Authentication#getPrincipal</code> 是Spring Security   <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/core/OAuth2AuthenticatedPrincipal.html">OAuth2AuthenticatedPrincipal</a></code>  对象,并且 <code>Authentication#getName</code> 映射到令牌的 <code>sub</code> 属性 (如果存在) .</p>
</div>
<div class="paragraph">
<p>从这里,您可能要跳转到:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#oauth2resourceserver-opaque-architecture">Opaque Token Authentication 是如何工作的</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-opaque-attributes">查找身份验证后的属性</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-opaque-authorization-extraction">手动提取权限</a></p>
</li>
<li>
<p><a href="#oauth2resourceserver-opaque-jwt-introspector">对 JWT 使用内省</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-architecture"><a class="anchor" href="#oauth2resourceserver-opaque-architecture"></a>12.3.14. Opaque Token Authentication 是如何工作的</h4>
<div class="paragraph">
<p>接下来， 让我们看看 Spring Security 用于支持基于 Servlet 的应用程序中的 <a href="https://tools.ietf.org/html/rfc7662">opaque token</a> 身份验证的架构组件， 如我们刚看到的应用程序.</p>
</div>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/server/resource/authentication/OpaqueTokenAuthenticationProvider.html"><code>OpaqueTokenAuthenticationProvider</code></a> 是一个 <a href="#servlet-authentication-authenticationprovider"><code>AuthenticationProvider</code></a> 的进一步实现， 它利用 <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a> 来验证不透明令牌.</p>
</div>
<div class="paragraph">
<p>让我们来看看 <code>OpaqueTokenAuthenticationProvider</code> 如何在 Spring Security 范围内工作.  该图解释了<a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">Reading the Bearer Token</a> 中的 <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a>  的详细信息.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/oauth2/opaquetokenauthenticationprovider.png" alt="opaquetokenauthenticationprovider">
</div>
<div class="title">Figure 17. <code>OpaqueTokenAuthenticationProvider</code> Usage</div>
</div>
<div class="paragraph">
<p>OpaqueTokenauthenticationProvider 内部 opaque 令牌， 并使用 OpaqueTokentRospector 添加授予的权限.  验证成功后， 返回的身份验证是 BearerTokenAuthentication 类型， 并且具有由已配置的 OpaqueTokentRospector 返回的 OAuth2authenticationPrincipal 的主体.  最终， 将通过认证过滤器在 SecurityContextholder 上设置返回的 bearertokenauthing.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> <a href="#oauth2resourceserver-authentication-bearertokenauthenticationfilter">读取 Bearer Token</a> 身份验证 <code>Filter</code> 将 <code>BearerTokenAuthenticationToken</code> 传递给实现了 <code>AuthenticationManager</code> 的 <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> <code>ProviderManager</code> 配置为使用 <code>OpaqueTokenAuthenticationProvider</code> 类型的 <a href="#servlet-authentication-authenticationprovider">AuthenticationProvider</a>.</p>
</div>
<div id="oauth2resourceserver-opaque-architecture-introspector" class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> <code>OpaqueTokenAuthenticationProvider</code> 内置 opaque token,  并使用 <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a> 添加授予的权限.  验证成功后， 返回的 <a href="#servlet-authentication-authentication"><code>Authentication</code></a> 对象为 <code>BearerTokenAuthentication</code> 并且具有由已配置的 <a href="#oauth2resourceserver-opaque-introspector"><code>OpaqueTokenIntrospector</code></a> 返回 <code>OAuth2AuthenticatedPrincipal</code> .
最终， 将通过认证过滤器在 <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a> 上设置返回的 <code>BearerTokenAuthentication</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-attributes"><a class="anchor" href="#oauth2resourceserver-opaque-attributes"></a>12.3.15. 查找身份验证后的属性</h4>
<div class="paragraph">
<p>令牌通过身份验证后,将在 <code>SecurityContext</code> 中设置 <code>BearerTokenAuthentication</code> 的实例.</p>
</div>
<div class="paragraph">
<p>这意味着在配置中使用 <code>@EnableWebMvc</code> 时,它可以在 <code>@Controller</code> 方法中使用:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/foo")
public String foo(BearerTokenAuthentication authentication) {
    return authentication.getTokenAttributes().get("sub") + " is the subject";
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/foo")
fun foo(authentication: BearerTokenAuthentication): String {
    return authentication.tokenAttributes["sub"].toString() + " is the subject"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于 <code>BearerTokenAuthentication</code> 拥有 <code>OAuth2AuthenticatedPrincipal</code>,这也意味着它也可用于控制器方法:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/foo")
public String foo(@AuthenticationPrincipal OAuth2AuthenticatedPrincipal principal) {
    return principal.getAttribute("sub") + " is the subject";
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/foo")
fun foo(@AuthenticationPrincipal principal: OAuth2AuthenticatedPrincipal): String {
    return principal.getAttribute&lt;Any&gt;("sub").toString() + " is the subject"
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="通过-spel-查找属性"><a class="anchor" href="#通过-spel-查找属性"></a>通过 SpEL 查找属性</h5>
<div class="paragraph">
<p>当然,这也意味着可以通过 SpEL 访问属性.</p>
</div>
<div class="paragraph">
<p>例如,如果使用 <code>@EnableGlobalMethodSecurity</code> 以便可以使用 <code>@PreAuthorize</code> 注解,则可以执行以下操作:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("principal?.attributes['sub'] == 'foo'")
public String forFoosEyesOnly() {
    return "foo";
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@PreAuthorize("principal?.attributes['sub'] == 'foo'")
fun forFoosEyesOnly(): String {
    return "foo"
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-sansboot"><a class="anchor" href="#oauth2resourceserver-opaque-sansboot"></a>12.3.16. 覆盖或替换自动配置</h4>
<div class="paragraph">
<p>Spring Boot 代表 Resource Server 生成了两个 <code>@Bean</code>.</p>
</div>
<div class="paragraph">
<p>第一个是将应用程序配置为资源服务器的 <code>WebSecurityConfigurerAdapter</code>. 使用 Opaque Token 时,此 <code>WebSecurityConfigurerAdapter</code> 如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 111. Default Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">override fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果应用程序未暴露 <code>WebSecurityConfigurerAdapter</code> Bean,则 Spring Boot 将暴露上述默认值.</p>
</div>
<div class="paragraph">
<p>替换它就像在应用程序中暴露 Bean 一样简单:</p>
</div>
<div class="exampleblock">
<div class="title">Example 112. Custom Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspector(myIntrospector())
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("SCOPE_message:read"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspector = myIntrospector()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以上要求 <code>message:read</code> 的作用域: 以 <code>/messages/</code> 开头的所有URL.</p>
</div>
<div class="paragraph">
<p><code>oauth2ResourceServer</code> DSL 上的方法还将覆盖或替换自动配置.</p>
</div>
<div id="oauth2resourceserver-opaque-introspector" class="paragraph">
<p>例如,第二个 <code>@Bean</code> Spring Boot 创建的是一个 <code>OpaqueTokenIntrospector</code>,它将 <code>String</code> 令牌解码为 <code>OAuth2AuthenticatedPrincipal</code> 的经过验证的实例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果应用程序未暴露 <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> Bean,则 Spring Boot 将暴露以上默认的 bean.</p>
</div>
<div class="paragraph">
<p>可以使用 <code>introspectionUri()</code> 和 <code>introspectionClientCredentials()</code> 覆盖其配置,也可以使用 <code>introspector()</code> 替换其配置.</p>
</div>
<div class="paragraph">
<p>或者,如果您根本不使用 Spring Boot,那么这两个组件-过滤器链和 <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a>  都可以用 XML 指定.</p>
</div>
<div class="paragraph">
<p>过滤器链的指定如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 113. Default Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;opaque-token introspector-ref="opaqueTokenIntrospector"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> 如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 114. Opaque Token Introspector</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="opaqueTokenIntrospector"
        class="org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector"&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.introspection_uri}"/&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.client_id}"/&gt;
    &lt;constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.client_secret}"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspectionuri-dsl"><a class="anchor" href="#oauth2resourceserver-opaque-introspectionuri-dsl"></a>使用 <code>introspectionUri()</code></h5>
<div class="paragraph">
<p>授权服务器的 Introspection Uri 可以配置为 <a href="#oauth2resourceserver-opaque-introspectionuri">配置属性</a>,也可以在 DSL 中提供:</p>
</div>
<div class="exampleblock">
<div class="title">Example 115. Introspection URI Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredIntrospectionUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspectionUri("https://idp.example.com/introspect")
                    .introspectionClientCredentials("client", "secret")
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredIntrospectionUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspectionUri = "https://idp.example.com/introspect"
                    introspectionClientCredentials("client", "secret")
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="opaqueTokenIntrospector"
        class="org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector"&gt;
    &lt;constructor-arg value="https://idp.example.com/introspect"/&gt;
    &lt;constructor-arg value="client"/&gt;
    &lt;constructor-arg value="secret"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>introspectionUri()</code> 优先于任何配置属性.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspector-dsl"><a class="anchor" href="#oauth2resourceserver-opaque-introspector-dsl"></a>使用 <code>introspector()</code></h5>
<div class="paragraph">
<p>比 <code>introspectionUri()</code> 更强大的是 <code>introspector()</code> ,它将完全替代 <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> 的所有 Boot 自动配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 116. Introspector Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class DirectlyConfiguredIntrospector extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspector(myCustomIntrospector())
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class DirectlyConfiguredIntrospector : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspector = myCustomIntrospector()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/**" access="authenticated"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;opaque-token introspector-ref="myCustomIntrospector"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当需要更深入的配置 (例如<a href="#oauth2resourceserver-opaque-authorization-extraction">权限映射</a>, <a href="#oauth2resourceserver-opaque-jwt-introspector">JWT 吊销</a>, 或 <a href="#oauth2resourceserver-opaque-timeouts">请求超时</a>) 时,这很方便.</p>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-introspector-bean"><a class="anchor" href="#oauth2resourceserver-opaque-introspector-bean"></a>暴露 <code>OpaqueTokenIntrospector</code> <code>@Bean</code></h5>
<div class="paragraph">
<p>或者,暴露  <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a>   <code>@Bean</code> 与 <code>introspector()</code> 具有相同的效果:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-authorization"><a class="anchor" href="#oauth2resourceserver-opaque-authorization"></a>12.3.17. 配置授权</h4>
<div class="paragraph">
<p>OAuth 2.0 内省端点通常会返回一个 <code>scope</code> 属性,指示其被授予的作用域 (或权限) ,例如:</p>
</div>
<div class="paragraph">
<p><code>{ &#8230;&#8203;, "scope" : "messages contacts"}</code></p>
</div>
<div class="paragraph">
<p>在这种情况下,资源服务器将尝试将这些作用域强制为已授予权限的列表,并为每个作用域添加字符串 "SCOPE_" 作为前缀.</p>
</div>
<div class="paragraph">
<p>这意味着要保护具有不透明令牌扩展范围的端点或方法,相应的表达式应包含以下前缀:</p>
</div>
<div class="exampleblock">
<div class="title">Example 117. Authorization Opaque Token Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class MappedAuthorities extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorizeRequests -&gt; authorizeRequests
                .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken);
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class MappedAuthorities : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
       http {
            authorizeRequests {
                authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
                authorize("/messages/**", hasAuthority("SCOPE_messages"))
                authorize(anyRequest, authenticated)
            }
           oauth2ResourceServer {
               opaqueToken { }
           }
        }
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/&gt;
    &lt;intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/&gt;
    &lt;oauth2-resource-server&gt;
        &lt;opaque-token introspector-ref="opaqueTokenIntrospector"/&gt;
    &lt;/oauth2-resource-server&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或类似地具有方法安全性:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasAuthority('SCOPE_messages')")
public List&lt;Message&gt; getMessages(...) {}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@PreAuthorize("hasAuthority('SCOPE_messages')")
fun getMessages(): List&lt;Message?&gt; {}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oauth2resourceserver-opaque-authorization-extraction"><a class="anchor" href="#oauth2resourceserver-opaque-authorization-extraction"></a>手动提取权限</h5>
<div class="paragraph">
<p>默认情况下,Opaque Token 支持将从内省响应中提取范围声明,并将其解析为各个 <code>GrantedAuthority</code> 实例.</p>
</div>
<div class="paragraph">
<p>例如,如果内省响应为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "active" : true,
    "scope" : "message:read message:write"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后,资源服务器将生成具有两个权限的  <code>Authentication</code> ,一个权限用于  <code>message:read</code> ,另一个权限用于 <code>message:write</code>.</p>
</div>
<div class="paragraph">
<p>当然,这可以使用自定义的 <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> 进行自定义,该 <code>OpaqueTokenIntrospector</code> 查看属性集并以自己的方式进行转换:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class CustomAuthoritiesOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");

    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);
        return new DefaultOAuth2AuthenticatedPrincipal(
                principal.getName(), principal.getAttributes(), extractAuthorities(principal));
    }

    private Collection&lt;GrantedAuthority&gt; extractAuthorities(OAuth2AuthenticatedPrincipal principal) {
        List&lt;String&gt; scopes = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE);
        return scopes.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class CustomAuthoritiesOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val principal: OAuth2AuthenticatedPrincipal = delegate.introspect(token)
        return DefaultOAuth2AuthenticatedPrincipal(
                principal.name, principal.attributes, extractAuthorities(principal))
    }

    private fun extractAuthorities(principal: OAuth2AuthenticatedPrincipal): Collection&lt;GrantedAuthority&gt; {
        val scopes: List&lt;String&gt; = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE)
        return scopes
                .map { SimpleGrantedAuthority(it) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此后,可以通过将其暴露为 <code>@Bean</code> 来简单地配置此自定义内省器:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new CustomAuthoritiesOpaqueTokenIntrospector();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return CustomAuthoritiesOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-timeouts"><a class="anchor" href="#oauth2resourceserver-opaque-timeouts"></a>12.3.18. 配置超时</h4>
<div class="paragraph">
<p>默认情况下,资源服务器使用 30 秒钟的连接和套接字超时来与授权服务器进行协调.</p>
</div>
<div class="paragraph">
<p>在某些情况下,这可能太短了.
此外,它不考虑退避和发现等更复杂的模式.</p>
</div>
<div class="paragraph">
<p>为了调整资源服务器连接到授权服务器的方式,<code>NimbusOpaqueTokenIntrospector</code> 接受 <code>RestOperations</code> 的实例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector(RestTemplateBuilder builder, OAuth2ResourceServerProperties properties) {
    RestOperations rest = builder
            .basicAuthentication(properties.getOpaquetoken().getClientId(), properties.getOpaquetoken().getClientSecret())
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build();

    return new NimbusOpaqueTokenIntrospector(introspectionUri, rest);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun introspector(builder: RestTemplateBuilder, properties: OAuth2ResourceServerProperties): OpaqueTokenIntrospector? {
    val rest: RestOperations = builder
            .basicAuthentication(properties.opaquetoken.clientId, properties.opaquetoken.clientSecret)
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build()
    return NimbusOpaqueTokenIntrospector(introspectionUri, rest)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-jwt-introspector"><a class="anchor" href="#oauth2resourceserver-opaque-jwt-introspector"></a>12.3.19. 对JWT使用内省</h4>
<div class="paragraph">
<p>一个常见的问题是内省是否与 JWT 兼容.
Spring Security 的 Opaque 令牌支持被设计为不关心令牌的格式-它将很乐意将任何令牌传递给提供的内省端点.</p>
</div>
<div class="paragraph">
<p>因此,假设您有一个要求,如果 JWT 被吊销,则要求您在每个请求中与授权服务器进行核对.</p>
</div>
<div class="paragraph">
<p>即使您为令牌使用 JWT 格式,您的验证方法也是内省的,这意味着您想要执行以下操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        opaque-token:
          introspection-uri: https://idp.example.org/introspection
          client-id: client
          client-secret: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,得到的  <code>Authentication</code> 将是 <code>BearerTokenAuthentication</code>.
相应的 <code>OAuth2AuthenticatedPrincipal</code> 中的任何属性将是内省端点返回的任何属性.</p>
</div>
<div class="paragraph">
<p>但是,可以说,奇怪的是,内省端点仅返回令牌是否处于 active 状态.
怎么办?</p>
</div>
<div class="paragraph">
<p>在这种情况下,您可以创建一个自定义的 <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> ,它仍然会命中端点,但是随后更新返回的主体以将 JWT 声明作为属性:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class JwtOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private JwtDecoder jwtDecoder = new NimbusJwtDecoder(new ParseOnlyJWTProcessor());

    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);
        try {
            Jwt jwt = this.jwtDecoder.decode(token);
            return new DefaultOAuth2AuthenticatedPrincipal(jwt.getClaims(), NO_AUTHORITIES);
        } catch (JwtException ex) {
            throw new OAuth2IntrospectionException(ex);
        }
    }

    private static class ParseOnlyJWTProcessor extends DefaultJWTProcessor&lt;SecurityContext&gt; {
        JWTClaimsSet process(SignedJWT jwt, SecurityContext context)
                throws JOSEException {
            return jwt.getJWTClaimsSet();
        }
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class JwtOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val jwtDecoder: JwtDecoder = NimbusJwtDecoder(ParseOnlyJWTProcessor())
    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val principal = delegate.introspect(token)
        return try {
            val jwt: Jwt = jwtDecoder.decode(token)
            DefaultOAuth2AuthenticatedPrincipal(jwt.claims, NO_AUTHORITIES)
        } catch (ex: JwtException) {
            throw OAuth2IntrospectionException(ex.message)
        }
    }

    private class ParseOnlyJWTProcessor : DefaultJWTProcessor&lt;SecurityContext&gt;() {
        override fun process(jwt: SignedJWT, context: SecurityContext): JWTClaimsSet {
            return jwt.jwtClaimsSet
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此后,可以通过将其暴露为 <code>@Bean</code> 来简单地配置此自定义内省器:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public OpaqueTokenIntrospector introspector() {
    return new JwtOpaqueTokenIntrospector();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return JwtOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-opaque-userinfo"><a class="anchor" href="#oauth2resourceserver-opaque-userinfo"></a>12.3.20. 调用 <code>/userinfo</code> 端点</h4>
<div class="paragraph">
<p>一般来说,资源服务器不在乎底层用户,而在乎已授予的权限.</p>
</div>
<div class="paragraph">
<p>就是说,有时将授权声明绑定到用户可能很有价值.</p>
</div>
<div class="paragraph">
<p>如果应用程序还使用 <code>spring-security-oauth2-client</code> 并设置了适当的 <code>ClientRegistrationRepository</code>,则使用自定义的 <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> 非常简单.  下面的实现实现了三件事:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>委托内省端点确认令牌的有效性</p>
</li>
<li>
<p>查找与 <code>/userinfo</code> 端点关联的适当的客户端注册</p>
</li>
<li>
<p>调用并返回来自 <code>/userinfo</code> 端点的响应</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private final OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final OAuth2UserService oauth2UserService = new DefaultOAuth2UserService();

    private final ClientRegistrationRepository repository;

    // ... constructor

    @Override
    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);
        Instant issuedAt = authorized.getAttribute(ISSUED_AT);
        Instant expiresAt = authorized.getAttribute(EXPIRES_AT);
        ClientRegistration clientRegistration = this.repository.findByRegistrationId("registration-id");
        OAuth2AccessToken token = new OAuth2AccessToken(BEARER, token, issuedAt, expiresAt);
        OAuth2UserRequest oauth2UserRequest = new OAuth2UserRequest(clientRegistration, token);
        return this.oauth2UserService.loadUser(oauth2UserRequest);
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val oauth2UserService = DefaultOAuth2UserService()
    private val repository: ClientRegistrationRepository? = null

    // ... constructor

    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val authorized = delegate.introspect(token)
        val issuedAt: Instant? = authorized.getAttribute(ISSUED_AT)
        val expiresAt: Instant? = authorized.getAttribute(EXPIRES_AT)
        val clientRegistration: ClientRegistration = repository!!.findByRegistrationId("registration-id")
        val accessToken = OAuth2AccessToken(BEARER, token, issuedAt, expiresAt)
        val oauth2UserRequest = OAuth2UserRequest(clientRegistration, accessToken)
        return oauth2UserService.loadUser(oauth2UserRequest)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您不使用 <code>spring-security-oauth2-client</code>,它仍然非常简单.  您只需要使用您自己的 <code>WebClient</code> 实例调用 <code>/userinfo</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private final OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final WebClient rest = WebClient.create();

    @Override
    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);
        return makeUserInfoRequest(authorized);
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val rest: WebClient = WebClient.create()

    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val authorized = delegate.introspect(token)
        return makeUserInfoRequest(authorized)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>无论哪种方式,在创建  <a href="#oauth2resourceserver-opaque-architecture-introspector"><code>OpaqueTokenIntrospector</code></a> 之后,都应该将其发布为 <code>@Bean</code> 来覆盖默认值:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
OpaqueTokenIntrospector introspector() {
    return new UserInfoOpaqueTokenIntrospector(...);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun introspector(): OpaqueTokenIntrospector {
    return UserInfoOpaqueTokenIntrospector(...)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2reourceserver-opaqueandjwt"><a class="anchor" href="#oauth2reourceserver-opaqueandjwt"></a>12.3.21. 同时支持 JWT 和 Opaque Token</h4>
<div class="paragraph">
<p>在某些情况下,您可能需要访问两种令牌.  例如,您可能支持多个租户,其中一个租户发布 JWT,其他租户发布不透明令牌.</p>
</div>
<div class="paragraph">
<p>如果必须在请求时做出此决定,则可以使用 <code>AuthenticationManagerResolver</code> 来实现,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
AuthenticationManagerResolver&lt;HttpServletRequest&gt; tokenAuthenticationManagerResolver() {
    BearerTokenResolver bearerToken = new DefaultBearerTokenResolver();
    JwtAuthenticationProvider jwt = jwt();
    OpaqueTokenAuthenticationProvider opaqueToken = opaqueToken();

    return request -&gt; {
        if (useJwt(request)) {
            return jwt::authenticate;
        } else {
            return opaqueToken::authenticate;
        }
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun tokenAuthenticationManagerResolver(): AuthenticationManagerResolver&lt;HttpServletRequest&gt; {
    val bearerToken: BearerTokenResolver = DefaultBearerTokenResolver()
    val jwt: JwtAuthenticationProvider = jwt()
    val opaqueToken: OpaqueTokenAuthenticationProvider = opaqueToken()

    return AuthenticationManagerResolver { request -&gt;
        if (useJwt(request)) {
            AuthenticationManager { jwt.authenticate(it) }
        } else {
            AuthenticationManager { opaqueToken.authenticate(it) }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>useJwt(HttpServletRequest)</code> 的实现可能取决于诸如路径之类的自定义请求..
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后在 DSL 中指定此 <code>AuthenticationManagerResolver</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 118. Authentication Manager Resolver</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">http
    .authorizeRequests(authorize -&gt; authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(this.tokenAuthenticationManagerResolver)
    );
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = tokenAuthenticationManagerResolver()
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server authentication-manager-resolver-ref="tokenAuthenticationManagerResolver"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-multitenancy"><a class="anchor" href="#oauth2resourceserver-multitenancy"></a>12.3.22. 多租户</h4>
<div class="paragraph">
<p>当存在多种验证承载令牌的策略时,资源服务器被视为多租户,并以某些租户标识符为关键字.</p>
</div>
<div class="paragraph">
<p>例如,您的资源服务器可能接受来自两个不同授权服务器的承载令牌.  或者,您的授权服务器可能代表多个发行者.</p>
</div>
<div class="paragraph">
<p>在每种情况下,都需要完成两件事,并且要与选择的方式进行权衡:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>解析租户</p>
</li>
<li>
<p>传播租户</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="通过-claim-解析租户"><a class="anchor" href="#通过-claim-解析租户"></a>通过 Claim 解析租户</h5>
<div class="paragraph">
<p>区分租户的一种方法是通过 issuer claim.  由于签发者的声明伴随着已签名的JWT,因此可以通过 <code>JwtIssuerAuthenticationManagerResolver</code> 来完成,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 119. Multitenancy Tenant by JWT Claim</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">JwtIssuerAuthenticationManagerResolver authenticationManagerResolver = new JwtIssuerAuthenticationManagerResolver
    ("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo");

http
    .authorizeRequests(authorize -&gt; authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val customAuthenticationManagerResolver = JwtIssuerAuthenticationManagerResolver
    ("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo")
http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server authentication-manager-resolver-ref="authenticationManagerResolver"/&gt;
&lt;/http&gt;

&lt;bean id="authenticationManagerResolver"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtIssuerAuthenticationManagerResolver"&gt;
    &lt;constructor-arg&gt;
        &lt;list&gt;
            &lt;value&gt;https://idp.example.org/issuerOne&lt;/value&gt;
            &lt;value&gt;https://idp.example.org/issuerTwo&lt;/value&gt;
        &lt;/list&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这很好,因为发布者端点是延迟加载的.  实际上,仅当发送带有相应发行者的第一个请求时,才会实例化相应的 <code>JwtAuthenticationProvider</code>.  这样就可以启动应用程序,而与启动并可用的那些授权服务器无关.</p>
</div>
<div class="sect5">
<h6 id="动态租户"><a class="anchor" href="#动态租户"></a>动态租户</h6>
<div class="paragraph">
<p>当然,您可能不想在每次添加新租户时都重新启动应用程序.  在这种情况下,可以使用 <code>AuthenticationManager</code> 实例的存储库配置 <code>JwtIssuerAuthenticationManagerResolver</code>,您可以在运行时对其进行编辑,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private void addManager(Map&lt;String, AuthenticationManager&gt; authenticationManagers, String issuer) {
    JwtAuthenticationProvider authenticationProvider = new JwtAuthenticationProvider
            (JwtDecoders.fromIssuerLocation(issuer));
    authenticationManagers.put(issuer, authenticationProvider::authenticate);
}

// ...

JwtIssuerAuthenticationManagerResolver authenticationManagerResolver =
        new JwtIssuerAuthenticationManagerResolver(authenticationManagers::get);

http
    .authorizeRequests(authorize -&gt; authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">private fun addManager(authenticationManagers: MutableMap&lt;String, AuthenticationManager&gt;, issuer: String) {
    val authenticationProvider = JwtAuthenticationProvider(JwtDecoders.fromIssuerLocation(issuer))
    authenticationManagers[issuer] = AuthenticationManager {
        authentication: Authentication? -&gt; authenticationProvider.authenticate(authentication)
    }
}

// ...

val customAuthenticationManagerResolver: JwtIssuerAuthenticationManagerResolver =
    JwtIssuerAuthenticationManagerResolver(authenticationManagers::get)
http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,您可以使用给定 issuer 的策略来构造 <code>JwtIssuerAuthenticationManagerResolver</code>,以获取 <code>AuthenticationManager</code>.  这种方法使我们可以在运行时从存储库中添加和删除元素 (如片段中的 <code>Map</code> 所示) .</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
仅选择任何 issuer 并从中构造 <code>AuthenticationManager</code> 是不安全的.  issuer 应该是代码可以从允许的 issuers 的受信任来源进行验证的发行者.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="仅解析一次-claim"><a class="anchor" href="#仅解析一次-claim"></a>仅解析一次 Claim</h6>
<div class="paragraph">
<p>您可能已经观察到,这种策略虽然简单,但是却存在一个折衷,即 JWT 由 <code>AuthenticationManagerResolver</code> 解析一次,然后由  <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> 解析.</p>
</div>
<div class="paragraph">
<p>通过直接使用Nimbus的 <code>JWTClaimSetAwareJWSKeySelector</code> 配置  <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> 可以减轻这种额外的解析:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
public class TenantJWSKeySelector
    implements JWTClaimSetAwareJWSKeySelector&lt;SecurityContext&gt; {

    private final TenantRepository tenants; <i class="conum" data-value="1"></i><b>(1)</b>
    private final Map&lt;String, JWSKeySelector&lt;SecurityContext&gt;&gt; selectors = new ConcurrentHashMap&lt;&gt;(); <i class="conum" data-value="2"></i><b>(2)</b>

    public TenantJWSKeySelector(TenantRepository tenants) {
        this.tenants = tenants;
    }

    @Override
    public List&lt;? extends Key&gt; selectKeys(JWSHeader jwsHeader, JWTClaimsSet jwtClaimsSet, SecurityContext securityContext)
            throws KeySourceException {
        return this.selectors.computeIfAbsent(toTenant(jwtClaimsSet), this::fromTenant)
                .selectJWSKeys(jwsHeader, securityContext);
    }

    private String toTenant(JWTClaimsSet claimSet) {
        return (String) claimSet.getClaim("iss");
    }

    private JWSKeySelector&lt;SecurityContext&gt; fromTenant(String tenant) {
        return Optional.ofNullable(this.tenantRepository.findById(tenant)) <i class="conum" data-value="3"></i><b>(3)</b>
                .map(t -&gt; t.getAttrbute("jwks_uri"))
                .map(this::fromUri)
                .orElseThrow(() -&gt; new IllegalArgumentException("unknown tenant"));
    }

    private JWSKeySelector&lt;SecurityContext&gt; fromUri(String uri) {
        try {
            return JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(new URL(uri)); <i class="conum" data-value="4"></i><b>(4)</b>
        } catch (Exception ex) {
            throw new IllegalArgumentException(ex);
        }
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class TenantJWSKeySelector(tenants: TenantRepository) : JWTClaimSetAwareJWSKeySelector&lt;SecurityContext&gt; {
    private val tenants: TenantRepository <i class="conum" data-value="1"></i><b>(1)</b>
    private val selectors: MutableMap&lt;String, JWSKeySelector&lt;SecurityContext&gt;&gt; = ConcurrentHashMap() <i class="conum" data-value="2"></i><b>(2)</b>

    init {
        this.tenants = tenants
    }

    fun selectKeys(jwsHeader: JWSHeader?, jwtClaimsSet: JWTClaimsSet, securityContext: SecurityContext): List&lt;Key?&gt; {
        return selectors.computeIfAbsent(toTenant(jwtClaimsSet)) { tenant: String -&gt; fromTenant(tenant) }
                .selectJWSKeys(jwsHeader, securityContext)
    }

    private fun toTenant(claimSet: JWTClaimsSet): String {
        return claimSet.getClaim("iss") as String
    }

    private fun fromTenant(tenant: String): JWSKeySelector&lt;SecurityContext&gt; {
        return Optional.ofNullable(this.tenants.findById(tenant)) <i class="conum" data-value="3"></i><b>(3)</b>
                .map { t -&gt; t.getAttrbute("jwks_uri") }
                .map { uri: String -&gt; fromUri(uri) }
                .orElseThrow { IllegalArgumentException("unknown tenant") }
    }

    private fun fromUri(uri: String): JWSKeySelector&lt;SecurityContext?&gt; {
        return try {
            JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(URL(uri)) <i class="conum" data-value="4"></i><b>(4)</b>
        } catch (ex: Exception) {
            throw IllegalArgumentException(ex)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>租户信息的假想来源</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>JWKKeySelector</code> 的缓存,由租户标识符输入</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>查找租户比简单地即时计算 JWK Set 端点更安全-查找充当租户白名单</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>通过从 JWK Set 端点返回的密钥类型创建一个 <code>JWSKeySelector</code> -此处的延迟查找意味着您不需要在启动时配置所有租户</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>上面的按键选择器由许多按键选择器组成.
它根据 JWT 中的 <code>iss</code> 声明选择要使用的键选择器.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
要使用此方法,请确保将授权服务器配置为包括声明集作为令牌签名的一部分.
没有这个,您就不能保证发行人不会被坏演员改变.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>接下来,我们可以构造一个 <code>JWTProcessor</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
JWTProcessor jwtProcessor(JWTClaimSetJWSKeySelector keySelector) {
    ConfigurableJWTProcessor&lt;SecurityContext&gt; jwtProcessor =
            new DefaultJWTProcessor();
    jwtProcessor.setJWTClaimSetJWSKeySelector(keySelector);
    return jwtProcessor;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtProcessor(keySelector: JWTClaimsSetAwareJWSKeySelector&lt;SecurityContext&gt;): JWTProcessor&lt;SecurityContext&gt; {
    val jwtProcessor = DefaultJWTProcessor&lt;SecurityContext&gt;()
    jwtProcessor.jwtClaimsSetAwareJWSKeySelector = keySelector
    return jwtProcessor
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如您所见,将租户意识降低到此级别的权衡是更多配置.
我们还有一点.</p>
</div>
<div class="paragraph">
<p>接下来,我们仍然要确保您正在验证发行人.
但是,由于每个 JWT 的颁发者可能有所不同,因此,您还需要一个支持租户的验证器:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
public class TenantJwtIssuerValidator implements OAuth2TokenValidator&lt;Jwt&gt; {
    private final TenantRepository tenants;
    private final Map&lt;String, JwtIssuerValidator&gt; validators = new ConcurrentHashMap&lt;&gt;();

    public TenantJwtIssuerValidator(TenantRepository tenants) {
        this.tenants = tenants;
    }

    @Override
    public OAuth2TokenValidatorResult validate(Jwt token) {
        return this.validators.computeIfAbsent(toTenant(token), this::fromTenant)
                .validate(token);
    }

    private String toTenant(Jwt jwt) {
        return jwt.getIssuer();
    }

    private JwtIssuerValidator fromTenant(String tenant) {
        return Optional.ofNullable(this.tenants.findById(tenant))
                .map(t -&gt; t.getAttribute("issuer"))
                .map(JwtIssuerValidator::new)
                .orElseThrow(() -&gt; new IllegalArgumentException("unknown tenant"));
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class TenantJwtIssuerValidator(tenants: TenantRepository) : OAuth2TokenValidator&lt;Jwt&gt; {
    private val tenants: TenantRepository
    private val validators: MutableMap&lt;String, JwtIssuerValidator&gt; = ConcurrentHashMap()
    override fun validate(token: Jwt): OAuth2TokenValidatorResult {
        return validators.computeIfAbsent(toTenant(token)) { tenant: String -&gt; fromTenant(tenant) }
                .validate(token)
    }

    private fun toTenant(jwt: Jwt): String {
        return jwt.issuer.toString()
    }

    private fun fromTenant(tenant: String): JwtIssuerValidator {
        return Optional.ofNullable(tenants.findById(tenant))
                .map({ t -&gt; t.getAttribute("issuer") })
                .map({ JwtIssuerValidator() })
                .orElseThrow({ IllegalArgumentException("unknown tenant") })
    }

    init {
        this.tenants = tenants
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>现在我们有了一个可以识别租户的处理器和一个可以识别租户的验证器,我们可以继续创建 <a href="#oauth2resourceserver-jwt-architecture-jwtdecoder"><code>JwtDecoder</code></a> 了:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
JwtDecoder jwtDecoder(JWTProcessor jwtProcessor, OAuth2TokenValidator&lt;Jwt&gt; jwtValidator) {
    NimbusJwtDecoder decoder = new NimbusJwtDecoder(processor);
    OAuth2TokenValidator&lt;Jwt&gt; validator = new DelegatingOAuth2TokenValidator&lt;&gt;
            (JwtValidators.createDefault(), this.jwtValidator);
    decoder.setJwtValidator(validator);
    return decoder;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(jwtProcessor: JWTProcessor&lt;SecurityContext&gt;?, jwtValidator: OAuth2TokenValidator&lt;Jwt&gt;?): JwtDecoder {
    val decoder = NimbusJwtDecoder(jwtProcessor)
    val validator: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(JwtValidators.createDefault(), jwtValidator)
    decoder.setJwtValidator(validator)
    return decoder
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>我们已经结束了有关解决租户的讨论.</p>
</div>
<div class="paragraph">
<p>如果选择按请求材料解决租户,则需要确保以相同的方式访问下游资源服务器.
例如,如果要按子域进行解析,则需要使用相同的子域来寻址下游资源服务器.</p>
</div>
<div class="paragraph">
<p>但是,如果您通过不记名令牌中的声明解决该问题,请继续阅读以了解<a href="#oauth2resourceserver-bearertoken-resolver">Spring Security&#8217;s support for bearer token propagation</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-bearertoken-resolver"><a class="anchor" href="#oauth2resourceserver-bearertoken-resolver"></a>12.3.23. Bearer Token 解析</h4>
<div class="paragraph">
<p>默认情况下,资源服务器在 <code>Authorization</code> 头中查找 bearer 令牌.
但是,可以通过两种方式进行自定义.</p>
</div>
<div class="sect4">
<h5 id="从自定义请求头读取-bearer-令牌"><a class="anchor" href="#从自定义请求头读取-bearer-令牌"></a>从自定义请求头读取 bearer 令牌</h5>
<div class="paragraph">
<p>例如,您可能需要从自定义请求头读取 bearer 令牌
为此,您可以将 <code>DefaultBearerTokenResolver</code> 实例连接到 DSL,如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 120. Custom Bearer Token Header</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
BearerTokenResolver bearerTokenResolver() {
    DefaultBearerTokenResolver bearerTokenResolver = new DefaultBearerTokenResolver();
    bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION);
    return bearerTokenResolver;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun bearerTokenResolver(): BearerTokenResolver {
    val bearerTokenResolver = DefaultBearerTokenResolver()
    bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION)
    return bearerTokenResolver
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server bearer-token-resolver-ref="bearerTokenResolver"/&gt;
&lt;/http&gt;

&lt;bean id="bearerTokenResolver"
        class="org.springframework.security.oauth2.server.resource.web.DefaultBearerTokenResolver"&gt;
    &lt;property name="bearerTokenHeaderName" value="Proxy-Authorization"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者， 在提供者同时使用自定义 header 头和值的情况下， 可以改用 <code>HeaderBearerTokenResolver</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="从表单参数读取-bearer-令牌"><a class="anchor" href="#从表单参数读取-bearer-令牌"></a>从表单参数读取 bearer 令牌</h5>
<div class="paragraph">
<p>或者,您可能希望从表单参数中读取令牌,可以通过配置 <code>DefaultBearerTokenResolver</code> 来完成,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 121. Form Parameter Bearer Token</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">DefaultBearerTokenResolver resolver = new DefaultBearerTokenResolver();
resolver.setAllowFormEncodedBodyParameter(true);
http
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .bearerTokenResolver(resolver)
    );
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val resolver = DefaultBearerTokenResolver()
resolver.setAllowFormEncodedBodyParameter(true)
http {
    oauth2ResourceServer {
        bearerTokenResolver = resolver
    }
}</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Xml</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;oauth2-resource-server bearer-token-resolver-ref="bearerTokenResolver"/&gt;
&lt;/http&gt;

&lt;bean id="bearerTokenResolver"
        class="org.springframework.security.oauth2.server.resource.web.HeaderBearerTokenResolver"&gt;
    &lt;property name="allowFormEncodedBodyParameter" value="true"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bearer-token-传递"><a class="anchor" href="#bearer-token-传递"></a>12.3.24. Bearer Token 传递</h4>
<div class="paragraph">
<p>现在您已经拥有了一个 Bearer 令牌,将它传递给下游服务可能会很方便.
使用 <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/server/resource/web/reactive/function/client/ServletBearerExchangeFilterFunction.html">ServletBearerExchangeFilterFunction</a></code> 非常简单,您可以在以下示例中看到它:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public WebClient rest() {
    return WebClient.builder()
            .filter(new ServletBearerExchangeFilterFunction())
            .build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun rest(): WebClient {
    return WebClient.builder()
            .filter(ServletBearerExchangeFilterFunction())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当上述 <code>WebClient</code> 用于执行请求时,Spring Security 将查找当前的 <code>Authentication</code> 并提取任何 <code>AbstractOAuth2Token</code> 凭据.  然后,它将在授权请求头中传递该令牌.</p>
</div>
<div class="paragraph">
<p>例如:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono(String.class)
        .block()
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono&lt;String&gt;()
        .block()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>将调用  <code><a href="https://other-service.example.com/endpoint" class="bare">other-service.example.com/endpoint</a></code>, 为您添加 Bearer 令牌授权 <code>Authorization</code>  头.</p>
</div>
<div class="paragraph">
<p>在您需要覆盖此行为的地方,您可以自己提供请求头,这很简单,例如:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers(headers -&gt; headers.setBearerAuth(overridingToken))
        .retrieve()
        .bodyToMono(String.class)
        .block()
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers{  headers -&gt; headers.setBearerAuth(overridingToken)}
        .retrieve()
        .bodyToMono&lt;String&gt;()
        .block()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,过滤器将回退并将请求转发到 Web 过滤器链的其余部分.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
与 <a href="https://docs.spring.io/spring-security/site/docs/current-SNAPSHOT/api/org/springframework/security/oauth2/client/web/reactive/function/client/ServletOAuth2AuthorizedClientExchangeFilterFunction.html">OAuth 2.0 Client filter function</a>功能不同,此过滤器功能不会在令牌过期时尝试更新令牌.  要获得此级别的支持,请使用 OAuth 2.0 客户端过滤器.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="resttemplate-支持"><a class="anchor" href="#resttemplate-支持"></a><code>RestTemplate</code> 支持</h5>
<div class="paragraph">
<p>目前尚无对 <code>ServletBearerExchangeFilterFunction</code> 的 <code>RestTemplate</code> 的专门支持,但您可以使用自己的拦截器非常简单地实现传播:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
RestTemplate rest() {
    RestTemplate rest = new RestTemplate();
    rest.getInterceptors().add((request, body, execution) -&gt; {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null) {
            return execution.execute(request, body);
        }

        if (!(authentication.getCredentials() instanceof AbstractOAuth2Token)) {
            return execution.execute(request, body);
        }

        AbstractOAuth2Token token = (AbstractOAuth2Token) authentication.getCredentials();
        request.getHeaders().setBearerAuth(token.getTokenValue());
        return execution.execute(request, body);
    });
    return rest;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun rest(): RestTemplate {
    val rest = RestTemplate()
    rest.interceptors.add(ClientHttpRequestInterceptor { request, body, execution -&gt;
        val authentication: Authentication? = SecurityContextHolder.getContext().authentication
        if (authentication != null) {
            execution.execute(request, body)
        }

        if (authentication!!.credentials !is AbstractOAuth2Token) {
            execution.execute(request, body)
        }

        val token: AbstractOAuth2Token = authentication.credentials as AbstractOAuth2Token
        request.headers.setBearerAuth(token.tokenValue)
        execution.execute(request, body)
    })
    return rest
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
与 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/client/OAuth2AuthorizedClientManager.html">OAuth 2.0 授权的客户端管理器不同</a>， 此过滤器拦截不会尝试续订令牌， 是否应该过期.  要获得此级别的支持， 请使用 <a href="#oauth2client">OAuth 2.0 Authorized Client Manager</a> 创建拦截器.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="oauth2resourceserver-bearertoken-failure"><a class="anchor" href="#oauth2resourceserver-bearertoken-failure"></a>12.3.25. Bearer Token 失败</h4>
<div class="paragraph">
<p>bearer token 可能由于多种原因而无效.  例如,令牌可能失效.</p>
</div>
<div class="paragraph">
<p>在这种情况下,资源服务器会抛出 <code>InvalidBearerTokenException</code>.
与其他例外一样,这会导致OAuth 2.0 bearer token 错误响应:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-http request" data-lang="http request">HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer error_code="invalid_token", error_description="Unsupported algorithm of none", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"</code></pre>
</div>
</div>
<div class="paragraph">
<p>此外,它以 <code>AuthenticationFailureBadCredentialsEvent</code> 的形式发布,您可以像这样: <a href="#servlet-events">监听您的应用程序</a></p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
public class FailureEvents {
    @EventListener
    public void onFailure(AuthenticationFailureEvent failure) {
        if (badCredentials.getAuthentication() instanceof BearerTokenAuthenticationToken) {
            // ... handle
        }
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Component
class FailureEvents {
    @EventListener
    fun onFailure(badCredentials: AuthenticationFailureBadCredentialsEvent) {
        if (badCredentials.authentication is BearerTokenAuthenticationToken) {
            // ... handle
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-saml2"><a class="anchor" href="#servlet-saml2"></a>13. SAML2</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="servlet-saml2login"><a class="anchor" href="#servlet-saml2login"></a>13.1. SAML 2.0 Login</h3>
<div class="paragraph">
<p>SAML 2.0 登录功能为应用程序提供了使用户能够通过使用其在 SAML 2.0 身份提供程序(Okta,ADFS 等) 上的现有帐户 <a href="https://wiki.shibboleth.net/confluence/display/CONCEPT/FlowsAndConfig">log in</a> 到该应用程序的功能.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
SAML 2.0 登录是通过使用 <a href="https://www.oasis-open.org/committees/download.php/35389/sstc-saml-profiles-errata-2.0-wd-06-diff.pdf#page=15">SAML 2 Profiles</a>中指定的 <strong>Web 浏览器 SSOProfile</strong> 来实现的.
</td>
</tr>
</table>
</div>
<div id="servlet-saml2login-spring-security-history" class="paragraph">
<p>自 2009 年以来， 对  relying party  的支持已作为 <a href="https://github.com/spring-projects/spring-security-saml/tree/1e013b07a7772defd6a26fcfae187c9bf661ee8f#spring-saml">extension project</a> 存在. 在 2019 年， 开始将其移植到 <a href="https://github.com/spring-projects/spring-security">Spring Security</a> 中. 此过程类似于 2017 年开始对 <a href="#oauth2">Spring Security 的 OAuth 2.0 支持的过程</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-security/master/">Spring Security repository</a>中提供了 <a href="https://github.com/spring-projects/spring-security/master//boot/saml2login">SAML 2.0 Login</a> 的示例.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>让我们来看看 SAML 2.0 如何在 Spring Security 内工作.  首先， 我们看到， 和 <a href="#oauth2login">OAuth 2.0 Login</a> 一样， Spring Security 将用户带到第三方进行身份验证.  它通过一系列重定向来实现这一点.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/saml2/saml2webssoauthenticationrequestfilter.png" alt="saml2webssoauthenticationrequestfilter">
</div>
<div class="title">Figure 18. Redirecting to Asserting Party Authentication</div>
</div>
<div class="paragraph">
<p>上图基于<a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> 和 <a href="#servlet-authentication-abstractprocessingfilter"><code>AbstractAuthenticationProcessingFilter</code></a> 图:</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> 首先， 用户对未经授权的 <code>/private</code> 资源进行身份验证请求.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> Spring Security 的 <a href="#servlet-authorization-filtersecurityinterceptor"><code>FilterSecurityInterceptor</code></a> 将通过抛出 <code>AccessDeniedException</code> 异常来表明身份验证被拒绝.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> 由于缺少用户授权, <a href="#servlet-exceptiontranslationfilter"><code>ExceptionTranslationFilter</code></a> 开始启动身份验证.
通过配置的 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.html"><code>LoginUrlAuthenticationEntryPoint</code></a> 实例 <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a>  将其重定向到 <a href="#servlet-saml2login-sp-initiated-factory"><code>&lt;saml2:AuthnRequest&gt;</code> 生成端点 </a>, <code>Saml2WebSsoAuthenticationRequestFilter</code>.
或者，  <a href="#servlet-saml2login-relyingpartyregistrationrepository">如果您已配置多个  asserting party</a>, 它将首先重定向到选择器页面.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_4.png" alt="number 4"></span> 接下来， <code>Saml2WebSsoAuthenticationRequestFilter</code> 使用配置的 <a href="#servlet-saml2login-sp-initiated-factory"><code>Saml2AuthenticationRequestFactory</code></a> 创建， 签名， 序列化和编码 <code>&lt;saml2:AuthnRequest&gt;</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_5.png" alt="number 5"></span> 然后， 浏览器将使用此 <code>&lt;saml2:AuthnRequest&gt;</code> 并将其呈现给 asserting party. asserting party 尝试对用户进行身份验证. 如果成功， 它将把 <code>&lt;saml2:Response&gt;</code> 返回给浏览器.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_6.png" alt="number 6"></span> 然后， 浏览器将 <code>&lt;saml2:Response&gt;</code> POST 到 assertion consumer service endpoint.</p>
</div>
<div id="servlet-saml2login-authentication-saml2webssoauthenticationfilter" class="imageblock">
<div class="content">
<img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/saml2/saml2webssoauthenticationfilter.png" alt="saml2webssoauthenticationfilter">
</div>
<div class="title">Figure 19. Authenticating a <code>&lt;saml2:Response&gt;</code></div>
</div>
<div class="paragraph">
<p>该图基于 <a href="#servlet-securityfilterchain"><code>SecurityFilterChain</code></a> 图.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> 当浏览器提交 <code>&lt;saml2:Response&gt;</code> 到应用程序时, 它将 <a href="#servlet-saml2login-authenticate-responses">委托给 <code>Saml2WebSsoAuthenticationFilter</code> 处理</a>.
此过滤器调用其配置的 <code>AuthenticationConverter</code> 并通过从 <code>HttpServletRequest</code> 中提取响应去创建一个 <code>Saml2AuthenticationToken</code>.
此转换器另外解析了 <a href="#servlet-saml2login-relyingpartyregistration"><code>RelyingPartyRegistration</code></a> 并将其提供给 <code>Saml2AuthenticationToken</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> 接下来, 过滤器将令牌传递给配置的 <a href="#servlet-authentication-providermanager"><code>AuthenticationManager</code></a>.
默认情况下, 它将使用 <a href="#servlet-saml2login-architecture"><code>OpenSamlAuthenticationProvider</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> 如果身份验证失败， 则 <em>失败</em></p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a> 被清除.</p>
</li>
<li>
<p>调用 <a href="#servlet-authentication-authenticationentrypoint"><code>AuthenticationEntryPoint</code></a> 以重新启动身份验证过程.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_4.png" alt="number 4"></span> 如果身份验证成功, 则 <em>成功</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 <a href="#servlet-authentication-securitycontextholder"><code>SecurityContextHolder</code></a> 中设置 <a href="#servlet-authentication-authentication"><code>Authentication</code></a>.</p>
</li>
<li>
<p><code>Saml2WebSsoAuthenticationFilter</code> 调用 <code>FilterChain#doFilter(request,response)</code> 继续应用程序逻辑的其余部分.</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-minimaldependencies"><a class="anchor" href="#servlet-saml2login-minimaldependencies"></a>13.1.1. 最小依赖</h4>
<div class="paragraph">
<p>SAML 2.0 服务提供商支持位于 <code>spring-security-saml2-service-provider</code> 中. 它基于 OpenSAML 库构建.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-minimalconfiguration"><a class="anchor" href="#servlet-saml2login-minimalconfiguration"></a>13.1.2. 最小配置</h4>
<div class="paragraph">
<p>使用 <a href="https://spring.io/projects/spring-boot">Spring Boot</a> 时， 将应用程序配置为服务提供商包括两个基本步骤.  首先， 包括所需的依赖， 第二， 指示必要的 asserting party 元数据.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
另外， 这假定您已经在 <a href="#servlet-saml2login-metadata">asserting party 中注册了  relying party 为前提</a>.
</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="指定身份提供者元数据"><a class="anchor" href="#指定身份提供者元数据"></a>指定身份提供者元数据</h5>
<div class="paragraph">
<p>在 Spring Boot 应用程序中， 要指定身份提供者的元数据， 只需执行以下操作: :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">spring:
  security:
    saml2:
      relyingparty:
        registration:
          adfs:
            identityprovider:
              entity-id: https://idp.example.com/issuer
              verification.credentials:
                - certificate-location: "classpath:idp.crt"
              singlesignon.url: https://idp.example.com/issuer/sso
              singlesignon.sign-request: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>where</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="https://idp.example.com/issuer" class="bare">idp.example.com/issuer</a></code> 是身份提供者将发布的 SAML 响应的 <code>Issuer</code> 属性中包含的值</p>
</li>
<li>
<p><code>classpath:idp.crt</code> 是身份提供者用于验证响应的证书在类路径上的位置， 以及</p>
</li>
<li>
<p><code><a href="https://idp.example.com/issuer/sso" class="bare">idp.example.com/issuer/sso</a></code> 是身份提供者期望 <code>AuthnRequest</code> 的端点.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>就这样简单!</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Identity Provider 和 Asserting Party 是同义词， 也是服务提供商和 relying party .  这些通常分别缩写为 AP 和 RP.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="runtime-expectations"><a class="anchor" href="#runtime-expectations"></a>Runtime Expectations</h5>
<div class="paragraph">
<p>如上所配置， 应用程序处理包含 <code>SAMLResponse</code> 参数的任何 <code>POST /login/saml2/sso/{registrationId}</code>  请求:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">POST /login/saml2/sso/adfs HTTP/1.1

SAMLResponse=PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>有两种方法可以看到引导你的 asserting party 来生成  <code>SAMLResponse</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先， 您可以导航到您的 asserting party.  对于每个注册的 relying party ， 它可能有一些链接或按钮可以单击以发送 <code>SamlResponse</code>.</p>
</li>
<li>
<p>其次， 您可以导航到应用程序中的受保护页面， 例如， <code><a href="http://localhost:8080" class="bare">localhost:8080</a></code>.  然后， 您的应用程序重定向到配置的 asserting party， 然后发送 <code>SamlResponse</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>从这里， 考虑跳到:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-saml2login-architecture">Saml 2.0 登录如何与 OpenSAML 集成</a></p>
</li>
<li>
<p><a href="#servlet-saml2login-authenticatedprincipal">如何使用 <code>Saml2AuthenticatedPrincipal</code></a></p>
</li>
<li>
<p><a href="#servlet-saml2login-sansboot">如何覆盖或替换的 Spring Boot 自动配置</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-architecture"><a class="anchor" href="#servlet-saml2login-architecture"></a>13.1.3. Saml 2.0 登录如何与 OpenSAML 集成</h4>
<div class="paragraph">
<p>Spring Security 的 Saml 2.0 支持有几个设计目标:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先, 需要依赖操作 SAML 2.0 和 domain objects 的库.为实现这一目标, Spring Security 使用 OpenSAML.</p>
</li>
<li>
<p>第二, 确保使用 Spring Security 的 SAML 支持不需要此库.为了达成此目的, 在 Spring Security  约定使用的任何 OpenSAML 中的类或接口都保留封装.这使得您可以将 OpenSAML 切换到其他一些库， 甚至是 OpenSAML 不受支持的版本.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>作为上述两个目标的结果， Spring Security 的 SAML API 相对于其他模块非常小.  相反， 像 <code>OpenSamlAuthenticationRequestFactory</code> 和 <code>OpenSamlAuthenticationProvider</code>  这样的类类暴露了自定义身份验证过程中各个步骤的 <code>Converter</code>.</p>
</div>
<div class="paragraph">
<p>例如， 一旦应用程序接收到 <code>SAMLResponse</code> 并委托给 <code>Saml2WebSsoAuthenticationFilter</code>， 该过滤器将委托给 <code>OpenSamlAuthenticationProvider</code>.</p>
</div>
<div class="paragraph">
<div class="title">Authenticating an OpenSAML <code>Response</code></div>
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/servlet/saml2/opensamlauthenticationprovider.png" alt="opensamlauthenticationprovider"></span></p>
</div>
<div class="paragraph">
<p>此图基于 <a href="#servlet-saml2login-authentication-saml2webssoauthenticationfilter"><code>Saml2WebSsoAuthenticationFilter</code> diagram</a> 构建.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_1.png" alt="number 1"></span> <code>Saml2WebSsoAuthenticationFilter</code> 构建 <code>Saml2AuthenticationToken</code> 并且调用 <a href="#servlet-authentication-providermanager"><code>AuthenticationManager</code></a>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_2.png" alt="number 2"></span> <a href="#servlet-authentication-providermanager"><code>AuthenticationManager</code></a> 调用 <code>OpenSamlAuthenticationProvider</code>.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_3.png" alt="number 3"></span> authentication provider 将响应反序列化为 OpenSAML <code>Response</code> 并检查 signature.
如果 signature 失效, 则身份验证失败.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_4.png" alt="number 4"></span> 接下来, provider 验证响应的 <code>Issuer</code> 和 <code>Destination</code> 值.
如果他们与 <code>RelyingPartyRegistration</code> 中的内容不匹配, 则身份验证失败.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_5.png" alt="number 5"></span> 然后, provider 解密所有加密的 assertions.
如果有一个解密失败, 则身份验证失败.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_6.png" alt="number 6"></span> 之后, provider 验证每个 <code>Assertion</code> 的签名.
如果有一个验证失败， 则身份验证失败.
此外， 如果响应和 assertions 都没有签名 signatures, 则身份验证失败.
需要响应或 assertions 有签名.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_7.png" alt="number 7"></span> 然后, provider 验证每个 assertion 的 <code>ExpiresAt</code> 和 <code>NotBefore</code> 时间戳, <code>&lt;Subject&gt;</code> 和任何 <code>&lt;AudienceRestriction&gt;</code> 条件.
如果有一个验证失败， 则身份验证失败.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_8.png" alt="number 8"></span> 在此之后, provider 将第一个 assertion 的 <code>AttributeStatement</code> 映射为 <code>Map&lt;String, List&lt;Object&gt;&gt;</code>.
他还授予 <code>ROLE_USER</code> 权限.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="https://resources.jcohy.com/jcohy-docs/images/2.4.5/spring-security/icons/number_9.png" alt="number 9"></span> 最后, provider 从第一个 assertion 中获取  <code>NameID</code>, 属性的 <code>Map</code> , 和 <code>GrantedAuthority</code> 并构造一个  <code>Saml2AuthenticatedPrincipal</code>.
然后, 将 principal 和 authorities 放入 <code>Saml2Authentication</code>.</p>
</div>
<div class="paragraph">
<p>生成的 <code>Authentication#getPrincipal</code> 是 Spring Security <code>Saml2AuthenticatedPrincipal</code> 对象, <code>Authentication#getName</code> 映射到第一个 assertion 的 <code>NameID</code> 元素.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensaml-customization"><a class="anchor" href="#servlet-saml2login-opensaml-customization"></a>自定义 OpenSAML 配置</h5>
<div class="paragraph">
<p>任何同时使用 Spring Security 和 OpenSAML 的类都应该在类的开头静态初始化 <code>OpenSamlInitializationService</code>， 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">static {
    OpenSamlInitializationService.initialize();
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这代替了 OpenSAML 的 <code>InitializationService#initialize</code>.</p>
</div>
<div class="paragraph">
<p>有时， 自定义 OpenSAML 如何构建， marshalls 和 unmarshalls SAML 对象可能是有价值的.  在这种情况下， 您可以拒绝调用 <code>OpenSamlInitializationService#requireInitialize(Consumer)</code>， 使您可以访问 OpenSAML 的 <code>XMLObjectProviderFactory</code>.</p>
</div>
<div class="paragraph">
<p>例如， 如果您始终想要始终强制 asserting party  才能重新认证用户， 您可以注册自己的 <code>AuthnRequestMarshaller</code>， 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">static {
    OpenSamlInitializationService.requireInitialize(factory -&gt; {
        AuthnRequestMarshaller marshaller = new AuthnRequestMarshaller() {
            @Override
            public Element marshall(XMLObject object, Element element) throws MarshallingException {
                configureAuthnRequest((AuthnRequest) object);
                return super.marshall(object, element);
            }

            public Element marshall(XMLObject object, Document document) throws MarshallingException {
                configureAuthnRequest((AuthnRequest) object);
                return super.marshall(object, document);
            }

            private void configureAuthnRequest(AuthnRequest authnRequest) {
                authnRequest.setForceAuthN(true);
            }
        }

        factory.getMarshallerFactory().registerMarshaller(AuthnRequest.DEFAULT_ELEMENT_NAME, marshaller);
    });
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>每个应用程序实例只能调用一次 <code>requireInitialize</code> 方法.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-sansboot"><a class="anchor" href="#servlet-saml2login-sansboot"></a>13.1.4. 如何覆盖或替换的 Spring Boot 自动配置</h4>
<div class="paragraph">
<p>Spring Boot 有两 个 <code>@Bean</code> 为 relying party 生成.</p>
</div>
<div class="paragraph">
<p>第一个是 <code>WebSecurityConfigurerAdapter</code>， 它将应用程序配置为 relying party .  在包括 <code>Spring-Security-Saml2-Service-Provider</code> 时， <code>WebSecurityConfigurerAdapter</code> 看起来像:</p>
</div>
<div class="exampleblock">
<div class="title">Example 122. Default JWT Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
        )
        .saml2Login(withDefaults());
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        saml2Login { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果应用程序未暴露 <code>WebSecurityConfigurerAdapter</code> Bean， 则 Spring 将暴露上述默认值.</p>
</div>
<div class="paragraph">
<p>您可以通过在应用程序中暴露 bean 来替换它:</p>
</div>
<div class="exampleblock">
<div class="title">Example 123. Custom SAML 2.0 Login Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("ROLE_USER")
                .anyRequest().authenticated()
            )
            .saml2Login(withDefaults());
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("ROLE_USER"))
                authorize(anyRequest, authenticated)
            }
            saml2Login {
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>上面需要 <code>USER</code> 对以 <code>/messages/</code> 开始的任何 URL 的角色.</p>
</div>
<div id="servlet-saml2login-relyingpartyregistrationrepository" class="paragraph">
<p>第二个 <code>@Bean</code> 是 Spring Boot 创建 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/saml2/provider/service/registration/RelyingPartyRegistrationRepository.html"><code>RelyingPartyRegistrationRepository</code></a>， 它代表了 asserting party 和 relying party元数据.  这包括 SSO 端点的位置， relying party 应在从 asserting party 请求身份验证时使用.</p>
</div>
<div class="paragraph">
<p>您可以通过发布您自己的 <code>RelyingPartyRegistrationRepository</code> Bean 来覆盖默认值.  例如， 您可以通过元数据端点提示来查找 asserting party 的配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 124. Relying Party Registration Repository</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Value("${metadata.location}")
String assertingPartyMetadataLocation;

@Bean
public RelyingPartyRegistrationRepository relyingPartyRegistrations() {
    RelyingPartyRegistration registration = RelyingPartyRegistrations
            .fromMetadataLocation(assertingPartyMetadataLocation)
            .registrationId("example")
            .build();
    return new InMemoryRelyingPartyRegistrationRepository(registration);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者， 您可以手动提供每个细节,如下:</p>
</div>
<div class="exampleblock">
<div class="title">Example 125. Relying Party Registration Repository Manual Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Value("${verification.key}")
File verificationKey;

@Bean
public RelyingPartyRegistrationRepository relyingPartyRegistrations() throws Exception {
    X509Certificate certificate = X509Support.decodeCertificate(this.verificationKey);
    Saml2X509Credential credential = Saml2X509Credential.verification(certificate);
    RelyingPartyRegistration registration = RelyingPartyRegistration
            .withRegistrationId("example")
            .assertingPartyDetails(party -&gt; party
                .entityId("https://idp.example.com/issuer")
                .singleSignOnServiceLocation("https://idp.example.com/SSO.saml2")
                .wantAuthnRequestsSigned(false)
                .verificationX509Credentials(c -&gt; c.add(credential))
            )
            .build();
    return new InMemoryRelyingPartyRegistrationRepository(registration);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>X509Support</code> 属于 OpenSAML 类, 为了简洁， 这里使用了这个部分代码
</td>
</tr>
</table>
</div>
<div id="servlet-saml2login-relyingpartyregistrationrepository-dsl" class="paragraph">
<p>或者， 您可以使用 DSL 直接连接存储库， 这也将覆盖自动配置的 <code>WebSecurityConfigurerAdapter</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 126. Custom Relying Party Registration DSL</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -&gt; authorize
                .mvcMatchers("/messages/**").hasAuthority("ROLE_USER")
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .relyingPartyRegistrationRepository(relyingPartyRegistrations())
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("ROLE_USER"))
                authorize(anyRequest, authenticated)
            }
            saml2Login {
                relyingPartyRegistrationRepository = relyingPartyRegistrations()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
通过在 <code>RelyingPartyRegistrationRepository</code> 中注册多个 relying party ， relying party  可以是多租户的.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-relyingpartyregistration"><a class="anchor" href="#servlet-saml2login-relyingpartyregistration"></a>13.1.5. RelyingPartyRegistration</h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/saml2/provider/service/registration/RelyingPartyRegistration.html"><code>RelyingPartyRegistration</code></a> 实例表示 relying party 和 asserting party 元数据之间的链接.</p>
</div>
<div class="paragraph">
<p>在 <code>RelyingPartyRegistration</code> 中， 您可以提供 relying party 元数据， 如它的 <code>Issuer</code> 值(它希望将 SAML 响应发送到该值)， 以及它所拥有的用于签名或解密有效负载的任何凭据.</p>
</div>
<div class="paragraph">
<p>此外， 您还可以提供 asserting party 元数据， 比如它期望将 <code>AuthnRequests</code> 发送到的 <code>Issuer</code> 值， 以及它所拥有的用于 relying party 验证或加密有效负载的任何公共凭据.</p>
</div>
<div class="paragraph">
<p>以下 <code>RelyingPartyRegistration</code> 是大多数设置的最低要求:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistrations
        .fromMetadataLocation("https://ap.example.org/metadata")
        .registrationId("my-id")
        .build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管也可以进行更复杂的设置， 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId("my-id")
        .entityId("{baseUrl}/{registrationId}")
        .decryptionX509Credentials(c -&gt; c.add(relyingPartyDecryptingCredential()))
        .assertionConsumerServiceLocation("/my-login-endpoint/{registrationId}")
        .assertingParty(party -&gt; party
                .entityId("https://ap.example.org")
                .verificationX509Credentials(c -&gt; c.add(assertingPartyVerifyingCredential()))
                .singleSignOnServiceLocation("https://ap.example.org/SSO.saml2")
        );
</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
顶级元数据方法是关于 relying party 的详细信息. <code>assertingPartyDetails</code> 内部的方法是关于 asserting party 的详细信息.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
relying party 期望 SAML 响应的位置是 Assertion Consumer Service Location.
</td>
</tr>
</table>
</div>
<div class="literalblock">
<div class="content">
<pre>relying party  `entityId` 的默认值是 `+{baseUrl}/saml2/service-provider-metadata/{registrationId}+`.  这是配置 asserting party 了解您的 relying party 时所需的值.</pre>
</div>
</div>
<div class="paragraph">
<p>默认的 <code>assertionConsumerServiceLocation</code> 是 <code>/login/saml2/sso/{registrationId}</code>.  它默认映射到过滤器链中的 <a href="#servlet-saml2login-authentication-saml2webssoauthenticationfilter"><code>Saml2WebSsoAuthenticationFilter</code></a>.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-uripatterns"><a class="anchor" href="#servlet-saml2login-rpr-uripatterns"></a>URI 模式</h5>
<div class="paragraph">
<p>您可能在上面的例子中注意到 <code>{baseUrl}</code> 和 <code>{registrationId}</code> 占位符.</p>
</div>
<div class="paragraph">
<p>这些对于生成 URI 是有用的.  因此，  relying party 的 <code>entityId</code> 和 <code>assertionConsumerServiceLocation</code>  支持以下占位符:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>baseUrl</code> - the scheme, host, and port of a deployed application</p>
</li>
<li>
<p><code>registrationId</code> - the registration id for this relying party</p>
</li>
<li>
<p><code>baseScheme</code> - the scheme of a deployed application</p>
</li>
<li>
<p><code>baseHost</code> - the host of a deployed application</p>
</li>
<li>
<p><code>basePort</code> - the port of a deployed application</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如， 上面定义的 <code>assertionConsumerServiceLocation</code> :</p>
</div>
<div class="paragraph">
<p><code>/my-login-endpoint/{registrationId}</code></p>
</div>
<div class="paragraph">
<p>在已部署的应用程序中将转换为</p>
</div>
<div class="paragraph">
<p><code>/my-login-endpoint/adfs</code></p>
</div>
<div class="paragraph">
<p>在上面的代码中 <code>entityId</code> 被定义为:</p>
</div>
<div class="paragraph">
<p><code>{baseUrl}/{registrationId}</code></p>
</div>
<div class="paragraph">
<p>在已部署的应用程序中将转换为</p>
</div>
<div class="paragraph">
<p><code>https://rp.example.com/adfs</code></p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-credentials"><a class="anchor" href="#servlet-saml2login-rpr-credentials"></a>Credentials(凭据)</h5>
<div class="paragraph">
<p>您还有可能注意到使用的凭证.</p>
</div>
<div class="paragraph">
<p>通常，  relying party 会使用相同的密钥对有效载荷进行签名和解密. 或者它将使用相同的密钥来验证有效载荷并加密它们.</p>
</div>
<div class="paragraph">
<p>因此， Spring Security 附带了 <code>Saml2X509Credential</code>， 这是一个特定于 saml 的凭据， 简化了针对不同用例配置相同密钥的过程.</p>
</div>
<div class="paragraph">
<p>至少， 必须有来自 asserting party 的证书， 这样才能验证 asserting party 的签名响应</p>
</div>
<div class="paragraph">
<p>要构造一个 <code>Saml2X509Credential</code>， 用于验证来自 asserting party 的 assertions， 您可以加载该文件并使用 <code>CertificateFactory</code>， 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Resource resource = new ClassPathResource("ap.crt");
try (InputStream is = resource.getInputStream()) {
    X509Certificate certificate = (X509Certificate)
            CertificateFactory.getInstance("X.509").generateCertificate(is);
    return Saml2X509Credential.verification(certificate);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>假设 asserting party 也要对 assertion 进行加密. 在这种情况下，  relying party 将需要一个私钥来解密加密的值.</p>
</div>
<div class="paragraph">
<p>在这种情况下， 您将需要一个 <code>RSAPrivateKey</code> 及其对应的 <code>X509Certificate</code>. 你可以使用 Spring Security 的 <code>RsaKeyConverters</code> 实用工具类来加载第一个和第二个， 就像你之前做的那样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">X509Certificate certificate = relyingPartyDecryptionCertificate();
Resource resource = new ClassPathResource("rp.crt");
try (InputStream is = resource.getInputStream()) {
    RSAPrivateKey rsa = RsaKeyConverters.pkcs8().convert(is);
    return Saml2X509Credential.decryption(rsa, certificate);
}
</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
当您将这些文件的位置指定为适当的 Spring Boot 属性时， Spring Boot 将为您执行这些转换
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-relyingpartyregistrationresolver"><a class="anchor" href="#servlet-saml2login-rpr-relyingpartyregistrationresolver"></a>解决请求中的 relying party</h5>
<div class="paragraph">
<p>到目前为止， Spring Security 通过在 URI 路径中查找 registration id 来解析 <code>RelyingPartyRegistration</code>.</p>
</div>
<div class="paragraph">
<p>您需要自定义的原因有很多. 其中包括:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>您知道您永远不会是一个多租户应用程序， 因此希望拥有一个更简单的 URL 模式</p>
</li>
<li>
<p>您可以通过 URI 路径以外的方式标识租户</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了自定义 <code>RelyingPartyRegistration</code> 的解析方式， 你可以配置一个自定义 <code>Converter&lt;HttpServletRequest, RelyingPartyRegistration&gt;</code>. 默认的方法是从 URI 的最后一个 path 元素查找 registration id， 并在 <code>RelyingPartyRegistrationRepository</code> 中查找.</p>
</div>
<div class="paragraph">
<p>你可以提供一个更简单的解析器， 例如， 它总是返回相同的 relying party :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class SingleRelyingPartyRegistrationResolver
        implements Converter&lt;HttpServletRequest, RelyingPartyRegistration&gt; {

    @Override
    public RelyingPartyRegistration convert(HttpServletRequest request) {
        return this.relyingParty;
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后， 您可以将此解析器提供给产生 <a href="#servlet-saml2login-sp-initiated-factory">produce <code>&lt;saml2:AuthnRequest&gt;</code> s</a>， 验证 <code>&lt;saml2:Response&gt;</code> s&gt;&gt; 的过滤器， <a href="#servlet-saml2login-metadata">并生成 <code>&lt;saml2:SPSSODescriptor&gt;</code> 元数据</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
请记住， 如果您在 <code>RelyingPartyRegistration</code> 中有任何占位符， 您的 resolver 实现需要解决他们.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-rpr-duplicated"><a class="anchor" href="#servlet-saml2login-rpr-duplicated"></a>重复 Relying Party 配置</h5>
<div class="paragraph">
<p>当应用程序使用多个 asserting party 时， 某些配置会在 <code>RelyingPartyRegistration</code> 实例之间重复:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>relying party 的 <code>entityId</code></p>
</li>
<li>
<p>他的 <code>assertionConsumerServiceLocation</code>, 和</p>
</li>
<li>
<p>他的凭据, 例如其签名或解密凭据</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这种设置的好处是， 相对于其他身份提供者， 某些身份提供者可以更容易地轮换凭据.</p>
</div>
<div class="paragraph">
<p>可以通过几种不同的方式减少重复.</p>
</div>
<div class="paragraph">
<p>首先， 在 YAML 中可以通过 references 来缓解这种情况， 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    saml2:
      relyingparty:
        okta:
          signing.credentials: &amp;relying-party-credentials
            - private-key-location: classpath:rp.key
            - certificate-location: classpath:rp.crt
          identityprovider:
            entity-id: ...
        azure:
          signing.credentials: *relying-party-credentials
          identityprovider:
            entity-id: ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>其次， 在数据库中， 没有必要复制 <code>RelyingPartyRegistration</code> model.</p>
</div>
<div class="paragraph">
<p>第三， 在 Java 中， 您可以创建自定义配置方法， 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private RelyingPartyRegistration.Builder
        addRelyingPartyDetails(RelyingPartyRegistration.Builder builder) {

    Saml2X509Credential signingCredential = ...
    builder.signingX509Credentials(c -&gt; c.addAll(signingCredential));
    // ... other relying party configurations
}

@Bean
public RelyingPartyRegistrationRepository relyingPartyRegistrations() {
    RelyingPartyRegistration okta = addRelyingPartyDetails(
            RelyingPartyRegistration
                .fromMetadataLocation(oktaMetadataUrl)
                .registrationId("okta")).build();

    RelyingPartyRegistration azure = addRelyingPartyDetails(
            RelyingPartyRegistration
                .fromMetadataLocation(oktaMetadataUrl)
                .registrationId("azure")).build();

    return new InMemoryRelyingPartyRegistrationRepository(okta, azure);
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-sp-initiated-factory"><a class="anchor" href="#servlet-saml2login-sp-initiated-factory"></a>13.1.6. 生成 <code>&lt;saml2:AuthnRequest&gt;</code></h4>
<div class="paragraph">
<p>如前所述， Spring Security 的 SAML 2.0 支持生成一个  <code>&lt;saml2:AuthnRequest&gt;</code>  来开始与 asserting party 的身份验证.</p>
</div>
<div class="paragraph">
<p>Spring Security 通过在过滤器链中注册 <code>Saml2WebSsoAuthenticationRequestFilter</code> 来实现这一点. 这个过滤器默认响应端点  <code>/saml2/authenticate/{registrationId}</code>.</p>
</div>
<div class="paragraph">
<p>例如， 如果你部署到 <code><a href="https://rp.example.com" class="bare">rp.example.com</a></code>， 你给你的 registration <code>okta</code> ID， 你可以链接到:</p>
</div>
<div class="paragraph">
<p><code><a href="https://rp.example.org/saml2/authenticate/ping" class="bare">rp.example.org/saml2/authenticate/ping</a></code></p>
</div>
<div class="paragraph">
<p>结果将是一个重定向， 其中包含一个包含有符号、压缩和编码 <code>&lt;saml2:AuthnRequest&gt;</code> 的 <code>SAMLRequest</code> 参数.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-sp-initiated-factory-signing"><a class="anchor" href="#servlet-saml2login-sp-initiated-factory-signing"></a>改变 <code>&lt;saml2:AuthnRequest&gt;</code> 的发送方式</h5>
<div class="paragraph">
<p>默认情况下， Spring Security 对每个 <code>&lt;saml2:AuthnRequest&gt;</code> 进行签名， 并将其作为 GET 发送到 asserting party .</p>
</div>
<div class="paragraph">
<p>许多 asserting party 不需要 signed <code>&lt;saml2:AuthnRequest&gt;</code>. 这可以通过  <code>RelyingPartyRegistrations</code> 自动配置， 也可以手动提供， 如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 127. Not Requiring Signed AuthnRequests</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Boot</div>
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    saml2:
      relyingparty:
        okta:
          identityprovider:
            entity-id: ...
            singlesignon.sign-request: false</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId("okta")
        // ...
        .assertingPartyDetails(party -&gt; party
            // ...
            .wantAuthnRequestsSigned(false)
        );
</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>否则， 你需要为 <code>RelyingPartyRegistration#signingX509Credentials</code> 指定一个私钥， 这样 Spring Security 就可以在发送之前对  <code>&lt;saml2:AuthnRequest&gt;</code> 进行签名.</p>
</div>
<div id="servlet-saml2login-sp-initiated-factory-binding" class="paragraph">
<p>一些 asserting party 要求 POSTed <code>&lt;saml2:AuthnRequest&gt;</code> . 这可以通过 <code>RelyingPartyRegistrations</code> 自动配置， 也可以手动提供， 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RelyingPartyRegistration relyingPartyRegistration = RelyingPartyRegistration.withRegistrationId("okta")
        // ...
        .assertingPartyDetails(party -&gt; party
            // ...
            .singleSignOnServiceBinding(Saml2MessageType.POST)
        );
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-sp-initiated-factory-custom-authnrequest"><a class="anchor" href="#servlet-saml2login-sp-initiated-factory-custom-authnrequest"></a>自定义 OpenSAML 的 <code>AuthnRequest</code> 实例</h5>
<div class="paragraph">
<p>调整 <code>AuthnRequest</code> 的原因有很多. 例如， 您可能希望将 <code>ForceAuthN</code> 设置为 <code>true</code>, Spring Security 默认设置为 <code>false</code>.</p>
</div>
<div class="paragraph">
<p>如果你不需要来自 <code>HttpServletRequest</code> 的信息来做决定， 那么最简单的方法就是用 <a href="#servlet-saml2login-opensaml-customization">OpenSAML 注册一个自定义的 <code>AuthnRequestMarshaller</code></a>.这将使您能够在 <code>AuthnRequest</code> 实例被序列化之前对其进行后处理.</p>
</div>
<div class="paragraph">
<p>但是， 如果你确实需要从请求中获取一些东西， 那么你可以创建一个自定义 <code>Saml2AuthenticationRequestContext</code> 实现， 然后使用 <code>Converter&lt;Saml2AuthenticationRequestContext, AuthnRequest&gt;</code> 来自己构建一个 <code>AuthnRequest</code>， 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
public class AuthnRequestConverter implements
        Converter&lt;MySaml2AuthenticationRequestContext, AuthnRequest&gt; {

    private final AuthnRequestBuilder authnRequestBuilder;
    private final IssuerBuilder issuerBuilder;

    // ... constructor

    public AuthnRequest convert(Saml2AuthenticationRequestContext context) {
        MySaml2AuthenticationRequestContext myContext = (MySaml2AuthenticationRequestContext) context;
        Issuer issuer = issuerBuilder.buildObject();
        issuer.setValue(myContext.getIssuer());

        AuthnRequest authnRequest = authnRequestBuilder.buildObject();
        authnRequest.setIssuer(iss);
        authnRequest.setDestination(myContext.getDestination());
        authnRequest.setAssertionConsumerServiceURL(myContext.getAssertionConsumerServiceUrl());

        // ... additional settings

        authRequest.setForceAuthn(myContext.getForceAuthn());
        return authnRequest;
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后， 你可以构造自己的 <code>Saml2AuthenticationRequestContextResolver</code> 和 <code>Saml2AuthenticationRequestFactory</code>， 并以 <code>@Bean</code> 的形式发布它们:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
Saml2AuthenticationRequestContextResolver authenticationRequestContextResolver() {
    Saml2AuthenticationRequestContextResolver resolver =
            new DefaultSaml2AuthenticationRequestContextResolver();
    return request -&gt; {
        Saml2AuthenticationRequestContext context = resolver.resolve(request);
        return new MySaml2AuthenticationRequestContext(context, request.getParameter("force") != null);
    };
}

@Bean
Saml2AuthenticationRequestFactory authenticationRequestFactory(
        AuthnRequestConverter authnRequestConverter) {

    OpenSamlAuthenticationRequestFactory authenticationRequestFactory =
            new OpenSamlAuthenticationRequestFactory();
    authenticationRequestFactory.setAuthenticationRequestContextConverter(authnRequestConverter);
    return authenticationRequestFactory;
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-authenticate-responses"><a class="anchor" href="#servlet-saml2login-authenticate-responses"></a>13.1.7. Authenticating <code>&lt;saml2:Response&gt;</code></h4>
<div class="paragraph">
<p>为了验证 SAML 2.0 响应， Spring Security 默认使用 <a href="#servlet-saml2login-architecture"><code>OpenSamlAuthenticationProvider</code></a>.</p>
</div>
<div class="paragraph">
<p>你可以通过多种方式来配置它， 包括:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将时钟偏斜设置为时间戳验证</p>
</li>
<li>
<p>将响应映射到一个 <code>GrantedAuthority</code> 实例列表</p>
</li>
<li>
<p>自定义验证 assertions 的策略</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>要配置这些， 您将在 DSL 中使用 <code>saml2Login#authenticationManager</code> 方法.</p>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensamlauthenticationprovider-clockskew"><a class="anchor" href="#servlet-saml2login-opensamlauthenticationprovider-clockskew"></a>设置 Clock Skew</h5>
<div class="paragraph">
<p>asserting 和 relying parties  具有不完全同步的系统时间并不罕见.  因此， 您可以使用一些时差配置 <code>OpenSamlAuthenticationProvider</code> 的默认断言验证器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        OpenSamlAuthenticationProvider authenticationProvider = new OpenSamlAuthenticationProvider();
        authenticationProvider.setAssertionValidator(OpenSamlAuthenticationProvider
                .createDefaultAssertionValidator(assertionToken -&gt; {
                    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
                    params.put(CLOCK_SKEW, Duration.ofMinutes(10).toMillis());
                    // ... other validation parameters
                    return new ValidationContext(params);
                })
        );

        http
            .authorizeRequests(authz -&gt; authz
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .authenticationManager(new ProviderManager(authenticationProvider))
            );
    }
}
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensamlauthenticationprovider-userdetailsservice"><a class="anchor" href="#servlet-saml2login-opensamlauthenticationprovider-userdetailsservice"></a>与  <code>UserDetailsService</code> 关联</h5>
<div class="paragraph">
<p>或者， 您可能希望包含来自遗留 <code>UserDetailsService</code> 的用户详细信息. 在这种情况下， 响应身份验证转换器可以派上用场， 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    UserDetailsService userDetailsService;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        OpenSamlAuthenticationProvider authenticationProvider = new OpenSamlAuthenticationProvider();
        authenticationProvider.setResponseAuthenticationConverter(responseToken -&gt; {
            Saml2Authentication authentication = OpenSamlAuthenticationProvider
                    .createDefaultResponseAuthenticationConverter() <i class="conum" data-value="1"></i><b>(1)</b>
                    .convert(responseToken);
            Assertion assertion = responseToken.getResponse().getAssertions().get(0);
            String username = assertion.getSubject().getNameID().getValue();
            UserDetails userDetails = this.userDetailsService.loadUserByUsername(username); <i class="conum" data-value="2"></i><b>(2)</b>
            return MySaml2Authentication(userDetails, authentication); <i class="conum" data-value="3"></i><b>(3)</b>
        });

        http
            .authorizeRequests(authz -&gt; authz
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .authenticationManager(new ProviderManager(authenticationProvider))
            );
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>首先， 调用默认转换器， 它从响应中提取属性和权限</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>其次， 使用相关信息调用 <a href="#servlet-authentication-userdetailsservice"><code>UserDetailsService</code></a></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>第三， 返回一个包含用户详细信息的自定义身份验证</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
它不需要调用 <code>OpenSamlAuthenticationProvider</code> 的默认身份验证转换器. 它返回一个 <code>Saml2AuthenticatedPrincipal</code>， 其中包含从 <code>AttributeStatement</code> 提取的属性以及单个 <code>ROLE_USER</code> 权限
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-opensamlauthenticationprovider-additionalvalidation"><a class="anchor" href="#servlet-saml2login-opensamlauthenticationprovider-additionalvalidation"></a>执行额外验证</h5>
<div class="paragraph">
<p><code>OpenSamlAuthenticationProvider</code> 对 SAML 2.0 assertion 执行最小验证. 在验证签名后， 它将:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>验证 <code>&lt;AudienceRestriction&gt;</code> 和 <code>&lt;DelegationRestriction&gt;</code> 条件</p>
</li>
<li>
<p>验证 <code>&lt;SubjectConfirmation&gt;</code> , 期望任何 IP 地址信息</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>要执行额外的验证， 您可以配置自己的断言验证器， 它委托给默认的 <code>OpenSamlAuthenticationProvider</code>， 然后执行自己的断言验证器.</p>
</div>
<div id="servlet-saml2login-opensamlauthenticationprovider-onetimeuse" class="paragraph">
<p>例如， 你可以使用 OpenSAML 的 <code>OneTimeUseConditionValidator</code> 来验证 <code>&lt;OneTimeUse&gt;</code> 条件， 就像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OpenSamlAuthenticationProvider provider = new OpenSamlAuthenticationProvider();
OneTimeUseConditionValidator validator = ...;
provider.setAssertionValidator(assertionToken -&gt; {
    Saml2ResponseValidatorResult result = OpenSamlAuthenticationProvider
            .createDefaultAssertionValidator()
            .convert(assertionToken);
    Assertion assertion = assertionToken.getAssertion();
    OneTimeUse oneTimeUse = assertion.getConditions().getOneTimeUse();
    ValidationContext context = new ValidationContext();
    try {
        if (validator.validate(oneTimeUse, assertion, context) == ValidationResult.VALID) {
            return result;
        }
    } catch (Exception e) {
        return result.concat(new Saml2Error(INVALID_ASSERTION, e.getMessage()));
    }
    return result.contact(new Saml2Error(INVALID_ASSERTION, context.getValidationFailureMessage()));
});
</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
虽然推荐使用， 但不需要调用 <code>OpenSamlAuthenticationProvider</code> 的默认断言验证器. 如果你不需要它来检查 <code>&lt;AudienceRestriction&gt;</code> 或 <code>&lt;SubjectConfirmation&gt;</code>， 因为你自己在做这些， 你就会跳过它.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servlet-saml2login-authenticationmanager-custom"><a class="anchor" href="#servlet-saml2login-authenticationmanager-custom"></a>使用自定义 Authentication Manager</h5>
<div id="servlet-saml2login-opensamlauthenticationprovider-authenticationmanager" class="paragraph">
<p>当然， AuthenticationManager DSL 方法也可以用于执行完全自定义的 SAML 2.0 身份验证.  此身份验证管理器应期望包含 SAML 2.0 响应 XML 数据的 <code>SAML2AuthenticationToken</code> 对象.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        AuthenticationManager authenticationManager = new MySaml2AuthenticationManager(...);
        http
            .authorizeRequests(authorize -&gt; authorize
                .anyRequest().authenticated()
            )
            .saml2Login(saml2 -&gt; saml2
                .authenticationManager(authenticationManager)
            )
        ;
    }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-authenticatedprincipal"><a class="anchor" href="#servlet-saml2login-authenticatedprincipal"></a>13.1.8. 使用 <code>Saml2AuthenticatedPrincipal</code></h4>
<div class="paragraph">
<p>在为给定 asserting party 正确配置了 relying party 之后， 它就可以接受 assertion 了. 一旦 relying party 验证了 assertion， 结果就是带有 <code>Saml2AuthenticatedPrincipal</code> 的 <code>Saml2Authentication</code>.</p>
</div>
<div class="paragraph">
<p>这意味着您可以访问控制器中的主体 principal:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Controller
public class MainController {
    @GetMapping("/")
    public String index(@AuthenticationPrincipal Saml2AuthenticatedPrincipal principal, Model model) {
        String email = principal.getFirstAttribute("email");
        model.setAttribute("email", email);
        return "index";
    }
}
</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
因为 SAML 2.0 规范允许每个属性有多个值， 所以您可以调用 <code>getAttribute</code> 来获取属性列表， 也可以调用 <code>getFirstAttribute</code> 来获取列表中的第一个属性. 当您知道只有一个值时， <code>getFirstAttribute</code> 非常方便.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-metadata"><a class="anchor" href="#servlet-saml2login-metadata"></a>13.1.9. 生成 <code>&lt;saml2:SPSSODescriptor&gt;</code> 元数据</h4>
<div class="paragraph">
<p>您可以通过将 <code>Saml2MetadataFilter</code> 添加到过滤器链来发布元数据端点， 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Converter&lt;HttpServletRequest, RelyingPartyRegistration&gt; relyingPartyRegistrationResolver =
        new DefaultRelyingPartyRegistrationResolver(this.relyingPartyRegistrationRepository);
Saml2MetadataFilter filter = new Saml2MetadataFilter(
        relyingPartyRegistrationResolver,
        new OpenSamlMetadataResolver());

http
    // ...
    .saml2Login(withDefaults())
    .addFilterBefore(new Saml2MetadataFilter(r), Saml2WebSsoAuthenticationFilter.class);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用此元数据端点向 asserting party 注册 relying party . 这通常与找到正确的表单字段来提供元数据端点一样简单.</p>
</div>
<div class="paragraph">
<p>默认情况下， 元数据端点是 <code>/saml2/service-provider-metadata/{registrationId}</code>. 你可以通过调用过滤器上的 <code>setRequestMatcher</code> 方法来改变这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">filter.setRequestMatcher(new AntPathRequestMatcher("/saml2/metadata/{registrationId}", "GET"));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>确保 <code>registrationId</code> 提示位于路径的末尾.</p>
</div>
<div class="paragraph">
<p>或者， 如果你已经在构造函数中注册了一个自定义 relying party 注册解析器， 那么你可以指定一个不带 <code>registrationId</code> 提示的路径， 如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">filter.setRequestMatcher(new AntPathRequestMatcher("/saml2/metadata", "GET"));
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-saml2login-logout"><a class="anchor" href="#servlet-saml2login-logout"></a>13.1.10. 执行单次注销</h4>
<div class="paragraph">
<p>Spring Security 还不支持单次登出.</p>
</div>
<div class="paragraph">
<p>一般来说， 你可以通过创建和注册一个自定义的 <code>LogoutSuccessHandler</code> 和 <code>RequestMatcher</code> 来实现这一点:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">http
    // ...
    .logout(logout -&gt; logout
        .logoutSuccessHandler(myCustomSuccessHandler())
        .logoutRequestMatcher(myRequestMatcher())
    )
</code></pre>
</div>
</div>
<div class="paragraph">
<p>成功处理程序将向 asserting party 发送注销请求.</p>
</div>
<div class="paragraph">
<p>请求匹配器将检测来自 asserting party 的注销请求.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="servlet-exploits"><a class="anchor" href="#servlet-exploits"></a>14. 防御利用漏洞</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="servlet-csrf"><a class="anchor" href="#servlet-csrf"></a>14.1. Servlet环境的跨站点请求伪造(CSRF)</h3>
<div class="paragraph">
<p>本部分讨论了 Spring Security 对 Servlet 环境的<a href="#csrf">跨站点请求伪造(CSRF) </a>支持.</p>
</div>
<div class="sect3">
<h4 id="servlet-csrf-using"><a class="anchor" href="#servlet-csrf-using"></a>14.1.1. 使用 Spring Security 保护 CSRF</h4>
<div class="paragraph">
<p>下面描述了如何使用 Spring Security 防御 CSRF 的步骤:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#servlet-csrf-idempotent">使用正确的 HTTP 动词</a></p>
</li>
<li>
<p><a href="#servlet-csrf-configure">配置防御 CSRF</a></p>
</li>
<li>
<p><a href="#servlet-csrf-include">包括 CSRF 令牌</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="servlet-csrf-idempotent"><a class="anchor" href="#servlet-csrf-idempotent"></a>使用正确的HTTP动词</h5>
<div class="paragraph">
<p>防御 CSRF 攻击的第一步是确保您的网站使用正确的 HTTP 动词.  <a href="#csrf-protection-idempotent">安全方法必须是幂等的</a>中对此进行了详细介绍.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-csrf-configure"><a class="anchor" href="#servlet-csrf-configure"></a>配置防御CSRF</h5>
<div class="paragraph">
<p>下一步是在您的应用程序中配置 Spring Security 的防御 CSRF.  默认情况下,Spring Security 的对 CSRF 的防御处于启用状态,但是您可能需要自定义配置.  以下是一些常见的自定义项.</p>
</div>
<div class="sect5">
<h6 id="servlet-csrf-configure-custom-repository"><a class="anchor" href="#servlet-csrf-configure-custom-repository"></a>自定义 CsrfTokenRepository</h6>
<div class="paragraph">
<p>默认情况下,Spring Security 使用 <code>HttpSessionCsrfTokenRepository</code> 将所需的 CSRF 令牌存储在 <code>HttpSession</code> 中.  在某些情况下,用户需要配置自定义 <code>CsrfTokenRepository</code>.  例如,可能需要将 <code>CsrfToken</code> 持久保存在 <code>cookie</code> 中以<a href="#servlet-csrf-include-ajax-auto">支持 JavaScript 的应用程序</a>.</p>
</div>
<div class="paragraph">
<p>默认情况下,<code>CookieCsrfTokenRepository</code> 将写入名为 <code>XSRF-TOKEN</code> 的 <code>cookie</code>,并从名为 <code>X-XSRF-TOKEN</code> 的请求头或 HTTP 参数 为 <code>_csrf</code> 中读取它.  这些默认值来自 <a href="https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection">AngularJS</a></p>
</div>
<div class="paragraph">
<p>您可以使用以下命令以 XML 配置 <code>CookieCsrfTokenRepository</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 128. 使用 XML 配置将 CSRF 令牌存储在 Cookie 中</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;
    &lt;csrf token-repository-ref="tokenRepository"/&gt;
&lt;/http&gt;
&lt;b:bean id="tokenRepository"
    class="org.springframework.security.web.csrf.CookieCsrfTokenRepository"
    p:cookieHttpOnly="false"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该示例显式设置 <code>cookieHttpOnly=false</code>.  这是允许 JavaScript(即 AngularJS) 可以从 cookie 中读取他需要的东西.  如果不需要直接使用 JavaScript 读取 cookie 的功能,建议省略 <code>cookieHttpOnly = false</code> 以提高安全性.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>您可以使用以下命令在 Java 配置中配置 <code>CookieCsrfTokenRepository</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 129. Store CSRF Token in a Cookie</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
        WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) {
        http
            .csrf(csrf -&gt; csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            csrf {
                csrfTokenRepository = CookieCsrfTokenRepository.withHttpOnlyFalse()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该示例显式设置 <code>cookieHttpOnly=false</code>.  这是允许 JavaScript(即 AngularJS) 可以从 cookie 中读取他需要的东西.  如果不需要直接使用 JavaScript 读取 cookie 的功能,建议省略 <code>cookieHttpOnly = false</code> (通过使用新的 <code>CookieCsrfTokenRepository()</code> 代替) 以提高安全性.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="servlet-csrf-configure-disable"><a class="anchor" href="#servlet-csrf-configure-disable"></a>禁用 CSRF 防御</h6>
<div class="paragraph">
<p>默认情况下,CSRF 保护处于启用状态. 但是,如果对<a href="#csrf-when">您的应用程序有意义</a>,则禁用 CSRF 防御很简单.</p>
</div>
<div class="paragraph">
<p>下面的XML配置将禁用 CSRF 保护.</p>
</div>
<div class="exampleblock">
<div class="title">Example 130. 禁用CSRF XML配置</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;
    &lt;csrf disabled="true"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的 Java 配置将禁用 CSRF 保护.</p>
</div>
<div class="exampleblock">
<div class="title">Example 131. Disable CSRF</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
        WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) {
        http
            .csrf(csrf -&gt; csrf.disable());
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            csrf {
                disable()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-csrf-include"><a class="anchor" href="#servlet-csrf-include"></a>包括CSRF令牌</h5>
<div class="paragraph">
<p>为了使<a href="#csrf-protection-stp">同步器令牌模式</a>免受 CSRF 攻击,我们必须在 HTTP 请求中包括实际的 CSRF 令牌.  这必须包含在请求的一部分(即表单参数,HTTP header 等) 中,浏览器不会自动将其包含在 HTTP 请求中.</p>
</div>
<div class="paragraph">
<p>Spring Security 的 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfFilter.html">CsrfFilter</a>  暴露了一个 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/csrf/CsrfToken.html">CsrfToken</a> 作为名为 <code>_csrf</code> 的 <code>HttpServletRequest</code> 属性.  这意味着任何视图技术都可以访问 <code>CsrfToken</code> 以将期望的令牌暴露为<a href="#servlet-csrf-include-form-attr">form</a>或<a href="#servlet-csrf-include-ajax-meta-attr">meta tag</a>.
幸运的是,下面列出了一些集成,这些集成使<a href="#servlet-csrf-include-form">form</a> 中的令牌和<a href="#servlet-csrf-include-ajax">ajax</a> 请求的包含变得更加容易.</p>
</div>
<div class="sect5">
<h6 id="servlet-csrf-include-form"><a class="anchor" href="#servlet-csrf-include-form"></a>Form URL Encoded</h6>
<div class="paragraph">
<p>为了 post HTML 表单,CSRF 令牌必须作为隐藏域包含在表单中. 例如,呈现的 HTML 可能如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 132. CSRF Token HTML</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;input type="hidden"
    name="_csrf"
    value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来,我们将讨论将 CSRF 令牌作为隐藏域包含在内的各种方式.</p>
</div>
<div class="sect6">
<h7 id="servlet-csrf-include-form-auto"><a class="anchor" href="#servlet-csrf-include-form-auto"></a>自动包含 CSRF 令牌</h7>
<div class="paragraph">
<p>Spring Security 的 CSRF 支持通过其 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/servlet/support/csrf/CsrfRequestDataValueProcessor.html">CsrfRequestDataValueProcessor</a>与 Spring 的 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/support/RequestDataValueProcessor.html">RequestDataValueProcessor</a> 集成.
这意味着,如果您利用 Spring 的 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view-jsp-formtaglib">Spring’s form tag library</a>,https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor[Thymeleaf] 或与 <code>RequestDataValueProcessor</code> 集成的任何其他视图技术,则具有不安全的 HTTP 方法(即发布) 的表单将自动包含实际的 CSRF  令牌.</p>
</div>
</div>
<div class="sect6">
<h7 id="servlet-csrf-include-form-tag"><a class="anchor" href="#servlet-csrf-include-form-tag"></a>csrfInput Tag</h7>
<div class="paragraph">
<p>如果您使用的是 JSP,则可以使用 Spring 的 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-view-jsp-formtaglib">Spring’s form tag library</a>..  但是,如果这不是一个选择,则还可以轻松地将标记包含在 <a href="#taglibs-csrfinput">csrfInput</a> 标签中.</p>
</div>
</div>
<div class="sect6">
<h7 id="servlet-csrf-include-form-attr"><a class="anchor" href="#servlet-csrf-include-form-attr"></a>CsrfToken 请求属性</h7>
<div class="paragraph">
<p>如果在请求中包括实际 CSRF 令牌的 <a href="#servlet-csrf-include">其他选项</a>不起作用,则可以利用 <code>CsrfToken</code> 作为名为 <code>_csrf</code> 的 <code>HttpServletRequest</code> 属性<a href="#servlet-csrf-include">暴露</a>的事实.</p>
</div>
<div class="paragraph">
<p>下面显示了使用 JSP 进行此操作的示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 133. 带有请求属性的表单中的 CSRF 令牌</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;c:url var="logoutUrl" value="/logout"/&gt;
&lt;form action="${logoutUrl}"
    method="post"&gt;
&lt;input type="submit"
    value="Log out" /&gt;
&lt;input type="hidden"
    name="${_csrf.parameterName}"
    value="${_csrf.token}"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="servlet-csrf-include-ajax"><a class="anchor" href="#servlet-csrf-include-ajax"></a>Ajax 和 JSON 请求</h6>
<div class="paragraph">
<p>如果使用的是 JSON,则无法在 HTTP 参数内提交 CSRF 令牌.  相反,您可以在 HTTP 头中提交令牌.</p>
</div>
<div class="paragraph">
<p>在以下各节中,我们将讨论在基于 JavaScript 的应用程序中将 CSRF 令牌作为 HTTP 请求头包括在内的各种方式.</p>
</div>
<div class="sect6">
<h7 id="servlet-csrf-include-ajax-auto"><a class="anchor" href="#servlet-csrf-include-ajax-auto"></a>自动包含</h7>
<div class="paragraph">
<p>可以轻松<a href="#servlet-csrf-configure-custom-repository">配置</a> Spring Security 将期望的 CSRF 令牌存储在 cookie 中.  通过将期望的 CSRF 存储在 cookie 中,像 <a href="https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection">AngularJS</a>  这样的 JavaScript 框架将自动在 HTTP 请求头中包含实际的 CSRF 令牌.</p>
</div>
</div>
<div class="sect6">
<h7 id="servlet-csrf-include-ajax-meta"><a class="anchor" href="#servlet-csrf-include-ajax-meta"></a>Meta tags</h7>
<div class="paragraph">
<p>在<a href="#servlet-csrf-include-form-auto">Cookie 中暴露 CSRF</a> 的另一种方式是将 CSRF 令牌包含在您的元标记中.  HTML 可能看起来像这样:</p>
</div>
<div class="exampleblock">
<div class="title">Example 134. CSRF meta tag HTML</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html&gt;
&lt;head&gt;
    &lt;meta name="_csrf" content="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/&gt;
    &lt;meta name="_csrf_header" content="X-CSRF-TOKEN"/&gt;
    &lt;!-- ... --&gt;
&lt;/head&gt;
&lt;!-- ... --&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦元标记包含 CSRF 令牌,JavaScript 代码就会读取元标记并将 CSRF 令牌作为 header 包含在内. 如果您使用的是 jQuery,则可以通过以下方式完成:</p>
</div>
<div class="exampleblock">
<div class="title">Example 135. AJAX send CSRF Token</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">$(function () {
    var token = $("meta[name='_csrf']").attr("content");
    var header = $("meta[name='_csrf_header']").attr("content");
    $(document).ajaxSend(function(e, xhr, options) {
        xhr.setRequestHeader(header, token);
    });
});</code></pre>
</div>
</div>
</div>
</div>
<div class="sect7">
<h8 id="servlet-csrf-include-ajax-meta-tag"><a class="anchor" href="#servlet-csrf-include-ajax-meta-tag"></a>csrfMeta 标签</h8>
<div class="paragraph">
<p>如果您使用的是 JSP,则将 CSRF 令牌写入 meta 标记的一种简单方法是利用  <a href="#taglibs-csrfmeta">csrfMeta</a> 标签.</p>
</div>
</div>
<div class="sect7">
<h8 id="servlet-csrf-include-ajax-meta-attr"><a class="anchor" href="#servlet-csrf-include-ajax-meta-attr"></a>CsrfToken 请求属性</h8>
<div class="paragraph">
<p>如果在请求中包括实际 CSRF 令牌的 <a href="#servlet-csrf-include">其他选项</a>  不起作用,则可以利用 <code>CsrfToken</code> 作为名为 <code>_csrf</code> 的 <code>HttpServletRequest</code> 属性<a href="#servlet-csrf-include">暴露</a>的事实. 下面显示了使用 JSP 进行此操作的示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 136. CSRF meta tag JSP</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html&gt;
&lt;head&gt;
    &lt;meta name="_csrf" content="${_csrf.token}"/&gt;
    &lt;!-- default header name is X-CSRF-TOKEN --&gt;
    &lt;meta name="_csrf_header" content="${_csrf.headerName}"/&gt;
    &lt;!-- ... --&gt;
&lt;/head&gt;
&lt;!-- ... --&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-csrf-considerations"><a class="anchor" href="#servlet-csrf-considerations"></a>14.1.2. CSRF 注意事项</h4>
<div class="paragraph">
<p>实施针对 CSRF 攻击的防护时,需要考虑一些特殊注意事项.  本节讨论与 Servlet 环境有关的那些注意事项.  请参阅 <a href="#csrf-considerations">CSRF 注意事项</a> 一节,以进行更一般的讨论.</p>
</div>
<div class="sect4">
<h5 id="servlet-considerations-csrf-login"><a class="anchor" href="#servlet-considerations-csrf-login"></a>登录</h5>
<div class="paragraph">
<p><a href="#csrf-considerations-login">要求 CSRF 进行登录</a> 请求很重要,以防止伪造登录尝试.  Spring Security 的 servlet 支持是开箱即用的.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-considerations-csrf-logout"><a class="anchor" href="#servlet-considerations-csrf-logout"></a>注销</h5>
<div class="paragraph">
<p><a href="#csrf-considerations-logout">要求 CSRF 进行注销</a>请求很重要,以防止伪造注销尝试.  如果启用了 CSRF 保护(默认) ,Spring Security 的 <code>LogoutFilter</code> 仅处理 HTTP POST.  这样可以确保注销需要 CSRF 令牌,并且恶意用户不能强制注销用户.</p>
</div>
<div class="paragraph">
<p>最简单的方法是使用表单注销.  如果您确实需要链接,则可以使用 JavaScript 来使链接执行 POST(即可能以隐藏形式) .  对于禁用了JavaScript 的浏览器,您可以选择使该链接将用户带到将执行 POST 的注销确认页面.</p>
</div>
<div class="paragraph">
<p>如果您确实想在注销时使用 HTTP GET,则可以这样做,但是请记住,通常不建议这样做.  例如,以下 Java 配置将使用 URL <code>/logout</code> 通过任何 HTTP 方法请求注销:</p>
</div>
<div class="exampleblock">
<div class="title">Example 137. Log out with HTTP GET</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
        WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) {
        http
            .logout(logout -&gt; logout
                .logoutRequestMatcher(new AntPathRequestMatcher("/logout"))
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            logout {
                logoutRequestMatcher = AntPathRequestMatcher("/logout")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-considerations-csrf-timeouts"><a class="anchor" href="#servlet-considerations-csrf-timeouts"></a>CSRF 和 Session 超时</h5>
<div class="paragraph">
<p>默认情况下,Spring Security 将 CSRF 令牌存储在 <code>HttpSession</code> 中.  这可能会导致会话到期的情况,这意味着没有期望的 CSRF 令牌进行验证.</p>
</div>
<div class="paragraph">
<p>我们已经讨论了会话超时的<a href="#csrf-considerations-login">一般解决方案</a> .  本节讨论与 Servlet 支持有关的 CSRF 超时的细节.</p>
</div>
<div class="paragraph">
<p>更改期望的  CSRF 令牌在 cookie 中的存储很简单.  有关详细信息,请参阅  <a href="#servlet-csrf-configure-custom-repository">自定义 CsrfTokenRepository</a>部分.</p>
</div>
<div class="paragraph">
<p>如果令牌确实过期,则可能需要通过指定自定义 <code>AccessDeniedHandler</code> 来定制令牌的处理方式.  自定义 <code>AccessDeniedHandler</code> 可以按照您喜欢的任何方式处理 <code>InvalidCsrfTokenException</code>.  有关如何自定义 <code>AccessDeniedHandler</code> 的示例,请参阅所提供的<a href="#nsa-access-denied-handler">xml</a>和 <a href="https://github.com/spring-projects/spring-security/blob/3.2.0.RC1/config/src/test/java/org/springframework/security/config/annotation/web/configurers/NamespaceHttpAccessDeniedHandlerTests.java#L64">Java configuration</a> 链接.</p>
</div>
</div>
<div class="sect4">
<h5 id="servlet-csrf-considerations-multipart"><a class="anchor" href="#servlet-csrf-considerations-multipart"></a>Multipart (文件上传)</h5>
<div class="paragraph">
<p>我们 <a href="#csrf-considerations-multipart">已经讨论</a> 了如何保护分段请求(文件上传) 免受 CSRF 攻击如何导致 <a href="https://en.wikipedia.org/wiki/Chicken_or_the_egg">鸡和蛋的问题</a> . 本节讨论如何实现将 CSRF 令牌放置在 Servlet 应用程序的 <a href="#servlet-csrf-considerations-multipart-body">body</a>和<a href="#servlet-csrf-considerations-multipart-url">url</a> 中.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有关在 Spring 中使用多部分表单的更多信息,请参见 <a href="https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-multipart">1.1.11. Multipart Resolver</a>和 <a href="https://docs.spring.io/spring/docs/5.2.x/javadoc-api/org/springframework/web/multipart/support/MultipartFilter.html">MultipartFilter javadoc</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="servlet-csrf-considerations-multipart-body"><a class="anchor" href="#servlet-csrf-considerations-multipart-body"></a>将 CSRF 令牌放入 body</h6>
<div class="paragraph">
<p>我们<a href="#csrf-considerations-multipart-body">已经讨论</a> 了将 CSRF 令牌放入正文的权衡. 在本节中,我们将讨论如何配置Spring Security 从主体读取 CSRF.</p>
</div>
<div class="paragraph">
<p>为了从主体读取 CSRF 令牌,在 Spring Security 过滤器之前指定 <code>MultipartFilter</code>.  在 Spring Security 过滤器之前指定 <code>MultipartFilter</code> 意味着没有授权可以调用 <code>MultipartFilter</code>,这意味着任何人都可以在您的服务器上放置临时文件.
但是,只有授权用户才能提交由您的应用程序处理的文件.  通常,这是推荐的方法,因为临时文件上传对大多数服务器的影响应该忽略不计.</p>
</div>
<div class="paragraph">
<p>为了确保在使用 Java 配置的 Spring Security 过滤器之前指定了 <code>MultipartFilter</code>,用户可以如下所示覆盖 <code>beforeSpringSecurityFilterChain</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 138. Initializer MultipartFilter</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class SecurityApplicationInitializer extends AbstractSecurityWebApplicationInitializer {

    @Override
    protected void beforeSpringSecurityFilterChain(ServletContext servletContext) {
        insertFilters(servletContext, new MultipartFilter());
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class SecurityApplicationInitializer : AbstractSecurityWebApplicationInitializer() {
    override fun beforeSpringSecurityFilterChain(servletContext: ServletContext?) {
        insertFilters(servletContext, MultipartFilter())
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了确保在具有 XML 配置的 Spring Security 过滤器之前指定 <code>MultipartFilter</code>,用户可以确保将 <code>MultipartFilter</code> 的 <code>&lt;filter-mapping&gt;</code> 元素放在 <code>web.xml</code> 中的 <code>springSecurityFilterChain</code> 之前,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 139. web.xml - MultipartFilter</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;filter&gt;
    &lt;filter-name&gt;MultipartFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.multipart.support.MultipartFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter&gt;
    &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;MultipartFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="servlet-csrf-considerations-multipart-url"><a class="anchor" href="#servlet-csrf-considerations-multipart-url"></a>将 CSRF Token 放在 URL 中</h6>
<div class="paragraph">
<p>如果不允许未经授权的用户上传临时文件,则可以选择将 <code>MultipartFilter</code> 放在 Spring Security 过滤器之后,并将 CSRF 作为查询参数包括在表单的 <code>action</code> 属性中.  由于 <code>CsrfToken</code> 是作为 <code>HttpServletRequest</code> <a href="#servlet-csrf-include">请求属性</a> 暴露的,因此我们可以使用它来创建带有 CSRF 令牌的操作.  带有 jsp 的示例如下所示</p>
</div>
<div class="exampleblock">
<div class="title">Example 140. CSRF Token in Action</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form method="post"
    action="./upload?${_csrf.parameterName}=${_csrf.token}"
    enctype="multipart/form-data"&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-csrf-considerations-override-method"><a class="anchor" href="#servlet-csrf-considerations-override-method"></a>HiddenHttpMethodFilter</h5>
<div class="paragraph">
<p>我们 <a href="#csrf-considerations-multipart-body">已经讨论</a> 了将 CSRF 令牌放入正文中的取舍.</p>
</div>
<div class="paragraph">
<p>在 Spring 的 Servlet 支持中,使用 <a href="https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html">HiddenHttpMethodFilter</a> 覆盖 HTTP 方法. 有关更多信息,请参见参考文档的 <a href="https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web.html#mvc-rest-method-conversion">HTTP Method Conversion</a>  部分.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-headers"><a class="anchor" href="#servlet-headers"></a>14.2. 安全HTTP响应头</h3>
<div class="paragraph">
<p><a href="#headers">Security HTTP Response Headers</a>可用于提高Web应用程序的安全性.  本节专门针对基于Servlet的安全HTTP响应头提供支持.</p>
</div>
<div class="sect3">
<h4 id="servlet-headers-default"><a class="anchor" href="#servlet-headers-default"></a>14.2.1. 默认安全请求头</h4>
<div class="paragraph">
<p>Spring Security 提供了一组默认的  <a href="#headers-default">default set of Security HTTP Response Headers</a>  ,以提供安全的默认值.  虽然这些 header 中的每一个均被视为最佳实践,但应注意,并非所有客户端都使用这些 header ,因此鼓励进行额外的测试.</p>
</div>
<div class="paragraph">
<p>您可以自定义特定的标题.  例如,假设您希望使用默认值,但您希望为 <a href="#servlet-headers-frame-options">X-Frame-Options</a> 指定 <code>SAMEORIGIN</code>.</p>
</div>
<div class="paragraph">
<p>您可以使用以下配置轻松完成此操作:</p>
</div>
<div class="exampleblock">
<div class="title">Example 141. Customize Default Security Headers</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
        WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) {
        http
            // ...
            .headers(headers -&gt; headers
                .frameOptions(frameOptions -&gt; frameOptions
                    .sameOrigin()
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN" /&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                frameOptions {
                    sameOrigin = true
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您不想添加默认值,并且希望对应使用的内容进行明确控制,则可以禁用默认值.  下面提供了配置示例:</p>
</div>
<div class="paragraph">
<p>如果您使用的是 Spring Security 的配置,则以下内容只会添加<a href="#headers-cache-control">Cache Control</a>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 142. Customize Cache Control Headers</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                // do not use any default headers unless explicitly listed
                .defaultsDisabled()
                .cacheControl(withDefaults())
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers defaults-disabled="true"&gt;
        &lt;cache-control/&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                // do not use any default headers unless explicitly listed
                defaultsDisabled = true
                cacheControl {
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如有必要， 可以使用以下配置禁用所有 HTTP 安全响应头:</p>
</div>
<div class="exampleblock">
<div class="title">Example 143. Disable All HTTP Security Headers</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers.disable());
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers disabled="true" /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                disable()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-cache-control"><a class="anchor" href="#servlet-headers-cache-control"></a>14.2.2. 缓存控制</h4>
<div class="paragraph">
<p>Spring Security 默认包含 <a href="#headers-cache-control">Cache Control</a>  header .</p>
</div>
<div class="paragraph">
<p>但是,如果您实际上想缓存特定的响应,则您的应用程序可以有选择地调用 <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String,java.lang.String)">HttpServletResponse.setHeader(String,String)</a>  来覆盖 Spring Security 设置的 header .  这对于确保正确缓存 CSS,JavaScript 和图片之类的内容很有用.</p>
</div>
<div class="paragraph">
<p>使用Spring Web MVC时,通常在您的配置中完成.  有关如何执行此操作的详细信息,请参见 Spring 参考文档的  <a href="https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources">静态资源</a> 部分.</p>
</div>
<div class="paragraph">
<p>如有必要,您还可以禁用Spring Security的缓存控制HTTP响应头.</p>
</div>
<div class="exampleblock">
<div class="title">Example 144. Cache Control Disabled</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) {
        http
            // ...
            .headers(headers -&gt; headers
                .cacheControl(cache -&gt; cache.disable())
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;cache-control disabled="true"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            headers {
                cacheControl {
                    disable()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-content-type-options"><a class="anchor" href="#servlet-headers-content-type-options"></a>14.2.3. Content Type 选项</h4>
<div class="paragraph">
<p>Spring Security  默认包含  <a href="#headers-content-type-options">Content-Type</a> 头.  但是,您可以使用以下命令在配置中将其禁用:</p>
</div>
<div class="exampleblock">
<div class="title">Example 145. Content Type Options Disabled</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
        WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) {
        http
            // ...
            .headers(headers -&gt; headers
                .contentTypeOptions(contentTypeOptions -&gt; contentTypeOptions.disable())
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;content-type-options disabled="true"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
       http {
            headers {
                contentTypeOptions {
                    disable()
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-hsts"><a class="anchor" href="#servlet-headers-hsts"></a>14.2.4. HTTP Strict Transport Security (HSTS)</h4>
<div class="paragraph">
<p>Spring Security 默认提供严格传输安全 header .  但是,您可以显式自定义结果.  例如,以下是为 HSTS 显式提供配置的示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 146. Strict Transport Security</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                .httpStrictTransportSecurity(hsts -&gt; hsts
                    .includeSubDomains(true)
                    .preload(true)
                    .maxAgeInSeconds(31536000)
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;hsts
            include-subdomains="true"
            max-age-seconds="31536000"
            preload="true" /&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            headers {
                httpStrictTransportSecurity {
                    includeSubDomains = true
                    preload = true
                    maxAgeInSeconds = 31536000
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-hpkp"><a class="anchor" href="#servlet-headers-hpkp"></a>14.2.5. HTTP Public Key Pinning (HPKP)</h4>
<div class="paragraph">
<p>出于被动性原因,Spring Security 为 <a href="#headers-hpkp">HTTP Public Key Pinning</a>  提供了 servlet 支持, <a href="#headers-hpkp-deprecated">但不再推荐使用</a>.</p>
</div>
<div class="paragraph">
<p>您可以使用配置启用 HPKP  header :</p>
</div>
<div class="exampleblock">
<div class="title">Example 147. HTTP Public Key Pinning</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                .httpPublicKeyPinning(hpkp -&gt; hpkp
                    .includeSubDomains(true)
                    .reportUri("https://example.net/pkp-report")
                    .addSha256Pins("d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=", "E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=")
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;hpkp
            include-subdomains="true"
            report-uri="https://example.net/pkp-report"&gt;
            &lt;pins&gt;
                &lt;pin algorithm="sha256"&gt;d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=&lt;/pin&gt;
                &lt;pin algorithm="sha256"&gt;E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=&lt;/pin&gt;
            &lt;/pins&gt;
        &lt;/hpkp&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            headers {
                httpPublicKeyPinning {
                    includeSubDomains = true
                    reportUri = "https://example.net/pkp-report"
                    pins = mapOf("d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=" to "sha256",
                            "E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=" to "sha256")
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-frame-options"><a class="anchor" href="#servlet-headers-frame-options"></a>14.2.6. X-Frame-Options</h4>
<div class="paragraph">
<p>默认情况下,Spring Security 使用  <a href="#headers-frame-options">X-Frame-Options</a> 禁用 iframe  中的渲染.</p>
</div>
<div class="paragraph">
<p>您可以使用以下方法自定义框架选项以在配置中使用相同的 origin:</p>
</div>
<div class="exampleblock">
<div class="title">Example 148. X-Frame-Options: SAMEORIGIN</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                .frameOptions(frameOptions -&gt; frameOptions
                    .sameOrigin()
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;frame-options
        policy="SAMEORIGIN" /&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            headers {
                frameOptions {
                    sameOrigin = true
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-xss-protection"><a class="anchor" href="#servlet-headers-xss-protection"></a>14.2.7. X-XSS-Protection</h4>
<div class="paragraph">
<p>默认情况下,Spring Security 指示浏览器使用 &lt;&lt;headers-xss-protection,X-XSS-Protection header&gt; 阻止反射的 XSS 攻击.
但是,您可以更改此默认值.  例如,以下配置指定 Spring Security 不再指示浏览器阻止内容:</p>
</div>
<div class="exampleblock">
<div class="title">Example 149. X-XSS-Protection Customization</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                .xssProtection(xss -&gt; xss
                    .block(false)
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;xss-protection block="false"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        // ...
        http {
            headers {
                xssProtection {
                    block = false
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-csp"><a class="anchor" href="#servlet-headers-csp"></a>14.2.8. Content Security Policy (CSP)</h4>
<div class="paragraph">
<p>Spring Security 默认情况下不会添加  <a href="#headers-csp">Content Security Policy</a>,因为没有应用程序的上下文就无法知道合理的默认值.  Web 应用程序作者必须声明安全策略以强制执行和/或监视受保护的资源.</p>
</div>
<div class="paragraph">
<p>例如,给定以下安全策略:</p>
</div>
<div class="exampleblock">
<div class="title">Example 150. Content Security Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-http" data-lang="http">Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用以下配置启用 CSP  header ,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 151. Content Security Policy</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) {
        http
            // ...
            .headers(headers -&gt; headers
                .contentSecurityPolicy(csp -&gt; csp
                    .policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;content-security-policy
            policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/" /&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                contentSecurityPolicy {
                    policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要启用 CSP <code>report-only</code> header， 请提供以下配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 152. Content Security Policy Report Only</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
        WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                .contentSecurityPolicy(csp -&gt; csp
                    .policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
                    .reportOnly()
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;content-security-policy
            policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
            report-only="true" /&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                contentSecurityPolicy {
                    policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
                    reportOnly = true
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-referrer"><a class="anchor" href="#servlet-headers-referrer"></a>14.2.9. 推荐人策略</h4>
<div class="paragraph">
<p>Spring Security 默认情况下不添加  <a href="#headers-referrer">Referrer Policy</a>  header .  您可以使用以下配置启用Referrer Policy  header ,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 153. Referrer Policy</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) {
        http
            // ...
            .headers(headers -&gt; headers
                .referrerPolicy(referrer -&gt; referrer
                    .policy(ReferrerPolicy.SAME_ORIGIN)
                )
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;referrer-policy policy="same-origin" /&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                referrerPolicy {
                    policy = ReferrerPolicy.SAME_ORIGIN
                }
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-feature"><a class="anchor" href="#servlet-headers-feature"></a>14.2.10. Feature Policy (功能策略)</h4>
<div class="paragraph">
<p>Spring Security 默认不添加  <a href="#headers-feature">Feature Policy</a>  头.  以下  <code>Feature-Policy</code>  头:</p>
</div>
<div class="exampleblock">
<div class="title">Example 154. Feature-Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Feature-Policy: geolocation 'self'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以使用以下配置启用 Feature-Policy 头,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 155. Feature-Policy</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                .featurePolicy("geolocation 'self'")
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;feature-policy policy-directives="geolocation 'self'" /&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                featurePolicy("geolocation 'self'")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-clear-site-data"><a class="anchor" href="#servlet-headers-clear-site-data"></a>14.2.11. 清除站点数据</h4>
<div class="paragraph">
<p>Spring Security 默认情况下不添加<a href="#headers-clear-site-data">Clear-Site-Data</a>   header .  以下 Clear-Site-Data header :</p>
</div>
<div class="exampleblock">
<div class="title">Example 156. Clear-Site-Data Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Clear-Site-Data: "cache", "cookies"</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以使用以下配置在注销时发送:</p>
</div>
<div class="exampleblock">
<div class="title">Example 157. Clear-Site-Data</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .logout()
                .addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(CACHE, COOKIES)));
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            logout {
                addLogoutHandler(HeaderWriterLogoutHandler(ClearSiteDataHeaderWriter(CACHE, COOKIES)))
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-headers-custom"><a class="anchor" href="#servlet-headers-custom"></a>14.2.12. 自定义 Headers</h4>
<div class="paragraph">
<p>Spring Security 具有使您可以方便地将更常见的安全 header 添加到您的应用程序的机制. 但是,它也提供了挂钩来启用添加自定义 header .</p>
</div>
<div class="sect4">
<h5 id="servlet-headers-static"><a class="anchor" href="#servlet-headers-static"></a>Static Headers</h5>
<div class="paragraph">
<p>有时您可能希望将不支持的自定义安全 header 注入应用程序中. 例如,给定以下自定义安全 header :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>X-Custom-Security-Header: header-value</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用以下配置将 header 添加到响应中,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 158. StaticHeadersWriter</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                .addHeaderWriter(new StaticHeadersWriter("X-Custom-Security-Header","header-value"))
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;header name="X-Custom-Security-Header" value="header-value"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                addHeaderWriter(StaticHeadersWriter("X-Custom-Security-Header","header-value"))
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servlet-headers-writer"><a class="anchor" href="#servlet-headers-writer"></a>Headers Writer</h5>
<div class="paragraph">
<p>如果命名空间或 Java 配置不支持所需的 header ,则可以创建自定义的 <code>HeadersWriter</code> 实例,甚至提供 <code>HeadersWriter</code> 的自定义实现.</p>
</div>
<div class="paragraph">
<p>让我们看一个使用 <code>XFrameOptionsHeaderWriter</code> 的自定义实例的示例.  也许您希望允许对相同来源的内容进行框架化.
如果要显式配置 <code>X-Frame-Options</code>,可以使用以下配置来完成:</p>
</div>
<div class="exampleblock">
<div class="title">Example 159. Headers Writer</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                .addHeaderWriter(new XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN))
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;header ref="frameOptionsWriter"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;
&lt;!-- Requires the c-namespace.
See https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-c-namespace
--&gt;
&lt;beans:bean id="frameOptionsWriter"
    class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"
    c:frameOptionsMode="SAMEORIGIN"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            headers {
                addHeaderWriter(XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN))
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="headers-delegatingrequestmatcherheaderwriter"><a class="anchor" href="#headers-delegatingrequestmatcherheaderwriter"></a>DelegatingRequestMatcherHeaderWriter</h5>
<div class="paragraph">
<p>有时您可能只想为某些请求编写 header .  例如,也许您只想保护登录页面免于陷害.  您可以使用 <code>DelegatingRequestMatcherHeaderWriter</code> 来实现.  使用 Java 配置时,可以使用以下方法完成:</p>
</div>
<div class="exampleblock">
<div class="title">Example 160. DelegatingRequestMatcherHeaderWriter Java Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        RequestMatcher matcher = new AntPathRequestMatcher("/login");
        DelegatingRequestMatcherHeaderWriter headerWriter =
            new DelegatingRequestMatcherHeaderWriter(matcher,new XFrameOptionsHeaderWriter());
        http
            // ...
            .headers(headers -&gt; headers
                .frameOptions(frameOptions -&gt; frameOptions.disable())
                .addHeaderWriter(headerWriter)
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;frame-options disabled="true"/&gt;
        &lt;header ref="headerWriter"/&gt;
    &lt;/headers&gt;
&lt;/http&gt;

&lt;beans:bean id="headerWriter"
    class="org.springframework.security.web.header.writers.DelegatingRequestMatcherHeaderWriter"&gt;
    &lt;beans:constructor-arg&gt;
        &lt;bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher"
            c:pattern="/login"/&gt;
    &lt;/beans:constructor-arg&gt;
    &lt;beans:constructor-arg&gt;
        &lt;beans:bean
            class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"/&gt;
    &lt;/beans:constructor-arg&gt;
&lt;/beans:bean&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        val matcher: RequestMatcher = AntPathRequestMatcher("/login")
        val headerWriter = DelegatingRequestMatcherHeaderWriter(matcher, XFrameOptionsHeaderWriter())
       http {
            headers {
                frameOptions {
                    disable()
                }
                addHeaderWriter(headerWriter)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-http"><a class="anchor" href="#servlet-http"></a>14.3. HTTP</h3>
<div class="paragraph">
<p>所有基于 HTTP 的通信都应使用 <a href="#http">使用 TLS</a> 保护.</p>
</div>
<div class="paragraph">
<p>您可以在下面找到有关协助 HTTPS 使用的 Servlet 特定功能的详细信息.</p>
</div>
<div class="sect3">
<h4 id="servlet-http-redirect"><a class="anchor" href="#servlet-http-redirect"></a>14.3.1. 重定向 HTTPS</h4>
<div class="paragraph">
<p>如果客户端使用 HTTP 而不是 HTTPS 发出请求,则可以将 Spring Security 配置为重定向到 HTTPS.</p>
</div>
<div class="paragraph">
<p>例如,以下 Java 配置会将所有 HTTP 请求重定向到 HTTPS:</p>
</div>
<div class="exampleblock">
<div class="title">Example 161. Redirect to HTTPS</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
        WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) {
        http
            // ...
            .requiresChannel(channel -&gt; channel
                .anyRequest().requiresSecure()
            );
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebSecurity
class SecurityConfig : WebSecurityConfigurerAdapter() {

    override fun configure(http: HttpSecurity) {
        http {
            // ...
            requiresChannel {
                secure(AnyRequestMatcher.INSTANCE, "REQUIRES_SECURE_CHANNEL")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以下 XML 配置会将所有 HTTP 请求重定向到 HTTPS</p>
</div>
<div class="exampleblock">
<div class="title">Example 162. Redirect to HTTPS with XML Configuration</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-url pattern="/**" access="ROLE_USER" requires-channel="https"/&gt;
...
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servlet-hsts"><a class="anchor" href="#servlet-hsts"></a>14.3.2. 严格的安全传输</h4>
<div class="paragraph">
<p>Spring Security 提供对严格传输安全的支持,并默认启用它.</p>
</div>
</div>
<div class="sect3">
<h4 id="servlet-http-proxy-server"><a class="anchor" href="#servlet-http-proxy-server"></a>14.3.3. 代理服务器配置</h4>
<div class="paragraph">
<p>Spring Security与 <a href="#http-proxy-server">代理服务器集成</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="servlet-httpfirewall"><a class="anchor" href="#servlet-httpfirewall"></a>14.4. HttpFirewall</h3>
<div class="paragraph">
<p>Spring Security 在多个区域中针对传入的请求对您定义的模式进行测试,以便确定应如何处理请求.  当 <code>FilterChainProxy</code> 决定请求应通过哪个过滤器链,以及 <code>FilterSecurityInterceptor</code> 决定将哪些安全性约束应用于请求时,会发生这种情况.
 根据定义的模式进行测试时,重要的是要了解该机制是什么以及使用了哪个 <code>URL</code> 值.</p>
</div>
<div class="paragraph">
<p>Servlet 规范为 <code>HttpServletRequest</code> 定义了一些属性,可以通过 <code>getter</code> 方法访问这些属性,我们可能希望将这些属性匹配. 这些是 <code>contextPath</code>,<code>servletPath</code>,<code>pathInfo</code> 和 <code>queryString</code>.  Spring Security 只对保护应用程序中的路径感兴趣,因此 <code>contextPath</code> 被忽略.
不幸的是,servlet 规范没有确切定义特定请求 <code>URI</code> 的 <code>ServletPath</code> 和 <code>pathInfo</code> 的值. 例如,URL 的每个路径段都可以包含 <a href="https://www.ietf.org/rfc/rfc2396.txt">RFC 2396</a> <sup class="footnote">[<a id="_footnoteref_6" class="footnote" href="#_footnotedef_6" title="View footnote.">6</a>]</sup>  中定义的参数. 规范没有明确说明是否应将这些参数包含在 <code>servletPath</code> 和 <code>pathInfo</code> 值中,并且行为在不同的 servlet 容器之间有所不同.
存在以下危险: 当将应用程序部署在不从这些值中剥离路径参数的容器中时,攻击者可能会将其添加到请求的 URL 中,从而导致模式匹配意外成功或失败. <sup class="footnote">[<a id="_footnoteref_7" class="footnote" href="#_footnotedef_7" title="View footnote.">7</a>]</sup>. 传入 URL 中的其他变体也是可能的.
例如,它可能包含路径遍历序列(例如  <code>/../</code>) 或多个正斜杠(<code>//</code>) ,这也可能导致模式匹配失败. 一些容器在执行 servlet 映射之前将它们标准化,但其他容器则没有. 为了避免此类问题,<code>FilterChainProxy</code> 使用 <code>HttpFirewall</code> 策略检查并包装请求.
默认情况下,未规范化的请求将自动被拒绝,并且出于匹配目的,将删除路径参数和重复的斜杠.  <sup class="footnote">[<a id="_footnoteref_8" class="footnote" href="#_footnotedef_8" title="View footnote.">8</a>]</sup>.
因此,必须使用 <code>FilterChainProxy</code> 来管理安全过滤器链. 请注意,<code>servletPath</code> 和 <code>pathInfo</code> 值由容器解码,因此您的应用程序不应具有任何包含分号的有效路径,因为将出于匹配目的而删除这些部分.</p>
</div>
<div class="paragraph">
<p>如上所述,默认策略是使用 Ant 样式的路径进行匹配,这对于大多数用户而言可能是最佳选择.  该策略在 <code>AntPathRequestMatcher</code> 类中实现,该类使用 Spring 的 <code>AntPathMatcher</code> 对连接的 <code>ServletPath</code> 和 <code>pathInfo</code> 进行模式的不区分大小写的匹配,而忽略了 <code>queryString</code>.</p>
</div>
<div class="paragraph">
<p>如果由于某种原因需要更强大的匹配策略,则可以使用正则表达式.  然后,该策略实现是 <code>RegexRequestMatcher</code>.  有关更多信息,请参见 Javadoc.</p>
</div>
<div class="paragraph">
<p>实际上,我们建议您在服务层使用方法安全性来控制对应用程序的访问,并且不要完全依赖于在 Web 应用程序级别定义的安全性约束的使用.  URL 会发生变化,很难考虑应用程序可能支持的所有可能的 URL 以及如何处理请求.
 您应该尝试限制自己使用一些简单易懂的简单蚂蚁路径.  始终尝试使用 "deny-by-default" 方法,在此方法中,您最后定义了一个全包通配符(/<strong> 或 </strong>) ,并拒绝访问.</p>
</div>
<div class="paragraph">
<p>在服务层定义的安全性更加健壮,更难绕开,因此您应始终利用 Spring Security 的方法安全性选项.</p>
</div>
<div class="paragraph">
<p><code>HttpFirewall</code> 还通过拒绝HTTP响应头中的换行符来防止 <a href="https://www.owasp.org/index.php/HTTP_Response_Splitting">HTTP Response Splitting</a> .</p>
</div>
<div class="paragraph">
<p>默认情况下,使用 <code>StrictHttpFirewall</code>.  此实现拒绝看起来是恶意的请求.  如果对您的要求过于严格,则可以自定义拒绝哪些类型的请求.  但是,重要的是要知道这样做可以使您的应用程序容易受到攻击.  例如,如果您希望利用 Spring MVC 的矩阵变量,则可以使用以下配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 163. 允许矩阵变量</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowSemicolon(true);
    return firewall;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;b:bean id="httpFirewall"
    class="org.springframework.security.web.firewall.StrictHttpFirewall"
    p:allowSemicolon="true"/&gt;

&lt;http-firewall ref="httpFirewall"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowSemicolon(true)
    return firewall
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>StrictHttpFirewall</code> 提供允许的有效 HTTP 方法的列表,这些方法可防止 <a href="https://www.owasp.org/index.php/Cross_Site_Tracing">跨站点跟踪(XST) </a> 和 <a href="https://www.owasp.org/index.php/Test_HTTP_Methods_(OTG-CONFIG-006)">HTTP 动词篡改</a>.
默认的有效方法是  "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", 和 "PUT"..  如果您的应用程序需要修改有效方法,则可以配置自定义 <code>StrictHttpFirewall</code> bean.  例如,以下内容仅允许 HTTP "GET" 和 "POST" 方法:</p>
</div>
<div class="exampleblock">
<div class="title">Example 164. 只允许 GET &amp; POST</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowedHttpMethods(Arrays.asList("GET", "POST"));
    return firewall;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">XML</div>
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;b:bean id="httpFirewall"
      class="org.springframework.security.web.firewall.StrictHttpFirewall"
      p:allowedHttpMethods="GET,HEAD"/&gt;

&lt;http-firewall ref="httpFirewall"/&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowedHttpMethods(listOf("GET", "POST"))
    return firewall
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您正在  <code>new MockHttpServletRequest()</code>,则当前会创建一个 HTTP 方法作为空字符串  "".  这是无效的 HTTP 方法,将被Spring Security 拒绝.  您可以通过将其替换为  <code>new MockHttpServletRequest("GET", "")</code> 来解决此问题.  有关要求改善此问题的问题,请参见 <a href="https://jira.spring.io/browse/SPR-16851">SPR_16851</a> .</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果必须允许任何 HTTP 方法(不推荐) ,则可以使用 <code>StrictHttpFirewall.setUnsafeAllowAnyHttpMethod(true)</code>.  这将完全禁用 HTTP 方法的验证.</p>
</div>
<div id="servlet-httpfirewall-headers-parameters" class="paragraph">
<p><code>StrictHttpFirewall</code> 还检查 header 的 name 和 value. 它要求每个字符都有一个定义的代码点， 而不是控制字符.</p>
</div>
<div class="paragraph">
<p>如有需要， 可通过以下方法放宽或调整这一要求:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>StrictHttpFirewall#setAllowedHeaderNames(Predicate)</code></p>
</li>
<li>
<p><code>StrictHttpFirewall#setAllowedHeaderValues(Predicate)</code></p>
</li>
<li>
<p><code>StrictHttpFirewall#setAllowedParameterNames(Predicate)</code></p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
另外， 可以使用 <code>setAllowedParameterValues(Predicate)</code> 控制参数值.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>例如， 要关闭此检查， 可以将 <code>StrictHttpFirewall</code> 与始终返回 <code>true</code> 的 <code>Predicate</code> 关联起来:</p>
</div>
<div class="exampleblock">
<div class="title">Example 165. Allow Any Header Name, Header Value, and Parameter Name</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    firewall.setAllowedHeaderNames((header) -&gt; true);
    firewall.setAllowedHeaderValues((header) -&gt; true);
    firewall.setAllowedParameterNames((parameter) -&gt; true);
    return firewall;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    firewall.setAllowedHeaderNames { true }
    firewall.setAllowedHeaderValues { true }
    firewall.setAllowedParameterNames { true }
    return firewall
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者， 可能存在允许的特定值.</p>
</div>
<div class="paragraph">
<p>例如， iPhone Xʀ 使用包含不在 ISO-8859-1 Charset 中的字符的 <code>User-Agent</code>.  由于此事实， 某些应用程序服务器将此值解析为两个单独的字符， 后者是一个未定义的字符.</p>
</div>
<div class="paragraph">
<p>您可以使用 <code>setAllowedHeaderValues</code> 方法解决此问题， 如您所见:</p>
</div>
<div class="exampleblock">
<div class="title">Example 166. Allow Certain User Agents</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public StrictHttpFirewall httpFirewall() {
    StrictHttpFirewall firewall = new StrictHttpFirewall();
    Pattern allowed = Pattern.compile("[\\p{IsAssigned}&amp;&amp;[^\\p{IsControl}]]*");
    Pattern userAgent = ...;
    firewall.setAllowedHeaderValues((header) -&gt; allowed.matcher(header).matches() || userAgent.matcher(header).matches());
    return firewall;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun httpFirewall(): StrictHttpFirewall {
    val firewall = StrictHttpFirewall()
    val allowed = Pattern.compile("[\\p{IsAssigned}&amp;&amp;[^\\p{IsControl}]]*")
    val userAgent = Pattern.compile(...)
    firewall.setAllowedHeaderValues { allowed.matcher(it).matches() || userAgent.matcher(it).matches() }
    return firewall
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>对于 header 的 value， 您可以考虑在验证时将其解析为 UTF-8， 如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 167. Parse Headers As UTF-8</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">firewall.setAllowedHeaderValues((header) -&gt; {
    String parsed = new String(header.getBytes(ISO_8859_1), UTF_8);
    return allowed.matcher(parsed).matches();
});
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">firewall.setAllowedHeaderValues {
    val parsed = String(header.getBytes(ISO_8859_1), UTF_8)
    return allowed.matcher(parsed).matches()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="集成"><a class="anchor" href="#集成"></a>15. 集成</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="servletapi"><a class="anchor" href="#servletapi"></a>15.1. Servlet API 整合</h3>
<div class="paragraph">
<p>本节描述了如何将 Spring Security 与 Servlet API 集成在一起.   <a href="https://github.com/spring-projects/spring-security/tree/master/samples/xml/servletapi">servletapi-xml</a> 示例应用程序演示了每种方法的用法.</p>
</div>
<div class="sect3">
<h4 id="servletapi-25"><a class="anchor" href="#servletapi-25"></a>15.1.1. Servlet 2.5+ 整合</h4>
<div class="sect4">
<h5 id="servletapi-remote-user"><a class="anchor" href="#servletapi-remote-user"></a>HttpServletRequest.getRemoteUser()</h5>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()">HttpServletRequest.getRemoteUser()</a> 将返回 <code>SecurityContextHolder.getContext().getAuthentication().getName()</code>  的结果,该结果通常是当前用户名.  如果要在应用程序中显示当前用户名,这将很有用.
此外,检查此属性是否为 <code>null</code> 可以用来指示用户已通过身份验证还是匿名.  知道用户是否通过身份验证对于确定是否应显示某些 UI 元素很有用(即,仅在用户通过身份验证时才显示注销链接) .</p>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-user-principal"><a class="anchor" href="#servletapi-user-principal"></a>HttpServletRequest.getUserPrincipal()</h5>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()">HttpServletRequest.getUserPrincipal()</a> 将返回 <code>SecurityContextHolder.getContext().getAuthentication()</code> 的结果.  这意味着它是一种身份验证,当使用基于用户名和密码的身份验证时,通常是 <code>UsernamePasswordAuthenticationToken</code> 的实例.
如果您需要有关用户的其他信息,这将很有用.  例如,您可能创建了一个自定义 <code>UserDetailsService</code>,该服务返回一个包含用户名和姓氏的自定义 <code>UserDetails</code>.  您可以通过以下方式获取此信息:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Authentication auth = httpServletRequest.getUserPrincipal();
// assume integrated custom UserDetails called MyCustomUserDetails
// by default, typically instance of UserDetails
MyCustomUserDetails userDetails = (MyCustomUserDetails) auth.getPrincipal();
String firstName = userDetails.getFirstName();
String lastName = userDetails.getLastName();
</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>应当指出,在整个应用程序中执行如此多的逻辑通常是一种不好的做法. 相反,应该将其集中化以减少 Spring Security 和 Servlet API 的耦合.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-user-in-role"><a class="anchor" href="#servletapi-user-in-role"></a>HttpServletRequest.isUserInRole(String)</h5>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)">HttpServletRequest.isUserInRole(String)</a> 将确定 <code>SecurityContextHolder.getContext().getAuthentication().getAuthorities()</code> 是否包含 <code>GrantedAuthority</code>,并将角色传递给 <code>isUserInRole(String)</code>.
通常,用户不应将 "ROLE_" 前缀传递给此方法,因为它是自动添加的.  例如,如果要确定当前用户是否具有权限 "ROLE_ADMIN",则可以使用以下命令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">boolean isAdmin = httpServletRequest.isUserInRole("ADMIN");
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这对于确定是否应显示某些 UI 组件可能很有用. 例如,仅当当前用户是管理员时,才可以显示管理员链接.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servletapi-3"><a class="anchor" href="#servletapi-3"></a>15.1.2. Servlet 3+ 整合</h4>
<div class="paragraph">
<p>下面描述了 Spring Security 与 Servlet 3 集成的方法.</p>
</div>
<div class="sect4">
<h5 id="servletapi-authenticate"><a class="anchor" href="#servletapi-authenticate"></a>HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)</h5>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#authenticate%28javax.servlet.http.HttpServletResponse%29">HttpServletRequest.authenticate(HttpServletRequest,HttpServletResponse)</a> 方法可用于确保对用户进行身份验证.  如果未通过身份验证,则将使用配置的 AuthenticationEntryPoint 来请求用户进行身份验证(即重定向到登录页面) .</p>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-login"><a class="anchor" href="#servletapi-login"></a>HttpServletRequest.login(String,String)</h5>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login%28java.lang.String,%20java.lang.String%29">HttpServletRequest.login(String,String)</a>  方法可用于使用当前 <code>AuthenticationManager</code> 对用户进行身份验证.  例如,以下尝试使用用户名 "user" 和密码 "password" 进行身份验证:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">try {
httpServletRequest.login("user","password");
} catch(ServletException ex) {
// fail to authenticate
}
</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您希望 Spring Security 处理失败的身份验证尝试,则不必捕获 ServletException.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-logout"><a class="anchor" href="#servletapi-logout"></a>HttpServletRequest.logout()</h5>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout%28%29">HttpServletRequest.logout()</a> 方法可用于注销当前用户.</p>
</div>
<div class="paragraph">
<p>通常,这意味着将清除 <code>SecurityContextHolder</code>,使 <code>HttpSession</code> 无效,将清除所有 "记住我" 身份验证,依此类推. 但是,配置的 <code>LogoutHandler</code> 实现取决于您的 Spring Security 配置.  重要的是要注意,在调用 <code>HttpServletRequest.logout()</code> 之后,您仍然负责写出响应.  通常,这将涉及重定向到欢迎页面.</p>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-start-runnable"><a class="anchor" href="#servletapi-start-runnable"></a>AsyncContext.start(Runnable)</h5>
<div class="paragraph">
<p>确保您的凭据将被传播到新线程的 <a href="https://docs.oracle.com/javaee/6/api/javax/servlet/AsyncContext.html#start%28java.lang.Runnable%29">AsyncContext.start(Runnable)</a>方法.  通过使用 Spring Security 的并发支持,Spring Security 重写 <code>AsyncContext.start(Runnable)</code> 以确保在处理 Runnable 时使用当前的 SecurityContext.  例如,以下代码将输出当前用户的身份验证:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">final AsyncContext async = httpServletRequest.startAsync();
async.start(new Runnable() {
    public void run() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        try {
            final HttpServletResponse asyncResponse = (HttpServletResponse) async.getResponse();
            asyncResponse.setStatus(HttpServletResponse.SC_OK);
            asyncResponse.getWriter().write(String.valueOf(authentication));
            async.complete();
        } catch(Exception ex) {
            throw new RuntimeException(ex);
        }
    }
});
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="servletapi-async"><a class="anchor" href="#servletapi-async"></a>异步 Servlet 支持</h5>
<div class="paragraph">
<p>如果您使用的是基于 Java 的配置,则可以开始使用. 如果使用 XML 配置,则需要进行一些更新. 第一步是确保已更新 <code>web.xml</code>,使其至少使用 3.0 模式,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"
version="3.0"&gt;

&lt;/web-app&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来,您需要确保已设置springSecurityFilterChain来处理异步请求.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;filter-class&gt;
    org.springframework.web.filter.DelegatingFilterProxy
&lt;/filter-class&gt;
&lt;async-supported&gt;true&lt;/async-supported&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
&lt;dispatcher&gt;ASYNC&lt;/dispatcher&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>而已！ 现在,Spring Security 将确保您的 SecurityContext 也可以在异步请求中传播.</p>
</div>
<div class="paragraph">
<p>那么它是怎样工作的? 如果您真的不感兴趣,请随时跳过本节的其余部分,否则请继续阅读.  大部分内容都内置在 Servlet 规范中,但是 Spring Security 做了一些调整,以确保异步请求可以正常工作.
在 Spring Security 3.2 之前,一旦提交 HttpServletResponse,就会自动保存 SecurityContextHolder 中的 SecurityContext.  这可能会在异步环境中引起问题.  例如,考虑以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">httpServletRequest.startAsync();
new Thread("AsyncThread") {
    @Override
    public void run() {
        try {
            // Do work
            TimeUnit.SECONDS.sleep(1);

            // Write to and commit the httpServletResponse
            httpServletResponse.getOutputStream().flush();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
}.start();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>问题是 Spring Security 不知道该线程,因此不会将 SecurityContext 传播给它.  这意味着当我们提交 HttpServletResponse 时,没有 SecurityContext.  当 Spring Security 在提交 HttpServletResponse 时自动保存 SecurityContext 时,它将丢失我们的登录用户.</p>
</div>
<div class="paragraph">
<p>从 3.2 版本开始,Spring Security 足够聪明,不再会在调用 <code>HttpServletRequest.startAsync()</code> 时自动保存 SecurityContext 来提交 HttpServletResponse.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="servletapi-31"><a class="anchor" href="#servletapi-31"></a>15.1.3. Servlet 3.1+ 整合</h4>
<div class="paragraph">
<p>下面描述了与 Spring Security 和 Servlet 3.1 集成的方法.</p>
</div>
<div class="sect4">
<h5 id="servletapi-change-session-id"><a class="anchor" href="#servletapi-change-session-id"></a>HttpServletRequest#changeSessionId()</h5>
<div class="paragraph">
<p><a href="https://docs.oracle.com/javaee/7/api/javax/servlet/http/HttpServletRequest.html#changeSessionId()">HttpServletRequest.changeSessionId()</a> 是防止 Servlet 3.1 及更高版本中的 <a href="#ns-session-fixation">Session Fixation</a> 攻击的默认方法.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="data"><a class="anchor" href="#data"></a>15.2. Spring Data 集成</h3>
<div class="paragraph">
<p>Spring Security 提供了 Spring Data 集成,允许在查询中引用当前用户.  将用户包括在查询中以支持分页结果不仅有用,而且有必要,因为事后过滤结果将无法扩展.</p>
</div>
<div class="sect3">
<h4 id="data-configuration"><a class="anchor" href="#data-configuration"></a>15.2.1. Spring Data &amp; Spring Security 配置</h4>
<div class="paragraph">
<p>要使用此支持,请添加 <code>org.springframework.security:spring-security-data</code> 依赖性并提供类型为 <code>SecurityEvaluationContextExtension</code> 的bean. 在Java配置中,这看起来像:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public SecurityEvaluationContextExtension securityEvaluationContextExtension() {
    return new SecurityEvaluationContextExtension();
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在XML配置中,这看起来像:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean class="org.springframework.security.data.repository.query.SecurityEvaluationContextExtension"/&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="data-query"><a class="anchor" href="#data-query"></a>15.2.2. Security Expressions within @Query</h4>
<div class="paragraph">
<p>现在,可以在查询中使用 Spring Security. 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Repository
public interface MessageRepository extends PagingAndSortingRepository&lt;Message,Long&gt; {
    @Query("select m from Message m where m.to.id = ?#{ principal?.id }")
    Page&lt;Message&gt; findInbox(Pageable pageable);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将检查 <code>Authentication.getPrincipal().getId()</code> 是否等于 <code>Message</code> 的收件人.  请注意,此示例假定您已将主体自定义为具有 id 属性的 Object.  通过暴露 <code>SecurityEvaluationContextExtension</code> Bean,所有 <a href="#common-expressions">通用安全表达式</a>都可以在查询中使用.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="concurrency"><a class="anchor" href="#concurrency"></a>15.3. 并发支持</h3>
<div class="paragraph">
<p>在大多数环境中,安全性是基于每个线程存储的.  这意味着当在新线程上完成工作时,<code>SecurityContext</code> 将丢失.  Spring Security 提供了一些基础架构来帮助用户轻松实现这一点.
Spring Security 提供了用于在多线程环境中使用 Spring Security 的底层抽象.  实际上,这就是 Spring Security 与名为 <a href="#servletapi-start-runnable">"`AsyncContext.start(Runnable) `"</a> 和的部分和进行 <a href="#mvc-async">第 15.6.4 节 "Spring MVC 异步集成"</a> 集成的基础.</p>
</div>
<div class="sect3">
<h4 id="delegatingsecuritycontextrunnable"><a class="anchor" href="#delegatingsecuritycontextrunnable"></a>15.3.1. DelegatingSecurityContextRunnable</h4>
<div class="paragraph">
<p>Spring Security 并发支持中最基本的构建块之一是 <code>DelegatingSecurityContextRunnable</code>.  它包装了一个委托 <code>Runnable</code>,以便使用为委托指定的 <code>SecurityContext</code> 初始化 <code>SecurityContextHolder</code>.  然后,它将调用委托 <code>Runnable</code>,以确保随后清除 <code>SecurityContextHolder</code>.  <code>DelegatingSecurityContextRunnable</code> 看起来像这样:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public void run() {
try {
    SecurityContextHolder.setContext(securityContext);
    delegate.run();
} finally {
    SecurityContextHolder.clearContext();
}
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管非常简单,但可以无缝地将 <code>SecurityContext</code> 从一个线程传输到另一个线程.  这很重要,因为在大多数情况下,<code>SecurityContextHolder</code> 会基于每个线程进行操作.  例如,您可能已使用 Spring Security 的 <a href="#nsa-global-method-security">global-method-security</a> 支持部分来保护您的一项服务.
现在,您可以轻松地将当前线程的 <code>SecurityContext</code> 转移到调用安全服务的线程.  下面是如何执行此操作的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Runnable originalRunnable = new Runnable() {
public void run() {
    // invoke secured service
}
};

SecurityContext context = SecurityContextHolder.getContext();
DelegatingSecurityContextRunnable wrappedRunnable =
    new DelegatingSecurityContextRunnable(originalRunnable, context);

new Thread(wrappedRunnable).start();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的代码执行以下步骤:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建一个将调用我们的安全服务的 <code>Runnable</code>. 请注意,它不会被 Spring Security 装配</p>
</li>
<li>
<p>从 <code>SecurityContextHolder</code> 获得我们希望使用的 <code>SecurityContext</code> 并初始化 <code>DelegatingSecurityContextRunnable</code></p>
</li>
<li>
<p>使用 <code>DelegatingSecurityContextRunnable</code> 创建线程</p>
</li>
<li>
<p>启动我们创建的线程</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于在 <code>SecurityContextHolder</code> 中使用 <code>SecurityContext</code> 创建 <code>DelegatingSecurityContextRunnable</code> 很普遍,因此有一个快捷方式构造函数. 以下代码与上面的代码相同:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Runnable originalRunnable = new Runnable() {
public void run() {
    // invoke secured service
}
};

DelegatingSecurityContextRunnable wrappedRunnable =
    new DelegatingSecurityContextRunnable(originalRunnable);

new Thread(wrappedRunnable).start();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们拥有的代码易于使用,但仍然需要了解我们正在使用 Spring Security. 在下一节中,我们将研究如何利用 <code>DelegatingSecurityContextExecutor</code> 隐藏我们正在使用 Spring Security 的事实.</p>
</div>
</div>
<div class="sect3">
<h4 id="delegatingsecuritycontextexecutor"><a class="anchor" href="#delegatingsecuritycontextexecutor"></a>15.3.2. DelegatingSecurityContextExecutor</h4>
<div class="paragraph">
<p>在上一节中,我们发现使用 <code>DelegatingSecurityContextRunnable</code> 很容易,但是它并不理想,因为我们必须知道 Spring Security 才能使用它.  让我们看一下 <code>DelegatingSecurityContextExecutor</code> 如何使我们的代码不受使用 Spring Security 的任何知识的影响.</p>
</div>
<div class="paragraph">
<p><code>DelegatingSecurityContextExecutor</code> 的设计与 <code>DelegatingSecurityContextRunnable</code> 的设计非常相似,只是它接受委托 <code>Executor</code> 而不是委托 <code>Runnable</code>.  您可以在下面查看如何使用它的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SecurityContext context = SecurityContextHolder.createEmptyContext();
Authentication authentication =
    new UsernamePasswordAuthenticationToken("user","doesnotmatter", AuthorityUtils.createAuthorityList("ROLE_USER"));
context.setAuthentication(authentication);

SimpleAsyncTaskExecutor delegateExecutor =
    new SimpleAsyncTaskExecutor();
DelegatingSecurityContextExecutor executor =
    new DelegatingSecurityContextExecutor(delegateExecutor, context);

Runnable originalRunnable = new Runnable() {
public void run() {
    // invoke secured service
}
};

executor.execute(originalRunnable);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码执行以下步骤:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>创建要用于我们的 <code>DelegatingSecurityContextExecutor</code> 的 <code>SecurityContext</code>.  请注意,在此示例中,我们仅手动创建了 <code>SecurityContext</code>.  但是,无论在何处或如何获取 <code>SecurityContext</code> 都无关紧要(也就是说,如果需要,我们可以从 <code>SecurityContextHolder</code> 获取它) .</p>
</li>
<li>
<p>创建一个负责执行提交的可运行对象的委托 Actuator</p>
</li>
<li>
<p>最后,我们创建一个 <code>DelegatingSecurityContextExecutor</code>,它负责使用 <code>DelegatingSecurityContextRunnable</code> 包装传递给 <code>execute</code> 方法的所有 <code>Runnable</code>.  然后,它将包装的 <code>Runnable</code> 传递给委托 Actuator.  在这种情况下,相同的 <code>SecurityContext</code> 将用于提交给我们的 <code>DelegatingSecurityContextExecutor</code> 的每个 <code>Runnable</code>.  如果我们正在运行需要由特权较高的用户运行的后台任务,那就很好.</p>
</li>
<li>
<p>在这一点上,您可能会问自己 "这如何屏蔽我的代码,使其不了解 Spring Security? " 代替在我们自己的代码中创建 <code>SecurityContext</code> 和 <code>DelegatingSecurityContextExecutor</code>,我们可以注入一个已经初始化的 <code>DelegatingSecurityContextExecutor</code> 实例.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowired
private Executor executor; // becomes an instance of our DelegatingSecurityContextExecutor

public void submitRunnable() {
Runnable originalRunnable = new Runnable() {
    public void run() {
    // invoke secured service
    }
};
executor.execute(originalRunnable);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在我们的代码不知道 <code>SecurityContext</code> 正在传播到线程,然后执行 <code>originalRunnable</code>,然后清除 <code>SecurityContextHolder</code>.  在此示例中,使用同一用户执行每个线程.
如果我们想在调用 <code>executor.execute(Runnable)</code> (即当前登录的用户) 来处理 <code>originalRunnable</code> 时使用 <code>SecurityContextHolder</code> 中的用户怎么办?  这可以通过从 <code>DelegatingSecurityContextExecutor</code> 构造函数中删除 <code>SecurityContext</code> 参数来完成.  例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">SimpleAsyncTaskExecutor delegateExecutor = new SimpleAsyncTaskExecutor();
DelegatingSecurityContextExecutor executor =
    new DelegatingSecurityContextExecutor(delegateExecutor);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在,无论何时执行 <code>executor.execute(Runnable)</code>,都首先由 <code>SecurityContextHolder</code> 获得 <code>SecurityContext</code>,然后使用该 <code>SecurityContext</code> 创建我们的 <code>DelegatingSecurityContextRunnable</code>.  这意味着我们将使用用于调用 <code>executor.execute(Runnable)</code> 代码的同一用户执行 <code>Runnable</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-security-concurrency-classes"><a class="anchor" href="#spring-security-concurrency-classes"></a>15.3.3. Spring Security Concurrency Classes</h4>
<div class="paragraph">
<p>有关与 Java 并发 API 和 Spring Task 抽象的其他集成,请参考 Javadoc.  一旦您理解了先前的代码,它们就非常不言自明.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DelegatingSecurityContextCallable</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextExecutor</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextExecutorService</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextRunnable</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextScheduledExecutorService</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextSchedulingTaskExecutor</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextAsyncTaskExecutor</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextTaskExecutor</code></p>
</li>
<li>
<p><code>DelegatingSecurityContextTaskScheduler</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jackson"><a class="anchor" href="#jackson"></a>15.4. Jackson 支持</h3>
<div class="paragraph">
<p>Spring Security 提供了 Jackson 持久化支持与 Spring Security 相关的类.  在使用分布式会话(即会话复制,Spring Session 等) 时,这可以提高序列化与 Spring Security 相关的类的性能.</p>
</div>
<div class="paragraph">
<p>要使用它,请使用 <code>ObjectMapper</code> 将 <code>SecurityJackson2Modules.getModules(ClassLoader)</code> 注册为 <a href="https://wiki.fasterxml.com/JacksonFeatureModules">Jackson Modules</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ObjectMapper mapper = new ObjectMapper();
ClassLoader loader = getClass().getClassLoader();
List&lt;Module&gt; modules = SecurityJackson2Modules.getModules(loader);
mapper.registerModules(modules);

// ... use ObjectMapper as normally ...
SecurityContext context = new SecurityContextImpl();
// ...
String json = mapper.writeValueAsString(context);
</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以下 Spring Security 模块提供 Jackson 支持:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>spring-security-core (<code>CoreJackson2Module</code>)</p>
</li>
<li>
<p>spring-security-web (<code>WebJackson2Module</code>, <code>WebServletJackson2Module</code>, <code>WebServerJackson2Module</code>)</p>
</li>
<li>
<p><a href="#oauth2client">spring-security-oauth2-client</a> (<code>OAuth2ClientJackson2Module</code>)</p>
</li>
<li>
<p>spring-security-cas (<code>CasJackson2Module</code>)</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="localization"><a class="anchor" href="#localization"></a>15.5. 国际化</h3>
<div class="paragraph">
<p>Spring Security 支持本地化最终用户可能会看到的异常消息.  如果您的应用程序是为说英语的用户设计的,则您无需执行任何操作,因为默认情况下,所有安全消息均以英语显示.  如果您需要支持其他语言环境,则本节包含您需要了解的所有内容.</p>
</div>
<div class="paragraph">
<p>可以对所有异常消息进行本地化,包括与身份验证失败和访问被拒绝(授权失败) 有关的消息.  针对开发人员或系统部署人员的异常和日志消息(包括不正确的属性,违反接口合同,使用不正确的构造函数,启动时间验证,调试级别的日志记录) 未本地化,而是在 Spring Security 的代码中以英文进行了硬编码.</p>
</div>
<div class="paragraph">
<p>在 <code>spring-security-core-xx.jar</code> 中,您将找到 <code>org.springframework.security</code> 包,该包反过来包含 <code>messages.properties</code> 文件以及某些通用语言的本地化版本.  由于 Spring Security 类实现了 Spring 的 <code>MessageSourceAware</code> 接口,并希望消息解析器在应用程序上下文启动时被注入依赖,因此应该由 <code>ApplicationContext</code> 引用.  通常,您要做的就是在应用程序上下文中注册一个 bean 来引用消息.  一个例子如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;bean id="messageSource"
    class="org.springframework.context.support.ReloadableResourceBundleMessageSource"&gt;
&lt;property name="basename" value="classpath:org/springframework/security/messages"/&gt;
&lt;/bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>messages.properties</code> 是根据标准资源包命名的,表示 Spring Security 消息支持的默认语言.  该默认文件为英文.</p>
</div>
<div class="paragraph">
<p>如果希望自定义 <code>messages.properties</code> 文件或支持其他语言,则应复制该文件,进行相应的重命名,然后在上述 bean 定义中注册它.  此文件中没有大量的消息密钥,因此不应将本地化视为主要举措.  如果您确实对此文件进行了本地化,请考虑通过记录 JIRA 任务并附加适当命名的 <code>messages.properties</code> 本地化版本与社区共享您的工作.</p>
</div>
<div class="paragraph">
<p>Spring Security 依靠 Spring 的本地化支持来实际查找适当的消息.  为了使它起作用,您必须确保来自传入请求的语言环境存储在 Spring 的 <code>org.springframework.context.i18n.LocaleContextHolder</code> 中.  Spring MVC 的 <code>DispatcherServlet</code> 自动为您的应用程序执行此操作,但是由于在此之前调用了 Spring Security 的过滤器,因此需要在调用过滤器之前将 <code>LocaleContextHolder</code> 设置为包含正确的 <code>Locale</code>.
您可以自己在过滤器中执行此操作(该过滤器必须位于 <code>web.xml</code> 中的 Spring Security 过滤器之前) ,也可以使用 Spring 的 <code>RequestContextFilter</code>.  请参阅 Spring Framework 文档以获取有关在 Spring 中使用本地化的更多详细信息.</p>
</div>
<div class="literalblock">
<div class="content">
<pre>"contacts" 示例应用程序被设置为使用本地化消息.</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mvc"><a class="anchor" href="#mvc"></a>15.6. Spring MVC 整合</h3>
<div class="paragraph">
<p>Spring Security 提供了许多与 Spring MVC 的可选集成. 本节将详细介绍集成.</p>
</div>
<div class="sect3">
<h4 id="mvc-enablewebmvcsecurity"><a class="anchor" href="#mvc-enablewebmvcsecurity"></a>15.6.1. @EnableWebMvcSecurity</h4>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
从 Spring Security 4.0 开始, <code>@EnableWebMvcSecurity</code> 已经标记为 过时注解. 替换为 <code>@EnableWebSecurity</code>,它将根据类路径确定添加 Spring MVC 功能.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要启用与 Spring MVC 的 Spring Security 集成,请在配置中添加 <code>@EnableWebSecurity</code> 注解.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security 使用 Spring MVC 的 <a href="https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-customize">WebMvcConfigurer</a>提供配置.  这意味着,如果您使用的是更高级的选项,例如直接与 <code>WebMvcConfigurationSupport</code> 集成,那么您将需要手动提供 Spring Security 配置.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="mvc-requestmatcher"><a class="anchor" href="#mvc-requestmatcher"></a>15.6.2. MvcRequestMatcher</h4>
<div class="paragraph">
<p>Spring Security 提供了与 Spring MVC 如何使用 <code>MvcRequestMatcher</code> 在 URL 上进行匹配的深度集成.  这有助于确保您的安全规则与用于处理请求的逻辑相匹配.</p>
</div>
<div class="paragraph">
<p>为了使用 MvcRequestMatcher,必须将 Spring Security Configuration 与 DispatcherServlet 放在同一 <code>ApplicationContext</code> 中.  这是必需的,因为 Spring Security 的 <code>MvcRequestMatcher</code> 希望您的 Spring MVC 配置会注册一个名称为 <code>mvcHandlerMappingIntrospector</code> 的 <code>HandlerMappingIntrospector</code> Bean,用于执行匹配.</p>
</div>
<div class="paragraph">
<p>对于 <code>web.xml</code>,这意味着您应该将配置放在 <code>DispatcherServlet.xml</code> 中.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;listener&gt;
  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

&lt;!-- All Spring Configuration (both MVC and Security) are in /WEB-INF/spring/ --&gt;
&lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;/WEB-INF/spring/*.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;servlet&gt;
  &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
  &lt;!-- Load from the ContextLoaderListener --&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;&lt;/param-value&gt;
  &lt;/init-param&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
  &lt;servlet-name&gt;spring&lt;/servlet-name&gt;
  &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>WebSecurityConfiguration</code> 下面的 <code>DispatcherServlets</code> 中放置 <code>ApplicationContext</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class SecurityInitializer extends
    AbstractAnnotationConfigDispatcherServletInitializer {

  @Override
  protected Class&lt;?&gt;[] getRootConfigClasses() {
    return null;
  }

  @Override
  protected Class&lt;?&gt;[] getServletConfigClasses() {
    return new Class[] { RootConfiguration.class,
        WebMvcConfiguration.class };
  }

  @Override
  protected String[] getServletMappings() {
    return new String[] { "/" };
  }
}
</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>始终建议通过匹配 <code>HttpServletRequest</code> 和方法安全性来提供授权规则.</p>
</div>
<div class="paragraph">
<p>通过在 <code>HttpServletRequest</code> 上进行匹配来提供授权规则是一件好事,因为它发生在代码路径的早期,并且有助于减少 <a href="https://en.wikipedia.org/wiki/Attack_surface">攻击面</a>.
方法安全性可确保如果有人绕过了 Web 授权规则,则您的应用程序仍然受到保护.  这就是所谓的 <a href="https://en.wikipedia.org/wiki/Defense_in_depth_(computing)">深度防御</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>考虑一个映射如下的控制器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RequestMapping("/admin")
public String admin() {
</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们想将对这种控制器方法的访问限制为管理员用户,则开发人员可以通过在 <code>HttpServletRequest</code> 上匹配以下内容来提供授权规则:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests(authorize -&gt; authorize
            .antMatchers("/admin").hasRole("ADMIN")
        );
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用xml</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-url pattern="/admin" access="hasRole('ADMIN')"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>无论采用哪种配置,URL  <code>/admin</code>  都将要求经过身份验证的用户为 admin 用户.  但是,根据我们的 Spring MVC 配置,URL <code>/admin.html</code> 也将映射到我们的 <code>admin()</code> 方法.  另外,根据我们的 Spring MVC 配置,URL <code>/admin/</code> 也将映射到我们的 <code>admin()</code> 方法.</p>
</div>
<div class="paragraph">
<p>问题在于我们的安全规则仅保护 <code>/admin</code> .  我们可以为 Spring MVC 的所有排列添加其他规则,但这将非常冗长而乏味.</p>
</div>
<div class="paragraph">
<p>相反,我们可以利用 Spring Security 的 <code>MvcRequestMatcher</code>.  以下配置通过使用 Spring MVC 在 URL 上进行匹配来保护与 Spring MVC 匹配的 URL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests(authorize -&gt; authorize
            .mvcMatchers("/admin").hasRole("ADMIN")
        );
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用 xml</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http request-matcher="mvc"&gt;
    &lt;intercept-url pattern="/admin" access="hasRole('ADMIN')"/&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-authentication-principal"><a class="anchor" href="#mvc-authentication-principal"></a>15.6.3. @AuthenticationPrincipal</h4>
<div class="paragraph">
<p>Spring Security 提供了 <code>AuthenticationPrincipalArgumentResolver</code>,它可以为 Spring MVC 参数自动解析当前的 <code>Authentication.getPrincipal()</code> .  通过使用 <code>@EnableWebSecurity</code>,您将自动将其添加到 Spring MVC 配置中.  如果使用基于 XML 的配置,则必须自己添加.  例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;mvc:annotation-driven&gt;
        &lt;mvc:argument-resolvers&gt;
                &lt;bean class="org.springframework.security.web.method.annotation.AuthenticationPrincipalArgumentResolver" /&gt;
        &lt;/mvc:argument-resolvers&gt;
&lt;/mvc:annotation-driven&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>正确配置 <code>AuthenticationPrincipalArgumentResolver</code> 之后,您就可以在 Spring MVC 层中与 Spring Security 完全脱钩.</p>
</div>
<div class="paragraph">
<p>考虑一种情况,其中自定义 <code>UserDetailsService</code> 返回一个实现 <code>UserDetails</code> 的对象和您自己的 <code>CustomUser</code> 对象.  可以使用以下代码访问当前已认证用户的 <code>CustomUser</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser() {
    Authentication authentication =
    SecurityContextHolder.getContext().getAuthentication();
    CustomUser custom = (CustomUser) authentication == null ? null : authentication.getPrincipal();

    // .. find messages for this user and return them ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>从 Spring Security 3.2 开始,我们可以通过添加注解来更直接地解析参数. 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.security.core.annotation.AuthenticationPrincipal;

</span><span class="fold-block">// ...

@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser(@AuthenticationPrincipal CustomUser customUser) {

    // .. find messages for this user and return them ...
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有时可能需要以某种方式转换主体.  例如,如果 <code>CustomUser</code> 需要为 <code>final</code>,则无法扩展.  在这种情况下,<code>UserDetailsService</code> 可能返回一个实现 <code>UserDetails</code> 的对象,并提供一个名为 <code>getCustomUser</code> 的方法来访问 <code>CustomUser</code>.  例如,它可能看起来像:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class CustomUserUserDetails extends User {
        // ...
        public CustomUser getCustomUser() {
                return customUser;
        }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后,我们可以使用 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html">SpEL表达式</a> 访问 <code>CustomUser</code>,该表达式使用 <code>Authentication.getPrincipal()</code> 作为根对象:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.security.core.annotation.AuthenticationPrincipal;

</span><span class="fold-block">// ...

@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser(@AuthenticationPrincipal(expression = "customUser") CustomUser customUser) {

    // .. find messages for this user and return them ...
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以在 SpEL 表达式中引用 Bean. 例如,如果我们使用 JPA 来管理用户,并且想要修改并保存当前用户的属性,则可以使用以下内容.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.security.core.annotation.AuthenticationPrincipal;

</span><span class="fold-block">// ...

@PutMapping("/users/self")
public ModelAndView updateName(@AuthenticationPrincipal(expression = "@jpaEntityManager.merge(#this)") CustomUser attachedCustomUser,
        @RequestParam String firstName) {

    // change the firstName on an attached instance which will be persisted to the database
    attachedCustomUser.setFirstName(firstName);

    // ...
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使 <code>@AuthenticationPrincipal</code> 成为我们自己的注解的元注解,我们可以进一步消除对 Spring Security 的依赖. 下面我们演示如何在名为 <code>@CurrentUser</code> 的注解上执行此操作.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
重要的是要意识到,为了消除对 Spring Security 的依赖,创建 <code>@CurrentUser</code> 的是消耗者的应用程序.  并非严格要求执行此步骤,但可以帮助您将对 Spring Security 的依赖隔离到更中央的位置.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Target({ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@AuthenticationPrincipal
public @interface CurrentUser {}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在已经指定了 <code>@CurrentUser</code>,我们可以用它来通知解析当前已认证用户的 <code>CustomUser</code>. 我们还将对 Spring Security 的依赖隔离到一个文件中.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RequestMapping("/messages/inbox")
public ModelAndView findMessagesForUser(@CurrentUser CustomUser customUser) {

    // .. find messages for this user and return them ...
}
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mvc-async"><a class="anchor" href="#mvc-async"></a>15.6.4. Spring MVC 异步整合</h4>
<div class="paragraph">
<p>Spring Web MVC 3.2+ 对 <a href="https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-ann-async">异步请求处理</a>提供了出色的支持.  无需其他配置,Spring Security 就会自动将 <code>SecurityContext</code> 设置为执行由您的控制器返回的 <code>Callable</code> 的线程.
例如,以下方法将自动使用创建 <code>Callable</code> 时可用的 <code>SecurityContext</code> 执行其 <code>Callable</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RequestMapping(method=RequestMethod.POST)
public Callable&lt;String&gt; processUpload(final MultipartFile file) {

return new Callable&lt;String&gt;() {
    public Object call() throws Exception {
    // ...
    return "someView";
    }
};
}
</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="title">将 SecurityContext 与 Callable 的关联</div>
<div class="paragraph">
<p>从技术上讲,Spring Security 与 <code>WebAsyncManager</code> 集成. 用于处理 <code>Callable</code> 的 <code>SecurityContext</code> 是在调用 <code>startCallableProcessing</code> 时 <code>SecurityContextHolder</code> 上存在的 <code>SecurityContext</code>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>没有与控制器返回的 <code>DeferredResult</code> 自动集成.  这是因为 <code>DeferredResult</code> 由用户处理,因此无法自动与其集成.  但是,您仍然可以使用<a href="#concurrency">并发支持</a> 来提供与 Spring Security 的透明集成.</p>
</div>
</div>
<div class="sect3">
<h4 id="mvc-csrf"><a class="anchor" href="#mvc-csrf"></a>15.6.5. Spring MVC 和 CSRF 整合</h4>
<div class="sect4">
<h5 id="自动包含令牌"><a class="anchor" href="#自动包含令牌"></a>自动包含令牌</h5>
<div class="paragraph">
<p>Spring Security 将在使用 <a href="https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/view.html#view-jsp-formtaglib-formtag">Spring MVC form tag</a>中自动<a href="#servlet-csrf-include">包含 CSRF 令牌</a>. 例如,以下 JSP:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;jsp:root xmlns:jsp="http://java.sun.com/JSP/Page"
    xmlns:c="http://java.sun.com/jsp/jstl/core"
    xmlns:form="http://www.springframework.org/tags/form" version="2.0"&gt;
    &lt;jsp:directive.page language="java" contentType="text/html" /&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"&gt;
    &lt;!-- ... --&gt;

    &lt;c:url var="logoutUrl" value="/logout"/&gt;
    &lt;form:form action="${logoutUrl}"
        method="post"&gt;
    &lt;input type="submit"
        value="Log out" /&gt;
    &lt;input type="hidden"
        name="${_csrf.parameterName}"
        value="${_csrf.token}"/&gt;
    &lt;/form:form&gt;

    &lt;!-- ... --&gt;
&lt;/html&gt;
&lt;/jsp:root&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>将输出类似于以下内容的 HTML:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;!-- ... --&gt;

&lt;form action="/context/logout" method="post"&gt;
&lt;input type="submit" value="Log out"/&gt;
&lt;input type="hidden" name="_csrf" value="f81d4fae-7dec-11d0-a765-00a0c91e6bf6"/&gt;
&lt;/form&gt;

&lt;!-- ... --&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mvc-csrf-resolver"><a class="anchor" href="#mvc-csrf-resolver"></a>CsrfToken 解析</h5>
<div class="paragraph">
<p>Spring Security 提供了 <code>CsrfTokenArgumentResolver</code>,它可以自动为 Spring MVC 参数解析当前的 <code>CsrfToken</code>.  通过使用 <a href="#jc-hello-wsca">@EnableWebSecurity</a> ,您将自动将其添加到 Spring MVC 配置中.  如果使用基于 XML 的配置,则必须自己添加.</p>
</div>
<div class="paragraph">
<p>正确配置 <code>CsrfTokenArgumentResolver</code> 后,即可将 <code>CsrfToken</code> 暴露给基于静态 HTML 的应用程序.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RestController
public class CsrfController {

    @RequestMapping("/csrf")
    public CsrfToken csrf(CsrfToken token) {
        return token;
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>保持 <code>CsrfToken</code> 对其他域的秘密非常重要. 这意味着,如果您使用 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">跨源共享(CORS) </a>,则不应将 <code>CsrfToken</code> 暴露给任何外部域.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="websocket"><a class="anchor" href="#websocket"></a>15.7. WebSocket 安全</h3>
<div class="paragraph">
<p>Spring Security 4 增加了对确保 Spring <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html">Spring&#8217;s WebSocket support</a>的支持. 本节介绍如何使用 Spring Security 的 WebSocket 支持.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
您可以在  <a href="https://github.com/spring-projects/spring-session/tree/master/spring-session-samples/spring-session-sample-boot-websocket" class="bare">github.com/spring-projects/spring-session/tree/master/spring-session-samples/spring-session-sample-boot-websocket</a>. 中找到 WebSocket 安全性的完整工作示例.
</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">直接JSR 356支持</div>
<div class="paragraph">
<p>Spring Security 不提供直接的 JSR-356 支持,因为这样做几乎没有价值.  这是因为格式是未知的,因此 Spring <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-intro-sub-protocol">几乎无法保护未知格式</a>.  另外,JSR-356 没有提供拦截消息的方法,因此安全性将具有相当大的侵入性.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-configuration"><a class="anchor" href="#websocket-configuration"></a>15.7.1. WebSocket 配置</h4>
<div class="paragraph">
<p>Spring Security 4.0 通过 Spring Messaging 抽象引入了对 WebSocket 的授权支持.  要使用 Java 配置来配置授权,只需扩展 <code>AbstractSecurityWebSocketMessageBrokerConfigurer</code> 并配置 <code>MessageSecurityMetadataSourceRegistry</code>.  例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class WebSocketSecurityConfig
      extends AbstractSecurityWebSocketMessageBrokerConfigurer { <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>

    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .simpDestMatchers("/user/**").authenticated() <i class="conum" data-value="3"></i><b>(3)</b>
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将确保:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>任何入站 CONNECT 消息均需要有效的 CSRF 令牌来实施 <a href="#websocket-sameorigin">同源策略</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>对于任何入站请求,在 simpUser header 属性中使用用户填充 SecurityContextHolder.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们的消息需要适当的授权. 具体来说,任何以 "/user/" 开头的入站消息都需要 <code>ROLE_USER</code>. 有关授权的更多详细信息,请参见 <a href="#websocket-authorization">第 15.7.3 节 "WebSocket授权"</a></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security 还提供<a href="#nsa-websocket-security">XML 命名空间</a>支持以保护 WebSocket.  可比较的基于XML的配置如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;websocket-message-broker&gt; <i class="conum" data-value="1"></i><b>(1)</b> <i class="conum" data-value="2"></i><b>(2)</b>
    <i class="conum" data-value="3"></i><b>(3)</b>
    &lt;intercept-message pattern="/user/**" access="hasRole('USER')" /&gt;
&lt;/websocket-message-broker&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将确保:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>任何入站 CONNECT 消息均需要有效的 CSRF 令牌来实施 <a href="#websocket-sameorigin">同源策略</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>对于任何入站请求,在 simpUser header 属性中使用用户填充 SecurityContextHolder.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>我们的消息需要适当的授权. 具体来说,任何以 "/user/" 开头的入站消息都需要 <code>ROLE_USER</code>. 有关授权的更多详细信息,请参见 <a href="#websocket-authorization">第15.7.3节 "WebSocket授权"</a></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="websocket-authentication"><a class="anchor" href="#websocket-authentication"></a>15.7.2. WebSocket 认证</h4>
<div class="paragraph">
<p>WebSockets 重用建立 <code>WebSocket</code> 连接时在 HTTP 请求中找到的相同身份验证信息.  这意味着 <code>HttpServletRequest</code> 上的 <code>Principal</code> 将移交给 <code>WebSockets</code>.  如果您使用的是 Spring Security,则 <code>HttpServletRequest</code> 上的 <code>Principal</code> 将被自动覆盖.</p>
</div>
<div class="paragraph">
<p>更具体地说,要确保用户已通过 <code>WebSocket</code> 应用程序的身份验证,所需要做的就是确保您设置 Spring Security 以对基于 HTTP 的 Web 应用程序进行身份验证.</p>
</div>
</div>
<div class="sect3">
<h4 id="websocket-authorization"><a class="anchor" href="#websocket-authorization"></a>15.7.3. WebSocket 授权</h4>
<div class="paragraph">
<p>Spring Security 4.0 通过 Spring Messaging 抽象引入了对 WebSocket 的授权支持.  要使用 Java 配置来配置授权,只需扩展 <code>AbstractSecurityWebSocketMessageBrokerConfigurer</code> 并配置 <code>MessageSecurityMetadataSourceRegistry</code>.  例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    @Override
    protected void configureInbound(MessageSecurityMetadataSourceRegistry messages) {
        messages
                .nullDestMatcher().authenticated() <i class="conum" data-value="1"></i><b>(1)</b>
                .simpSubscribeDestMatchers("/user/queue/errors").permitAll() <i class="conum" data-value="2"></i><b>(2)</b>
                .simpDestMatchers("/app/**").hasRole("USER") <i class="conum" data-value="3"></i><b>(3)</b>
                .simpSubscribeDestMatchers("/user/**", "/topic/friends/*").hasRole("USER") <i class="conum" data-value="4"></i><b>(4)</b>
                .simpTypeMatchers(MESSAGE, SUBSCRIBE).denyAll() <i class="conum" data-value="5"></i><b>(5)</b>
                .anyMessage().denyAll(); <i class="conum" data-value="6"></i><b>(6)</b>

    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将确保:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>任何没有目的地的消息(即除了消息类型或订阅之外的任何消息)都需要用户进行身份验证</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>任何人都可以订阅 /user/queue/errors</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>任何以 "/app/" 开头的消息都要求用户使用角色 ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>任何以 "/user/" 或类型为 SUBSCRIBE 的 "/topic/friends/" 开头的消息都需要ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>拒绝消息或订阅类型的任何其他消息. 由于第 6 步,我们不需要这个步骤,但它说明了如何匹配特定的消息类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>拒绝任何其他消息. 这是一个确保您不会错过任何消息的好主意.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Security 还提供<a href="#nsa-websocket-security">XML 命名空间</a>支持以保护 WebSocket. 可比较的基于 XML 的配置如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;websocket-message-broker&gt;
    <i class="conum" data-value="1"></i><b>(1)</b>
    &lt;intercept-message type="CONNECT" access="permitAll" /&gt;
    &lt;intercept-message type="UNSUBSCRIBE" access="permitAll" /&gt;
    &lt;intercept-message type="DISCONNECT" access="permitAll" /&gt;

    &lt;intercept-message pattern="/user/queue/errors" type="SUBSCRIBE" access="permitAll" /&gt; <i class="conum" data-value="2"></i><b>(2)</b>
    &lt;intercept-message pattern="/app/**" access="hasRole('USER')" /&gt;      <i class="conum" data-value="3"></i><b>(3)</b>

    <i class="conum" data-value="4"></i><b>(4)</b>
    &lt;intercept-message pattern="/user/**" access="hasRole('USER')" /&gt;
    &lt;intercept-message pattern="/topic/friends/*" access="hasRole('USER')" /&gt;

    <i class="conum" data-value="5"></i><b>(5)</b>
    &lt;intercept-message type="MESSAGE" access="denyAll" /&gt;
    &lt;intercept-message type="SUBSCRIBE" access="denyAll" /&gt;

    &lt;intercept-message pattern="/**" access="denyAll" /&gt; <i class="conum" data-value="6"></i><b>(6)</b>
&lt;/websocket-message-broker&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将确保:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>任何没有目的地的消息(即除了消息类型或订阅之外的任何消息)都需要用户进行身份验证</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>任何人都可以订阅 /user/queue/errors</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>任何以 "/app/" 开头的消息都要求用户使用角色ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>任何以 "/user/" 或类型为 SUBSCRIBE 的 "/topic/friends/" 开头的消息都需要 ROLE_USER</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>拒绝消息或订阅类型的任何其他消息. 由于第 6 步,我们不需要这个步骤,但它说明了如何匹配特定的消息类型.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>拒绝任何其他消息. 这是一个确保您不会错过任何消息的好主意.</td>
</tr>
</table>
</div>
<div class="sect4">
<h5 id="websocket-authorization-notes"><a class="anchor" href="#websocket-authorization-notes"></a>WebSocket授权说明</h5>
<div class="paragraph">
<p>为了正确保护您的应用程序,了解 Spring 的 WebSocket 支持非常重要.</p>
</div>
<div class="sect5">
<h6 id="websocket-authorization-notes-messagetypes"><a class="anchor" href="#websocket-authorization-notes-messagetypes"></a>WebSocket对消息类型的授权</h6>
<div class="paragraph">
<p>重要的是要了解 SUBSCRIBE 和 MESSAGE 类型的消息之间的区别以及它在 Spring 中的工作方式.</p>
</div>
<div class="paragraph">
<p>考虑聊天应用程序.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>系统可以通过 "/topic/system/notifications" 的目的地向所有用户发送 "MESSAGE" 通知</p>
</li>
<li>
<p>客户可以通过订阅接收到 "/topic/system/notifications" 的通知.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>尽管我们希望客户能够订阅  "/topic/system/notifications",但我们不想让他们将 MESSAGE 发送到该目的地.  如果我们允许向  "/topic/system/notifications" 发送消息,则客户端可以直接向该端点发送消息并模拟系统.</p>
</div>
<div class="paragraph">
<p>通常,应用程序通常拒绝发送到以 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp">代理前缀</a>(即 "/topic/" 或 "/queue/") 开头的目标的任何 MESSAGE.</p>
</div>
</div>
<div class="sect5">
<h6 id="websocket-authorization-notes-destinations"><a class="anchor" href="#websocket-authorization-notes-destinations"></a>目的地上的WebSocket授权</h6>
<div class="paragraph">
<p>了解目的地如何转变也很重要.</p>
</div>
<div class="paragraph">
<p>考虑聊天应用程序.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用户可以通过将消息发送到 "/app/chat" 的目的地来向特定用户发送消息.</p>
</li>
<li>
<p>应用程序会看到该消息,并确保将  "from" 属性指定为当前用户(我们不能信任客户端) .</p>
</li>
<li>
<p>然后,应用程序使用  <code>SimpMessageSendingOperations.convertAndSendToUser("toUser", "/queue/messages", message)</code> 将消息发送给收件人.</p>
</li>
<li>
<p>消息变成目标 "/queue/user/messages-&lt;sessionid&gt;"</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用上面的应用程序,我们希望允许我们的客户端收听 "/user/queue",它被转换为  "/queue/user/messages-&lt;sessionid&gt;".  但是,我们不希望客户端能够收听 "/queue/*",因为那样会使客户端看到每个用户的消息.</p>
</div>
<div class="paragraph">
<p>通常,应用程序通常会拒绝发送到以 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp">代理前缀</a> (即 "/topic/" 或 "/queue/")开头的消息的任何 SUBSCRIBE.  当然,我们可能会提供例外情况来说明类似</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="websocket-authorization-notes-outbound"><a class="anchor" href="#websocket-authorization-notes-outbound"></a>出站邮件</h5>
<div class="paragraph">
<p>Spring 包含一个标题为 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-stomp-message-flow">消息流</a> 的部分,该部分描述了消息如何在系统中流动.  重要的是要注意,Spring Security 仅保护 <code>clientInboundChannel</code>.  Spring Security 不会尝试保护 <code>clientOutboundChannel</code>.</p>
</div>
<div class="paragraph">
<p>最重要的原因是性能.  对于每条传入的消息,通常会有更多的出去消息.  我们鼓励保护对端点的订阅,而不是保护出站消息.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sameorigin"><a class="anchor" href="#websocket-sameorigin"></a>15.7.4. 强制同源策略</h4>
<div class="paragraph">
<p>需要强调的是,浏览器不会对 WebSocket 连接强制执行 <a href="https://en.wikipedia.org/wiki/Same-origin_policy">同源策略</a>. 这是一个非常重要的考虑因素.</p>
</div>
<div class="sect4">
<h5 id="websocket-sameorigin-why"><a class="anchor" href="#websocket-sameorigin-why"></a>为什么同源?</h5>
<div class="paragraph">
<p>请考虑以下情形.  用户访问 bank.com 并验证其帐户.  同一用户在其浏览器中打开另一个选项卡,并访问 evil.com.  相同来源政策可确保 evil.com 无法读取数据或将数据写入 bank.com.</p>
</div>
<div class="paragraph">
<p>对于 WebSocket,不适用 "同源策略".  实际上,除非 bank.com 明确禁止,否则 evil.com 可以代表用户读取和写入数据.  这意味着用户可以通过 webSocket 进行任何操作(即转帐) ,evil.com 可以代表该用户进行操作.</p>
</div>
<div class="paragraph">
<p>由于 SockJS 尝试模拟 WebSocket,因此它也绕过了相同起源策略.  这意味着开发人员在使用 SockJS 时需要明确保护其应用程序不受外部域的影响.</p>
</div>
</div>
<div class="sect4">
<h5 id="websocket-sameorigin-spring"><a class="anchor" href="#websocket-sameorigin-spring"></a>Spring WebSocket允许的来源</h5>
<div class="paragraph">
<p>幸运的是,自 Spring 4.1.5 起,Spring 的 WebSocket 和 SockJS 支持限制了对 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-server-allowed-origins">当前域</a> 的访问.  Spring Security 增加了一层保护,以提供 <a href="https://en.wikipedia.org/wiki/Defense_in_depth_%2528computing%2529">深度防御</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="websocket-sameorigin-csrf"><a class="anchor" href="#websocket-sameorigin-csrf"></a>将 CSRF 添加到 Stomp 头</h5>
<div class="paragraph">
<p>默认情况下,Spring Security 需要任何 CONNECT 消息类型的 <a href="#csrf">CSRF 令牌</a>.  这样可以确保只有有权访问 CSRF 令牌的站点才能连接.  由于只有相同来源可以访问 CSRF 令牌,因此不允许外部域进行连接.</p>
</div>
<div class="paragraph">
<p>通常,我们需要在 HTTP header 或 HTTP 参数中包含 CSRF 令牌.  但是,SockJS 不允许使用这些选项.  相反,我们必须在 Stomp header 中包含令牌</p>
</div>
<div class="paragraph">
<p>应用程序可以通过访问名为 <code>_csrf</code> 的请求属性来<a href="#servlet-csrf-include">获取 CSRF 令牌</a>.  例如,以下将允许在 JSP 中访问 <code>CsrfToken</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">var headerName = "${_csrf.headerName}";
var token = "${_csrf.token}";</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用的是静态 HTML,则可以在 REST 端点上暴露 <code>CsrfToken</code>. 例如,以下内容将在 URL /csrf 上暴露 <code>CsrfToken</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RestController
public class CsrfController {

    @RequestMapping("/csrf")
    public CsrfToken csrf(CsrfToken token) {
        return token;
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>JavaScript 可以对端点进行 REST 调用,并使用响应填充 <code>headerName</code> 和令牌.</p>
</div>
<div class="paragraph">
<p>现在,我们可以将令牌包含在Stomp客户端中.
例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">...
var headers = {};
headers[headerName] = token;
stompClient.connect(headers, function(frame) {
  ...

}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="websocket-sameorigin-disable"><a class="anchor" href="#websocket-sameorigin-disable"></a>在WebSockets中禁用CSRF</h5>
<div class="paragraph">
<p>如果您想允许其他域访问您的站点,则可以禁用 Spring Security 的保护.
例如,在 Java 配置中,您可以使用以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
public class WebSocketSecurityConfig extends AbstractSecurityWebSocketMessageBrokerConfigurer {

    ...

    @Override
    protected boolean sameOriginDisabled() {
        return true;
    }
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="websocket-sockjs"><a class="anchor" href="#websocket-sockjs"></a>15.7.5. 使用SockJS</h4>
<div class="paragraph">
<p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/websocket.html#websocket-fallback">SockJS</a> 提供后备传输以支持较旧的浏览器. 使用后备选项时,我们需要放松一些安全性约束,以允许 SockJS 与 Spring Security 一起使用.</p>
</div>
<div class="sect4">
<h5 id="websocket-sockjs-sameorigin"><a class="anchor" href="#websocket-sockjs-sameorigin"></a>SockJS &amp; frame-options</h5>
<div class="paragraph">
<p>SockJS 可能使用利用 <a href="https://github.com/sockjs/sockjs-client/tree/v0.3.4">iframe的传输方式</a>.  默认情况下,Spring Security 会 <a href="#headers-frame-options">拒绝</a>对网站进行构架以防止 Clickjacking 攻击.  为了允许基于 SockJS 框架的传输正常工作,我们需要配置 Spring Security 以允许相同的来源对内容进行框架化.</p>
</div>
<div class="paragraph">
<p>您可以使用 frame-options 元素来自定义 X-Frame-Options.  例如,以下内容将指示 Spring Security 使用 "X-Frame-Options: SAMEORIGIN" 它允许在同一域内的 iframe:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- ... --&gt;

    &lt;headers&gt;
        &lt;frame-options
          policy="SAMEORIGIN" /&gt;
    &lt;/headers&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>同样,您可以使用以下方法自定义框架选项以在 Java 配置中使用相同的来源:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends
   WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // ...
            .headers(headers -&gt; headers
                .frameOptions(frameOptions -&gt; frameOptions
                     .sameOrigin()
                )
        );
    }
}
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="websocket-sockjs-csrf"><a class="anchor" href="#websocket-sockjs-csrf"></a>SockJS &amp; 放宽CSRF</h5>
<div class="paragraph">
<p>SockJS 在 CONNECT 消息上使用 POST 进行任何基于 HTTP 的传输.  通常,我们需要在 HTTP header 或 HTTP 参数中包含 CSRF 令牌.  但是,SockJS 不允许使用这些选项.  相反,我们必须按照<a href="#websocket-sameorigin-csrf">将 CSRF 添加到 Stomp 头</a>一节中的说明,将令牌包括在 Stomp header 中.</p>
</div>
<div class="paragraph">
<p>这也意味着我们需要通过 Web 层放宽对 CSRF 的保护.  具体来说,我们要为连接 URL 禁用 CSRF 保护.  我们不想禁用每个 URL 的 CSRF 保护.  否则,我们的站点将容易受到 CSRF 攻击.</p>
</div>
<div class="paragraph">
<p>通过提供 CSRF RequestMatcher,我们可以轻松实现这一目标.  我们的 Java 配置非常简单.  例如,如果我们的踩踏端点为 "/chat/" ,则可以使用以下配置仅对以 "/chat/" 开头的 URL 禁用 CSRF 保护:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebSecurity
public class WebSecurityConfig
    extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -&gt; csrf
                // ignore our stomp endpoints since they are protected using Stomp headers
                .ignoringAntMatchers("/chat/**")
            )
            .headers(headers -&gt; headers
                // allow same origin to frame our site to support iframe SockJS
                .frameOptions(frameOptions -&gt; frameOptions
                    .sameOrigin()
                )
            )
            .authorizeRequests(authorize -&gt; authorize
                ...
            )
            ...
</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用基于 XML 的配置,则可以使用<a href="#nsa-csrf-request-matcher-ref">csrf@request-matcher-ref</a>. 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http ...&gt;
    &lt;csrf request-matcher-ref="csrfMatcher"/&gt;

    &lt;headers&gt;
        &lt;frame-options policy="SAMEORIGIN"/&gt;
    &lt;/headers&gt;

    ...
&lt;/http&gt;

&lt;b:bean id="csrfMatcher"
    class="AndRequestMatcher"&gt;
    &lt;b:constructor-arg value="#{T(org.springframework.security.web.csrf.CsrfFilter).DEFAULT_CSRF_MATCHER}"/&gt;
    &lt;b:constructor-arg&gt;
        &lt;b:bean class="org.springframework.security.web.util.matcher.NegatedRequestMatcher"&gt;
          &lt;b:bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher"&gt;
            &lt;b:constructor-arg value="/chat/**"/&gt;
          &lt;/b:bean&gt;
        &lt;/b:bean&gt;
    &lt;/b:constructor-arg&gt;
&lt;/b:bean&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cors"><a class="anchor" href="#cors"></a>15.8. CORS</h3>
<div class="paragraph">
<p>Spring Framework 为 CORS 提供了 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-cors">一流的支持</a>.  必须在 Spring Security 之前处理 CORS,因为飞行前请求将不包含任何 cookie (即 <code>JSESSIONID</code>) .
如果请求不包含任何 cookie,并且首先使用 Spring Security,则该请求将确定用户未通过身份验证(因为请求中没有 cookie) ,并拒绝该用户.</p>
</div>
<div class="paragraph">
<p>确保首先处理 CORS 的最简单方法是使用 <code>CorsFilter</code>.  用户可以通过使用以下内容提供 <code>CorsConfigurationSource</code> 来将 <code>CorsFilter</code> 与 Spring Security 集成:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // by default uses a Bean by the name of corsConfigurationSource
            .cors(withDefaults())
            ...
    }

    @Bean
    CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("https://example.com"));
        configuration.setAllowedMethods(Arrays.asList("GET","POST"));
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用 xml</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;cors configuration-source-ref="corsSource"/&gt;
    ...
&lt;/http&gt;
&lt;b:bean id="corsSource" class="org.springframework.web.cors.UrlBasedCorsConfigurationSource"&gt;
    ...
&lt;/b:bean&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用的是 Spring MVC 的 CORS 支持,则可以省略指定 <code>CorsConfigurationSource</code>,而 Spring Security 将利用提供给 Spring MVC 的 CORS 配置.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // if Spring MVC is on classpath and no CorsConfigurationSource is provided,
            // Spring Security will use CORS configuration provided to Spring MVC
            .cors(withDefaults())
            ...
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>或使用 xml</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;!-- Default to Spring MVC's CORS configuration --&gt;
    &lt;cors /&gt;
    ...
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="taglibs"><a class="anchor" href="#taglibs"></a>15.9. JSP 标签库</h3>
<div class="paragraph">
<p>Spring Security 有自己的 taglib,它为访问安全信息和在 JSP 中应用安全约束提供了基本的支持.</p>
</div>
<div class="sect3">
<h4 id="declaring-the-taglib"><a class="anchor" href="#declaring-the-taglib"></a>15.9.1. Declaring the Taglib</h4>
<div class="paragraph">
<p>要使用任何标签,必须在 JSP 中声明 Security 的标签库:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;%@ taglib prefix="sec" uri="http://www.springframework.org/security/tags" %&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="taglibs-authorize"><a class="anchor" href="#taglibs-authorize"></a>15.9.2. 授权标签</h4>
<div class="paragraph">
<p>该标签用于确定是否应评估其内容.  在 Spring Security 3.0 中,它可以以两种方式使用 <sup class="footnote">[<a id="_footnoteref_9" class="footnote" href="#_footnotedef_9" title="View footnote.">9</a>]</sup>.  第一种方法使用网络安全表达式,该表达式在标记的访问属性中指定.
表达式评估将委派给在应用程序上下文中定义的 <code>SecurityExpressionHandler&lt;FilterInvocation&gt;</code> (您应该在 <code>&lt;http&gt;</code> 命名空间配置中启用 Web 表达式,以确保此服务可用) .  因此,例如,您可能有</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;sec:authorize access="hasRole('supervisor')"&gt;

This content will only be visible to users who have the "supervisor" authority in their list of &lt;tt&gt;GrantedAuthority&lt;/tt&gt;s.

&lt;/sec:authorize&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>当与 Spring Security PermissionEvaluator 结合使用时,该标签还可用于检查权限.
例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;sec:authorize access="hasPermission(#domain,'read') or hasPermission(#domain,'write')"&gt;

This content will only be visible to users who have read or write permission to the Object found as a request attribute named "domain".

&lt;/sec:authorize&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>通常的要求是,如果实际上允许用户单击某个链接,则仅显示该链接.
我们如何预先确定是否允许某事? 此标记还可以在替代模式下运行,该模式允许您将特定的 URL 定义为属性.
如果允许用户调用该URL,则将评估标记主体,否则将跳过该标记主体.
所以你可能会喜欢</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;sec:authorize url="/admin"&gt;

This content will only be visible to users who are authorized to send requests to the "/admin" URL.

&lt;/sec:authorize&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用此标记,您的应用程序上下文中还必须有一个 <code>WebInvocationPrivilegeEvaluator</code> 的实例.
如果使用命名空间,将自动注册一个命名空间.
这是 <code>DefaultWebInvocationPrivilegeEvaluator</code> 的实例,该实例为提供的URL创建一个虚拟Web请求,并调用安全拦截器以查看该请求成功还是失败.
这使您可以委托给您在 <code>&lt;http&gt;</code> 命名空间配置中使用 <code>intercept-url</code> 声明定义的访问控制设置,并且省去了在JSP中重复信息(例如所需角色) 的麻烦.
这种方法还可以与提供HTTP方法的 <code>method</code> 属性结合使用,以实现更具体的匹配.</p>
</div>
<div class="paragraph">
<p>通过将变量 <code>var</code> 属性设置为变量名称,可以将评估标记(无论是授予还是拒绝访问) 的布尔结果存储在页面上下文作用域变量中,而无需在其他地方重复和重新评估条件在页面中.</p>
</div>
<div class="sect4">
<h5 id="禁用测试的授权标签"><a class="anchor" href="#禁用测试的授权标签"></a>禁用测试的授权标签</h5>
<div class="paragraph">
<p>在页面上为未授权用户隐藏链接不会阻止他们访问 URL.  例如,他们可以直接将其输入浏览器中.  在测试过程中,您可能希望显示隐藏区域,以检查链接在后端是否真正固定.  如果将系统属性 <code>spring.security.disableUISecurity</code> 设置为 <code>true</code>,则 <code>authorize</code> 标记仍将运行,但不会隐藏其内容.
默认情况下,它还将用 <code>&lt;span class="securityHiddenUI"&gt;&#8230;&#8203;&lt;/span&gt;</code>  标签包围内容.  这使您可以显示具有特定 CSS 样式(例如不同的背景颜色) 的 "隐藏" 内容.  例如,尝试在启用此属性的情况下运行 "教程" 示例应用程序.</p>
</div>
<div class="paragraph">
<p>如果要更改默认作用域标签中的周围文本(或使用空字符串将其完全删除) ,还可以设置属性 <code>spring.security.securedUIPrefix</code> 和 <code>spring.security.securedUISuffix</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="authentication-标签"><a class="anchor" href="#authentication-标签"></a>15.9.3. authentication 标签</h4>
<div class="paragraph">
<p>此标记允许访问存储在安全上下文中的当前 <code>Authentication</code>  对象.  它直接在 JSP 中呈现对象的属性.  因此,例如,如果 <code>Authentication</code> 的 <code>principal</code> 属性是 Spring Security 的 <code>UserDetails</code> 对象的实例,则使用 <code>&lt;sec:authentication property="principal.username" /&gt;</code> 将呈现当前用户的名称.</p>
</div>
<div class="paragraph">
<p>当然,在这种情况下不必使用 JSP 标签,并且有些人希望在视图中保持尽可能少的逻辑.  您可以在 MVC 控制器中访问 <code>Authentication</code> 对象(通过调用 <code>SecurityContextHolder.getContext().getAuthentication()</code>) ,然后将数据直接添加到模型中以通过视图进行呈现.</p>
</div>
</div>
<div class="sect3">
<h4 id="accesscontrollist-标签"><a class="anchor" href="#accesscontrollist-标签"></a>15.9.4. accesscontrollist 标签</h4>
<div class="paragraph">
<p>该标签仅在与 Spring Security 的 ACL 模块一起使用时才有效.  它检查以逗号分隔的指定域对象的所需权限列表.  如果当前用户拥有所有这些权限,则将评估标签正文.  如果他们不这样做,它将被跳过.  一个例子可能是</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
通常,应将此标签视为已弃用. 而是使用<a href="#taglibs-authorize">第15.9.2节 "授权标签"</a>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;sec:accesscontrollist hasPermission="1,2" domainObject="${someObject}"&gt;

This will be shown if the user has all of the permissions represented by the values "1" or "2" on the given object.

&lt;/sec:accesscontrollist&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>权限被传递到在应用程序上下文中定义的 <code>PermissionFactory</code>,将它们转换为ACL <code>Permission</code> 实例,因此它们可以是工厂支持的任何格式-它们不必是整数,它们可以是诸如 <code>READ</code> 或 <code>WRITE</code> 之类的字符串 .  如果未找到 <code>PermissionFactory</code>,则将使用 <code>DefaultPermissionFactory</code> 的实例.  应用程序上下文中的 <code>AclService</code> 将用于加载所提供对象的 Acl 实例.  将以所需的权限调用 Acl,以检查是否所有权限都被授予.</p>
</div>
<div class="paragraph">
<p>该标签还与 <code>authorize</code> 标签相同,支持 <code>var</code> 属性.</p>
</div>
</div>
<div class="sect3">
<h4 id="taglibs-csrfinput"><a class="anchor" href="#taglibs-csrfinput"></a>15.9.5. csrfInput 标签</h4>
<div class="paragraph">
<p>如果启用了 CSRF 保护,则此标签会插入一个隐藏的表单字段,其中包含 CSRF 保护令牌的正确名称和值.  如果未启用 CSRF 保护,则此标签不输出任何内容.</p>
</div>
<div class="paragraph">
<p>通常,Spring Security 会为您使用的任何 <code>&lt;form:form&gt;</code> 标记自动插入 CSRF 表单字段,但是如果由于某些原因您不能使用 <code>&lt;form:form&gt;</code>,<code>csrfInput</code> 是一个方便的替代品.</p>
</div>
<div class="paragraph">
<p>您应该将此标记放置在 HTML <code>&lt;form&gt;&lt;/form&gt;</code> 块中,通常将其放置在其他输入字段中.  请勿将此标签放在 Spring  <code>&lt;form:form&gt;&lt;/form:form&gt;</code>  块中.  Spring Security 自动处理 Spring 表单.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;form method="post" action="/do/something"&gt;
    &lt;sec:csrfInput /&gt;
    Name:&lt;br /&gt;
    &lt;input type="text" name="name" /&gt;
    ...
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="taglibs-csrfmeta"><a class="anchor" href="#taglibs-csrfmeta"></a>15.9.6. csrfMetaTags 标签</h4>
<div class="paragraph">
<p>如果启用了 CSRF 保护,则此标记将插入包含 CSRF 保护令牌形式字段, header 名称和 CSRF 保护令牌值的元标记.  这些元标记对于在应用程序中的 JavaScript 中采用 CSRF 保护很有用.</p>
</div>
<div class="paragraph">
<p>您应该将 <code>csrfMetaTags</code> 放置在 HTML <code>&lt;head&gt;&lt;/head&gt;</code> 块中,通常将其放置在其他 meta 标签中.  使用此标记后,您可以使用 JavaScript 轻松访问表单字段名称,标题名称和令牌值.  在此示例中,使用 JQuery 简化了任务.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;CSRF Protected JavaScript Page&lt;/title&gt;
        &lt;meta name="description" content="This is the description for this page" /&gt;
        &lt;sec:csrfMetaTags /&gt;
        &lt;script type="text/javascript" language="javascript"&gt;

            var csrfParameter = $("meta[name='_csrf_parameter']").attr("content");
            var csrfHeader = $("meta[name='_csrf_header']").attr("content");
            var csrfToken = $("meta[name='_csrf']").attr("content");

            // using XMLHttpRequest directly to send an x-www-form-urlencoded request
            var ajax = new XMLHttpRequest();
            ajax.open("POST", "https://www.example.org/do/something", true);
            ajax.setRequestHeader("Content-Type", "application/x-www-form-urlencoded data");
            ajax.send(csrfParameter + "=" + csrfToken + "&amp;name=John&amp;...");

            // using XMLHttpRequest directly to send a non-x-www-form-urlencoded request
            var ajax = new XMLHttpRequest();
            ajax.open("POST", "https://www.example.org/do/something", true);
            ajax.setRequestHeader(csrfHeader, csrfToken);
            ajax.send("...");

            // using JQuery to send an x-www-form-urlencoded request
            var data = {};
            data[csrfParameter] = csrfToken;
            data["name"] = "John";
            ...
            $.ajax({
                url: "https://www.example.org/do/something",
                type: "POST",
                data: data,
                ...
            });

            // using JQuery to send a non-x-www-form-urlencoded request
            var headers = {};
            headers[csrfHeader] = csrfToken;
            $.ajax({
                url: "https://www.example.org/do/something",
                type: "POST",
                headers: headers,
                ...
            });

        &lt;script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        ...
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果未启用 CSRF 保护,则 <code>csrfMetaTags</code> 不输出任何内容.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jc"><a class="anchor" href="#jc"></a>16. Java Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring 3.1 在 Spring Framework 中添加了对 <a href="https://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/beans.html#beans-java">Java Configuration</a> 的常规支持.  从 Spring Security 3.2 开始,已经有 Spring Security Java Configuration 支持,它使用户可以轻松配置 Spring Security,而无需使用任何 XML.</p>
</div>
<div class="paragraph">
<p>如果您熟悉 <a href="#ns-config">第17章 "security 命名空间配置"</a>,则应该发现它与 Security Java Configuration 支持之间有很多相似之处.</p>
</div>
<div class="paragraph">
<p>NOTE:Spring Security 提供了 <a href="https://github.com/spring-projects/spring-security/tree/master/samples/javaconfig">许多示例应用程序</a> ,它们演示了 Spring Security Java Configuration 的使用.</p>
</div>
<div class="sect2">
<h3 id="hello-web-security-java配置"><a class="anchor" href="#hello-web-security-java配置"></a>16.1. Hello Web Security Java配置</h3>
<div class="paragraph">
<p>第一步是创建我们的 Spring Security Java 配置.  该配置将创建一个称为 <code>springSecurityFilterChain</code> 的 Servlet 过滤器,该过滤器负责应用程序内的所有安全性 (保护应用程序 URL,验证提交的用户名和密码,重定向到登录表单等) .  您可以在下面找到 Spring Security Java 配置的最基本示例:</p>
</div>
<div id="jc-hello-wsca" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.beans.factory.annotation.Autowired;

import org.springframework.context.annotation.*;
import org.springframework.security.config.annotation.authentication.builders.*;
import org.springframework.security.config.annotation.web.configuration.*;

</span><span class="fold-block">@EnableWebSecurity
public class WebSecurityConfig {

    @Bean
    public UserDetailsService userDetailsService() {
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withDefaultPasswordEncoder().username("user").password("password").roles("USER").build());
        return manager;
    }
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个配置确实没什么,但是它做了很多.  您可以找到以下功能的摘要:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>要求对应用程序中的每个 URL 进行身份验证</p>
</li>
<li>
<p>为您生成一个登录表单</p>
</li>
<li>
<p>允许用 <strong>用户名</strong> <em>user</em> 和 <strong>密码</strong> <em>password</em> 的用户使用基于表单的身份验证进行身份验证</p>
</li>
<li>
<p>允许用户注销</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF attack</a> 预防</p>
</li>
<li>
<p><a href="https://en.wikipedia.org/wiki/Session_fixation">Session Fixation</a> 保护</p>
</li>
<li>
<p>Security Header 集成</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security">HTTP Strict Transport Security</a> for secure requests</p>
</li>
<li>
<p><a href="https://msdn.microsoft.com/en-us/library/ie/gg622941(v=vs.85).aspx">X-Content-Type-Options</a> 集成</p>
</li>
<li>
<p>缓存控制 (以后可以由您的应用程序覆盖,以允许缓存您的静态资源)</p>
</li>
<li>
<p><a href="https://msdn.microsoft.com/en-us/library/dd565647(v=vs.85).aspx">X-XSS-Protection</a> 集成</p>
</li>
<li>
<p>X-Frame-Options 集成有助于防止 <a href="https://en.wikipedia.org/wiki/Clickjacking">Clickjacking</a></p>
</li>
</ul>
</div>
</li>
<li>
<p>与以下 Servlet API 方法集成</p>
<div class="ulist">
<ul>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getRemoteUser()">HttpServletRequest#getRemoteUser()</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#getUserPrincipal()">HttpServletRequest#getUserPrincipal()</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#isUserInRole(java.lang.String)">HttpServletRequest#isUserInRole(java.lang.String)</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#login(java.lang.String,%20java.lang.String)">HttpServletRequest#login(java.lang.String, java.lang.String)</a></p>
</li>
<li>
<p><a href="https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletRequest.html#logout()">HttpServletRequest#logout()</a></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="abstractsecuritywebapplicationinitializer"><a class="anchor" href="#abstractsecuritywebapplicationinitializer"></a>16.1.1. AbstractSecurityWebApplicationInitializer</h4>
<div class="paragraph">
<p>下一步是向 war 注册 <code>springSecurityFilterChain</code>.  可以在 Java 配置中,在 Servlet 3.0+ 环境中使用 Spring 的 <a href="https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/mvc.html#mvc-container-config">Spring&#8217;s WebApplicationInitializer support</a> .
毫无疑问,Spring Security 提供了一个基类 <code>AbstractSecurityWebApplicationInitializer</code>,它将确保 <code>springSecurityFilterChain</code> 为您注册.  我们使用 <code>AbstractSecurityWebApplicationInitializer</code> 的方式有所不同,这取决于我们是否已经在使用 Spring,或者 Spring Security 是应用程序中唯一的 Spring 组件.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#abstractsecuritywebapplicationinitializer-without-existing-spring">没有 Spring 的 AbstractSecurityWebApplicationInitializer</a> - 如果您尚未使用 Spring,请按照以下说明进行操作</p>
</li>
<li>
<p><a href="#abstractsecuritywebapplicationinitializer-with-spring-mvc">Spring MVC 的 AbstractSecurityWebApplicationInitializer</a> - 如果您已经在使用 Spring,请按照以下说明进行操作</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="abstractsecuritywebapplicationinitializer-without-existing-spring"><a class="anchor" href="#abstractsecuritywebapplicationinitializer-without-existing-spring"></a>16.1.2. 没有 Spring 的 AbstractSecurityWebApplicationInitializer</h4>
<div class="paragraph">
<p>如果您不使用 Spring 或 Spring MVC,则需要将 <code>WebSecurityConfig</code> 传递到超类中,以确保配置被选中. 您可以在下面找到一个示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.security.web.context.*;

</span><span class="fold-block">public class SecurityWebApplicationInitializer
    extends AbstractSecurityWebApplicationInitializer {

    public SecurityWebApplicationInitializer() {
        super(WebSecurityConfig.class);
    }
}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>SecurityWebApplicationInitializer</code> 将执行以下操作:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为应用程序中的每个 URL 自动注册 <code>springSecurityFilterChain</code> 过滤器</p>
</li>
<li>
<p>添加一个用于加载 <a href="#jc-hello-wsca">WebSecurityConfig</a> 的 <code>ContextLoaderListener</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="abstractsecuritywebapplicationinitializer-with-spring-mvc"><a class="anchor" href="#abstractsecuritywebapplicationinitializer-with-spring-mvc"></a>16.1.3. Spring MVC 的 AbstractSecurityWebApplicationInitializer</h4>
<div class="paragraph">
<p>如果我们在应用程序的其他地方使用 Spring,则可能已经有一个 <code>WebApplicationInitializer</code> 正在加载 Spring 配置.  如果我们使用以前的配置,将会得到一个错误.  相反,我们应该向现有的 <code>ApplicationContext</code> 注册 Spring Security.  例如,如果我们使用的是 Spring MVC,则 <code>SecurityWebApplicationInitializer</code> 看起来将类似于以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.security.web.context.*;

</span><span class="fold-block">public class SecurityWebApplicationInitializer
    extends AbstractSecurityWebApplicationInitializer {

}
</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这只会为应用程序中的每个 URL 仅注册 <code>springSecurityFilterChain</code> 过滤器.  之后,我们将确保将 <code>WebSecurityConfig</code> 加载到我们现有的 <code>ApplicationInitializer</code> 中.  例如,如果我们使用的是 Spring MVC,则将其添加到  <code>getRootConfigClasses()</code> 中.</p>
</div>
<div id="message-web-application-inititializer-java" class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MvcWebApplicationInitializer extends
        AbstractAnnotationConfigDispatcherServletInitializer {

    @Override
    protected Class&lt;?&gt;[] getRootConfigClasses() {
        return new Class[] { WebSecurityConfig.class };
    }

    // ... other overrides ...
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jc-httpsecurity"><a class="anchor" href="#jc-httpsecurity"></a>16.2. HttpSecurity</h3>
<div class="paragraph">
<p>到目前为止,我们的  <a href="#jc-hello-wsca">WebSecurityConfig</a> 仅包含有关如何验证用户身份的信息.  Spring Security 如何知道我们要要求所有用户进行身份验证?  Spring Security 如何知道我们要支持基于表单的身份验证?  实际上,在后台调用了一个名为 <code>WebSecurityConfigurerAdapter</code> 的配置类.  它具有一种名为 <code>configure</code> 的方法,具有以下默认实现:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
        )
        .formLogin(withDefaults())
        .httpBasic(withDefaults());
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的默认配置:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保对我们应用程序的任何请求都需要对用户进行身份验证</p>
</li>
<li>
<p>允许用户使用基于表单的登录进行身份验证</p>
</li>
<li>
<p>允许用户使用 HTTP Basic 身份验证进行身份验证</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您会注意到此配置与 XML Namespace 非常相似</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-url pattern="/**" access="authenticated"/&gt;
    &lt;form-login /&gt;
    &lt;http-basic /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="multiple-httpsecurity"><a class="anchor" href="#multiple-httpsecurity"></a>16.3. Multiple HttpSecurity</h3>
<div class="paragraph">
<p>我们可以配置多个 <code>HttpSecurity</code> 实例,就像我们可以具有多个 <code>&lt;http&gt;</code>  块一样.  关键是多次扩展 <code>WebSecurityConfigurerAdapter</code>.  例如,以下示例说明了以 <code>/api/</code> 开头的 URL 具有不同的配置.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class MultiHttpSecurityConfig {
    @Bean                                                             <i class="conum" data-value="1"></i><b>(1)</b>
    public UserDetailsService userDetailsService() throws Exception {
        // ensure the passwords are encoded properly
        UserBuilder users = User.withDefaultPasswordEncoder();
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(users.username("user").password("password").roles("USER").build());
        manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build());
        return manager;
    }

    @Configuration
    @Order(1)                                                        <i class="conum" data-value="2"></i><b>(2)</b>
    public static class ApiWebSecurityConfigurationAdapter extends WebSecurityConfigurerAdapter {
        protected void configure(HttpSecurity http) throws Exception {
            http
                .antMatcher("/api/**")                               <i class="conum" data-value="3"></i><b>(3)</b>
                .authorizeRequests(authorize -&gt; authorize
                    .anyRequest().hasRole("ADMIN")
                )
                .httpBasic(withDefaults());
        }
    }

    @Configuration                                                   <i class="conum" data-value="4"></i><b>(4)</b>
    public static class FormLoginWebSecurityConfigurerAdapter extends WebSecurityConfigurerAdapter {

        @Override
        protected void configure(HttpSecurity http) throws Exception {
            http
                .authorizeRequests(authorize -&gt; authorize
                    .anyRequest().authenticated()
                )
                .formLogin(withDefaults());
        }
    }
}
</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>正常配置身份验证</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建一个包含 <code>@Order</code> 的 <code>WebSecurityConfigurerAdapter</code> 实例,以指定应首先考虑哪个 <code>WebSecurityConfigurerAdapter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>http.antMatcher</code> 声明此 <code>HttpSecurity</code> 仅适用于以 <code>/api/</code> 开头的URL</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>创建 <code>WebSecurityConfigurerAdapter的另一个实例</code>.  如果网址不是以 <code>/api/</code> 开头,则将使用此配置.  在 <code>ApiWebSecurityConfigurationAdapter</code> 之后考虑此配置,因为它的 <code>@Order</code> 值在 <code>1</code> 以后 (没有 <code>@Order</code> 默认为 <code>last</code>) .</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="jc-custom-dsls"><a class="anchor" href="#jc-custom-dsls"></a>16.4. 自定义 DSLs</h3>
<div class="paragraph">
<p>您可以在 Spring Security 中提供自己的自定义 DSL. 例如,您可能会有类似以下内容的内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MyCustomDsl extends AbstractHttpConfigurer&lt;MyCustomDsl, HttpSecurity&gt; {
    private boolean flag;

    @Override
    public void init(H http) throws Exception {
        // any method that adds another configurer
        // must be done in the init method
        http.csrf().disable();
    }

    @Override
    public void configure(H http) throws Exception {
        ApplicationContext context = http.getSharedObject(ApplicationContext.class);

        // here we lookup from the ApplicationContext. You can also just create a new instance.
        MyFilter myFilter = context.getBean(MyFilter.class);
        myFilter.setFlag(flag);
        http.addFilterBefore(myFilter, UsernamePasswordAuthenticationFilter.class);
    }

    public MyCustomDsl flag(boolean value) {
        this.flag = value;
        return this;
    }

    public static MyCustomDsl customDsl() {
        return new MyCustomDsl();
    }
}
</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
实际上,这就是实现诸如 <code>HttpSecurity.authorizeRequests()</code> 之类的方法的方式.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>然后可以像下面这样使用自定义 DSL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .apply(customDsl())
                .flag(true)
                .and()
            ...;
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>该代码按以下顺序调用:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>调用 <code>Config</code> 的 configure 方法中的代码</p>
</li>
<li>
<p>MyCustomDsl 的 init 方法中的代码被调用</p>
</li>
<li>
<p>MyCustomDsl 的 configure 方法中的代码被调用</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果需要,可以使用 <code>SpringFactories</code> 在默认情况下使 <code>WebSecurityConfigurerAdapter</code> 添加 <code>MyCustomDsl</code>. 例如,您将在具有以下内容的类路径上创建名为 <code>META-INF/spring.factories</code> 的资源:</p>
</div>
<div class="listingblock">
<div class="title">META-INF/spring.factories</div>
<div class="content">
<pre>org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer = sample.MyCustomDsl</pre>
</div>
</div>
<div class="paragraph">
<p>希望禁用默认设置的用户可以明确地这样做.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebSecurity
public class Config extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            .apply(customDsl()).disable()
            ...;
    }
}
</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="post-processing-configured-objects"><a class="anchor" href="#post-processing-configured-objects"></a>16.5. 配置对象后置处理器</h3>
<div class="paragraph">
<p>Spring Security 的 Java 配置并未暴露其配置的每个对象的每个属性.  这简化了大多数用户的配置.  毕竟,如果每个属性都暴露,则用户可以使用标准 Bean 配置.</p>
</div>
<div class="paragraph">
<p>尽管有充分的理由不直接暴露每个属性,但用户可能仍需要更多高级配置选项.  为了解决这个问题,Spring Security 引入了 <code>ObjectPostProcessor</code> 的概念,该概念可用于修改或替换 Java 配置创建的许多 Object 实例.
例如,如果要在 <code>FilterSecurityInterceptor</code> 上配置 <code>filterSecurityPublishAuthorizationSuccess</code> 属性,则可以使用以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        .authorizeRequests(authorize -&gt; authorize
            .anyRequest().authenticated()
            .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() {
                public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(
                        O fsi) {
                    fsi.setPublishAuthorizationSuccess(true);
                    return fsi;
                }
            })
        );
}
</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kotlin-config"><a class="anchor" href="#kotlin-config"></a>17. Kotlin Configuration</h2>
<div class="sectionbody">
<div class="paragraph">
<p>从 Spring Security 5.3 开始,Spring Security Kotlin Configuration 支持已经可用.  它使用户可以使用本地 Kotlin DSL 轻松配置 Spring Security.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security 提供了一个 <a href="https://github.com/spring-projects/spring-security/tree/master/samples/boot/kotlin">示例应用程序</a>,演示了如何使用 Spring Security Kotlin 配置.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="kotlin-config-httpsecurity"><a class="anchor" href="#kotlin-config-httpsecurity"></a>17.1. HttpSecurity</h3>
<div class="paragraph">
<p>Spring Security 如何知道我们要要求所有用户进行身份验证?
 Spring Security 如何知道我们要支持基于表单的身份验证?
 在后台调用了一个名为 <code>WebSecurityConfigurerAdapter</code> 的配置类.  它具有一种名为 configure 的方法,具有以下默认实现:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">fun configure(http: HttpSecurity) {
   http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
       formLogin { }
       httpBasic { }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的默认配置:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保对我们应用程序的任何请求都需要对用户进行身份验证</p>
</li>
<li>
<p>允许用户使用基于表单的登录进行身份验证</p>
</li>
<li>
<p>允许用户使用 HTTP Basic 身份验证进行身份验证</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>您会注意到此配置与 XML 命名空间配置非常相似:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
    &lt;intercept-url pattern="/**" access="authenticated"/&gt;
    &lt;form-login /&gt;
    &lt;http-basic /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="多个-httpsecurity"><a class="anchor" href="#多个-httpsecurity"></a>17.2. 多个 HttpSecurity</h3>
<div class="paragraph">
<p>我们可以配置多个 <code>HttpSecurity</code> 实例,就像我们可以具有多个 <code>&lt;http&gt;</code>  块一样.  关键是多次扩展 <code>WebSecurityConfigurerAdapter</code>.  例如,以下示例说明了以  <code>/api/</code> 开头的URL具有不同的配置.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebSecurity
class MultiHttpSecurityConfig {
    @Bean                                                            <i class="conum" data-value="1"></i><b>(1)</b>
    public fun userDetailsService(): UserDetailsService {
        val users: User.UserBuilder = User.withDefaultPasswordEncoder()
        val manager = InMemoryUserDetailsManager()
        manager.createUser(users.username("user").password("password").roles("USER").build())
        manager.createUser(users.username("admin").password("password").roles("USER","ADMIN").build())
        return manager
    }

    @Configuration
    @Order(1)                                                        <i class="conum" data-value="2"></i><b>(2)</b>
    class ApiWebSecurityConfigurationAdapter: WebSecurityConfigurerAdapter() {
        override fun configure(http: HttpSecurity) {
            http {
                securityMatcher("/api/**")                           <i class="conum" data-value="3"></i><b>(3)</b>
                authorizeRequests {
                    authorize(anyRequest, hasRole("ADMIN"))
                }
                httpBasic { }
            }
        }
    }

    @Configuration                                                   <i class="conum" data-value="4"></i><b>(4)</b>
    class FormLoginWebSecurityConfigurerAdapter: WebSecurityConfigurerAdapter() {
        override fun configure(http: HttpSecurity) {
            http {
                authorizeRequests {
                    authorize(anyRequest, authenticated)
                }
                formLogin { }
            }
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>正常配置身份验证</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>创建一个包含 <code>@Order</code> 的 <code>WebSecurityConfigurerAdapter</code> 实例,以指定应首先考虑哪个 <code>WebSecurityConfigurerAdapter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>http.antMatcher</code> 声明此 <code>HttpSecurity</code> 仅适用于以  <code>/api/</code> 开头的URL</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>创建 <code>WebSecurityConfigurerAdapter</code> 的另一个实例.  如果网址不是以  <code>/api/</code>  开头,则将使用此配置.  在 <code>ApiWebSecurityConfigurationAdapter</code> 之后考虑此配置,因为它的 <code>@Order</code> 值在1以后 (没有 <code>@Order</code> 默认为 <code>last</code>) .</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ns-config"><a class="anchor" href="#ns-config"></a>18. Security 命名空间配置</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="介绍-2"><a class="anchor" href="#介绍-2"></a>18.1. 介绍</h3>
<div class="paragraph">
<p>从 Spring Framework 2.0 版开始,可以使用命名空间配置.  它允许您使用其他 XML 模式中的元素来补充传统的 Spring bean 应用程序上下文语法.  您可以在 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/">Spring参考文档</a>中找到更多信息.  命名空间元素可以简单地用于允许以更简洁的方式配置单个 bean,或者更强大地定义一种替代配置语法,该语法与问题域更紧密地匹配并向用户隐藏底层的复杂性.
一个简单的元素可能掩盖了将多个 bean 和处理步骤添加到应用程序上下文的事实.  例如,将以下元素从安全命名空间添加到应用程序上下文中将启动嵌入式 LDAP 服务器,以测试应用程序中的使用情况:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;security:ldap-server /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这比连接等效的 Apache Directory Server Bean 要简单得多.  <code>ldap-server</code> 元素上的属性支持最常见的替代配置要求,并且使用户不必担心他们需要创建哪些 bean 以及 bean 属性名称是什么. <sup class="footnote">[<a id="_footnoteref_10" class="footnote" href="#_footnotedef_10" title="View footnote.">10</a>]</sup>一章中找到有关 <code>ldap-server</code> 元素使用的更多信息.]
在编辑应用程序上下文文件时使用良好的 XML 编辑器应提供有关可用属性和元素的信息.  我们建议您尝试一下 <a href="https://spring.io/tools/sts">Spring Tool Suite</a>,因为它具有使用标准 Spring 命名空间的特殊功能.</p>
</div>
<div class="paragraph">
<p>要开始在应用程序上下文中使用安全性命名空间,您需要在类路径上具有 <code>spring-security-config jar</code>.  然后,您要做的就是将架构声明添加到您的应用程序上下文文件中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans"
xmlns:security="http://www.springframework.org/schema/security"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/security
        https://www.springframework.org/schema/security/spring-security.xsd"&gt;
    ...
&lt;/beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在您将看到的许多示例中(以及在示例应用程序中) ,我们通常将 "security" 用作默认命名空间,而不是 "beans",这意味着我们可以在所有 security 命名空间元素上省略前缀,从而使内容 更容易阅读.
如果将应用程序上下文划分为单独的文件,并且大多数安全配置都放在其中一个文件中,则可能还需要这样做.  然后,您的安全应用程序上下文文件将像这样开始</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;beans:beans xmlns="http://www.springframework.org/schema/security"
xmlns:beans="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/security
        https://www.springframework.org/schema/security/spring-security.xsd"&gt;
    ...
&lt;/beans:beans&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>从现在开始,我们将假定使用此语法.</p>
</div>
<div class="sect3">
<h4 id="命名空间的设计"><a class="anchor" href="#命名空间的设计"></a>18.1.1. 命名空间的设计</h4>
<div class="paragraph">
<p>命名空间旨在捕获框架的最常见用法,并提供简化和简洁的语法以在应用程序中启用它们.  该设计基于框架内的大规模依赖,并且可以分为以下几个方面:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Web/HTTP Security</em> - 最复杂的部分.  设置用于应用框架身份验证机制的过滤器和相关服务Bean,以保护URL,呈现登录页面和错误页面等.</p>
</li>
<li>
<p><em>Business Object (Method) Security</em> - 用于保护服务层的选项.</p>
</li>
<li>
<p><em>AuthenticationManager</em> - 处理来自框架其他部分的身份验证请求.</p>
</li>
<li>
<p><em>AccessDecisionManager</em> - 提供有关 Web 和方法安全性的访问决策.  默认的将被注册,但是您也可以选择使用自定义的,使用常规的Spring bean语法声明.</p>
</li>
<li>
<p><em>AuthenticationProvider</em>s - 身份验证管理器用来验证用户身份的机制.  命名空间提供了对几个标准选项的支持,还提供了添加使用传统语法声明的自定义bean的方法.</p>
</li>
<li>
<p><em>UserDetailsService</em> - 与身份验证提供者密切相关,但其他 bean 通常也需要.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们将在以下各节中介绍如何配置它们.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-getting-started"><a class="anchor" href="#ns-getting-started"></a>18.2. security 命名空间配置入门</h3>
<div class="paragraph">
<p>在本节中,我们将研究如何构建命名空间配置以使用框架的一些主要功能.  假设您最初希望尽快启动并运行,并通过一些测试登录来向现有 Web 应用程序添加身份验证支持和访问控制.  然后,我们将研究如何转换为针对数据库或其他安全存储库的身份验证.  在后面的部分中,我们将介绍更多高级的命名空间配置选项.</p>
</div>
<div class="sect3">
<h4 id="ns-web-xml"><a class="anchor" href="#ns-web-xml"></a>18.2.1. web.xml 配置</h4>
<div class="paragraph">
<p>您需要做的第一件事是将以下过滤器声明添加到您的 <code>web.xml</code> 文件中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;filter&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
&lt;/filter&gt;

&lt;filter-mapping&gt;
&lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
&lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这为 Spring Security Web 基础架构提供了一个挂钩.  <code>DelegatingFilterProxy</code> 是一个Spring Framework类,它委托一个过滤器实现,该实现在您的应用程序上下文中定义为 Spring Bean.  在这种情况下,该 Bean 名为 "springSecurityFilterChain",
它是由命名空间创建的内部基础结构 Bean,用于处理Web安全.  请注意,您不应自己使用此 bean 名称.  将其添加到 <code>web.xml</code> 后,就可以开始编辑应用程序上下文文件了.  Web 安全服务是使用 <code>&lt;http&gt;</code> 元素配置的.</p>
</div>
</div>
<div class="sect3">
<h4 id="ns-minimal"><a class="anchor" href="#ns-minimal"></a>18.2.2. 最小化 &lt;http&gt; 配置</h4>
<div class="paragraph">
<p>启用Web安全所需要做的就是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;intercept-url pattern="/**" access="hasRole('USER')" /&gt;
&lt;form-login /&gt;
&lt;logout /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这表示我们希望保护应用程序中的所有 URL,需要角色 <code>ROLE_USER</code> 对其进行访问,我们希望使用带有用户名和密码的表单登录到该应用程序,并且希望注册一个注销 URL,以允许我们 注销该应用程序.  <code>&lt;http&gt;</code> 元素是所有与Web相关的命名空间功能的父级. <code>&lt;intercept-url&gt;</code> 元素定义了一种模式,该模式使用 Ant 路径样式语法<sup class="footnote">[<a id="_footnoteref_11" class="footnote" href="#_footnotedef_11" title="View footnote.">11</a>]</sup>]
与传入请求的 URL 匹配.  您还可以使用正则表达式匹配作为替代(有关更多详细信息,请参见命名空间附录) .  访问属性定义了与给定模式匹配的请求的访问要求.  在默认配置下,这通常是一个用逗号分隔的角色列表,必须允许用户发出一个角色来进行请求.
前缀 &#8220;ROLE_&#8221; 是一个标记,表示应与用户权限进行简单比较.  换句话说,应该使用基于角色的常规检查.  Spring Security 中的访问控制不限于使用简单角色(因此使用前缀来区分不同类型的安全属性) .
稍后我们将解释解释如何变化 <sup class="footnote">[<a id="_footnoteref_12" class="footnote" href="#_footnotedef_12" title="View footnote.">12</a>]</sup>.  在 Spring Security 3.0 中,该属性也可以填充为 <a href="#el-access">EL expression</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您可以使用多个 <code>&lt;intercept-url&gt;</code> 元素为不同的 URL 集定义不同的访问要求,但是将按照列出的顺序对其进行评估,并且将使用第一个匹配项.  因此,您必须将最具体的匹配项放在顶部.  您还可以添加方法属性,以将匹配限制为特定的 HTTP 方法(<code>GET</code>,<code>POST</code>,<code>PUT</code> 等) .</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>要添加一些用户,可以直接在命名空间中定义一组测试数据:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;authentication-manager&gt;
&lt;authentication-provider&gt;
    &lt;user-service&gt;
    &lt;!-- Password is prefixed with {noop} to indicate to DelegatingPasswordEncoder that
    NoOpPasswordEncoder should be used. This is not safe for production, but makes reading
    in samples easier. Normally passwords should be hashed using BCrypt --&gt;
    &lt;user name="jimi" password="{noop}jimispassword" authorities="ROLE_USER, ROLE_ADMIN" /&gt;
    &lt;user name="bob" password="{noop}bobspassword" authorities="ROLE_USER" /&gt;
    &lt;/user-service&gt;
&lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是存储相同密码的安全方法的示例. 密码以 <code>{bcrypt}</code> 为前缀来指示 <code>DelegatingPasswordEncoder</code>(该密码支持任何已配置的 <code>PasswordEncoder</code> 进行匹配) 使用 BCrypt 对密码进行哈希处理:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;authentication-manager&gt;
&lt;authentication-provider&gt;
    &lt;user-service&gt;
    &lt;user name="jimi" password="{bcrypt}$2a$10$ddEWZUl8aU0GdZPPpy7wbu82dvEw/pBpbRvDQRqA41y6mK1CoH00m"
            authorities="ROLE_USER, ROLE_ADMIN" /&gt;
    &lt;user name="bob" password="{bcrypt}$2a$10$/elFpMBnAYYig6KRR5bvOOYeZr1ie1hSogJryg9qDlhza4oCw1Qka"
            authorities="ROLE_USER" /&gt;
    &lt;user name="jimi" password="{noop}jimispassword" authorities="ROLE_USER, ROLE_ADMIN" /&gt;
    &lt;user name="bob" password="{noop}bobspassword" authorities="ROLE_USER" /&gt;
    &lt;/user-service&gt;
&lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;</code></pre>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>如果您熟悉框架的命名空间前版本,则可能已经大概猜到了这里发生了什么.  <code>&lt;http&gt;</code> 元素负责创建 <code>FilterChainProxy</code> 及其使用的过滤器.  由于预定义了过滤器位置,不再像过滤器排序不正确这样的常见问题.</p>
</div>
<div class="paragraph">
<p><code>&lt;authentication-provider&gt;</code> 元素创建一个 <code>DaoAuthenticationProvider</code> bean,而 <code>&lt;user-service&gt;</code> 元素创建一个 <code>InMemoryDaoImpl</code>.  所有身份验证提供者元素都必须是 <code>&lt;authentication-manager&gt;</code> 元素的子元素,该元素创建 <code>ProviderManager</code> 并向其注册身份验证提供者.
您可以找到有关在<a href="#appendix-namespace">命名空间附录</a>中创建的 bean 的更多详细信息.  如果您想开始了解框架中的重要类是什么以及如何使用它们,特别是如果您以后要自定义,则值得进行交叉检查.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>上面的配置定义了两个用户,他们的密码和他们在应用程序中的角色(将用于访问控制) .  也可以使用 <code>user-service</code> 上的 <code>properties</code> 属性从标准属性文件中加载用户信息.  有关文件格式的更多详细信息,请参见<a href="#servlet-authentication-inmemory">内存中身份验证</a>部分.  使用 <code>&lt;authentication-provider&gt;</code> 元素意味着身份验证管理器将使用用户信息来处理身份验证请求.  您可以具有多个 <code>&lt;authentication-provider&gt;</code> 元素来定义不同的身份验证源,并且将依次查询每个身份验证源.</p>
</div>
<div class="paragraph">
<p>此时,您应该可以启动应用程序,并且需要登录才能继续.  试试看,或尝试使用该项目随附的 "教程" 示例应用程序.</p>
</div>
<div class="sect4">
<h5 id="ns-form-target"><a class="anchor" href="#ns-form-target"></a>设置默认的登录后目标</h5>
<div class="paragraph">
<p>如果尝试访问受保护的资源未提示登录表单,则将使用 <code>default-target-url</code> 选项.  这是用户成功登录后将转到的URL,默认为 "/".  您还可以通过将 <code>always-use-default-target</code> 属性设置为 "true",进行配置,以使用户始终在该页面上结束(无论登录是 "按需" 还是明确选择登录) .   如果您的应用程序始终要求用户从 "主页" 页面开始,这将很有用,例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http pattern="/login.htm*" security="none"/&gt;
&lt;http use-expressions="false"&gt;
&lt;intercept-url pattern='/**' access='ROLE_USER' /&gt;
&lt;form-login login-page='/login.htm' default-target-url='/home.htm'
        always-use-default-target='true' /&gt;
&lt;/http&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了更好地控制目标,可以使用 <code>authentication-success-handler-ref</code> 属性作为 <code>default-target-url</code> 的替代方法.  引用的bean应该是 <code>AuthenticationSuccessHandler</code> 的实例.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-web-advanced"><a class="anchor" href="#ns-web-advanced"></a>18.3. 高级 Web 功能</h3>
<div class="sect3">
<h4 id="ns-custom-filters"><a class="anchor" href="#ns-custom-filters"></a>18.3.1. 添加自己的过滤器</h4>
<div class="paragraph">
<p>如果您以前使用过 Spring Security,那么您会知道该框架会维护一系列过滤器,以便应用其服务.  您可能想在特定位置将自己的过滤器添加到堆栈中,或者使用 Spring Security 过滤器,该过滤器目前没有命名空间配置选项(例如 CAS) .
或者,您可能想使用标准命名空间过滤器的定制版本,例如由 <code>&lt;form-login&gt;</code> 元素创建的 <code>UsernamePasswordAuthenticationFilter</code>,它利用了一些显式使用 Bean 可用的额外配置选项.  由于过滤器链未直接暴露,您如何使用命名空间配置来做到这一点?</p>
</div>
<div class="paragraph">
<p>使用命名空间时,始终严格执行过滤器的顺序.  创建应用程序上下文时,过滤器 bean 按照命名空间处理代码进行排序,标准的 Spring Security 过滤器每个在命名空间中都有一个别名和一个众所周知的位置.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在以前的版本中,排序是在应用程序上下文的后处理期间,在创建过滤器实例之后进行的.  在版本 3.0+ 中,现在在实例化类之前在 bean 元数据级别完成排序.  这对如何将自己的过滤器添加到堆栈有影响,因为在解析 <code>&lt;http&gt;</code> 元素期间必须知道整个过滤器列表,因此在 3.0 中语法略有变化.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><a href="#filter-stack">表 17.1 "标准过滤器别名和排序"</a>中显示了创建过滤器的过滤器,别名和命名空间元素/属性. 过滤器按它们在过滤器链中出现的顺序列出.</p>
</div>
<table id="filter-stack" class="tableblock frame-all grid-all stretch">
<caption class="title">Table 11. 标准过滤器别名和排序</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">别名</th>
<th class="tableblock halign-left valign-top">Filter 类</th>
<th class="tableblock halign-left valign-top">命名空间元素或属性</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CHANNEL_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ChannelProcessingFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/intercept-url@requires-channel</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SECURITY_CONTEXT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SecurityContextPersistenceFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CONCURRENT_SESSION_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ConcurrentSessionFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>session-management/concurrency-control</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">HEADERS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>HeaderWriterFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/headers</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CSRF_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CsrfFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/csrf</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LOGOUT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>LogoutFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/logout</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">X509_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>X509AuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/x509</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">PRE_AUTH_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AbstractPreAuthenticatedProcessingFilter</code> Subclasses</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CAS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>CasAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FORM_LOGIN_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UsernamePasswordAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/form-login</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BASIC_AUTH_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BasicAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/http-basic</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SERVLET_API_SUPPORT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SecurityContextHolderAwareRequestFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/@servlet-api-provision</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">JAAS_API_SUPPORT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>JaasApiIntegrationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/@jaas-api-provision</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">REMEMBER_ME_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>RememberMeAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/remember-me</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ANONYMOUS_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>AnonymousAuthenticationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http/anonymous</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SESSION_MANAGEMENT_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SessionManagementFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>session-management</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">EXCEPTION_TRANSLATION_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ExceptionTranslationFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FILTER_SECURITY_INTERCEPTOR</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>FilterSecurityInterceptor</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>http</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SWITCH_USER_FILTER</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>SwitchUserFilter</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">N/A</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>您可以使用 <code>custom-filter</code> 元素和以下名称之一指定自己的过滤器到堆栈中,以指定过滤器应出现的位置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http&gt;
&lt;custom-filter position="FORM_LOGIN_FILTER" ref="myFilter" /&gt;
&lt;/http&gt;

&lt;beans:bean id="myFilter" class="com.mycompany.MySpecialAuthenticationFilter"/&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果要在堆栈中的另一个过滤器之前或之后插入过滤器,也可以使用 <code>after</code> 或 <code>before</code> 属性.  名称 "FIRST" 和 "LAST" 可以与 <code>position</code> 属性一起使用,以指示您希望过滤器分别出现在整个堆栈之前或之后.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">避免过滤器位置冲突</div>
<div class="paragraph">
<p>如果您要插入一个自定义过滤器,该过滤器的位置可能与命名空间创建的标准过滤器中的位置相同,那么一定不要误添加命名空间版本,这一点很重要.  删除所有创建要替换其功能的过滤器的元素.</p>
</div>
<div class="paragraph">
<p>请注意,您不能替换使用 &lt;http&gt; 元素本身创建的过滤器- <code>SecurityContextPersistenceFilter</code>,<code>ExceptionTranslationFilter</code> 或 <code>FilterSecurityInterceptor</code>.  默认情况下会添加其他一些过滤器,但是您可以禁用它们.  默认情况下会添加 <code>AnonymousAuthenticationFilter</code>,除非您禁用了<a href="#ns-session-fixation">会话固定保护</a>,否则 <code>SessionManagementFilter</code> 也将添加到过滤器链中.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>如果您要替换需要身份验证入口点的命名空间过滤器(即,未经身份验证的用户试图访问受保护的资源而触发身份验证过程) ,则也需要添加自定义入口点 Bean.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ns-method-security"><a class="anchor" href="#ns-method-security"></a>18.4. 安全方法</h3>
<div class="paragraph">
<p>从 2.0 版开始,Spring Security 大大改进了对为服务层方法增加安全性的支持.  它提供对 JSR-250 注解安全性以及框架原始 <code>@Secured</code> 注解的支持.  从 3.0 开始,您还可以使用新的<a href="#el-access">基于表达式的注解</a>.
您可以使用 <code>intercept-methods</code> 元素来修饰bean声明,从而将安全性应用于单个bean,或者可以使用 AspectJ 样式切入点在整个服务层中保护多个 bean.</p>
</div>
</div>
<div class="sect2">
<h3 id="ns-access-manager"><a class="anchor" href="#ns-access-manager"></a>18.5. 默认 AccessDecisionManager</h3>
<div class="paragraph">
<p>本部分假定您具有 Spring Security 中用于访问控制的基础架构的一些知识.  如果您不这样做,则可以跳过它,稍后再返回,因为此部分仅与需要进行一些自定义才能使用更多功能(而不是基于角色的简单安全性) 的人员有关.</p>
</div>
<div class="paragraph">
<p>当您使用命名空间配置时,<code>AccessDecisionManager</code> 的默认实例将自动为您注册,并将根据您在拦截 URL 和保护切入点声明中指定的访问属性,为方法调用和 Web URL 访问制定访问决策.  (如果使用的是注解安全方法,则在注解中) .</p>
</div>
<div class="paragraph">
<p>默认策略是将 <code>AffirmativeBased</code> <code>AccessDecisionManager</code> 与 <code>RoleVoter</code> 和 <code>AuthenticatedVoter</code> 一起使用.  您可以在<a href="#authz-arch">授权</a>一章中找到更多有关这些的信息.</p>
</div>
<div class="sect3">
<h4 id="ns-custom-access-mgr"><a class="anchor" href="#ns-custom-access-mgr"></a>18.5.1. 自定义 AccessDecisionManager</h4>
<div class="paragraph">
<p>如果您需要使用更复杂的访问控制策略,则可以轻松设置方法和 Web 安全性的替代方案.</p>
</div>
<div class="paragraph">
<p>为了实现方法安全,可以通过在应用程序上下文中将 <code>global-method-security</code> 上的 <code>access-decision-manager-ref</code> 属性设置为适当的 <code>AccessDecisionManager</code> bean 的 ID 来实现此目的:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;global-method-security access-decision-manager-ref="myAccessDecisionManagerBean"&gt;
...
&lt;/global-method-security&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Web安全性的语法相同,但是在 <code>http</code> 元素上:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;http access-decision-manager-ref="myAccessDecisionManagerBean"&gt;
...
&lt;/http&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="test"><a class="anchor" href="#test"></a>19. 测试</h2>
<div class="sectionbody">
<div class="paragraph">
<p>本节描述了 Spring Security 提供的测试支持.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要使用 Spring Security 测试支持,您必须包含 <code>spring-security-test-5.4.6.jar</code> 作为项目的依赖.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="test-method"><a class="anchor" href="#test-method"></a>19.1. 测试安全方法</h3>
<div class="paragraph">
<p>本节演示如何使用 Spring Security 的测试支持来测试基于方法的安全性。我们首先介绍一个 <code>MessageService</code>，它要求用户进行身份验证才能访问它.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class HelloMessageService implements MessageService {

    @PreAuthorize("authenticated")
    public String getMessage() {
        Authentication authentication = SecurityContextHolder.getContext()
            .getAuthentication();
        return "Hello " + authentication;
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>getMessage</code> 的结果是一个字符串,表示当前的 Spring Security <code>Authentication</code> 为  "Hello" . 输出示例如下所示.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Hello org.springframework.security.authentication.UsernamePasswordAuthenticationToken@ca25360: Principal: org.springframework.security.core.userdetails.User@36ebcb: Username: user; Password: [PROTECTED]; Enabled: true; AccountNonExpired: true; credentialsNonExpired: true; AccountNonLocked: true; Granted Authorities: ROLE_USER; Credentials: [PROTECTED]; Authenticated: true; Details: null; Granted Authorities: ROLE_USER</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="test-method-setup"><a class="anchor" href="#test-method-setup"></a>19.1.1. 安全测试设置</h4>
<div class="paragraph">
<p>在使用 Spring Security Test 支持之前,我们必须执行一些设置. 可以在下面看到一个示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class) <i class="conum" data-value="1"></i><b>(1)</b>
@ContextConfiguration <i class="conum" data-value="2"></i><b>(2)</b>
public class WithMockUserTests {
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是如何设置 Spring Security Test 的基本示例. 重点是:</p>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>@RunWith</code> 指示 <code>spring-test</code> 模块应该创建一个 <code>ApplicationContext</code>.  这与使用现有的Spring Test支持没有什么不同.  有关更多信息,请参考 <a href="https://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/htmlsingle/#integration-testing-annotations-standard">Spring Reference</a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>@ContextConfiguration</code> 指示弹簧测试配置用于创建 <code>ApplicationContext</code>.  由于未指定任何配置,因此将尝试使用默认配置位置.  这与使用现有的 Spring Test 支持没有什么不同.  有关更多信息,请参考 <a href="https://docs.spring.io/spring-framework/docs/4.0.x/spring-framework-reference/htmlsingle/#testcontext-ctx-management">Spring Reference</a></td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security 使用 <code>WithSecurityContextTestExecutionListener</code> 吸引了Spring Test的支持,这将确保我们的测试以正确的用户运行.  它通过在运行我们的测试之前填充 <code>SecurityContextHolder</code> 来实现.  如果您正在使用响应式方法安全性,则还需要 <code>ReactorContextTestExecutionListener</code> 来填充 <code>ReactiveSecurityContextHolder</code>.
测试完成后,它将清除 <code>SecurityContextHolder</code>.  如果只需要与 Spring Security 相关的支持,则可以将 <code>@ContextConfiguration</code> 替换为 <code>@SecurityTestExecutionListeners</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>记住,我们已将 <code>@PreAuthorize</code> 注解添加到我们的 <code>HelloMessageService</code> 中,因此需要经过身份验证的用户才能调用它. 如果我们运行以下测试,我们期望以下测试将通过:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test(expected = AuthenticationCredentialsNotFoundException.class)
public void getMessageUnauthenticated() {
    messageService.getMessage();
}
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-method-withmockuser"><a class="anchor" href="#test-method-withmockuser"></a>19.1.2. @WithMockUser</h4>
<div class="paragraph">
<p>问题是 "我们如何最轻松地以特定用户身份运行测试? " ,答案是使用 <code>@WithMockUser</code>. 以下测试将以用户名 "user",密码 "password" 和角色 "ROLE_USER" 的用户身份运行.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser
public void getMessageWithMockUser() {
String message = messageService.getMessage();
...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>具体来说,以下是正确的:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用户名 "user" 的用户不必存在,因为我们在模拟用户</p>
</li>
<li>
<p>在 <code>SecurityContext</code> 中填充的 <code>Authentication</code> 的类型为 <code>UsernamePasswordAuthenticationToken</code></p>
</li>
<li>
<p><code>Authentication</code> 的主体是 Spring Security 的 <code>User</code> 对象</p>
</li>
<li>
<p>用户将具有用户名 "user",密码 "password" ,并使用一个名为 "ROLE_USER" 的 <code>GrantedAuthority</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们的示例很好,因为我们能够利用很多默认值. 如果我们想使用其他用户名运行测试该怎么办? 以下测试将使用用户名 "customUser" 运行. 同样,用户不需要实际存在.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser("customUsername")
public void getMessageWithMockUserCustomUsername() {
    String message = messageService.getMessage();
...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以轻松地自定义角色. 例如,将使用用户名 "admin" 以及角色 "ROLE_USER" 和 "ROLE_ADMIN" 调用此测试.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser(username="admin",roles={"USER","ADMIN"})
public void getMessageWithMockUserCustomUser() {
    String message = messageService.getMessage();
    ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们不希望该值自动以 <code>ROLE_</code> 作为前缀,则可以利用 <code>Authority</code> 属性. 例如,将使用用户名 "admin" 以及权限 "USER" 和 "ADMIN" 调用此测试.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser(username = "admin", authorities = { "ADMIN", "USER" })
public void getMessageWithMockUserCustomAuthorities() {
    String message = messageService.getMessage();
    ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然,在每种测试方法上放置注解可能会有些乏味.  相反,我们可以将注解放置在类级别,并且每个测试都将使用指定的用户.  例如,下面的代码将使用用户名 "admin" ,密码 "password" 以及角色 "ROLE_USER" 和 "ROLE_ADMIN" 的用户运行每个测试.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@WithMockUser(username="admin",roles={"USER","ADMIN"})
public class WithMockUserTests {
</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下,在 <code>TestExecutionListener.beforeTestMethod</code> 事件期间设置 <code>SecurityContext</code>.  这相当于在JUnit的 <code>@Before</code> 之前发生.  您可以将其更改为在 <code>TestExecutionListener.beforeTestExecution</code> 事件期间发生,该事件在JUnit的 <code>@Before</code> 之后但在调用测试方法之前.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@WithMockUser(setupBefore = TestExecutionEvent.TEST_EXECUTION)
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-method-withanonymoususer"><a class="anchor" href="#test-method-withanonymoususer"></a>19.1.3. @WithAnonymousUser</h4>
<div class="paragraph">
<p>使用 <code>@WithAnonymousUser</code> 允许以匿名用户身份运行.  当您希望与特定用户一起运行大多数测试,但希望以匿名用户身份运行一些测试时,这特别方便.  例如,以下将使用 <a href="#test-method-withmockuser">@WithMockUser</a> 和匿名用户(匿名用户) 在 withMockUser1 和 withMockUser2 中运行.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringJUnit4ClassRunner.class)
@WithMockUser
public class WithUserClassLevelAuthenticationTests {

    @Test
    public void withMockUser1() {
    }

    @Test
    public void withMockUser2() {
    }

    @Test
    @WithAnonymousUser
    public void anonymous() throws Exception {
        // override default to run as anonymous user
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下,在 <code>TestExecutionListener.beforeTestMethod</code> 事件期间设置 <code>SecurityContext</code>.  这相当于在 JUnit 的 <code>@Before</code> 之前发生.  您可以将其更改为在 <code>TestExecutionListener.beforeTestExecution</code> 事件期间发生,该事件在 JUnit 的 <code>@Before</code> 之后但在调用测试方法之前.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@WithAnonymousUser(setupBefore = TestExecutionEvent.TEST_EXECUTION)
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-method-withuserdetails"><a class="anchor" href="#test-method-withuserdetails"></a>19.1.4. @WithUserDetails</h4>
<div class="paragraph">
<p>虽然 <code>@WithMockUser</code> 是一种非常方便的入门方法,但可能并非在所有情况下都有效.  例如,应用程序通常期望 <code>Authentication</code> 主体为特定类型.  这样做是为了使应用程序可以将委托人称为自定义类型,并减少 Spring Security 上的耦合.</p>
</div>
<div class="paragraph">
<p>自定义主体通常由自定义 <code>UserDetailsService</code> 返回,该 <code>UserDetailsService</code> 返回一个实现了 <code>UserDetails</code> 和自定义类型的对象.  在这种情况下,使用自定义 <code>UserDetailsService</code> 创建测试用户非常有用.  这正是 <code>@WithUserDetails</code> 所做的.</p>
</div>
<div class="paragraph">
<p>假设我们将 <code>UserDetailsService</code> 暴露为 Bean,将使用类型为 <code>UsernamePasswordAuthenticationToken</code> 的 <code>Authentication</code> 和从 <code>UserDetailsService</code> 返回且用户名为 "user" 的主体来调用以下测试.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
@WithUserDetails
public void getMessageWithUserDetails() {
    String message = messageService.getMessage();
    ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以自定义用于从 <code>UserDetailsService</code> 查找用户的用户名. 例如,将使用从 <code>UserDetailsService</code> 返回的用户名为 "customUsername" 的委托人执行此测试.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
@WithUserDetails("customUsername")
public void getMessageWithUserDetailsCustomUsername() {
    String message = messageService.getMessage();
    ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以提供一个明确的 bean 名称来查找 <code>UserDetailsService</code>. 例如,此测试将使用具有 bean 名称 <code>myUserDetailsService</code> 的 <code>UserDetailsService</code> 查找 "customUsername" 的用户名.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
@WithUserDetails(value="customUsername", userDetailsServiceBeanName="myUserDetailsService")
public void getMessageWithUserDetailsServiceBeanName() {
    String message = messageService.getMessage();
    ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>像 <code>@WithMockUser</code> 一样,我们也可以将注解放在类级别,以便每个测试都使用同一用户.  但是,与 <code>@WithMockUse</code> r不同,<code>@WithUserDetails</code> 要求用户存在.</p>
</div>
<div class="paragraph">
<p>默认情况下,在 <code>TestExecutionListener.beforeTestMethod</code> 事件期间设置 <code>SecurityContext</code>.  这相当于在 JUnit 的 <code>@Before</code> 之前发生.  您可以将其更改为在 <code>TestExecutionListener.beforeTestExecution</code> 事件期间发生,该事件在 JUnit 的 <code>@Before</code> 之后但在调用测试方法之前.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@WithUserDetails(setupBefore = TestExecutionEvent.TEST_EXECUTION)
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-method-withsecuritycontext"><a class="anchor" href="#test-method-withsecuritycontext"></a>19.1.5. @WithSecurityContext</h4>
<div class="paragraph">
<p>我们已经看到,如果不使用自定义身份验证主体,则 <code>@WithMockUser</code> 是一个很好的选择.  接下来,我们发现 <code>@WithUserDetails</code> 将允许我们使用自定义 <code>UserDetailsService</code> 来创建我们的身份验证主体,但需要用户存在.  现在,我们将看到一个具有最大灵活性的选项.</p>
</div>
<div class="paragraph">
<p>我们可以创建自己的注解,该注解使用 <code>@WithSecurityContext</code> 创建所需的任何 <code>SecurityContext</code>.  例如,我们可以创建一个名为 <code>@WithMockCustomUser</code> 的注解,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@WithSecurityContext(factory = WithMockCustomUserSecurityContextFactory.class)
public @interface WithMockCustomUser {

    String username() default "rob";

    String name() default "Rob Winch";
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以看到 <code>@WithMockCustomUser</code> 带有 <code>@WithSecurityContext</code> 注解.  这就是向 Spring Security Test 支持人员发出信号的信号,我们打算为该测试创建一个 <code>SecurityContext</code>.  <code>@WithSecurityContext</code> 注解要求我们指定一个 <code>SecurityContextFactory</code>,
它会在给定 <code>@WithMockCustomUser</code> 注解的情况下创建一个新的 <code>SecurityContext</code>.  您可以在下面找到我们的 <code>WithMockCustomUserSecurityContextFactory</code> 实现:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class WithMockCustomUserSecurityContextFactory
    implements WithSecurityContextFactory&lt;WithMockCustomUser&gt; {
    @Override
    public SecurityContext createSecurityContext(WithMockCustomUser customUser) {
        SecurityContext context = SecurityContextHolder.createEmptyContext();

        CustomUserDetails principal =
            new CustomUserDetails(customUser.name(), customUser.username());
        Authentication auth =
            new UsernamePasswordAuthenticationToken(principal, "password", principal.getAuthorities());
        context.setAuthentication(auth);
        return context;
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在,我们可以使用新的注解对测试类或测试方法进行注解,并且 Spring Security 的 <code>WithSecurityContextTestExecutionListener</code> 将确保正确填充我们的 <code>SecurityContext</code>.</p>
</div>
<div class="paragraph">
<p>创建自己的 <code>WithSecurityContextFactory</code> 实现时,很高兴知道可以使用标准的 Spring 注解对其进行注解.  例如,<code>WithUserDetailsSecurityContextFactory</code> 使用 <code>@Autowired</code> 注解来获取 <code>UserDetailsService</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">final class WithUserDetailsSecurityContextFactory
    implements WithSecurityContextFactory&lt;WithUserDetails&gt; {

    private UserDetailsService userDetailsService;

    @Autowired
    public WithUserDetailsSecurityContextFactory(UserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    public SecurityContext createSecurityContext(WithUserDetails withUser) {
        String username = withUser.value();
        Assert.hasLength(username, "value() must be non-empty String");
        UserDetails principal = userDetailsService.loadUserByUsername(username);
        Authentication authentication = new UsernamePasswordAuthenticationToken(principal, principal.getPassword(), principal.getAuthorities());
        SecurityContext context = SecurityContextHolder.createEmptyContext();
        context.setAuthentication(authentication);
        return context;
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下,在 <code>TestExecutionListener.beforeTestMethod</code> 事件期间设置 <code>SecurityContext</code>.  这相当于在 JUnit 的 <code>@Before</code> 之前发生.  您可以将其更改为在 <code>TestExecutionListener.beforeTestExecution</code> 事件期间发生,该事件在 JUnit 的 <code>@Before</code> 之后但在调用测试方法之前.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@WithSecurityContext(setupBefore = TestExecutionEvent.TEST_EXECUTION)
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="test-method-meta-annotations"><a class="anchor" href="#test-method-meta-annotations"></a>19.1.6. 测试元注解</h4>
<div class="paragraph">
<p>如果您经常在测试中重用同一用户,则不理想的是必须重复指定属性.  例如,如果有许多与用户名为 "admin" 且角色为 <code>ROLE_USER</code> 和 <code>ROLE_ADMIN</code> 的管理用户相关的测试,则您必须编写:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@WithMockUser(username="admin",roles={"USER","ADMIN"})
</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们可以使用元注解,而不是在所有地方重复此操作. 例如,我们可以创建一个名为 <code>WithMockAdmin</code> 的元注解:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Retention(RetentionPolicy.RUNTIME)
@WithMockUser(value="rob",roles="ADMIN")
public @interface WithMockAdmin { }
</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在,我们可以像使用更详细的 <code>@WithMockUser</code> 一样使用 <code>@WithMockAdmin</code> .</p>
</div>
<div class="paragraph">
<p>元注解可与上述任何测试注解一起使用.  例如,这意味着我们也可以为  <code>@WithUserDetails("admin")</code> 创建一个元注解.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test-mockmvc"><a class="anchor" href="#test-mockmvc"></a>19.2. Spring MVC 集成测试</h3>
<div class="paragraph">
<p>Spring Security 提供与 <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/html/testing.html#spring-mvc-test-framework">Spring MVC Test</a>的全面集成</p>
</div>
<div class="sect3">
<h4 id="test-mockmvc-setup"><a class="anchor" href="#test-mockmvc-setup"></a>19.2.1. 设置MockMvc和Spring Security</h4>
<div class="paragraph">
<p>为了将 Spring Security 与 Spring MVC Test 一起使用,有必要添加Spring Security <code>FilterChainProxy</code> 作为过滤器.  还必须添加 Spring Security 的 <code>TestSecurityContextHolderPostProcessor</code> 以支持在<a href="#test-mockmvc-securitycontextholder-a">带有注解的 Spring MVC 测试中以用户身份运行</a>.  可以使用 Spring Security 的 <code>SecurityMockMvcConfigurers.springSecurity()</code> 来完成.  例如:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security 的测试支持需要 spring-test-4.1.3.RELEASE 或更高版本.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import static org.springframework.security.test.web.servlet.setup.SecurityMockMvcConfigurers.*;

</span><span class="fold-block">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
@WebAppConfiguration
public class CsrfShowcaseTests {

    @Autowired
    private WebApplicationContext context;

    private MockMvc mvc;

    @Before
    public void setup() {
        mvc = MockMvcBuilders
                .webAppContextSetup(context)
                .apply(springSecurity()) <i class="conum" data-value="1"></i><b>(1)</b>
                .build();
    }

...
</span></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>SecurityMockMvcConfigurers.springSecurity()</code> 将执行我们将 Spring Security 与 Spring MVC Test 集成在一起所需的所有初始设置</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="test-mockmvc-smmrpp"><a class="anchor" href="#test-mockmvc-smmrpp"></a>19.2.2. SecurityMockMvcRequestPostProcessors</h4>
<div class="paragraph">
<p>Spring MVC Test 提供了一个方便的接口,称为 <code>RequestPostProcessor</code>,可用于修改请求.  Spring Security提供了许多 <code>RequestPostProcessor</code> 实现,这些实现使测试更加容易.  为了使用 Spring Security 的 <code>RequestPostProcessor</code> 实现,请确保使用以下静态导入:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import static org.springframework.security.test.web.servlet.request.SecurityMockMvcRequestPostProcessors.*;
</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="test-mockmvc-csrf"><a class="anchor" href="#test-mockmvc-csrf"></a>使用 CSRF 保护进行测试</h5>
<div class="paragraph">
<p>在测试任何非安全的 HTTP 方法并使用 Spring Security 的 CSRF 保护时,必须确保在请求中包括有效的 CSRF 令牌. 使用以下命令将有效的 CSRF 令牌指定为请求参数:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(post("/").with(csrf()))
</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果愿意,可以在标题中包含 CSRF 令牌:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(post("/").with(csrf().asHeader()))
</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以使用以下方法测试提供的 CSRF 令牌无效:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(post("/").with(csrf().useInvalidToken()))
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="test-mockmvc-securitycontextholder"><a class="anchor" href="#test-mockmvc-securitycontextholder"></a>在 Spring MVC 测试中以用户身份运行测试</h5>
<div class="paragraph">
<p>通常需要以特定用户身份运行测试.  填充用户有两种简单的方法:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#test-mockmvc-securitycontextholder-rpp">在 Spring MVC Test 中使用 RequestPostProcessor 以用户身份运行 </a></p>
</li>
<li>
<p><a href="#test-mockmvc-securitycontextholder-a">在带有注解的 Spring MVC 测试中以用户身份运行</a></p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="test-mockmvc-securitycontextholder-rpp"><a class="anchor" href="#test-mockmvc-securitycontextholder-rpp"></a>在 Spring MVC Test 中使用 RequestPostProcessor 以用户身份运行</h5>
<div class="paragraph">
<p>有许多选项可用于将用户与当前 <code>HttpServletRequest</code> 关联. 例如,以下将以用户名 "user",密码 "password" 和角色 "ROLE_USER" 的用户身份(不需要存在) 运行:</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该支持通过将用户与 <code>HttpServletRequest</code> 关联而起作用.  要将请求关联到 <code>SecurityContextHolder</code>,您需要确保 <code>SecurityContextPersistenceFilter</code> 与 <code>MockMvc</code> 实例关联.  实现此目的的几种方法是:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>调用 <a href="#test-mockmvc-setup">apply(springSecurity())</a></p>
</li>
<li>
<p>将 Spring Security 的 <code>FilterChainProxy</code> 添加到 <code>MockMvc</code></p>
</li>
<li>
<p>使用 <code>MockMvcBuilders.standaloneSetup</code> 时,将 <code>SecurityContextPersistenceFilter</code> 手动添加到 <code>MockMvc</code> 实例可能很有意义.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/").with(user("user")))
</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以轻松进行自定义. 例如,以下用户名(管理员) ,用户名 "admin", 密码 "pass" 以及角色 "ROLE_USER 和 "ROLE_ADMIN" 将作为用户(不需要存在) 运行.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/admin").with(user("admin").password("pass").roles("USER","ADMIN")))
</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您有要使用的自定义 <code>UserDetails</code>,则也可以轻松指定它.  例如,下面的代码将使用指定的 <code>UserDetails</code>(不需要存在) 来运行具有指定 <code>UserDetails</code> 主体的 <code>UsernamePasswordAuthenticationToken</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/").with(user(userDetails)))
</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以使用以下身份以匿名用户身份运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/").with(anonymous()))
</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果您使用默认用户运行,并希望以匿名用户身份执行一些请求,则此功能特别有用.</p>
</div>
<div class="paragraph">
<p>如果需要自定义身份验证(不需要存在) ,可以使用以下方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/").with(authentication(authentication)))
</code></pre>
</div>
</div>
<div class="paragraph">
<p>您甚至可以使用以下方法自定义 <code>SecurityContext</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/").with(securityContext(securityContext)))
</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过使用 <code>MockMvcBuilders</code> 的默认请求,我们还可以确保针对每个请求以特定用户身份运行.  例如,以下用户名(管理员) ,用户名 "admin",密码 "password", 和角色 "ROLE_ADMIN" 将作为用户(不需要存在) 运行:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc = MockMvcBuilders
        .webAppContextSetup(context)
        .defaultRequest(get("/").with(user("user").roles("ADMIN")))
        .apply(springSecurity())
        .build();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果发现您在许多测试中使用的是同一用户,建议将用户移至某个方法. 例如,您可以在自己的名为 <code>CustomSecurityMockMvcRequestPostProcessors</code> 的类中指定以下内容:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public static RequestPostProcessor rob() {
    return user("rob").roles("ADMIN");
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在,您可以在 <code>SecurityMockMvcRequestPostProcessors</code> 上执行静态导入,并在测试中使用它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import static sample.CustomSecurityMockMvcRequestPostProcessors.*;

</span><span class="fold-block">...

mvc
    .perform(get("/").with(rob()))
</span></code></pre>
</div>
</div>
<div class="sect5">
<h6 id="test-mockmvc-securitycontextholder-a"><a class="anchor" href="#test-mockmvc-securitycontextholder-a"></a>在带有注解的 Spring MVC 测试中以用户身份运行</h6>
<div class="paragraph">
<p>除了使用 <code>RequestPostProcessor</code> 创建用户之外,还可以使用<a href="#jc-erms">测试方法安全性</a>所述的注解.  例如,以下将对具有用户名 "user",密码 "password" 和角色 "ROLE_USER" 的用户运行测试:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser
public void requestProtectedUrlWithUser() throws Exception {
mvc
        .perform(get("/"))
        ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者,以下将使用用户名 "user",密码 "password" 和角色 "ROLE_ADMIN" 的用户运行测试:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
@WithMockUser(roles="ADMIN")
public void requestProtectedUrlWithUser() throws Exception {
mvc
        .perform(get("/"))
        ...
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="测试-http-基本身份验证"><a class="anchor" href="#测试-http-基本身份验证"></a>测试 HTTP 基本身份验证</h5>
<div class="paragraph">
<p>虽然始终可以使用 HTTP Basic 进行身份验证,但是记住 header 名称,格式和对值进行编码有点繁琐.  现在,可以使用 Spring Security 的 <code>httpBasic</code> <code>RequestPostProcessor</code> 完成此操作.  例如,以下代码段:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/").with(httpBasic("user","password")))
</code></pre>
</div>
</div>
<div class="paragraph">
<p>将通过确保在 HTTP 请求上填充以下 header ,尝试使用 HTTP Basic 对用户名 "user" 和密码 "password" 进行身份验证:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Authorization: Basic dXNlcjpwYXNzd29yZA==</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testing-oauth2"><a class="anchor" href="#testing-oauth2"></a>测试 OAuth 2.0</h5>
<div class="paragraph">
<p>当涉及到 OAuth 2.0 时,仍然可以使用前面介绍的相同原理: 最终,它取决于您所测试的方法期望 <code>在SecurityContextHolder</code> 中使用什么.</p>
</div>
<div class="paragraph">
<p>例如,对于如下所示的控制器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public String foo(Principal user) {
    return user.getName();
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有关于 OAuth2 的特定信息,因此您可能只需使 <code>用@WithMockUser</code> 就可以了.</p>
</div>
<div class="paragraph">
<p>但是,如果您的控制器绑定到 Spring Security 的 OAuth 2.0 支持的某些方面,例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OidcUser user) {
    return user.getIdToken().getSubject();
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后 Spring Security 的测试支持将派上用场.</p>
</div>
</div>
<div class="sect4">
<h5 id="testing-oidc-login"><a class="anchor" href="#testing-oidc-login"></a>Testing OIDC Login</h5>
<div class="paragraph">
<p>使用 Spring MVC Test 测试上述方法将需要使用授权服务器模拟授权流程. 当然,这将是一项艰巨的任务,这就是 Spring Security 测试支持可以帮助删除大部分样板代码.</p>
</div>
<div class="paragraph">
<p>例如,我们可以使用  <code>SecurityMockServerConfigurers#oidcLogin</code> 方法告诉 Spring Security 包含默认的 <code>OidcUser</code>,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint").with(oidcLogin()));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使用的 <code>MockHttpServletRequest</code> 创建关联的 <code>OidcUser</code> ,该 <code>OidcUser</code> 包括的一个模拟的 <code>OidcIdToken</code>,模拟 <code>OidcUserInfo</code> 和一个模拟的授权集合.</p>
</div>
<div class="paragraph">
<p>具体来说,它将包括一个 <code>OidcIdToken</code>,并为用户设置了一个 claim</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(user.getIdToken().getClaim("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有 claims 的 <code>OidcUserInfo</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(user.getUserInfo().getClaims()).isEmpty();</code></pre>
</div>
</div>
<div class="paragraph">
<p>和只有一个权限 <code>SCOPE_read</code> 的权限集合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security 做了必要的工作,以确保 <code>OidcUser</code> 实例可用于  <a href="#mvc-authentication-principal"><code>@AuthenticationPrincipal</code> 注解</a>.</p>
</div>
<div class="paragraph">
<p>此外,它还将 <code>OidcUser</code> 链接到 <code>OAuth2AuthorizedClient</code> 的简单实例,并将其注入模拟的 <code>OAuth2AuthorizedClientRepository</code>. 如果您的测试 <a href="#testing-oauth2-client">使用 <code>@RegisteredOAuth2AuthorizedClient</code> 注解</a>,则此方法很方便.</p>
</div>
<div class="sect5">
<h6 id="testing-oidc-login-authorities"><a class="anchor" href="#testing-oidc-login-authorities"></a>配置权限</h6>
<div class="paragraph">
<p>在许多情况下,您的方法受到过滤器或安全方法的保护,并且需要您的身份验证具有某些授予的权限才能允许该请求.</p>
</div>
<div class="paragraph">
<p>在这种情况下,您可以使用 <code>authorities()</code> 方法提供所需的已授予权限:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(oidcLogin()
            .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
        )
    );
</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-oidc-login-claims"><a class="anchor" href="#testing-oidc-login-claims"></a>配置 Claims</h6>
<div class="paragraph">
<p>尽管授予的权限在整个 Spring Security 中非常普遍,但在 OAuth 2.0 方面我们也有主张.</p>
</div>
<div class="paragraph">
<p>举例来说,假设您有一个 <code>user_id</code> 声明,该声明指出了系统中的用户 ID. 您可以像在控制器中那样访问它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OidcUser oidcUser) {
    String userId = oidcUser.getIdToken().getClaim("user_id");
    // ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,您需要使用  <code>idToken()</code>  方法指定该声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(oidcLogin()
                .idToken(token -&gt; token.claim("user_id", "1234"))
        )
    );
</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为 <code>OidcUser</code> 从 <code>OidcIdToken</code> 收集了其 claims.</p>
</div>
</div>
<div class="sect5">
<h6 id="testing-oidc-login-user"><a class="anchor" href="#testing-oidc-login-user"></a>其他配置</h6>
<div class="paragraph">
<p>还有其他方法可用于进一步配置身份验证. 它仅取决于您的控制器需要什么数据:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>userInfo(OidcUserInfo.Builder)</code> - 配置 <code>OidcUserInfo</code> 实例</p>
</li>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - 使用已有 <code>ClientRegistration</code> 关联 <code>OAuth2AuthorizedClient</code></p>
</li>
<li>
<p><code>oidcUser(OidcUser)</code> - 用于配置完整的 <code>OidcUser</code> 实例</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您:
1. 有自己的 <code>OidcUser</code> 的实现,
2. 需要更改 name 属性</p>
</div>
<div class="paragraph">
<p>例如,假设您的授权服务器在 <code>user_name</code> claim 中发送主体名称,而不在 <code>sub</code> claim 中发送主体名称. 在这种情况下,您可以手动配置 <code>OidcUser</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OidcUser oidcUser = new DefaultOidcUser(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

mvc
    .perform(get("/endpoint")
        .with(oidcLogin().oidcUser(oidcUser))
    );
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testing-oauth2-login"><a class="anchor" href="#testing-oauth2-login"></a>测试 OAuth 2.0 登录</h5>
<div class="paragraph">
<p>与 <a href="#testing-oidc-login">测试 OIDC 登录</a> 一样,测试 OAuth 2.0 登录也面临着类似需要模拟授权流程挑战. 因此,Spring Security 还对非 OIDC 用例提供了测试支持.</p>
</div>
<div class="paragraph">
<p>假设我们有一个控制器,可以将登录用户作为 <code>OAuth2User</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    return oauth2User.getAttribute("sub");
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,我们可以告诉 Spring Security 使用  <code>SecurityMockMvcRequestPostProcessors#oauth2User</code> 方法包含一个默认的 <code>OAuth2User</code>,就像这样</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint").with(oauth2Login()));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使用 <code>OAuth2User</code> 配置关联的 <code>MockHttpServletRequest</code>,该 <code>OAuth2User</code> 包括简单的属性映射和已授予权限的集合.</p>
</div>
<div class="paragraph">
<p>具体来说,它将包括一个带有 <code>sub</code>/<code>user</code> 的键值对:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat((String) user.getAttribute("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>和只有一个权限 <code>SCOPE_read</code> 的权限集合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security 做了必要的工作,以确保 <code>OAuth2User</code> 实例可用于  <a href="#mvc-authentication-principal"><code>@AuthenticationPrincipal</code> 注解</a>.</p>
</div>
<div class="paragraph">
<p>此外,它还将 <code>OAuth2User</code> 链接到 <code>OAuth2AuthorizedClient</code> 的简单实例,并将其注入模拟的 <code>OAuth2AuthorizedClientRepository</code> 中. 如果您的测试使用 <a href="#testing-oauth2-client">使用 <code>@RegisteredOAuth2AuthorizedClient</code> 注解</a> ,则这会很方便.</p>
</div>
<div class="sect5">
<h6 id="testing-oauth2-login-authorities"><a class="anchor" href="#testing-oauth2-login-authorities"></a>配置权限</h6>
<div class="paragraph">
<p>在许多情况下,您的方法受到过滤器或安全方法的保护,并且需要 <code>Authentication</code> 具有某些授予的权限才能允许该请求.</p>
</div>
<div class="paragraph">
<p>在这种情况下,您可以使用 <code>authorities()</code> 方法提供所需的已授予权限:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(oauth2Login()
            .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
        )
    );
</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-oauth2-login-claims"><a class="anchor" href="#testing-oauth2-login-claims"></a>配置 Claims</h6>
<div class="paragraph">
<p>尽管授予的权限在整个 Spring Security 中非常普遍,但在 OAuth 2.0 方面我们也有主张.</p>
</div>
<div class="paragraph">
<p>举例来说,假设您有一个 <code>user_id</code> 声明,该声明指出了系统中的用户 ID. 您可以像在控制器中那样访问它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public String foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    String userId = oauth2User.getAttribute("user_id");
    // ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,您需要使用  <code>attributes()</code> 方法指定该属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(oauth2Login()
                .attributes(attrs -&gt; attrs.put("user_id", "1234"))
        )
    );
</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-oauth2-login-user"><a class="anchor" href="#testing-oauth2-login-user"></a>其他配置</h6>
<div class="paragraph">
<p>还有其他方法可用于进一步配置身份验证. 它仅取决于您的控制器需要什么数据:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - 使用已有 <code>ClientRegistration</code> 关联 <code>OAuth2AuthorizedClient</code></p>
</li>
<li>
<p><code>oidcUser(OAuth2User)</code> - 用于配置完整的 <code>OAuth2User</code> 实例</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您:
1. 有自己的 <code>OAuth2User</code> 的实现,
2. 需要更改 name 属性</p>
</div>
<div class="paragraph">
<p>例如,假设您的授权服务器在 <code>user_name</code> claim 中发送主体名称,而不在 <code>sub</code> claim 中发送主体名称. 在这种情况下,您可以手动配置 <code>OAuth2User</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OAuth2User oauth2User = new DefaultOAuth2User(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

mvc
    .perform(get("/endpoint")
        .with(oauth2Login().oauth2User(oauth2User))
    );
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testing-oauth2-client"><a class="anchor" href="#testing-oauth2-client"></a>测试 OAuth 2.0 客户端</h5>
<div class="paragraph">
<p>与用户的身份验证方式无关,对于正在测试的请求,您可能还有其他令牌和客户端注册在起作用. 例如,您的控制器可能依赖于客户端凭据授予来获取与用户完全不相关的令牌:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">@GetMapping("/endpoint")
public String foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    return this.webClient.get()
        .attributes(oauth2AuthorizedClient(authorizedClient))
        .retrieve()
        .bodyToMono(String.class)
        .block();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用授权服务器模拟此握手可能很麻烦. 相反,可以使用 <code>SecurityMockServerConfigurers#oauth2Client</code> 将 <code>OAuth2AuthorizedClient</code> 添加到 <code>OAuth2AuthorizedClientRepository</code> 中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint").with(oauth2Client("my-app")));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将创建一个具有简单 <code>ClientRegistration</code>,<code>OAuth2AccessToken</code> 和资源所有者名称的 <code>OAuth2AuthorizedClient</code>.</p>
</div>
<div class="paragraph">
<p>具体来说,它将包括一个 <code>ClientRegistration</code>,其客户端 ID 为 "test-client",客户端密码为 "test-secret":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(authorizedClient.getClientRegistration().getClientId()).isEqualTo("test-client");
assertThat(authorizedClient.getClientRegistration().getClientSecret()).isEqualTo("test-secret");</code></pre>
</div>
</div>
<div class="paragraph">
<p>资源所有者名字 "user":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(authorizedClient.getPrincipalName()).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>OAuth2AccessToken</code> 只包含一个权限, <code>read</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(authorizedClient.getAccessToken().getScopes()).hasSize(1);
assertThat(authorizedClient.getAccessToken().getScopes()).containsExactly("read");</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以在控制器方法中使用 <code>@RegisteredOAuth2AuthorizedClient</code> 正常检索客户端.</p>
</div>
<div class="sect5">
<h6 id="testing-oauth2-client-scopes"><a class="anchor" href="#testing-oauth2-client-scopes"></a>配置 Scopes</h6>
<div class="paragraph">
<p>在许多情况下,OAuth 2.0 访问令牌都带有一组范围.如果您的控制器检查了这些,如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">@GetMapping("/endpoint")
public String foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    Set&lt;String&gt; scopes = authorizedClient.getAccessToken().getScopes();
    if (scopes.contains("message:read")) {
        return this.webClient.get()
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono(String.class)
            .block();
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您可以使用  <code>accessToken()</code> 方法配置范围:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(oauth2Client("my-app")
            .accessToken(new OAuth2AccessToken(BEARER, "token", null, null, Collections.singleton("message:read"))))
        )
    );
</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-oauth2-client-registration"><a class="anchor" href="#testing-oauth2-client-registration"></a>其他配置</h6>
<div class="paragraph">
<p>还有其他方法可用于进一步配置身份验证. 它仅取决于您的控制器需要什么数据:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>principalName(String)</code> - 资源所有者名字</p>
</li>
<li>
<p><code>clientRegistration(Consumer&lt;ClientRegistration.Builder&gt;)</code> - 用于配置相关的 <code>ClientRegistration</code></p>
</li>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - 配置完整的 <code>ClientRegistration</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您想使用真实的 <code>ClientRegistration</code>,那么最后一个方便</p>
</div>
<div class="paragraph">
<p>例如,假设您要使用 <code>application.yml</code> 中定义的 <code>ClientRegistration</code> .</p>
</div>
<div class="paragraph">
<p>在这种情况下,您的测试可以自动连接 <code>ClientRegistrationRepository</code> 并查找您的测试所需的一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowired
ClientRegistrationRepository clientRegistrationRepository;

// ...

mvc
    .perform(get("/endpoint")
        .with(oauth2Client()
            .clientRegistration(this.clientRegistrationRepository.findByRegistrationId("facebook"))));
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testing-jwt"><a class="anchor" href="#testing-jwt"></a>测试 JWT 认证</h5>
<div class="paragraph">
<p>为了在资源服务器上发出授权请求,您需要一个承载令牌.</p>
</div>
<div class="paragraph">
<p>如果为JWT配置了资源服务器,则这意味着需要对承载令牌进行签名,然后根据 JWT 规范进行编码.  所有这些都可能令人生畏,尤其是当这不是您的测试重点时.</p>
</div>
<div class="paragraph">
<p>幸运的是,您可以通过许多简单的方法来克服此难题,并使您的测试专注于授权而不是表示承载令牌.  现在我们来看其中两个:</p>
</div>
<div class="sect5">
<h6 id="jwt-requestpostprocessor"><a class="anchor" href="#jwt-requestpostprocessor"></a><code>jwt() RequestPostProcessor</code></h6>
<div class="paragraph">
<p>第一种方法是通过 <code>RequestPostProcessor</code>.  其中最简单的如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint").with(jwt()));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将创建一个模拟的 <code>Jwt</code>,并将其正确地通过任何身份验证 API 传递,以便可用于您的授权机制进行验证.</p>
</div>
<div class="paragraph">
<p>默认情况下,它创建的 <code>JWT</code> 具有以下特征:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "headers" : { "alg" : "none" },
  "claims" : {
    "sub" : "user",
    "scope" : "read"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>经过测试的结果 <code>Jwt</code> 将通过以下方式通过:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">assertThat(jwt.getTokenValue()).isEqualTo("token");
assertThat(jwt.getHeaders().get("alg")).isEqualTo("none");
assertThat(jwt.getSubject()).isEqualTo("sub");
GrantedAuthority authority = jwt.getAuthorities().iterator().next();
assertThat(authority.getAuthority()).isEqualTo("read");
</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然可以配置这些值.</p>
</div>
<div class="paragraph">
<p>可以使用其相应的方法配置任何标题或声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt -&gt; jwt.header("kid", "one").claim("iss", "https://idp.example.org"))));
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt -&gt; jwt.claims(claims -&gt; claims.remove("scope")))));
</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>scope</code> 和 <code>scp</code> claims 在这里的处理方式与它们在普通承载令牌请求中的处理方式相同.  但是,可以通过提供测试所需的 <code>GrantedAuthority</code> 实例列表来覆盖此方法:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(jwt().authorities(new SimpleGrantedAuthority("SCOPE_messages"))));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者,如果您有一个自定义的 <code>Jwt</code> to  <code>Collection&lt;GrantedAuthority&gt;</code> 转换器,则还可以使用它来导出权限:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(jwt().authorities(new MyConverter())));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以指定一个完整的 <code>Jwt</code>,为此 <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/jwt/Jwt.Builder.html">Jwt.Builder</a></code> 非常方便:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .claim("scope", "read");

mvc
    .perform(get("/endpoint")
        .with(jwt().jwt(jwt)));
</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="authentication-requestpostprocessor"><a class="anchor" href="#authentication-requestpostprocessor"></a><code>authentication()</code> <code>RequestPostProcessor</code></h6>
<div class="paragraph">
<p>第二种方法是通过使用  <code>authentication()</code> <code>RequestPostProcessor</code>.  本质上,您可以实例化自己的 <code>JwtAuthenticationToken</code> 并在测试中提供它,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .build();
Collection&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList("SCOPE_read");
JwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities);

mvc
    .perform(get("/endpoint")
        .with(authentication(token)));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意,作为替代方法,您还可以使用 <code>@MockBean</code> 注解来模拟 <code>JwtDecoder</code> bean本身.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="testing-opaque-token"><a class="anchor" href="#testing-opaque-token"></a>测试 Opaque Token 认证</h5>
<div class="paragraph">
<p>与 <a href="#testing-jwt">JWTs</a> 相似,不透明令牌需要授权服务器才能验证其有效性,这会使测试更加困难. 为了解决这个问题,Spring Security 提供了对不透明令牌的测试支持.</p>
</div>
<div class="paragraph">
<p>假设我们有一个控制器,可以将身份验证作为 <code>BearerTokenAuthentication</code> 进行检索:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public String foo(BearerTokenAuthentication authentication) {
    return (String) authentication.getTokenAttributes("sub");
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,我们可以使用 <code>SecurityMockMvcRequestPostProcessors#opaqueToken</code>  方法告诉 Spring Security 包含默认的 <code>BearerTokenAuthentication</code>,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint").with(opaqueToken()));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使用 <code>BearerTokenAuthentication</code> 配置关联的 <code>MockHttpServletRequest</code>,该 <code>BearerTokenAuthentication</code> 包括简单的 <code>OAuth2AuthenticatedPrincipal</code>,属性映射和授予的权限集合.</p>
</div>
<div class="paragraph">
<p>具体来说,它将包括一个带有 <code>sub</code>/<code>user</code> 键值对:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat((String) token.getTokenAttributes().get("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>和只有一个权限 <code>SCOPE_read</code> 的权限集合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(token.getAuthorities()).hasSize(1);
assertThat(token.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security 做了必要的工作,以确保 <code>BearerTokenAuthentication</code> 实例可用于您的控制器方法.</p>
</div>
<div class="sect5">
<h6 id="testing-opaque-token-authorities"><a class="anchor" href="#testing-opaque-token-authorities"></a>Configuring Authorities</h6>
<div class="paragraph">
<p>在许多情况下,您的方法受到过滤器或安全方法的保护,并且需要 <code>Authentication</code> 具有某些授予的权限才能允许该请求.</p>
</div>
<div class="paragraph">
<p>在这种情况下,您可以使用 <code>authorities()</code> 方法提供所需的已授予权限:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(opaqueToken()
            .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
        )
    );
</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-opaque-token-attributes"><a class="anchor" href="#testing-opaque-token-attributes"></a>配置 Claims</h6>
<div class="paragraph">
<p>尽管授予的权限在整个 Spring Security 中非常普遍,但在 OAuth 2.0 方面我们也有主张.</p>
</div>
<div class="paragraph">
<p>举例来说,假设您有一个 <code>user_id</code> 声明,该声明指出了系统中的用户 ID. 您可以像在控制器中那样访问它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public String foo(BearerTokenAuthentication authentication) {
    String userId = (String) authentication.getTokenAttributes().get("user_id");
    // ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,您需要使用  <code>attributes()</code> 方法指定该属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(get("/endpoint")
        .with(opaqueToken()
                .attributes(attrs -&gt; attrs.put("user_id", "1234"))
        )
    );
</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="testing-opaque-token-principal"><a class="anchor" href="#testing-opaque-token-principal"></a>其他配置</h6>
<div class="paragraph">
<p>还有其他方法可用于进一步配置身份验证. 它仅取决于您的控制器需要什么数据:</p>
</div>
<div class="paragraph">
<p><code>principal(OAuth2AuthenticatedPrincipal)</code> 就是这样的一种,您可以使用它来配置作为 <code>BearerTokenAuthentication</code> 基础的完整 <code>OAuth2AuthenticatedPrincipal</code> 实例.</p>
</div>
<div class="paragraph">
<p>如果您:
1. 有自己的 <code>OAuth2AuthenticatedPrincipal</code> 实现, 或者
2. 想指定 principal 名字</p>
</div>
<div class="paragraph">
<p>例如,假设您的授权服务器在 <code>user_name</code> claim 中发送主体名称,而不在 <code>sub</code> claim 中发送主体名称. 在这种情况下,您可以手动配置 <code>OAuth2AuthenticatedPrincipal</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Map&lt;String, Object&gt; attributes = Collections.singletonMap("user_name", "foo_user");
OAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal(
        (String) attributes.get("user_name"),
        attributes,
        AuthorityUtils.createAuthorityList("SCOPE_message:read"));

mvc
    .perform(get("/endpoint")
        .with(opaqueToken().principal(principal))
    );
</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意,作为使用  <code>mockOpaqueToken()</code> 测试支持的替代方法,您还可以使用 <code>@MockBean</code> 注解来模拟 <code>OpaqueTokenIntrospector</code> bean 本身.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="test-logout"><a class="anchor" href="#test-logout"></a>测试注销</h5>
<div class="paragraph">
<p>使用标准的 Spring MVC 测试相当简单,但您可以使用 Spring Security 的测试支持来简化测试注销.  例如,以下代码将使用有效的CSRF令牌向 "/logout" 提交 POST:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(logout())
</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以自定义要发布到的 URL.  例如,下面的代码片段将使用有效的 CSRF 令牌向 "/signout" 提交 POST:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(logout("/signout"))
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="securitymockmvcresultmatchers"><a class="anchor" href="#securitymockmvcresultmatchers"></a>19.2.3. SecurityMockMvcResultMatchers</h4>
<div class="paragraph">
<p>有时希望对请求做出各种与安全性有关的断言.  为了满足这一需求,Spring Security Test 支持实现了 Spring MVC Test 的 <code>ResultMatcher</code> 接口.  为了使用 Spring Security 的 <code>ResultMatcher</code> 实现,请确保使用以下静态导入:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import static org.springframework.security.test.web.servlet.response.SecurityMockMvcResultMatchers.*;
</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="未经身份验证的断言"><a class="anchor" href="#未经身份验证的断言"></a>未经身份验证的断言</h5>
<div class="paragraph">
<p>有时断言没有与 <code>MockMvc</code> 调用的结果相关联的经过身份验证的用户可能很有价值.  例如,您可能要测试提交的用户名和密码无效,并验证没有用户通过身份验证.  您可以使用 Spring Security 的测试支持轻松地执行以下操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(formLogin().password("invalid"))
    .andExpect(unauthenticated());
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="认证断言"><a class="anchor" href="#认证断言"></a>认证断言</h5>
<div class="paragraph">
<p>通常,我们必须断言已通过身份验证的用户存在.  例如,我们可能要验证我们已成功验证.  我们可以使用以下代码片段来验证基于表单的登录是否成功:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(formLogin())
    .andExpect(authenticated());
</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们想断言用户的角色,我们可以优化我们以前的代码,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(formLogin().user("admin"))
    .andExpect(authenticated().withRoles("USER","ADMIN"));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者,我们可以验证用户名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(formLogin().user("admin"))
    .andExpect(authenticated().withUsername("admin"));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以结合以下断言:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(formLogin().user("admin").roles("USER","ADMIN"))
    .andExpect(authenticated().withUsername("admin"));
</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们还可以对身份验证进行任意断言</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">mvc
    .perform(formLogin())
    .andExpect(authenticated().withAuthentication(auth -&gt;
        assertThat(auth).isInstanceOf(UsernamePasswordAuthenticationToken.class)));
</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="crypto"><a class="anchor" href="#crypto"></a>20. Spring Security 加密 模块</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="spring-security-crypto-introduction"><a class="anchor" href="#spring-security-crypto-introduction"></a>20.1. 简介</h3>
<div class="paragraph">
<p>Spring Security Crypto 模块提供对对称加密,密钥生成和密码编码的支持.  该代码作为核心模块的一部分分发,但与任何其他 Spring Security (或 Spring) 代码无关.</p>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-crypto-encryption"><a class="anchor" href="#spring-security-crypto-encryption"></a>20.2. Encryptors(加密器)</h3>
<div class="paragraph">
<p><code>Encryptors</code> 类提供了用于构造对称加密器的工厂方法.  使用此类,您可以创建 <code>ByteEncryptor</code> 来以原始 <code>byte[]</code> 形式加密数据.  您还可以构造 <code>TextEncryptor</code> 来加密文本字符串.  加密器是线程安全的.</p>
</div>
<div class="sect3">
<h4 id="spring-security-crypto-encryption-bytes"><a class="anchor" href="#spring-security-crypto-encryption-bytes"></a>20.2.1. BytesEncryptor</h4>
<div class="paragraph">
<p>使用 <code>Encryptors.stronger</code> 工厂方法来构造 <code>BytesEncryptor</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 168. BytesEncryptor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Encryptors.stronger("password", "salt");
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">Encryptors.stronger("password", "salt")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>"stronger" 加密方法是使用 Galois Counter Mode (GCM) 的256位AES. 它使用 PKCS#5 的 PBKDF2(基于密码的密钥扩展功能#2) 的密钥. 此方法需要 Java6. 用于生成 SecretKey 的密码应保存在安全的地方,并且不能共享.  如果您的加密数据遭到破坏,该盐可用于防止针对密钥的字典攻击.  还应用了 16 字节的随机初始化向量,因此每个加密的消息都是唯一的.</p>
</div>
<div class="paragraph">
<p>提供的盐应采用十六进制编码的字符串形式,并且是随机的,并且长度至少为 8 个字节.  可以使用 KeyGenerator 生成这种盐:</p>
</div>
<div class="exampleblock">
<div class="title">Example 169. Generating a key</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">String salt = KeyGenerators.string().generateKey(); // generates a random 8-byte salt that is then hex-encoded
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val salt = KeyGenerators.string().generateKey() // generates a random 8-byte salt that is then hex-encoded</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>用户还可以使用 standard 加密方法,即  Cipher Block Chaining (CBC) 模式下的 256 位 AES. 此模式未经  <a href="https://en.wikipedia.org/wiki/Authenticated_encryption">authenticated</a>,不提供有关数据真实性的任何保证. 为了获得更安全的选择,用户应首选 <code>Encryptors.stronger</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="spring-security-crypto-encryption-text"><a class="anchor" href="#spring-security-crypto-encryption-text"></a>20.2.2. TextEncryptor</h4>
<div class="paragraph">
<p>使用 <code>Encryptors.text</code> 工厂方法构造一个标准的 <code>TextEncryptor</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 170. TextEncryptor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Encryptors.text("password", "salt");
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">Encryptors.text("password", "salt")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>TextEncryptor 使用标准的 BytesEncryptor 来加密文本数据.  加密结果以十六进制编码的字符串形式返回,以便于存储在文件系统或数据库中.</p>
</div>
<div class="paragraph">
<p>使用 Encryptors.queryableText 工厂方法构造一个 "queryable" TextEncryptor:</p>
</div>
<div class="exampleblock">
<div class="title">Example 171. Queryable TextEncryptor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Encryptors.queryableText("password", "salt");
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">Encryptors.queryableText("password", "salt")</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可查询的 TextEncryptor 与标准 TextEncryptor 之间的区别与初始化向量(iv) 处理有关.  可查询 TextEncryptor#encrypt 操作中使用的 iv 是共享的或常量,并且不会随机生成.  这意味着多次加密相同的文本将始终产生相同的加密结果.  这不太安全,但是对于需要查询的加密数据来说是必需的.  可查询的加密文本的一个示例是 OAuth apiKey.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-crypto-keygenerators"><a class="anchor" href="#spring-security-crypto-keygenerators"></a>20.3. 密钥生成器</h3>
<div class="paragraph">
<p>KeyGenerators 类为构造不同类型的密钥生成器提供了许多便利的工厂方法.  使用此类,您可以创建一个 BytesKeyGenerator 来生成byte[] 键.  您还可以构造一个 StringKeyGenerator 来生成字符串键.  KeyGenerators 是线程安全的.</p>
</div>
<div class="sect3">
<h4 id="byteskeygenerator"><a class="anchor" href="#byteskeygenerator"></a>20.3.1. BytesKeyGenerator</h4>
<div class="paragraph">
<p>使用 <code>KeyGenerators.secureRandom</code> 工厂方法来生成由 SecureRandom 实例支持的 BytesKeyGenerator:</p>
</div>
<div class="exampleblock">
<div class="title">Example 172. BytesKeyGenerator</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">BytesKeyGenerator generator = KeyGenerators.secureRandom();
byte[] key = generator.generateKey();
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val generator = KeyGenerators.secureRandom()
val key = generator.generateKey()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>默认密钥长度为 8 个字节. 还有一个 KeyGenerators.secureRandom 变体,可以控制密钥长度:</p>
</div>
<div class="exampleblock">
<div class="title">Example 173. KeyGenerators.secureRandom</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">KeyGenerators.secureRandom(16);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">KeyGenerators.secureRandom(16)</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>KeyGenerators.shared</code> 工厂方法构造一个 <code>BytesKeyGenerator</code>,该每次调用总是返回相同的密钥:</p>
</div>
<div class="exampleblock">
<div class="title">Example 174. KeyGenerators.shared</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">KeyGenerators.shared(16);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">KeyGenerators.shared(16)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="stringkeygenerator"><a class="anchor" href="#stringkeygenerator"></a>20.3.2. StringKeyGenerator</h4>
<div class="paragraph">
<p>使用 KeyGenerators.string 工厂方法来构造一个 8 字节的 SecureRandom KeyGenerator,该十六进制将每个密钥编码为字符串:</p>
</div>
<div class="exampleblock">
<div class="title">Example 175. StringKeyGenerator</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">KeyGenerators.string();
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">KeyGenerators.string()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="spring-security-crypto-passwordencoders"><a class="anchor" href="#spring-security-crypto-passwordencoders"></a>20.4. Password Encoding</h3>
<div class="paragraph">
<p>spring-security-crypto 模块的密码软件包提供了对密码编码的支持.  <code>PasswordEncoder</code> 是中央服务接口,具有以下签名:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public interface PasswordEncoder {

String encode(String rawPassword);

boolean matches(String rawPassword, String encodedPassword);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 rawPassword 一旦编码,等于已编码的 Password,则 matches 方法返回 true.  此方法旨在支持基于密码的身份验证方案.</p>
</div>
<div class="paragraph">
<p><code>BCryptPasswordEncoder</code> 实现使用广泛支持的 "bcrypt" 算法来对密码进行哈希处理.  Bcrypt 使用一个随机的 16 字节盐值,并且是一种故意慢速的算法,目的是阻止密码破解者.  可以使用 "strength" 参数调整它所做的工作量,该参数的取值范围为 4 到 31. 值越高,计算散列所需的工作就越多.  默认值为 10. 您可以在已部署的系统中更改此值,而不会影响现有密码,因为该值也存储在编码的哈希中.</p>
</div>
<div class="exampleblock">
<div class="title">Example 176. BCryptPasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Create an encoder with strength 16
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16);
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Create an encoder with strength 16
val encoder = BCryptPasswordEncoder(16)
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>Pbkdf2PasswordEncoder</code> 实现使用 PBKDF2 算法对密码进行哈希处理.  为了破解密码破解,PBKDF2 是一种故意缓慢的算法,应调整为大约 0.5 秒以验证系统上的密码.</p>
</div>
<div class="exampleblock">
<div class="title">Example 177. Pbkdf2PasswordEncoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">// Create an encoder with all the defaults
Pbkdf2PasswordEncoder encoder = new Pbkdf2PasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">// Create an encoder with all the defaults
val encoder = Pbkdf2PasswordEncoder()
val result: String = encoder.encode("myPassword")
assertTrue(encoder.matches("myPassword", result))</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="附录"><a class="anchor" href="#附录"></a>21. 附录</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="appendix-schema"><a class="anchor" href="#appendix-schema"></a>21.1. Security Database Schema</h3>
<div class="paragraph">
<p>框架使用了各种数据库架构,本附录为它们提供了单个参考点.  您只需要提供所需功能范围的表即可.</p>
</div>
<div class="paragraph">
<p>为 HSQLDB 数据库提供了 DDL 语句.  您可以将这些用作定义正在使用的数据库的 Schema 的准则.</p>
</div>
<div class="sect3">
<h4 id="user-schema"><a class="anchor" href="#user-schema"></a>21.1.1. User Schema</h4>
<div class="paragraph">
<p><code>UserDetailsService</code> (<code>JdbcDaoImpl</code>) 的标准 JDBC 实现要求表为用户加载密码,帐户状态 (启用或禁用) 和权限列表 (角色) .  您将需要调整此 Schema 以匹配您正在使用的数据库语法.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>create table users(
    username varchar_ignorecase(50) not null primary key,
    password varchar_ignorecase(50) not null,
    enabled boolean not null
);

create table authorities (
    username varchar_ignorecase(50) not null,
    authority varchar_ignorecase(50) not null,
    constraint fk_authorities_users foreign key(username) references users(username)
);
create unique index ix_auth_username on authorities (username,authority);</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="oracle-数据库"><a class="anchor" href="#oracle-数据库"></a>Oracle 数据库</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CREATE TABLE USERS (
    USERNAME NVARCHAR2(128) PRIMARY KEY,
    PASSWORD NVARCHAR2(128) NOT NULL,
    ENABLED CHAR(1) CHECK (ENABLED IN ('Y','N') ) NOT NULL
);


CREATE TABLE AUTHORITIES (
    USERNAME NVARCHAR2(128) NOT NULL,
    AUTHORITY NVARCHAR2(128) NOT NULL
);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_UNIQUE UNIQUE (USERNAME, AUTHORITY);
ALTER TABLE AUTHORITIES ADD CONSTRAINT AUTHORITIES_FK1 FOREIGN KEY (USERNAME) REFERENCES USERS (USERNAME) ENABLE;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="组授权"><a class="anchor" href="#组授权"></a>组授权</h5>
<div class="paragraph">
<p>Spring Security 的 2.0 引入了在 <code>JdbcDaoImpl</code> 组主管部门的支持.  如果组都被启用表结构如下.  您将需要调整此架构以匹配您正在使用的数据库方言.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>create table groups (
    id bigint generated by default as identity(start with 0) primary key,
    group_name varchar_ignorecase(50) not null
);

create table group_authorities (
    group_id bigint not null,
    authority varchar(50) not null,
    constraint fk_group_authorities_group foreign key(group_id) references groups(id)
);

create table group_members (
    id bigint generated by default as identity(start with 0) primary key,
    username varchar(50) not null,
    group_id bigint not null,
    constraint fk_group_members_group foreign key(group_id) references groups(id)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>请记住,如果您使用的是提供的JDBC <code>UserDetailsService</code> 的实现,这些表时,才需要.  如果您自己编写或选择在没有 <code>UserDetailsService</code> 的情况下实现 <code>AuthenticationProvider</code>,则只要满足接口协定,就可以完全自由地存储数据.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="永久登录-记住我-schema"><a class="anchor" href="#永久登录-记住我-schema"></a>21.1.2. 永久登录 (记住我)  Schema</h4>
<div class="paragraph">
<p>该表用于存储更安全的<a href="#remember-me-persistent-token">持久令牌</a> "记住我" 实现所使用的数据.  如果直接或通过命名空间使用 <code>JdbcTokenRepositoryImpl</code>,则需要此表.  切记调整此架构以匹配您正在使用的数据库方言.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>create table persistent_logins (
    username varchar(64) not null,
    series varchar(64) primary key,
    token varchar(64) not null,
    last_used timestamp not null
);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dbschema-acl"><a class="anchor" href="#dbschema-acl"></a>21.1.3. ACL Schema</h4>
<div class="paragraph">
<p>Spring Security  <a href="#domain-acls">ACL</a> 实现使用了四个表.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>acl_sid</code> 存储 ACL 系统识别的安全身份.  这些可以是唯一的委托人,也可以适用于多个委托人.</p>
</li>
<li>
<p><code>acl_class</code> 定义 ACL 应用于的域对象类型.  类列存储对象的 Java 类名称.</p>
</li>
<li>
<p><code>acl_object_identity</code> 存储特定域对象的对象身份定义.</p>
</li>
<li>
<p><code>acl_entry</code> 存储适用于特定对象标识和安全标识的 ACL 权限.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>假设数据库将为每个身份自动生成主键.  <code>JdbcMutableAclService</code> 必须在 <code>acl_sid</code> 或 <code>acl_class</code> 表中创建新行时才能检索这些.  它具有两个属性,这些属性定义了检索这些值 <code>classIdentityQuery</code> 和 <code>sidIdentityQuery</code> 所需的 SQL.  这两个默认都调用 <code>identity()</code></p>
</div>
<div class="paragraph">
<p>ACL artifacts JAR 包含用于在HyperSQL (HSQLDB) ,HyperSQL (HSQLDB), PostgreSQL, MySQL/MariaDB, Microsoft SQL Server, 和 Oracle Database.数据库中创建 ACL 模式的文件.  在以下各节中还将演示这些架构.</p>
</div>
<div class="sect4">
<h5 id="hypersql"><a class="anchor" href="#hypersql"></a>HyperSQL</h5>
<div class="paragraph">
<p>默认模式与框架中的单元测试中使用的嵌入式 HSQLDB 数据库一起使用.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ddl" data-lang="ddl">create table acl_sid(
    id bigint generated by default as identity(start with 100) not null primary key,
    principal boolean not null,
    sid varchar_ignorecase(100) not null,
    constraint unique_uk_1 unique(sid,principal)
);

create table acl_class(
    id bigint generated by default as identity(start with 100) not null primary key,
    class varchar_ignorecase(100) not null,
    constraint unique_uk_2 unique(class)
);

create table acl_object_identity(
    id bigint generated by default as identity(start with 100) not null primary key,
    object_id_class bigint not null,
    object_id_identity varchar_ignorecase(36) not null,
    parent_object bigint,
    owner_sid bigint,
    entries_inheriting boolean not null,
    constraint unique_uk_3 unique(object_id_class,object_id_identity),
    constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),
    constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),
    constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id)
);

create table acl_entry(
    id bigint generated by default as identity(start with 100) not null primary key,
    acl_object_identity bigint not null,
    ace_order int not null,
    sid bigint not null,
    mask integer not null,
    granting boolean not null,
    audit_success boolean not null,
    audit_failure boolean not null,
    constraint unique_uk_4 unique(acl_object_identity,ace_order),
    constraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id),
    constraint foreign_fk_5 foreign key(sid) references acl_sid(id)
);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="postgresql"><a class="anchor" href="#postgresql"></a>PostgreSQL</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ddl" data-lang="ddl">create table acl_sid(
    id bigserial not null primary key,
    principal boolean not null,
    sid varchar(100) not null,
    constraint unique_uk_1 unique(sid,principal)
);

create table acl_class(
    id bigserial not null primary key,
    class varchar(100) not null,
    constraint unique_uk_2 unique(class)
);

create table acl_object_identity(
    id bigserial primary key,
    object_id_class bigint not null,
    object_id_identity varchar(36) not null,
    parent_object bigint,
    owner_sid bigint,
    entries_inheriting boolean not null,
    constraint unique_uk_3 unique(object_id_class,object_id_identity),
    constraint foreign_fk_1 foreign key(parent_object)references acl_object_identity(id),
    constraint foreign_fk_2 foreign key(object_id_class)references acl_class(id),
    constraint foreign_fk_3 foreign key(owner_sid)references acl_sid(id)
);

create table acl_entry(
    id bigserial primary key,
    acl_object_identity bigint not null,
    ace_order int not null,
    sid bigint not null,
    mask integer not null,
    granting boolean not null,
    audit_success boolean not null,
    audit_failure boolean not null,
    constraint unique_uk_4 unique(acl_object_identity,ace_order),
    constraint foreign_fk_4 foreign key(acl_object_identity) references acl_object_identity(id),
    constraint foreign_fk_5 foreign key(sid) references acl_sid(id)
);</code></pre>
</div>
</div>
<div class="paragraph">
<p>您必须将 <code>JdbcMutableAclService</code> 的 <code>classIdentityQuery</code> 和 <code>sidIdentityQuery</code> 属性分别设置为以下值:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>select currval(pg_get_serial_sequence('acl_class', 'id'))</code></p>
</li>
<li>
<p><code>select currval(pg_get_serial_sequence('acl_sid', 'id'))</code></p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="mysql-and-mariadb"><a class="anchor" href="#mysql-and-mariadb"></a>MySQL and MariaDB</h6>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ddl" data-lang="ddl">CREATE TABLE acl_sid (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    principal BOOLEAN NOT NULL,
    sid VARCHAR(100) NOT NULL,
    UNIQUE KEY unique_acl_sid (sid, principal)
) ENGINE=InnoDB;

CREATE TABLE acl_class (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    class VARCHAR(100) NOT NULL,
    UNIQUE KEY uk_acl_class (class)
) ENGINE=InnoDB;

CREATE TABLE acl_object_identity (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    object_id_class BIGINT UNSIGNED NOT NULL,
    object_id_identity VARCHAR(36) NOT NULL,
    parent_object BIGINT UNSIGNED,
    owner_sid BIGINT UNSIGNED,
    entries_inheriting BOOLEAN NOT NULL,
    UNIQUE KEY uk_acl_object_identity (object_id_class, object_id_identity),
    CONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id),
    CONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id),
    CONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id)
) ENGINE=InnoDB;

CREATE TABLE acl_entry (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
    acl_object_identity BIGINT UNSIGNED NOT NULL,
    ace_order INTEGER NOT NULL,
    sid BIGINT UNSIGNED NOT NULL,
    mask INTEGER UNSIGNED NOT NULL,
    granting BOOLEAN NOT NULL,
    audit_success BOOLEAN NOT NULL,
    audit_failure BOOLEAN NOT NULL,
    UNIQUE KEY unique_acl_entry (acl_object_identity, ace_order),
    CONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id),
    CONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id)
) ENGINE=InnoDB;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="microsoft-sql-server"><a class="anchor" href="#microsoft-sql-server"></a>Microsoft SQL Server</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ddl" data-lang="ddl">CREATE TABLE acl_sid (
    id BIGINT NOT NULL IDENTITY PRIMARY KEY,
    principal BIT NOT NULL,
    sid VARCHAR(100) NOT NULL,
    CONSTRAINT unique_acl_sid UNIQUE (sid, principal)
);

CREATE TABLE acl_class (
    id BIGINT NOT NULL IDENTITY PRIMARY KEY,
    class VARCHAR(100) NOT NULL,
    CONSTRAINT uk_acl_class UNIQUE (class)
);

CREATE TABLE acl_object_identity (
    id BIGINT NOT NULL IDENTITY PRIMARY KEY,
    object_id_class BIGINT NOT NULL,
    object_id_identity VARCHAR(36) NOT NULL,
    parent_object BIGINT,
    owner_sid BIGINT,
    entries_inheriting BIT NOT NULL,
    CONSTRAINT uk_acl_object_identity UNIQUE (object_id_class, object_id_identity),
    CONSTRAINT fk_acl_object_identity_parent FOREIGN KEY (parent_object) REFERENCES acl_object_identity (id),
    CONSTRAINT fk_acl_object_identity_class FOREIGN KEY (object_id_class) REFERENCES acl_class (id),
    CONSTRAINT fk_acl_object_identity_owner FOREIGN KEY (owner_sid) REFERENCES acl_sid (id)
);

CREATE TABLE acl_entry (
    id BIGINT NOT NULL IDENTITY PRIMARY KEY,
    acl_object_identity BIGINT NOT NULL,
    ace_order INTEGER NOT NULL,
    sid BIGINT NOT NULL,
    mask INTEGER NOT NULL,
    granting BIT NOT NULL,
    audit_success BIT NOT NULL,
    audit_failure BIT NOT NULL,
    CONSTRAINT unique_acl_entry UNIQUE (acl_object_identity, ace_order),
    CONSTRAINT fk_acl_entry_object FOREIGN KEY (acl_object_identity) REFERENCES acl_object_identity (id),
    CONSTRAINT fk_acl_entry_acl FOREIGN KEY (sid) REFERENCES acl_sid (id)
);</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="oracle-database"><a class="anchor" href="#oracle-database"></a>Oracle Database</h5>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ddl" data-lang="ddl">CREATE TABLE ACL_SID (
    ID NUMBER(18) PRIMARY KEY,
    PRINCIPAL NUMBER(1) NOT NULL CHECK (PRINCIPAL IN (0, 1 )),
    SID NVARCHAR2(128) NOT NULL,
    CONSTRAINT ACL_SID_UNIQUE UNIQUE (SID, PRINCIPAL)
);
CREATE SEQUENCE ACL_SID_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_SID_SQ_TR BEFORE INSERT ON ACL_SID FOR EACH ROW
BEGIN
    SELECT ACL_SID_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;


CREATE TABLE ACL_CLASS (
    ID NUMBER(18) PRIMARY KEY,
    CLASS NVARCHAR2(128) NOT NULL,
    CONSTRAINT ACL_CLASS_UNIQUE UNIQUE (CLASS)
);
CREATE SEQUENCE ACL_CLASS_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_CLASS_ID_TR BEFORE INSERT ON ACL_CLASS FOR EACH ROW
BEGIN
    SELECT ACL_CLASS_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;


CREATE TABLE ACL_OBJECT_IDENTITY(
    ID NUMBER(18) PRIMARY KEY,
    OBJECT_ID_CLASS NUMBER(18) NOT NULL,
    OBJECT_ID_IDENTITY NVARCHAR2(64) NOT NULL,
    PARENT_OBJECT NUMBER(18),
    OWNER_SID NUMBER(18),
    ENTRIES_INHERITING NUMBER(1) NOT NULL CHECK (ENTRIES_INHERITING IN (0, 1)),
    CONSTRAINT ACL_OBJECT_IDENTITY_UNIQUE UNIQUE (OBJECT_ID_CLASS, OBJECT_ID_IDENTITY),
    CONSTRAINT ACL_OBJECT_IDENTITY_PARENT_FK FOREIGN KEY (PARENT_OBJECT) REFERENCES ACL_OBJECT_IDENTITY(ID),
    CONSTRAINT ACL_OBJECT_IDENTITY_CLASS_FK FOREIGN KEY (OBJECT_ID_CLASS) REFERENCES ACL_CLASS(ID),
    CONSTRAINT ACL_OBJECT_IDENTITY_OWNER_FK FOREIGN KEY (OWNER_SID) REFERENCES ACL_SID(ID)
);
CREATE SEQUENCE ACL_OBJECT_IDENTITY_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_OBJECT_IDENTITY_ID_TR BEFORE INSERT ON ACL_OBJECT_IDENTITY FOR EACH ROW
BEGIN
    SELECT ACL_OBJECT_IDENTITY_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;


CREATE TABLE ACL_ENTRY (
    ID NUMBER(18) NOT NULL PRIMARY KEY,
    ACL_OBJECT_IDENTITY NUMBER(18) NOT NULL,
    ACE_ORDER INTEGER NOT NULL,
    SID NUMBER(18) NOT NULL,
    MASK INTEGER NOT NULL,
    GRANTING NUMBER(1) NOT NULL CHECK (GRANTING IN (0, 1)),
    AUDIT_SUCCESS NUMBER(1) NOT NULL CHECK (AUDIT_SUCCESS IN (0, 1)),
    AUDIT_FAILURE NUMBER(1) NOT NULL CHECK (AUDIT_FAILURE IN (0, 1)),
    CONSTRAINT ACL_ENTRY_UNIQUE UNIQUE (ACL_OBJECT_IDENTITY, ACE_ORDER),
    CONSTRAINT ACL_ENTRY_OBJECT_FK FOREIGN KEY (ACL_OBJECT_IDENTITY) REFERENCES ACL_OBJECT_IDENTITY (ID),
    CONSTRAINT ACL_ENTRY_ACL_FK FOREIGN KEY (SID) REFERENCES ACL_SID(ID)
);
CREATE SEQUENCE ACL_ENTRY_SQ START WITH 1 INCREMENT BY 1 NOMAXVALUE;
CREATE OR REPLACE TRIGGER ACL_ENTRY_ID_TRIGGER BEFORE INSERT ON ACL_ENTRY FOR EACH ROW
BEGIN
    SELECT ACL_ENTRY_SQ.NEXTVAL INTO :NEW.ID FROM DUAL;
END;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dbschema-oauth2-client"><a class="anchor" href="#dbschema-oauth2-client"></a>21.1.4. OAuth 2.0 Client Schema</h4>
<div class="paragraph">
<p><a href="#oauth2Client-authorized-repo-service">OAuth2AuthorizedClientService</a> (<code>JdbcOAuth2AuthorizedClientService</code>)  的 JDBC 实现需要一个用于持久化  <code>OAuth2AuthorizedClient</code>(s) 的表.
您将需要调整此架构以匹配您正在使用的数据库方言.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-ddl" data-lang="ddl">CREATE TABLE oauth2_authorized_client (
  client_registration_id varchar(100) NOT NULL,
  principal_name varchar(200) NOT NULL,
  access_token_type varchar(100) NOT NULL,
  access_token_value blob NOT NULL,
  access_token_issued_at timestamp NOT NULL,
  access_token_expires_at timestamp NOT NULL,
  access_token_scopes varchar(1000) DEFAULT NULL,
  refresh_token_value blob DEFAULT NULL,
  refresh_token_issued_at timestamp DEFAULT NULL,
  created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL,
  PRIMARY KEY (client_registration_id, principal_name)
);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-namespace"><a class="anchor" href="#appendix-namespace"></a>21.2. Security 命名空间</h3>
<div class="paragraph">
<p>本附录提供了对安全性命名空间中可用元素的引用以及它们创建的基础 Bean 的信息 (假定您了解各个类以及它们如何协同工作-您可以在项目Javadoc 和本文档的其他地方找到更多信息.  ) .  如果您以前从未使用过命名空间,请阅读有关<a href="#ns-config">命名空间</a>配置的介绍性章节,因为这是对此处信息的补充.
建议在编辑基于模式的配置时使用高质量的 XML 编辑器,因为这将提供有关哪些元素和属性可用的上下文信息,以及说明其用途的注解.  命名空间以 <a href="https://relaxng.org/">RELAX NG</a> Compact 格式编写,后来被转换为 XSD 模式.  如果您熟悉此格式,则可能希望直接检查 <a href="https://raw.githubusercontent.com/spring-projects/spring-security/master/config/src/main/resources/org/springframework/security/config/spring-security-4.1.rnc">schema file</a>文件.</p>
</div>
<div class="sect3">
<h4 id="nsa-web"><a class="anchor" href="#nsa-web"></a>21.2.1. Web Application Security</h4>
<div class="sect4">
<h5 id="nsa-debug"><a class="anchor" href="#nsa-debug"></a>&lt;debug&gt;</h5>
<div class="paragraph">
<p>启用 Spring Security 调试基础结构.  这将提供人类可读的 (多行) 调试信息,以监视进入安全过滤器的请求.  这可能包括敏感信息,例如请求参数或 header,并且仅应在开发环境中使用.</p>
</div>
</div>
<div class="sect4">
<h5 id="nsa-http"><a class="anchor" href="#nsa-http"></a>&lt;http&gt;</h5>
<div class="paragraph">
<p>如果在应用程序中使用 <code>&lt;http&gt;</code> 元素,则会创建一个名为 "springSecurityFilterChain" 的 <code>FilterChainProxy</code> bean,并且该元素中的配置用于在 <code>FilterChainProxy</code> 中构建过滤器链.  从 Spring Security 3.1 开始,可以使用附加的 <code>http</code> 元素添加附加的过滤器链 <sup class="footnote">[<a id="_footnoteref_13" class="footnote" href="#_footnotedef_13" title="View footnote.">13</a>]</sup>. ].
某些核心过滤器始终在过滤器链中创建,而其他核心过滤器将根据存在的属性和子元素添加到堆栈中.  标准过滤器的位置是固定的 (请参见命名空间介绍中的<a href="#filter-stack">过滤器顺序表</a>) ,当用户必须在 <code>FilterChainProxy</code> bean 中显式配置过滤器链时,消除了框架以前版本的常见错误源.  当然,如果需要完全控制配置,您仍然可以这样做.</p>
</div>
<div class="paragraph">
<p>所有需要引用  <a href="#servlet-authentication-authenticationmanager"><code>AuthenticationManager</code></a>  的过滤器都会自动注入由命名空间配置创建的内部实例.</p>
</div>
<div class="paragraph">
<p>每个 <code>&lt;http&gt;</code> 命名空间块始终创建一个 <code>SecurityContextPersistenceFilter</code>,一个 <code>ExceptionTranslationFilter</code> 和一个 <code>FilterSecurityInterceptor</code>.  这些是固定的,不能用替代方法替代.</p>
</div>
<div class="sect5">
<h6 id="nsa-http-attributes"><a class="anchor" href="#nsa-http-attributes"></a>&lt;http&gt; 属性</h6>
<div class="paragraph">
<p><code>&lt;http&gt;</code> 元素上的属性控制核心过滤器上的某些属性.</p>
</div>
<div id="nsa-http-access-decision-manager-ref" class="ulist">
<ul>
<li>
<p><strong>access-decision-manager-ref</strong>
可选属性,用于指定应用于授权 HTTP 请求的 <code>AccessDecisionManager</code> 实现的 ID. 默认情况下,<code>AffirmativeBased</code> 实现用于 <code>RoleVoter</code> 和 <code>AuthenticatedVoter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-authentication-manager-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-manager-ref</strong>
对用于此 http 元素创建的 <code>FilterChain</code> 的 <code>AuthenticationManager</code> 的引用.</p>
</li>
</ul>
</div>
<div id="nsa-http-auto-config" class="ulist">
<ul>
<li>
<p><strong>auto-config</strong>
自动注册登录表单,BASIC 身份验证,注销服务.  如果设置为 "true",则会添加所有这些功能 (尽管您仍然可以通过提供相应的元素来自定义每个功能的配置) .  如果未指定,则默认为 "false".  不建议使用此属性.  请使用显式配置元素来避免混淆.</p>
</li>
</ul>
</div>
<div id="nsa-http-create-session" class="ulist">
<ul>
<li>
<p><strong>create-session</strong>
控制 Spring Security 类创建 HTTP 会话的迫切性. 选项包括:</p>
<div class="ulist">
<ul>
<li>
<p><code>always</code> - 如果不存在会话,Spring Security 将主动创建一个会话.</p>
</li>
<li>
<p><code>ifRequired</code> - 仅在需要一个会话时,Spring Security 才会创建一个会话 (默认值) .</p>
</li>
<li>
<p><code>never</code> - Spring Security 永远不会创建会话,但如果应用程序创建会话,它将使用一个会话.</p>
</li>
<li>
<p><code>stateless</code> - Spring Security 不会创建会话,并且会忽略该会话以获取 Spring <code>Authentication</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="nsa-http-disable-url-rewriting" class="ulist">
<ul>
<li>
<p><strong>disable-url-rewriting</strong>
防止将会话 ID 附加到应用程序中的 URL. 如果此属性设置为 <code>true</code>,则客户端必须使用 cookie. 默认值为 <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-entry-point-ref" class="ulist">
<ul>
<li>
<p><strong>entry-point-ref</strong>
通常,将根据已配置的身份验证机制来设置使用的 <code>AuthenticationEntryPoint</code>.  此属性允许通过定义自定义的 <code>AuthenticationEntryPoint</code> bean来覆盖此行为,该 bean 将启动身份验证过程.</p>
</li>
</ul>
</div>
<div id="nsa-http-jaas-api-provision" class="ulist">
<ul>
<li>
<p><strong>jaas-api-provision</strong>
如果可用,则将请求作为从 <code>JaasAuthenticationToken</code> 获取的 <code>Subject</code> 运行,该请求是通过将 <code>JaasApiIntegrationFilter</code> bean 添加到堆栈中来实现的.  默认为 <code>false</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-name" class="ulist">
<ul>
<li>
<p><strong>name</strong>
Bean 标识符,用于引用上下文中其他位置的 Bean.</p>
</li>
</ul>
</div>
<div id="nsa-http-once-per-request" class="ulist">
<ul>
<li>
<p><strong>once-per-request</strong>
对应于 <code>FilterSecurityInterceptor</code> 的 <code>observeOncePerRequest</code> 属性. 默认为 <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong>
为<a href="#nsa-http">http</a>元素定义模式可控制将通过其定义的过滤器列表进行过滤的请求.  解释取决于配置的 <a href="#nsa-http-request-matcher">request-matcher</a>.  如果未定义任何模式,则将匹配所有请求,因此应首先声明最具体的模式.</p>
</li>
</ul>
</div>
<div id="nsa-http-realm" class="ulist">
<ul>
<li>
<p><strong>realm</strong>
设置用于基本身份验证的领域名称 (如果启用) . 对应于 <code>BasicAuthenticationEntryPoint</code> 上的 <code>realmName</code> 属性.</p>
</li>
</ul>
</div>
<div id="nsa-http-request-matcher" class="ulist">
<ul>
<li>
<p><strong>request-matcher</strong>
定义在 <code>FilterChainProxy</code> 中使用的 <code>RequestMatcher</code> 策略以及由 <code>intercept-url</code> 创建的 Bean,以匹配传入的请求.  当前,Spring MVC 的选项分别是 <code>mvc</code>,<code>ant</code>,<code>regex</code> 和 <code>ciRegex</code>,ant,regular-expression 和不区分大小写的正则表达式.
使用其<a href="#nsa-intercept-url-pattern">pattern</a>,<a href="#nsa-intercept-url-method">method</a> 和<a href="#nsa-intercept-url-servlet-path">servlet-path</a>属性为每个<a href="#nsa-intercept-url">intercept-url</a>元素创建一个单独的实例.
使用 <code>AntPathRequestMatcher</code> 匹配 Ant 路径,使用 <code>RegexRequestMatcher</code> 匹配正则表达式,对于 Spring MVC 路径,使用 <code>MvcRequestMatcher</code> 匹配.  有关这些类的确切执行方式的更多详细信息,请参见 Javadoc.  蚂蚁路径是默认策略.</p>
</li>
</ul>
</div>
<div id="nsa-http-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
对实现 <code>RequestMatcher</code> 的 bean 的引用,该请求将确定是否应使用此 <code>FilterChain</code>. 这是<a href="#nsa-http-pattern">pattern</a>的更强大替代方案.</p>
</li>
</ul>
</div>
<div id="nsa-http-security" class="ulist">
<ul>
<li>
<p><strong>security</strong>
通过将此属性设置为 <code>none</code>,可以将请求模式映射到一个空的过滤器链. 不会应用任何安全性,并且 Spring Security 的任何功能都不可用.</p>
</li>
</ul>
</div>
<div id="nsa-http-security-context-repository-ref" class="ulist">
<ul>
<li>
<p><strong>security-context-repository-ref</strong>
允许将自定义 <code>SecurityContextRepository</code> 注入 <code>SecurityContextPersistenceFilter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-servlet-api-provision" class="ulist">
<ul>
<li>
<p><strong>servlet-api-provision</strong>
提供 <code>HttpServletRequest</code> 安全方法的版本,例如 <code>isUserInRole()</code> 和 <code>getPrincipal()</code>,这些方法是通过将 <code>SecurityContextHolderAwareRequestFilter</code> bean添加到堆栈中来实现的. 默认为 <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-http-use-expressions" class="ulist">
<ul>
<li>
<p><strong>use-expressions</strong>
如关于<a href="#el-access-web">基于表达式的访问控制</a>一章所述,在访问属性中启用 EL 表达式. 默认值是 <code>true</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-http-children"><a class="anchor" href="#nsa-http-children"></a>&lt;http&gt; 子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-access-denied-handler">access-denied-handler</a></p>
</li>
<li>
<p><a href="#nsa-anonymous">anonymous</a></p>
</li>
<li>
<p><a href="#nsa-cors">cors</a></p>
</li>
<li>
<p><a href="#nsa-csrf">csrf</a></p>
</li>
<li>
<p><a href="#nsa-custom-filter">custom-filter</a></p>
</li>
<li>
<p><a href="#nsa-expression-handler">expression-handler</a></p>
</li>
<li>
<p><a href="#nsa-form-login">form-login</a></p>
</li>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
<li>
<p><a href="#nsa-http-basic">http-basic</a></p>
</li>
<li>
<p><a href="#nsa-intercept-url">intercept-url</a></p>
</li>
<li>
<p><a href="#nsa-jee">jee</a></p>
</li>
<li>
<p><a href="#nsa-logout">logout</a></p>
</li>
<li>
<p><a href="#nsa-oauth2-client">oauth2-client</a></p>
</li>
<li>
<p><a href="#nsa-oauth2-login">oauth2-login</a></p>
</li>
<li>
<p><a href="#nsa-oauth2-resource-server">oauth2-resource-server</a></p>
</li>
<li>
<p><a href="#nsa-openid-login">openid-login</a></p>
</li>
<li>
<p><a href="#nsa-port-mappings">port-mappings</a></p>
</li>
<li>
<p><a href="#nsa-remember-me">remember-me</a></p>
</li>
<li>
<p><a href="#nsa-request-cache">request-cache</a></p>
</li>
<li>
<p><a href="#nsa-session-management">session-management</a></p>
</li>
<li>
<p><a href="#nsa-x509">x509</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-access-denied-handler"><a class="anchor" href="#nsa-access-denied-handler"></a>&lt;access-denied-handler&gt;</h5>
<div class="paragraph">
<p>该元素允许您使用 <code>error-page</code> 属性为 <code>ExceptionTranslationFilter</code> 所使用的默认 <code>AccessDeniedHandler</code> 设置 <a href="#nsa-access-denied-handler-error-page">error-page</a> 属性,或者使用 <a href="#nsa-access-denied-handler-ref">ref</a> 属性提供您自己的实现.  在 <a href="#servlet-exceptiontranslationfilter">ExceptionTranslationFilter</a> 的部分中对此进行了更详细的讨论.</p>
</div>
<div class="sect5">
<h6 id="nsa-access-denied-handler-parents"><a class="anchor" href="#nsa-access-denied-handler-parents"></a>&lt;access-denied-handler&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-access-denied-handler-attributes"><a class="anchor" href="#nsa-access-denied-handler-attributes"></a>&lt;access-denied-handler&gt; 属性</h6>
<div id="nsa-access-denied-handler-error-page" class="ulist">
<ul>
<li>
<p><strong>error-page</strong>
如果身份验证的用户请求他们无权访问的页面,则重定向到该页面的访问被拒绝页面.</p>
</li>
</ul>
</div>
<div id="nsa-access-denied-handler-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义对类型为 <code>AccessDeniedHandler</code> 的 Spring bean 的引用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-cors"><a class="anchor" href="#nsa-cors"></a>&lt;cors&gt;</h5>
<div class="paragraph">
<p>该元素允许配置 <code>CorsFilter</code>. 如果未指定 <code>CorsFilter</code> 或 <code>CorsConfigurationSource</code> 且 Spring MVC 在类路径上,则将 <code>HandlerMappingIntrospector</code> 用作 <code>CorsConfigurationSource</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-cors-attributes"><a class="anchor" href="#nsa-cors-attributes"></a>&lt;cors&gt; 属性</h6>
<div class="paragraph">
<p><code>&lt;cors&gt;</code> 元素上的属性控制 <code>headers</code> 元素.</p>
</div>
<div id="nsa-cors-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
指定 <code>CorsFilter</code> 的 bean 名称的可选属性.</p>
</li>
</ul>
</div>
<div id="nsa-cors-configuration-source-ref" class="ulist">
<ul>
<li>
<p><strong>cors-configuration-source-ref</strong>
可选属性,用于指定要注入到XML命名空间创建的 <code>CorsFilter</code> 中的 <code>CorsConfigurationSource</code> 的 Bean 名称.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-cors-parents"><a class="anchor" href="#nsa-cors-parents"></a>&lt;cors&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-headers"><a class="anchor" href="#nsa-headers"></a>&lt;headers&gt;</h5>
<div class="paragraph">
<p>此元素允许配置要与响应一起发送的其他 (安全) header.  它可以轻松配置多个 header,还可以通过 <a href="#nsa-header">header</a>元素设置自定义 header.  可以在 <a href="#headers">Security Headers</a>部分中找到其他信息.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Cache-Control</code>, <code>Pragma</code>, and <code>Expires</code> - 可以使用<a href="#nsa-cache-control">cache-control</a>元素进行设置. 这样可以确保浏览器不会缓存您的安全页面.</p>
</li>
<li>
<p><code>Strict-Transport-Security</code> - 可以使用 <a href="#nsa-hsts">hsts</a>元素进行设置. 这样可以确保浏览器自动为将来的请求请求HTTPS.</p>
</li>
<li>
<p><code>X-Frame-Options</code> - 可以使用 <a href="#nsa-frame-options">frame-options</a> 元素进行设置.  <a href="https://en.wikipedia.org/wiki/Clickjacking#X-Frame-Options">X-Frame-Options</a>  头可用于防止点击劫持攻击.</p>
</li>
<li>
<p><code>X-XSS-Protection</code> - 可以使用<a href="#nsa-xss-protection">xss-protection</a> 元素进行设置. 浏览器可以使用 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">X-XSS-Protection </a> 头进行基本控制.</p>
</li>
<li>
<p><code>X-Content-Type-Options</code> - 可以使用<a href="#nsa-content-type-options">content-type-options</a>元素进行设置.  <a href="https://blogs.msdn.com/b/ie/archive/2008/09/02/ie8-security-part-vi-beta-2-update.aspx">X-Content-Type-Options</a> 头可防止 Internet Explorer MIME 嗅探远离已声明内容类型的响应. 下载扩展程序时,这也适用于 Google Chrome 浏览器.</p>
</li>
<li>
<p><code>Public-Key-Pinning</code> or <code>Public-Key-Pinning-Report-Only</code> - 可以使用<a href="#nsa-hpkp">hpkp</a> 元素进行设置. 这允许 HTTPS 网站使用错误签发或欺诈性证书来抵制攻击者的冒名顶替.</p>
</li>
<li>
<p><code>Content-Security-Policy</code> 或 <code>Content-Security-Policy-Report-Only</code> - 可以使用<a href="#nsa-content-security-policy">content-security-policy</a>元素进行设置. <a href="https://www.w3.org/TR/CSP2/">Content Security Policy (CSP)</a>是 Web 应用程序可以利用的一种机制,可以缓解诸如跨站点脚本 (XSS) 之类的内容注入漏洞.</p>
</li>
<li>
<p><code>Referrer-Policy</code> - 可以使用<a href="#nsa-referrer-policy">referrer-policy</a>元素进行设置, <a href="https://www.w3.org/TR/referrer-policy/">Referrer-Policy</a>是Web应用程序可以用来管理 Referrer 字段的机制,该字段包含用户所在的最后一页.</p>
</li>
<li>
<p><code>Feature-Policy</code> - 可以使用<a href="#nsa-feature-policy">feature-policy</a>元素进行设置, <a href="https://wicg.github.io/feature-policy/">Feature-Policy</a>是一种机制,允许 Web 开发人员在浏览器中选择性地启用,禁用和修改某些 API 和 Web 功能的行为.</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="nsa-headers-attributes"><a class="anchor" href="#nsa-headers-attributes"></a>&lt;headers&gt; 属性</h6>
<div class="paragraph">
<p><code>&lt;headers&gt;</code> 元素上的属性控制 headers 元素.</p>
</div>
<div id="nsa-headers-defaults-disabled" class="ulist">
<ul>
<li>
<p><strong>defaults-disabled</strong>
可选属性,用于指定默认的 Spring Security 的 HTTP 响应头. 默认值为 false (包括默认标题) .</p>
</li>
</ul>
</div>
<div id="nsa-headers-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
可选属性,用于指定禁用 Spring Security 的 HTTP 响应头. 默认值为 false (已启用 header ) .</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-headers-parents"><a class="anchor" href="#nsa-headers-parents"></a>&lt;headers&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-headers-children"><a class="anchor" href="#nsa-headers-children"></a>&lt;headers&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-cache-control">cache-control</a></p>
</li>
<li>
<p><a href="#nsa-content-security-policy">content-security-policy</a></p>
</li>
<li>
<p><a href="#nsa-content-type-options">content-type-options</a></p>
</li>
<li>
<p><a href="#nsa-feature-policy">feature-policy</a></p>
</li>
<li>
<p><a href="#nsa-frame-options">frame-options</a></p>
</li>
<li>
<p><a href="#nsa-header">header</a></p>
</li>
<li>
<p><a href="#nsa-hpkp">hpkp</a></p>
</li>
<li>
<p><a href="#nsa-hsts">hsts</a></p>
</li>
<li>
<p><a href="#nsa-referrer-policy">referrer-policy</a></p>
</li>
<li>
<p><a href="#nsa-xss-protection">xss-protection</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-cache-control"><a class="anchor" href="#nsa-cache-control"></a>&lt;cache-control&gt;</h5>
<div class="paragraph">
<p>添加 <code>Cache-Control</code>,<code>Pragma</code> 和 <code>Expires</code> 头,以确保浏览器不缓存您的安全页面.</p>
</div>
<div class="sect5">
<h6 id="nsa-cache-control-attributes"><a class="anchor" href="#nsa-cache-control-attributes"></a>&lt;cache-control&gt; 属性</h6>
<div id="nsa-cache-control-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
指定是否应禁用缓存控制. 默认为 <code>false</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-cache-control-parents"><a class="anchor" href="#nsa-cache-control-parents"></a>&lt;cache-control&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-hsts"><a class="anchor" href="#nsa-hsts"></a>&lt;hsts&gt;</h5>
<div class="paragraph">
<p>启用后,会将 <a href="https://tools.ietf.org/html/rfc6797">Strict-Transport-Security</a> 头添加到任何安全请求的响应中. 这允许服务器指示浏览器自动将 HTTPS 用于将来的请求.</p>
</div>
<div class="sect5">
<h6 id="nsa-hsts-attributes"><a class="anchor" href="#nsa-hsts-attributes"></a>&lt;hsts&gt; 属性</h6>
<div id="nsa-hsts-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
指定是否应禁用 "严格传输安全性". 默认为 <code>false</code>.</p>
</li>
</ul>
</div>
<div id="nsa-hsts-include-subdomains" class="ulist">
<ul>
<li>
<p><strong>include-sub-domains</strong>
指定是否应包含子域. 默认为 <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-hsts-max-age-seconds" class="ulist">
<ul>
<li>
<p><strong>max-age-seconds</strong>
指定应将主机视为已知 HSTS 主机的最长时间. 默认一年.</p>
</li>
</ul>
</div>
<div id="nsa-hsts-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
用于确定是否应设置 header 的 RequestMatcher 实例. 默认值为 <code>HttpServletRequest.isSecure()</code> 为 <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-hsts-preload" class="ulist">
<ul>
<li>
<p><strong>preload</strong>
指定是否应包含预加载. 默认为 false.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-hsts-parents"><a class="anchor" href="#nsa-hsts-parents"></a>&lt;hsts&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-hpkp"><a class="anchor" href="#nsa-hpkp"></a>&lt;hpkp&gt;</h5>
<div class="paragraph">
<p>启用后,会将 <a href="https://tools.ietf.org/html/rfc7469">HTTP头的 "公钥固定扩展"</a> 添加到任何安全请求的响应中. 这允许 HTTPS 网站使用错误签发或欺诈性证书来抵制攻击者的冒名顶替.</p>
</div>
<div class="sect5">
<h6 id="nsa-hpkp-attributes"><a class="anchor" href="#nsa-hpkp-attributes"></a>&lt;hpkp&gt; 属性</h6>
<div id="nsa-hpkp-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
指定是否应禁用 HTTP 公钥固定 (HPKP) .  默认为true.</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-include-subdomains" class="ulist">
<ul>
<li>
<p><strong>include-sub-domains</strong>
指定是否应包含子域.  默认为 <code>false</code>.</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-max-age-seconds" class="ulist">
<ul>
<li>
<p><strong>max-age-seconds</strong>
设置 Public-Key-Pins header 的 max-age 指令的值.  默认为 60 天.</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-report-only" class="ulist">
<ul>
<li>
<p><strong>report-only</strong>
指定浏览器是否仅应报告引脚验证失败.  默认为 <code>true</code>.</p>
</li>
</ul>
</div>
<div id="nsa-hpkp-report-uri" class="ulist">
<ul>
<li>
<p><strong>report-uri</strong>
指定浏览器应向其报告引脚验证失败的 URI.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-hpkp-parents"><a class="anchor" href="#nsa-hpkp-parents"></a>&lt;hpkp&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-pins"><a class="anchor" href="#nsa-pins"></a>&lt;pins&gt;</h5>
<div class="paragraph">
<p>引脚列表</p>
</div>
<div class="sect5">
<h6 id="nsa-pins-children"><a class="anchor" href="#nsa-pins-children"></a>&lt;pins&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pin">pin</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-pin"><a class="anchor" href="#nsa-pin"></a>&lt;pin&gt;</h5>
<div class="paragraph">
<p>使用 base64 编码的 SPKI 指纹作为值并使用密码哈希算法作为属性来指定引脚</p>
</div>
<div class="sect5">
<h6 id="nsa-pin-attributes"><a class="anchor" href="#nsa-pin-attributes"></a>&lt;pin&gt; 属性</h6>
<div id="nsa-pin-algorithm" class="ulist">
<ul>
<li>
<p><strong>algorithm</strong>
密码哈希算法. 默认值为 SHA256.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-pin-parents"><a class="anchor" href="#nsa-pin-parents"></a>&lt;pin&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pins">pins</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-content-security-policy"><a class="anchor" href="#nsa-content-security-policy"></a>&lt;content-security-policy&gt;</h5>
<div class="paragraph">
<p>启用后,将 <a href="https://www.w3.org/TR/CSP2/">Content Security Policy (CSP)</a> 头添加到响应中.  CSP 是 Web 应用程序可以用来缓解内容注入漏洞 (例如跨站点脚本 (XSS)) 的一种机制.</p>
</div>
<div class="sect5">
<h6 id="nsa-content-security-policy-attributes"><a class="anchor" href="#nsa-content-security-policy-attributes"></a>&lt;content-security-policy&gt; 属性</h6>
<div id="nsa-content-security-policy-policy-directives" class="ulist">
<ul>
<li>
<p><strong>policy-directives</strong>
Content-Security-Policy header 的安全策略指令,或者如果仅报告设置为 true,则使用 Content-Security-Policy-Report-Only header .</p>
</li>
</ul>
</div>
<div id="nsa-content-security-policy-report-only" class="ulist">
<ul>
<li>
<p><strong>report-only</strong>
设置为 true,启用 Content-Security-Policy-Report-Only header 仅用于报告策略违例. 默认为 false.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-content-security-policy-parents"><a class="anchor" href="#nsa-content-security-policy-parents"></a>&lt;content-security-policy&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-referrer-policy"><a class="anchor" href="#nsa-referrer-policy"></a>&lt;referrer-policy&gt;</h5>
<div class="paragraph">
<p>启用后,将 <a href="https://www.w3.org/TR/referrer-policy/">Referrer Policy</a> 头添加到响应中.</p>
</div>
<div class="sect5">
<h6 id="nsa-referrer-policy-attributes"><a class="anchor" href="#nsa-referrer-policy-attributes"></a>&lt;referrer-policy&gt; 属性</h6>
<div id="nsa-referrer-policy-policy" class="ulist">
<ul>
<li>
<p><strong>policy</strong>
Referrer-Policy header 的策略. 默认为 "no-referrer".</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-referrer-policy-parents"><a class="anchor" href="#nsa-referrer-policy-parents"></a>&lt;referrer-policy&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-feature-policy"><a class="anchor" href="#nsa-feature-policy"></a>&lt;feature-policy&gt;</h5>
<div class="paragraph">
<p>启用后,将 <a href="https://wicg.github.io/feature-policy/">Feature Policy</a> 头添加到响应中.</p>
</div>
<div class="sect5">
<h6 id="nsa-feature-policy-attributes"><a class="anchor" href="#nsa-feature-policy-attributes"></a>&lt;feature-policy&gt; 属性</h6>
<div id="nsa-feature-policy-policy-directives" class="ulist">
<ul>
<li>
<p><strong>policy-directives</strong>
Feature-Policy 头的安全策略指令.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-feature-policy-parents"><a class="anchor" href="#nsa-feature-policy-parents"></a>&lt;feature-policy&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-frame-options"><a class="anchor" href="#nsa-frame-options"></a>&lt;frame-options&gt;</h5>
<div class="paragraph">
<p>启用后,将 <a href="https://tools.ietf.org/html/draft-ietf-websec-x-frame-options">X-Frame-Options header</a> 头添加到响应中,这使较新的浏览器可以进行一些安全检查并防止 <a href="https://en.wikipedia.org/wiki/Clickjacking">clickjacking</a>攻击.</p>
</div>
<div class="sect5">
<h6 id="nsa-frame-options-attributes"><a class="anchor" href="#nsa-frame-options-attributes"></a>&lt;frame-options&gt; 属性</h6>
<div id="nsa-frame-options-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
如果禁用,则不包括 X-Frame-Options 头. 默认为 <code>false</code>.</p>
</li>
</ul>
</div>
<div id="nsa-frame-options-policy" class="ulist">
<ul>
<li>
<p><strong>policy</strong></p>
<div class="ulist">
<ul>
<li>
<p><code>DENY</code> 该页面无法显示在框架中,无论站点尝试这样做.  当指定 frame-options-policy 时,这是默认设置.</p>
</li>
<li>
<p><code>SAMEORIGIN</code> 该页面只能以与页面本身相同的原点显示在框架中</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>换句话说,如果指定 DENY,则从其他站点加载时,不仅尝试在框架中加载页面失败,而且从同一站点加载时,尝试也会失败.  另一方面,如果指定SAMEORIGIN,则只要框架中包含该站点的页面与提供该页面的站点相同,您仍可以在框架中使用该页面.</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-frame-options-parents"><a class="anchor" href="#nsa-frame-options-parents"></a>&lt;frame-options&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-xss-protection"><a class="anchor" href="#nsa-xss-protection"></a>&lt;xss-protection&gt;</h5>
<div class="paragraph">
<p>将 <a href="https://blogs.msdn.com/b/ie/archive/2008/07/02/ie8-security-part-iv-the-xss-filter.aspx">X-XSS-Protection header</a> 添加到响应中,以帮助防止 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent">reflected / Type-1 Cross-Site Scripting (XSS)</a>攻击. 这绝不是对 XSS 攻击的全面保护！</p>
</div>
<div class="sect5">
<h6 id="nsa-xss-protection-attributes"><a class="anchor" href="#nsa-xss-protection-attributes"></a>&lt;xss-protection&gt; 属性</h6>
<div id="nsa-xss-protection-disabled" class="ulist">
<ul>
<li>
<p><strong>xss-protection-disabled</strong>
不要包括用于 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent">reflected / Type-1 Cross-Site Scripting (XSS)</a> 保护的头.</p>
</li>
</ul>
</div>
<div id="nsa-xss-protection-enabled" class="ulist">
<ul>
<li>
<p><strong>xss-protection-enabled</strong>
明确启用或禁用 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting#Non-Persistent">reflected / Type-1 Cross-Site Scripting (XSS)</a>保护.</p>
</li>
</ul>
</div>
<div id="nsa-xss-protection-block" class="ulist">
<ul>
<li>
<p><strong>xss-protection-block</strong>
如果为 <code>true</code> 且 xss-protection-enabled 为 <code>true</code>,则将 <code>mode = block</code> 添加到 header .  这向浏览器指示根本不应加载该页面.  如果为 <code>false</code> 并且 xss-protection-enabled 为 <code>true</code>,则在检测到反射攻击时仍将呈现页面,但是将修改响应以防止受到攻击.  请注意,有时存在绕过此模式的方法,这些方法常常使阻塞页面更为可取.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-xss-protection-parents"><a class="anchor" href="#nsa-xss-protection-parents"></a>&lt;xss-protection&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-content-type-options"><a class="anchor" href="#nsa-content-type-options"></a>&lt;content-type-options&gt;</h5>
<div class="paragraph">
<p>将带有 nosniff 值的 X-Content-Type-Options header 添加到响应中. 这将禁用 IE8+ 和 Chrome 扩展的 <a href="https://blogs.msdn.com/b/ie/archive/2008/09/02/ie8-security-part-vi-beta-2-update.aspx">disables MIME-sniffing</a>.</p>
</div>
<div class="sect5">
<h6 id="nsa-content-type-options-attributes"><a class="anchor" href="#nsa-content-type-options-attributes"></a>&lt;content-type-options&gt; 属性</h6>
<div id="nsa-content-type-options-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
指定是否应禁用 "内容类型选项". 默认为 false.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-content-type-options-parents"><a class="anchor" href="#nsa-content-type-options-parents"></a>&lt;content-type-options&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-header"><a class="anchor" href="#nsa-header"></a>&lt;header&gt;</h5>
<div class="paragraph">
<p>向响应添加其他 header ,名称和值都需要指定.</p>
</div>
<div class="sect5">
<h6 id="nsa-header-attributes"><a class="anchor" href="#nsa-header-attributes"></a>&lt;header-attributes&gt; 属性</h6>
<div id="nsa-header-name" class="ulist">
<ul>
<li>
<p><strong>header-name</strong>
header 名称</p>
</li>
</ul>
</div>
<div id="nsa-header-value" class="ulist">
<ul>
<li>
<p><strong>value</strong>
要添加的 header 的值.</p>
</li>
</ul>
</div>
<div id="nsa-header-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
引用 <code>HeaderWriter</code> 接口的自定义实现.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-header-parents"><a class="anchor" href="#nsa-header-parents"></a>&lt;header&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-headers">headers</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-anonymous"><a class="anchor" href="#nsa-anonymous"></a>&lt;anonymous&gt;</h5>
<div class="paragraph">
<p>将 <code>AnonymousAuthenticationFilter</code> 添加到堆栈和 <code>AnonymousAuthenticationProvider</code>. 如果使用 <code>IS_AUTHENTICATED_ANONYMOUSLY</code> 属性,则为必需.</p>
</div>
<div class="sect5">
<h6 id="nsa-anonymous-parents"><a class="anchor" href="#nsa-anonymous-parents"></a>&lt;anonymous&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-anonymous-attributes"><a class="anchor" href="#nsa-anonymous-attributes"></a>&lt;anonymous&gt; 属性</h6>
<div id="nsa-anonymous-enabled" class="ulist">
<ul>
<li>
<p><strong>enabled</strong>
使用默认的命名空间设置,将自动启用匿名 "身份验证" 功能. 您可以使用此属性禁用它.</p>
</li>
</ul>
</div>
<div id="nsa-anonymous-granted-authority" class="ulist">
<ul>
<li>
<p><strong>granted-authority</strong>
应该分配给匿名请求的授权权限. 通常,这用于为匿名请求分配特定角色,随后可以在授权决策中使用这些角色. 如果未设置,则默认为 <code>ROLE_ANONYMOUS</code>.</p>
</li>
</ul>
</div>
<div id="nsa-anonymous-key" class="ulist">
<ul>
<li>
<p><strong>key</strong>
提供者和过滤器之间共享的密钥.  通常不需要设置.  如果未设置,则默认为安全随机生成的值.  这意味着在使用匿名功能时设置此值可以缩短启动时间,因为生成安全随机值可能需要一段时间.</p>
</li>
</ul>
</div>
<div id="nsa-anonymous-username" class="ulist">
<ul>
<li>
<p><strong>username</strong>
应该分配给匿名请求的用户名. 这样可以确定主体,这对于日志记录和审核可能很重要. 如果未设置,则默认为 <code>anonymousUser</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-csrf"><a class="anchor" href="#nsa-csrf"></a>&lt;csrf&gt;</h5>
<div class="paragraph">
<p>该元素将向应用程序添加 <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">Cross Site Request Forger (CSRF)</a> 保护.  它还将默认的 RequestCache 更新为仅在成功身份验证后重播 "GET" 请求.  可以在<a href="#csrf">跨站点请求伪造 (CSRF) </a>部分中找到其他信息.</p>
</div>
<div class="sect5">
<h6 id="nsa-csrf-parents"><a class="anchor" href="#nsa-csrf-parents"></a>&lt;csrf&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-csrf-attributes"><a class="anchor" href="#nsa-csrf-attributes"></a>&lt;csrf&gt; 属性</h6>
<div id="nsa-csrf-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
可选属性,用于指定禁用 Spring Security 的 CSRF 保护. 默认值为 <code>false</code> (启用 CSRF 保护) . 强烈建议使 CSRF 保护处于启用状态.</p>
</li>
</ul>
</div>
<div id="nsa-csrf-token-repository-ref" class="ulist">
<ul>
<li>
<p><strong>token-repository-ref</strong>
要使用的 <code>CsrfTokenRepository</code>. 默认值为 <code>HttpSessionCsrfTokenRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-csrf-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
用于确定是否应应用 CSRF 的 RequestMatcher 实例. 默认为除 "GET", "TRACE", "HEAD", "OPTIONS" 之外的任何 HTTP 方法.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-custom-filter"><a class="anchor" href="#nsa-custom-filter"></a>&lt;custom-filter&gt;</h5>
<div class="paragraph">
<p>该元素用于向过滤器链添加过滤器.  它不会创建任何其他 bean,而是用于选择 <code>javax.servlet.Filter</code> 类型的 bean (已在应用程序上下文中定义) ,并将其添加到 Spring Security 维护的过滤器链中的特定位置.  完整的详细信息可以在<a href="#ns-custom-filters">命名空间</a>一章中找到.</p>
</div>
<div class="sect5">
<h6 id="nsa-custom-filter-parents"><a class="anchor" href="#nsa-custom-filter-parents"></a>&lt;custom-filter&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-custom-filter-attributes"><a class="anchor" href="#nsa-custom-filter-attributes"></a>&lt;custom-filter&gt; 属性</h6>
<div id="nsa-custom-filter-after" class="ulist">
<ul>
<li>
<p><strong>after</strong>
紧随其后的过滤器,应将自定义过滤器放置在链中.  只有希望将自己的过滤器混入安全过滤器链并了解标准 Spring Security 过滤器的高级用户才需要使用此功能.  过滤器名称映射到特定的 Spring Security 实现过滤器.</p>
</li>
</ul>
</div>
<div id="nsa-custom-filter-before" class="ulist">
<ul>
<li>
<p><strong>before</strong>
紧接在过滤器之前的自定义过滤器应放置在链中的过滤器</p>
</li>
</ul>
</div>
<div id="nsa-custom-filter-position" class="ulist">
<ul>
<li>
<p><strong>position</strong>
自定义过滤器应放置在链中的明确位置. 如果要更换标准过滤器,请使用.</p>
</li>
</ul>
</div>
<div id="nsa-custom-filter-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义对实现 <code>Filter</code> 的 Spring bean 的引用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-expression-handler"><a class="anchor" href="#nsa-expression-handler"></a>&lt;expression-handler&gt;</h5>
<div class="paragraph">
<p>定义 <code>SecurityExpressionHandler</code> 实例,如果启用了基于表达式的访问控制,则将使用该实例. 如果未提供,则将使用默认实现 (不支持 ACL) .</p>
</div>
<div class="sect5">
<h6 id="nsa-expression-handler-parents"><a class="anchor" href="#nsa-expression-handler-parents"></a>&lt;expression-handler&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
<li>
<p><a href="#nsa-websocket-message-broker">websocket-message-broker</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-expression-handler-attributes"><a class="anchor" href="#nsa-expression-handler-attributes"></a>&lt;expression-handler&gt; 属性</h6>
<div id="nsa-expression-handler-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>定义对实现 <code>SecurityExpressionHandler</code> 的 Spring bean 的引用.</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-form-login"><a class="anchor" href="#nsa-form-login"></a>&lt;form-login&gt;</h5>
<div class="paragraph">
<p>用于将 <code>UsernamePasswordAuthenticationFilter</code> 添加到过滤器堆栈,并将 <code>LoginUrlAuthenticationEntryPoint</code> 添加到应用程序上下文,以按需提供身份验证.  这将始终优先于其他由命名空间创建的入口点.  如果未提供任何属性,则将在 URL "/login" <sup class="footnote">[<a id="_footnoteref_14" class="footnote" href="#_footnotedef_14" title="View footnote.">14</a>]</sup> 上自动生成登录页面.
可以使用 <a href="#nsa-form-login-attributes"><code>&lt;form-login&gt;</code> 属性</a> 自定义行为.</p>
</div>
<div class="sect5">
<h6 id="nsa-form-login-parents"><a class="anchor" href="#nsa-form-login-parents"></a>&lt;form-login&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-form-login-attributes"><a class="anchor" href="#nsa-form-login-attributes"></a>&lt;form-login&gt; 属性</h6>
<div id="nsa-form-login-always-use-default-target" class="ulist">
<ul>
<li>
<p><strong>always-use-default-target</strong>
如果设置为 <code>true</code>,则无论用户如何到达登录页面,用户将始终从 <a href="#nsa-form-login-default-target-url">default-target-url</a> 给定的值开始. 映射到 <code>UsernamePasswordAuthenticationFilter</code> 的 <code>alwaysUseDefaultTargetUrl</code> 属性. 默认值为 <code>false</code>.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
对将由身份验证过滤器使用的 <code>AuthenticationDetailsSource</code> 的引用</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-failure-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-handler-ref</strong>
可以用作<a href="#nsa-form-login-authentication-failure-url">authentication-failure-url</a> 的替代方法,从而使您可以在身份验证失败后完全控制导航流程. 该值应该是应用程序上下文中的 <code>AuthenticationFailureHandler</code> bean的名称.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-failure-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-url</strong>
映射到 <code>UsernamePasswordAuthenticationFilter</code> 的 <code>authenticationFailureUrl</code> 属性.  定义登录失败时浏览器将重定向到的URL.  默认值为 <code>/login?error</code>,它将由自动登录页面生成器自动处理,并使用错误消息重新呈现登录页面.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-success-handler-ref</strong>
这可以用作<a href="#nsa-form-login-default-target-url">default-target-url</a> 和<a href="#nsa-form-login-always-use-default-target">always-use-default-target</a>的替代方法,使您在成功认证后完全控制导航流程.  该值应该是应用程序上下文中 <code>AuthenticationSuccessHandler</code> bean的名称.  默认情况下,将使用 <code>SavedRequestAwareAuthenticationSuccessHandler</code> 的实现,并将其注入<a href="#nsa-form-login-default-target-url">default-target-url </a>.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-default-target-url" class="ulist">
<ul>
<li>
<p><strong>default-target-url</strong>
映射到 <code>UsernamePasswordAuthenticationFilter</code> 的 <code>defaultTargetUrl</code> 属性.  如果未设置,则默认值为 "/" (应用程序根目录) .  如果将用户带到最初请求的URL,则在尝试访问受保护的资源时不要求用户登录后,将在登录后将其带到该URL.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-login-page" class="ulist">
<ul>
<li>
<p><strong>login-page</strong>
用于呈现登录页面的 URL. 映射到 <code>LoginUrlAuthenticationEntryPoint</code> 的 <code>loginFormUrl</code> 属性. 默认为 "/login".</p>
</li>
</ul>
</div>
<div id="nsa-form-login-login-processing-url" class="ulist">
<ul>
<li>
<p><strong>login-processing-url</strong>
映射到 <code>UsernamePasswordAuthenticationFilter</code> 的 <code>filterProcessesUrl</code> 属性. 默认值为 "/login".</p>
</li>
</ul>
</div>
<div id="nsa-form-login-password-parameter" class="ulist">
<ul>
<li>
<p><strong>password-parameter</strong>
包含密码的请求参数的名称. 默认为 "password".</p>
</li>
</ul>
</div>
<div id="nsa-form-login-username-parameter" class="ulist">
<ul>
<li>
<p><strong>username-parameter</strong>
包含用户名的请求参数的名称. 默认为 "username".</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-success-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-success-forward-url</strong>
将 <code>ForwardAuthenticationSuccessHandler</code> 映射到 <code>UsernamePasswordAuthenticationFilter</code> 的 <code>authenticationSuccessHandler</code> 属性.</p>
</li>
</ul>
</div>
<div id="nsa-form-login-authentication-failure-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-forward-url</strong>
将 <code>ForwardAuthenticationFailureHandler</code> 映射到 <code>UsernamePasswordAuthenticationFilter</code> 的 <code>authenticationFailureHandler</code> 属性.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-oauth2-login"><a class="anchor" href="#nsa-oauth2-login"></a>&lt;oauth2-login&gt;</h5>
<div class="paragraph">
<p><a href="#oauth2login">OAuth 2.0 Login</a> 功能使用 OAuth 2.0 和/或 OpenID Connect 1.0 提供程序配置身份验证支持.</p>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-login-parents"><a class="anchor" href="#nsa-oauth2-login-parents"></a>&lt;oauth2-login&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-login-attributes"><a class="anchor" href="#nsa-oauth2-login-attributes"></a>&lt;oauth2-login&gt; 属性</h6>
<div id="nsa-oauth2-login-client-registration-repository-ref" class="ulist">
<ul>
<li>
<p><strong>client-registration-repository-ref</strong>
对 <code>ClientRegistrationRepository</code> 的引用.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authorized-client-repository-ref" class="ulist">
<ul>
<li>
<p><strong>authorized-client-repository-ref</strong>
引用 <code>OAuth2AuthorizedClientRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authorized-client-service-ref" class="ulist">
<ul>
<li>
<p><strong>authorized-client-service-ref</strong>
引用 <code>OAuth2AuthorizedClientService</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authorization-request-repository-ref" class="ulist">
<ul>
<li>
<p><strong>authorization-request-repository-ref</strong>
引用 <code>AuthorizationRequestRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authorization-request-resolver-ref" class="ulist">
<ul>
<li>
<p><strong>authorization-request-resolver-ref</strong>
引用 <code>OAuth2AuthorizationRequestResolver</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-access-token-response-client-ref" class="ulist">
<ul>
<li>
<p><strong>access-token-response-client-ref</strong>
引用 <code>OAuth2AccessTokenResponseClient</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-user-authorities-mapper-ref" class="ulist">
<ul>
<li>
<p><strong>user-authorities-mapper-ref</strong>
引用 <code>GrantedAuthoritiesMapper</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
引用 <code>OAuth2UserService</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-oidc-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>oidc-user-service-ref</strong>
对 OpenID Connect <code>OAuth2UserService</code> 的引用.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-login-processing-url" class="ulist">
<ul>
<li>
<p><strong>login-processing-url</strong>
过滤器在其中处理身份验证请求的 URI.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-login-page" class="ulist">
<ul>
<li>
<p><strong>login-page</strong>
发送用户登录的 URI.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authentication-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-success-handler-ref</strong>
引用 <code>AuthenticationSuccessHandler</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-authentication-failure-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-handler-ref</strong>
引用 <code>AuthenticationFailureHandler</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-login-jwt-decoder-factory-ref" class="ulist">
<ul>
<li>
<p><strong>jwt-decoder-factory-ref</strong>
引用由 <code>OidcAuthorizationCodeAuthenticationProvider</code> 使用的 <code>JwtDecoderFactory</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-oauth2-client"><a class="anchor" href="#nsa-oauth2-client"></a>&lt;oauth2-client&gt;</h5>
<div class="paragraph">
<p>配置  <a href="#oauth2client">OAuth 2.0 Client</a>  支持.</p>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-client-parents"><a class="anchor" href="#nsa-oauth2-client-parents"></a>&lt;oauth2-client&gt; 父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-client-attributes"><a class="anchor" href="#nsa-oauth2-client-attributes"></a>&lt;oauth2-client&gt; 属性</h6>
<div id="nsa-oauth2-client-client-registration-repository-ref" class="ulist">
<ul>
<li>
<p><strong>client-registration-repository-ref</strong>
引用 <code>ClientRegistrationRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-client-authorized-client-repository-ref" class="ulist">
<ul>
<li>
<p><strong>authorized-client-repository-ref</strong>
引用 <code>OAuth2AuthorizedClientRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-client-authorized-client-service-ref" class="ulist">
<ul>
<li>
<p><strong>authorized-client-service-ref</strong>
引用 <code>OAuth2AuthorizedClientService</code>.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-client-children"><a class="anchor" href="#nsa-oauth2-client-children"></a>&lt;oauth2-client&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authorization-code-grant">authorization-code-grant</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-authorization-code-grant"><a class="anchor" href="#nsa-authorization-code-grant"></a>&lt;authorization-code-grant&gt;</h5>
<div class="paragraph">
<p>配置 <a href="#oauth2Client-auth-grant-support">OAuth 2.0 Authorization Code Grant</a>.</p>
</div>
<div class="sect5">
<h6 id="nsa-authorization-code-grant-parents"><a class="anchor" href="#nsa-authorization-code-grant-parents"></a>&lt;authorization-code-grant&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-oauth2-client">oauth2-client</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-authorization-code-grant-attributes"><a class="anchor" href="#nsa-authorization-code-grant-attributes"></a>&lt;authorization-code-grant&gt; 属性</h6>
<div id="nsa-authorization-code-grant-authorization-request-repository-ref" class="ulist">
<ul>
<li>
<p><strong>authorization-request-repository-ref</strong>
引用 <code>AuthorizationRequestRepository</code>.</p>
</li>
</ul>
</div>
<div id="nsa-authorization-code-grant-authorization-request-resolver-ref" class="ulist">
<ul>
<li>
<p><strong>authorization-request-resolver-ref</strong>
引用 <code>OAuth2AuthorizationRequestResolver</code>.</p>
</li>
</ul>
</div>
<div id="nsa-authorization-code-grant-access-token-response-client-ref" class="ulist">
<ul>
<li>
<p><strong>access-token-response-client-ref</strong>
引用 <code>OAuth2AccessTokenResponseClient</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-client-registrations"><a class="anchor" href="#nsa-client-registrations"></a>&lt;client-registrations&gt;</h5>
<div class="paragraph">
<p>已向 OAuth 2.0 或 OpenID Connect 1.0 提供程序注册的客户端 (<a href="#oauth2Client-client-registration">ClientRegistration</a>)  的容器元素.</p>
</div>
<div class="sect5">
<h6 id="nsa-client-registrations-children"><a class="anchor" href="#nsa-client-registrations-children"></a>&lt;client-registrations&gt; 子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-client-registration">client-registration</a></p>
</li>
<li>
<p><a href="#nsa-provider">provider</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-client-registration"><a class="anchor" href="#nsa-client-registration"></a>&lt;client-registration&gt;</h5>
<div class="paragraph">
<p>代表在 OAuth 2.0 或 OpenID Connect 1.0 提供程序中注册的客户端.</p>
</div>
<div class="sect5">
<h6 id="nsa-client-registration-parents"><a class="anchor" href="#nsa-client-registration-parents"></a>&lt;client-registration&gt; 父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-client-registrations">client-registrations</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-client-registration-attributes"><a class="anchor" href="#nsa-client-registration-attributes"></a>&lt;client-registration&gt; 属性</h6>
<div id="nsa-client-registration-registration-id" class="ulist">
<ul>
<li>
<p><strong>registration-id</strong>
唯一标识 <code>ClientRegistration</code> 的ID.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-client-id" class="ulist">
<ul>
<li>
<p><strong>client-id</strong>
客户端标识符.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-client-secret" class="ulist">
<ul>
<li>
<p><strong>client-secret</strong>
客户端 secret.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-client-authentication-method" class="ulist">
<ul>
<li>
<p><strong>client-authentication-method</strong>
使用提供者对客户端进行身份验证的方法.
支持的值为  <strong>basic</strong>, <strong>post</strong>  和  <strong>none</strong>  <a href="https://tools.ietf.org/html/rfc6749#section-2.1">(public clients)</a></p>
</li>
</ul>
</div>
<div id="nsa-client-registration-authorization-grant-type" class="ulist">
<ul>
<li>
<p><strong>authorization-grant-type</strong>
OAuth 2.0 授权框架定义了四种 <a href="https://tools.ietf.org/html/rfc6749#section-1.3">Authorization Grant</a> 类型.
支持的值是  <code>authorization_code</code>, <code>client_credentials</code> 和  <code>password</code>.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-redirect-uri" class="ulist">
<ul>
<li>
<p><strong>redirect-uri</strong>
<em>Authorization Server</em> 在最终用户对客户端进行身份验证和授权访问之后,<em>Authorization Server</em> 将最终用户的用户代理重定向到的客户端的注册重定向 URI.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-scope" class="ulist">
<ul>
<li>
<p><strong>scope</strong>
客户在授权请求流程中请求的范围,例如 openid,电子邮件或配置文件.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-client-name" class="ulist">
<ul>
<li>
<p><strong>client-name</strong>
用于客户端的描述性名称.
该名称可能在某些情况下使用,例如在自动生成的登录页面中显示客户端名称时.</p>
</li>
</ul>
</div>
<div id="nsa-client-registration-provider-id" class="ulist">
<ul>
<li>
<p><strong>provider-id</strong>
对关联提供者的引用.  可以引用 <code>&lt;provider&gt;</code> 元素或使用常见的提供程序之一 (google,github,facebook,okta) .</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-provider"><a class="anchor" href="#nsa-provider"></a>&lt;provider&gt;</h5>
<div class="paragraph">
<p>OAuth 2.0 或 OpenID Connect 1.0 提供程序的配置信息.</p>
</div>
<div class="sect5">
<h6 id="nsa-provider-parents"><a class="anchor" href="#nsa-provider-parents"></a>&lt;provider&gt; 父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-client-registrations">client-registrations</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-provider-attributes"><a class="anchor" href="#nsa-provider-attributes"></a>&lt;provider&gt; 属性</h6>
<div id="nsa-provider-provider-id" class="ulist">
<ul>
<li>
<p><strong>provider-id</strong>
唯一标识提供者的 ID.</p>
</li>
</ul>
</div>
<div id="nsa-provider-authorization-uri" class="ulist">
<ul>
<li>
<p><strong>authorization-uri</strong>
授权服务器的授权端点 URI.</p>
</li>
</ul>
</div>
<div id="nsa-provider-token-uri" class="ulist">
<ul>
<li>
<p><strong>token-uri</strong>
授权服务器的令牌端点 URI.</p>
</li>
</ul>
</div>
<div id="nsa-provider-user-info-uri" class="ulist">
<ul>
<li>
<p><strong>user-info-uri</strong>
UserInfo 端点 URI,用于访问经过身份验证的最终用户的  claims/attributes.</p>
</li>
</ul>
</div>
<div id="nsa-provider-user-info-authentication-method" class="ulist">
<ul>
<li>
<p><strong>user-info-authentication-method</strong>
将访问令牌发送到 UserInfo 端点时使用的身份验证方法.
支持的值为  <strong>header</strong>, <strong>form</strong> 和 <strong>query</strong>.</p>
</li>
</ul>
</div>
<div id="nsa-provider-user-info-user-name-attribute" class="ulist">
<ul>
<li>
<p><strong>user-info-user-name-attribute</strong>
在 UserInfo 响应中返回的属性名称,该属性引用了最终用户的名称或标识符.</p>
</li>
</ul>
</div>
<div id="nsa-provider-jwk-set-uri" class="ulist">
<ul>
<li>
<p><strong>jwk-set-uri</strong>
用于从授权服务器检索 JSON Web 密钥 (<a href="https://tools.ietf.org/html/rfc7517">JSON Web Key (JWK)</a> ) 集的 URI,其中包含用于验证 ID 令牌的 JSON Web 签名 (<a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a> ) 以及用户信息响应 (可选) 的加密密钥.</p>
</li>
</ul>
</div>
<div id="nsa-provider-issuer-uri" class="ulist">
<ul>
<li>
<p><strong>issuer-uri</strong>
用于发现 OpenID Connect 提供程序的 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Configuration endpoint</a>或授权服务器的  <a href="https://tools.ietf.org/html/rfc8414#section-3">Metadata endpoint</a> 的 URI,用于初始配置 <code>ClientRegistration</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-oauth2-resource-server"><a class="anchor" href="#nsa-oauth2-resource-server"></a>&lt;oauth2-resource-server&gt;</h5>
<div class="paragraph">
<p>将 <code>BearerTokenAuthenticationFilter</code>,<code>BearerTokenAuthenticationEntryPoint</code> 和 <code>BearerTokenAccessDeniedHandler</code> 添加到配置中.  另外,必须指定 <code>&lt;jwt&gt;</code> 或 <code>&lt;opaque-token&gt;</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-resource-server-parents"><a class="anchor" href="#nsa-oauth2-resource-server-parents"></a>&lt;oauth2-resource-server&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-resource-server-children"><a class="anchor" href="#nsa-oauth2-resource-server-children"></a>&lt;oauth2-resource-server&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-jwt">jwt</a></p>
</li>
<li>
<p><a href="#nsa-opaque-token">opaque-token</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-oauth2-resource-server-attributes"><a class="anchor" href="#nsa-oauth2-resource-server-attributes"></a>&lt;oauth2-resource-server&gt; 属性</h6>
<div id="nsa-oauth2-resource-server-authentication-manager-resolver-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-manager-resolver-ref</strong>
引用 <code>AuthenticationManagerResolver</code>,它将在请求时解析 <code>AuthenticationManager</code></p>
</li>
</ul>
</div>
<div id="nsa-oauth2-resource-server-bearer-token-resolver-ref" class="ulist">
<ul>
<li>
<p><strong>bearer-token-resolver-ref</strong>
引用 <code>BearerTokenResolver</code>,它将从请求中获取承载令牌.</p>
</li>
</ul>
</div>
<div id="nsa-oauth2-resource-server-entry-point-ref" class="ulist">
<ul>
<li>
<p><strong>entry-point-ref</strong>
引用将处理未授权请求的 <code>AuthenticationEntryPoint</code></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-jwt"><a class="anchor" href="#nsa-jwt"></a>&lt;jwt&gt;</h5>
<div class="paragraph">
<p>表示将授权 JWT 的 OAuth 2.0 资源服务器</p>
</div>
<div class="sect5">
<h6 id="nsa-jwt-parents"><a class="anchor" href="#nsa-jwt-parents"></a>&lt;jwt&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-oauth2-resource-server">oauth2-resource-server</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-jwt-attributes"><a class="anchor" href="#nsa-jwt-attributes"></a>&lt;jwt&gt; 属性</h6>
<div id="nsa-jwt-jwt-authentication-converter-ref" class="ulist">
<ul>
<li>
<p><strong>jwt-authentication-converter-ref</strong>
对  <code>Converter&lt;Jwt, AbstractAuthenticationToken&gt;</code> 的引用</p>
</li>
</ul>
</div>
<div id="nsa-jwt-decoder-ref" class="ulist">
<ul>
<li>
<p><strong>jwt-decoder-ref</strong>
引用 <code>JwtDecoder</code>.  这是一个较大的组件,它会覆盖 <code>jwk-set-uri</code></p>
</li>
</ul>
</div>
<div id="nsa-jwt-jwk-set-uri" class="ulist">
<ul>
<li>
<p><strong>jwk-set-uri</strong>
用于从 OAuth 2.0 授权服务器加载签名验证密钥的 JWK 集 Uri</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-opaque-token"><a class="anchor" href="#nsa-opaque-token"></a>&lt;opaque-token&gt;</h5>
<div class="paragraph">
<p>表示将授权不透明令牌的 OAuth 2.0 资源服务器</p>
</div>
<div class="sect5">
<h6 id="nsa-opaque-token-parents"><a class="anchor" href="#nsa-opaque-token-parents"></a>&lt;opaque-token&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-oauth2-resource-server">oauth2-resource-server</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-opaque-token-attributes"><a class="anchor" href="#nsa-opaque-token-attributes"></a>&lt;opaque-token&gt; 属性</h6>
<div id="nsa-opaque-token-introspector-ref" class="ulist">
<ul>
<li>
<p><strong>introspector-ref</strong>
引用 <code>OpaqueTokenIntrospector</code>. 这是一个较大的组件,它会覆盖 <code>introspection-uri</code>, <code>client-id</code>, 和 <code>client-secret</code>.</p>
</li>
</ul>
</div>
<div id="nsa-opaque-token-introspection-uri" class="ulist">
<ul>
<li>
<p><strong>introspection-uri</strong>
内省 Uri 用来内省不透明令牌的详细信息.  应随附 <code>client-id</code> 和 <code>client-secret</code>.</p>
</li>
</ul>
</div>
<div id="nsa-opaque-token-client-id" class="ulist">
<ul>
<li>
<p><strong>client-id</strong>
用于针对提供的 <code>introspection-uri</code> 进行客户端身份验证的客户端 ID.</p>
</li>
</ul>
</div>
<div id="nsa-opaque-token-client-secret" class="ulist">
<ul>
<li>
<p><strong>client-secret</strong>
用于根据提供的 <code>introspection-uri</code> 进行客户端身份验证的客户端密钥.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-http-basic"><a class="anchor" href="#nsa-http-basic"></a>&lt;http-basic&gt;</h5>
<div class="paragraph">
<p>将 <code>BasicAuthenticationFilter</code> 和 <code>BasicAuthenticationEntryPoint</code> 添加到配置中. 如果未启用基于表单的登录,则后者将仅用作配置入口点.</p>
</div>
<div class="sect5">
<h6 id="nsa-http-basic-parents"><a class="anchor" href="#nsa-http-basic-parents"></a>&lt;http-basic&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-http-basic-attributes"><a class="anchor" href="#nsa-http-basic-attributes"></a>&lt;http-basic&gt; 属性</h6>
<div id="nsa-http-basic-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
对将由身份验证过滤器使用 的 <code>AuthenticationDetailsSource</code> 的引用</p>
</li>
</ul>
</div>
<div id="nsa-http-basic-entry-point-ref" class="ulist">
<ul>
<li>
<p><strong>entry-point-ref</strong>
设置 <code>BasicAuthenticationFilter</code> 使用的 <code>AuthenticationEntryPoint</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-http-firewall"><a class="anchor" href="#nsa-http-firewall"></a>&lt;http-firewall&gt; 元素</h5>
<div class="paragraph">
<p>这是一个顶级元素,可用于将 <code>HttpFirewall</code> 的自定义实现注入到由命名空间创建的 <code>FilterChainProxy</code> 中. 默认实现应适合大多数应用程序.</p>
</div>
<div class="sect5">
<h6 id="nsa-http-firewall-attributes"><a class="anchor" href="#nsa-http-firewall-attributes"></a>&lt;http-firewall&gt; 属性</h6>
<div id="nsa-http-firewall-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义对实现 <code>HttpFirewall</code> 的Spring bean的引用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-intercept-url"><a class="anchor" href="#nsa-intercept-url"></a>&lt;intercept-url&gt;</h5>
<div class="paragraph">
<p>此元素用于定义应用程序感兴趣的 URL 模式集,并配置应如何处理它们.  它用于构造 <code>FilterSecurityInterceptor</code> 使用的 <code>FilterInvocationSecurityMetadataSource</code>.  例如,如果需要通过 HTTPS 访问特定的 URL,它还负责配置 <code>ChannelProcessingFilter</code>.  当将指定的模式与传入的请求进行匹配时,将按照声明元素的顺序进行匹配.
因此,最具体的模式应该放在首位,最一般的模式应该放在最后.</p>
</div>
<div class="sect5">
<h6 id="nsa-intercept-url-parents"><a class="anchor" href="#nsa-intercept-url-parents"></a>&lt;intercept-url&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-filter-security-metadata-source">filter-security-metadata-source</a></p>
</li>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-intercept-url-attributes"><a class="anchor" href="#nsa-intercept-url-attributes"></a>&lt;intercept-url&gt; 属性</h6>
<div id="nsa-intercept-url-access" class="ulist">
<ul>
<li>
<p><strong>access</strong>
列出访问属性,这些属性将为定义的 URL 模式/方法组合存储在 <code>FilterInvocationSecurityMetadataSource</code> 中. 这应该是安全配置属性 (例如角色名称) 的逗号分隔列表.</p>
</li>
</ul>
</div>
<div id="nsa-intercept-url-method" class="ulist">
<ul>
<li>
<p><strong>method</strong>
HTTP 方法将与模式和 servlet 路径 (可选) 结合使用,以匹配传入的请求.  如果省略,则任何方法都将匹配.  如果使用和不使用方法指定了相同的模式,则特定于方法的匹配将优先.</p>
</li>
</ul>
</div>
<div id="nsa-intercept-url-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong>
定义URL路径的模式. 内容将取决于包含http元素的 <code>request-matcher</code> 属性,因此默认为 ant path 语法.</p>
</li>
</ul>
</div>
<div id="nsa-intercept-url-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
对 <code>RequestMatcher</code> 的引用,该引用将用于确定是否使用此 <code>&lt;intercept-url&gt;</code>.</p>
</li>
</ul>
</div>
<div id="nsa-intercept-url-requires-channel" class="ulist">
<ul>
<li>
<p><strong>requires-channel</strong>
可以为 "http"  或 "https",具体取决于应分别通过 HTTP 还是 HTTPS 访问特定的 URL 模式.  或者,在没有首选项时可以使用值 "any".  如果任何 <code>&lt;intercept-url&gt;</code> 元素上都存在此属性,则将 <code>ChannelProcessingFilter</code> 添加到过滤器堆栈中,并将其附加依赖添加到应用程序上下文中.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果添加了 <code>&lt;port-mappings&gt;</code> 配置,则 <code>SecureChannelProcessor</code> 和 <code>InsecureChannelProcessor</code> Bean 将使用此配置来确定用于重定向到 <code>HTTP/HTTPS</code> 的端口.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
此属性对于<a href="#nsa-filter-security-metadata-source">filter-security-metadata-source</a>无效
</td>
</tr>
</table>
</div>
<div id="nsa-intercept-url-servlet-path" class="ulist">
<ul>
<li>
<p><strong>servlet-path</strong>
Servlet 路径将与模式和 HTTP 方法结合使用,以匹配传入的请求.  仅当<a href="#nsa-http-request-matcher">请求匹配</a>为 <code>mvc</code> 时,此属性才适用.  另外,仅在以下两个用例中需要该值: 1) 在 <code>ServletContext</code> 中注册了2个或更多 <code>HttpServlet</code>,它们的映射以 <code>/</code> 开头并且不同.
2) 模式以已注册 <code>HttpServlet</code> 路径的相同值开头,但不包括默认 (根)  <code>HttpServlet</code> <code>'/'</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
此属性对于<a href="#nsa-filter-security-metadata-source">filter-security-metadata-source</a>无效
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-jee"><a class="anchor" href="#nsa-jee"></a>&lt;jee&gt;</h5>
<div class="paragraph">
<p>将 J2eePreAuthenticatedProcessingFilter 添加到过滤器链以提供与容器身份验证的集成.</p>
</div>
<div class="sect5">
<h6 id="nsa-jee-parents"><a class="anchor" href="#nsa-jee-parents"></a>&lt;jee&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-jee-attributes"><a class="anchor" href="#nsa-jee-attributes"></a>&lt;jee&gt; 属性</h6>
<div id="nsa-jee-mappable-roles" class="ulist">
<ul>
<li>
<p><strong>mappable-roles</strong>
在传入的 HttpServletRequest 中寻找以逗号分隔得 Role 列表.</p>
</li>
</ul>
</div>
<div id="nsa-jee-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
对用户服务 (或 UserDetailsService bean) ID的引用</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-logout"><a class="anchor" href="#nsa-logout"></a>&lt;logout&gt;</h5>
<div class="paragraph">
<p>将 <code>LogoutFilter</code> 添加到过滤器堆栈. 这是使用 <code>SecurityContextLogoutHandler</code> 配置的.</p>
</div>
<div class="sect5">
<h6 id="nsa-logout-parents"><a class="anchor" href="#nsa-logout-parents"></a>&lt;logout&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-logout-attributes"><a class="anchor" href="#nsa-logout-attributes"></a>&lt;logout&gt; 属性</h6>
<div id="nsa-logout-delete-cookies" class="ulist">
<ul>
<li>
<p><strong>delete-cookies</strong>
Cookie 的名称的逗号分隔列表,当用户注销时应删除.</p>
</li>
</ul>
</div>
<div id="nsa-logout-invalidate-session" class="ulist">
<ul>
<li>
<p><strong>invalidate-session</strong>
映射到 <code>SecurityContextLogoutHandler</code> 的 <code>invalidateHttpSession</code>. 默认为 "true",因此会话将在注销时失效.</p>
</li>
</ul>
</div>
<div id="nsa-logout-logout-success-url" class="ulist">
<ul>
<li>
<p><strong>logout-success-url</strong>
用户注销后将被带到的目标 URL.  默认为 <code>&lt;form-login-login-page&gt;/?logout</code> (即 <code>/login?logout</code>)</p>
<div class="paragraph">
<p>设置此属性将注入配置有属性值的 <code>SimpleRedirectInvalidSessionStrategy</code> 的 <code>SessionManagementFilter</code>.  提交无效的会话 ID 后,将调用该策略,并重定向到配置的 URL.</p>
</div>
</li>
</ul>
</div>
<div id="nsa-logout-logout-url" class="ulist">
<ul>
<li>
<p><strong>logout-url</strong>
导致注销的网址 (即由过滤器处理的网址) .  默认为 "/logout".</p>
</li>
</ul>
</div>
<div id="nsa-logout-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>success-handler-ref</strong>
可用于提供 <code>LogoutSuccessHandler</code> 的实例,注销后将调用该实例来控制导航.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-openid-login"><a class="anchor" href="#nsa-openid-login"></a>&lt;openid-login&gt;</h5>
<div class="paragraph">
<p>与 <code>&lt;form-login&gt;</code> 相似,并且具有相同的属性.  <code>login-processing-url</code> 的默认值为 "/login/openid".  将注册一个 <code>OpenIDAuthenticationFilter</code> 和 <code>OpenIDAuthenticationProvider</code>.  后者需要对 <code>UserDetailsService</code> 的引用.
同样,可以使用 <code>user-service-ref</code> 属性由 <code>id</code> 指定,或者将其自动定位在应用程序上下文中.</p>
</div>
<div class="sect5">
<h6 id="nsa-openid-login-parents"><a class="anchor" href="#nsa-openid-login-parents"></a>&lt;openid-login&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-openid-login-attributes"><a class="anchor" href="#nsa-openid-login-attributes"></a>&lt;openid-login&gt; 属性</h6>
<div id="nsa-openid-login-always-use-default-target" class="ulist">
<ul>
<li>
<p><strong>always-use-default-target</strong>
登录后是否应始终将用户重定向到 default-target-url.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
对将由身份验证过滤器使用的 <code>AuthenticationDetailsSource</code> 的引用</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-failure-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-handler-ref</strong>
对 AuthenticationFailureHandler bean 的引用,该 bean 应该用于处理失败的身份验证请求.  不应与 authentication-failure-url 结合使用,因为实现应始终处理到后续目标的导航</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-failure-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-url</strong>
登录失败页面的 URL. 如果未指定登录失败 URL,Spring Security 将在 <code>/login?login_error</code> 处自动创建一个失败登录URL,并创建一个相应的过滤器以在请求时呈现该登录失败 URL.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-success-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-success-forward-url</strong>
将 <code>ForwardAuthenticationSuccessHandler</code> 映射到 <code>UsernamePasswordAuthenticationFilter</code> 的 <code>authenticationSuccessHandler</code> 属性.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-failure-forward-url" class="ulist">
<ul>
<li>
<p><strong>authentication-failure-forward-url</strong>
将 <code>ForwardAuthenticationFailureHandler</code> 映射到 <code>UsernamePasswordAuthenticationFilter</code> 的 <code>authenticationFailureHandler</code> 属性.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-authentication-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-success-handler-ref</strong>
引用AuthenticationSuccessHandler bean,应将其用于处理成功的身份验证请求.  不应与 <a href="#nsa-openid-login-default-target-url">default-target-url</a> (或<a href="#nsa-openid-login-always-use-default-target">always-use-default-target</a>) 结合使用,因为实现应始终处理到后续目标的导航</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-default-target-url" class="ulist">
<ul>
<li>
<p><strong>default-target-url</strong>
如果无法恢复用户的先前操作,则在成功认证后将重定向到的 URL.  如果用户在未先请求触发身份验证的安全操作的情况下访问登录页面,通常会发生这种情况.  如果未指定,则默认为应用程序的根目录.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-login-page" class="ulist">
<ul>
<li>
<p><strong>login-page</strong>
登录页面的 URL.  如果未指定登录 URL,Spring Security 将在 <code>/login</code> 自动创建一个登录 URL,并在请求时自动创建一个相应的过滤器来呈现该登录 URL.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-login-processing-url" class="ulist">
<ul>
<li>
<p><strong>login-processing-url</strong>
登录表单发布到的 URL. 如果未指定,则默认为 /login.</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-password-parameter" class="ulist">
<ul>
<li>
<p><strong>password-parameter</strong>
包含密码的请求参数的名称. 默认为 "password".</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
对用户服务 (或UserDetailsService bean) ID 的引用</p>
</li>
</ul>
</div>
<div id="nsa-openid-login-username-parameter" class="ulist">
<ul>
<li>
<p><strong>username-parameter</strong>
包含用户名的请求参数的名称. 默认为 "username".</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-openid-login-children"><a class="anchor" href="#nsa-openid-login-children"></a>&lt;openid-login&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-attribute-exchange">attribute-exchange</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-attribute-exchange"><a class="anchor" href="#nsa-attribute-exchange"></a>&lt;attribute-exchange&gt;</h5>
<div class="paragraph">
<p><code>attribute-exchange</code> 元素定义应从身份提供者请求的属性列表.  可以在命名空间配置一章的 <a href="#servlet-openid">OpenID Support</a>部分中找到一个示例.  可以使用多个,在这种情况下,每个必须具有 <code>identifier-match</code> 属性,其中包含与提供的 OpenID 标识符匹配的正则表达式.  这允许从不同的提供程序 (Google,Yahoo 等) 获取不同的属性列表.</p>
</div>
<div class="sect5">
<h6 id="nsa-attribute-exchange-parents"><a class="anchor" href="#nsa-attribute-exchange-parents"></a>&lt;attribute-exchange&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-openid-login">openid-login</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-attribute-exchange-attributes"><a class="anchor" href="#nsa-attribute-exchange-attributes"></a>&lt;attribute-exchange&gt; 属性</h6>
<div id="nsa-attribute-exchange-identifier-match" class="ulist">
<ul>
<li>
<p><strong>identifier-match</strong>
确定在身份验证期间使用哪种属性交换配置时,将与所声明的身份进行比较的正则表达式.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-attribute-exchange-children"><a class="anchor" href="#nsa-attribute-exchange-children"></a>&lt;attribute-exchange&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-openid-attribute">openid-attribute</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-openid-attribute"><a class="anchor" href="#nsa-openid-attribute"></a>&lt;openid-attribute&gt;</h5>
<div class="paragraph">
<p>发出 OpenID AX <a href="https://openid.net/specs/openid-attribute-exchange-1_0.html#fetch_request"> Fetch Request</a> 时使用的属性</p>
</div>
<div class="sect5">
<h6 id="nsa-openid-attribute-parents"><a class="anchor" href="#nsa-openid-attribute-parents"></a>&lt;openid-attribute&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-attribute-exchange">attribute-exchange</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-openid-attribute-attributes"><a class="anchor" href="#nsa-openid-attribute-attributes"></a>&lt;openid-attribute&gt; 属性</h6>
<div id="nsa-openid-attribute-count" class="ulist">
<ul>
<li>
<p><strong>count</strong>
指定希望获取的属性数量. 例如,返回 3 封电子邮件. 预设值为 1</p>
</li>
</ul>
</div>
<div id="nsa-openid-attribute-name" class="ulist">
<ul>
<li>
<p><strong>name</strong>
指定要获取的属性的名称. 例如,电子邮件.</p>
</li>
</ul>
</div>
<div id="nsa-openid-attribute-required" class="ulist">
<ul>
<li>
<p><strong>required</strong>
指定该属性是否是 OP 所必需的,但如果 OP 不返回该属性,则不会出错. 默认为 false.</p>
</li>
</ul>
</div>
<div id="nsa-openid-attribute-type" class="ulist">
<ul>
<li>
<p><strong>type</strong>
指定属性类型. 例如, <a href="https://axschema.org/contact/email" class="bare">axschema.org/contact/email</a>. 有关有效属性类型,请参见您的 OP 文档.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-port-mappings"><a class="anchor" href="#nsa-port-mappings"></a>&lt;port-mappings&gt;</h5>
<div class="paragraph">
<p>默认情况下,会将 <code>PortMapperImpl</code> 的实例添加到配置中,以用于重定向到安全和不安全的URL.  可以选择使用此元素来覆盖该类定义的默认映射.  每个子 <code>&lt;port-mapping&gt;</code> 元素都定义一对 HTTP: HTTPS 端口.  默认映射为 80: 443 和 8080: 8443.  在 <a href="#servlet-http-redirect">重定向 HTTPS</a> 中可以找到覆盖这些示例.</p>
</div>
<div class="sect5">
<h6 id="nsa-port-mappings-parents"><a class="anchor" href="#nsa-port-mappings-parents"></a>&lt;port-mappings&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-port-mappings-children"><a class="anchor" href="#nsa-port-mappings-children"></a>&lt;port-mappings&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-port-mapping">port-mapping</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-port-mapping"><a class="anchor" href="#nsa-port-mapping"></a>&lt;port-mapping&gt;</h5>
<div class="paragraph">
<p>提供一种在强制重定向时将 http 端口映射到 https 端口的方法.</p>
</div>
<div class="sect5">
<h6 id="nsa-port-mapping-parents"><a class="anchor" href="#nsa-port-mapping-parents"></a>&lt;port-mapping&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-port-mappings">port-mappings</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-port-mapping-attributes"><a class="anchor" href="#nsa-port-mapping-attributes"></a>&lt;port-mapping&gt; 属性</h6>
<div id="nsa-port-mapping-http" class="ulist">
<ul>
<li>
<p><strong>http</strong>
要使用的 http 端口.</p>
</li>
</ul>
</div>
<div id="nsa-port-mapping-https" class="ulist">
<ul>
<li>
<p><strong>https</strong>
要使用的 https 端口.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-remember-me"><a class="anchor" href="#nsa-remember-me"></a>&lt;remember-me&gt;</h5>
<div class="paragraph">
<p>将 <code>RememberMeAuthenticationFilter</code> 添加到堆栈中.  反过来,将根据属性设置,使用 <code>TokenBasedRememberMeServices</code>,<code>PersistentTokenBasedRememberMeServices</code> 或由用户指定的实现 <code>RememberMeServices</code> 的 bea n进行配置.</p>
</div>
<div class="sect5">
<h6 id="nsa-remember-me-parents"><a class="anchor" href="#nsa-remember-me-parents"></a>&lt;remember-me&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-remember-me-attributes"><a class="anchor" href="#nsa-remember-me-attributes"></a>&lt;remember-me&gt; 属性</h6>
<div id="nsa-remember-me-authentication-success-handler-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-success-handler-ref</strong>
如果需要自定义导航,则在 <code>RememberMeAuthenticationFilter</code> 上设置 <code>authenticationSuccessHandler</code> 属性. 该值应该是应用程序上下文中 <code>AuthenticationSuccessHandler</code> bean的名称.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-data-source-ref" class="ulist">
<ul>
<li>
<p><strong>data-source-ref</strong>
对 <code>DataSource</code> bean 的引用. 如果设置此选项,将使用 <code>PersistentTokenBasedRememberMeServices</code> 并通过 <code>JdbcTokenRepositoryImpl</code> 实例进行配置.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-remember-me-parameter" class="ulist">
<ul>
<li>
<p><strong>remember-me-parameter</strong>
切换 "记住我" 身份验证的请求参数的名称. 默认为 "remember-me". 映射到 <code>AbstractRememberMeServices</code> 的 "parameter" 属性.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-remember-me-cookie" class="ulist">
<ul>
<li>
<p><strong>remember-me-cookie</strong>
存储用于记住我身份验证的令牌的 cookie 的名称. 默认为 "remember-me". 映射到 <code>AbstractRememberMeServices</code> 的 "cookieName" 属性.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-key" class="ulist">
<ul>
<li>
<p><strong>key</strong>
映射到 <code>AbstractRememberMeServices</code> 的 "key" 属性.  应将其设置为唯一值,以确保 "记住我的Cookie" 仅在一个应用程序中有效 <sup class="footnote">[<a id="_footnoteref_15" class="footnote" href="#_footnotedef_15" title="View footnote.">15</a>]</sup>.  如果未设置,将生成一个安全的随机值.
由于生成安全的随机值可能需要一段时间,因此,在使用 "记住我" 功能时,显式设置该值有助于缩短启动时间.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-services-alias" class="ulist">
<ul>
<li>
<p><strong>services-alias</strong>
将内部定义的 <code>RememberMeServices</code> 导出为 bean 别名,从而允许应用程序上下文中的其他 bean 使用它.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-services-ref" class="ulist">
<ul>
<li>
<p><strong>services-ref</strong>
允许完全控制过滤器将使用的 <code>RememberMeServices</code> 实现.  该值应该是实现此接口的应用程序上下文中的 bean 的 <code>ID</code>.  如果正在使用注销过滤器,则还应该实现 <code>LogoutHandler</code>.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-token-repository-ref" class="ulist">
<ul>
<li>
<p><strong>token-repository-ref</strong>
<code>PersistentTokenBasedRememberMeServices</code>,但允许使用自定义 <code>PersistentTokenRepository</code> bean.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-token-validity-seconds" class="ulist">
<ul>
<li>
<p><strong>token-validity-seconds</strong>
映射到 <code>AbstractRememberMeServices</code> 的 <code>tokenValiditySeconds</code> 属性. 指定记住我的 cookie 有效的时间段 (以秒为单位) . 默认情况下,有效期为14天.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-use-secure-cookie" class="ulist">
<ul>
<li>
<p><strong>use-secure-cookie</strong>
建议记住我的 cookie 仅通过 HTTPS 提交,因此应将其标记为 "安全".  默认情况下,如果发出登录请求的连接是安全的 (应该如此) ,则将使用安全 cookie.  如果将此属性设置为 <code>false</code>,将不使用安全 cookie.  将其设置为 <code>true</code> 将始终在 cookie 上设置安全标志.  此属性映射到 <code>AbstractRememberMeServices</code> 的 <code>useSecureCookie</code> 属性.</p>
</li>
</ul>
</div>
<div id="nsa-remember-me-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
"记住我" 服务实现要求访问 <code>UserDetailsService</code>,因此在应用程序上下文中必须定义一个.  如果只有一个,它将由命名空间配置自动选择和使用.  如果有多个实例,则可以使用此属性显式指定bean <code>ID</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-request-cache"><a class="anchor" href="#nsa-request-cache"></a>&lt;request-cache&gt; 元素</h5>
<div class="paragraph">
<p>设置 <code>RequestCache</code> 实例,在调用 <code>AuthenticationEntryPoint</code> 之前,<code>ExceptionTranslationFilter</code> 将使用该实例存储请求信息.</p>
</div>
<div class="sect5">
<h6 id="nsa-request-cache-parents"><a class="anchor" href="#nsa-request-cache-parents"></a>&lt;request-cache&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-request-cache-attributes"><a class="anchor" href="#nsa-request-cache-attributes"></a>&lt;request-cache&gt; 属性</h6>
<div id="nsa-request-cache-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义对作为 <code>RequestCache</code> 的 Spring bean 的引用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-session-management"><a class="anchor" href="#nsa-session-management"></a>&lt;session-management&gt;</h5>
<div class="paragraph">
<p>与会话管理相关的功能是通过在过滤器堆栈中添加 <code>SessionManagementFilter</code> 来实现的.</p>
</div>
<div class="sect5">
<h6 id="nsa-session-management-parents"><a class="anchor" href="#nsa-session-management-parents"></a>&lt;session-management&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-session-management-attributes"><a class="anchor" href="#nsa-session-management-attributes"></a>&lt;session-management&gt; 属性</h6>
<div id="nsa-session-management-invalid-session-url" class="ulist">
<ul>
<li>
<p><strong>invalid-session-url</strong>
设置此属性将注入配置有属性值的 <code>SimpleRedirectInvalidSessionStrategy</code> 的 <code>SessionManagementFilter</code>. 提交无效的会话 ID 后,将调用该策略,并重定向到配置的 URL.</p>
</li>
</ul>
</div>
<div id="nsa-session-management-invalid-session-strategy-ref" class="ulist">
<ul>
<li>
<p><strong>invalid-session-url</strong>
允许注入由 <code>SessionManagementFilter</code> 使用的 <code>InvalidSessionStrategy</code> 实例. 使用此属性或 <code>invalid-session-url</code> 属性,但不能同时使用.</p>
</li>
</ul>
</div>
<div id="nsa-session-management-session-authentication-error-url" class="ulist">
<ul>
<li>
<p><strong>session-authentication-error-url</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>定义错误页面的 URL,当 <code>SessionAuthenticationStrategy</code> 引发异常时应显示该页面.  如果未设置,则将未经授权的 (401) 错误代码返回给客户端.  请注意,如果在基于表单的登录过程中发生错误,则该属性将不适用,在该表单中,身份验证失败的 URL 将优先.</p>
</div>
<div id="nsa-session-management-session-authentication-strategy-ref" class="ulist">
<ul>
<li>
<p><strong>session-authentication-strategy-ref</strong>
允许注入由 SessionManagementFilter 使用的 SessionAuthenticationStrategy 实例</p>
</li>
</ul>
</div>
<div id="nsa-session-management-session-fixation-protection" class="ulist">
<ul>
<li>
<p><strong>session-fixation-protection</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>指示用户认证时如何应用会话固定保护.  如果设置为 "none",则不会应用任何保护.  "newSession" 将创建一个新的空会话,仅迁移与 Spring Security 相关的属性.  "migrateSession" 将创建一个新会话并将所有会话属性复制到新会话.
在 Servlet 3.1 (Java EE 7) 和更高版本的容器中,指定 "changeSessionId" 将保留现有会话并使用容器提供的会话固定保护 (<code>HttpServletRequest#changeSessionId()</code>) .  在 Servlet 3.1 和更高版本的容器中,默认值为 "changeSessionId"; 在较旧的容器中,
默认值为 "migrateSession".  如果在较旧的容器中使用 "changeSessionId",则抛出异常.</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="paragraph">
<p>如果启用了会话固定保护,则会向 <code>SessionManagementFilter</code> 注入适当配置的 <code>DefaultSessionAuthenticationStrategy</code>.  有关更多详细信息,请参见此类的 Javadoc.</p>
</div>
</div>
<div class="sect5">
<h6 id="nsa-session-management-children"><a class="anchor" href="#nsa-session-management-children"></a>&lt;session-management&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-concurrency-control">concurrency-control</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-concurrency-control"><a class="anchor" href="#nsa-concurrency-control"></a>&lt;concurrency-control&gt;</h5>
<div class="paragraph">
<p>增加了对并发会话控制的支持,从而可以限制用户可以拥有的 active 会话的数量.  将创建一个 <code>ConcurrentSessionFilter</code>,并将 <code>ConcurrentSessionControlAuthenticationStrategy</code> 与 <code>SessionManagementFilter</code> 一起使用.  如果声明了 <code>form-login</code> 元素,则策略对象也将注入到创建的身份验证过滤器中.  将创建一个 <code>SessionRegistry</code> 实例 (除非用户希望使用自定义 bean,否则将为 <code>SessionRegistryImpl</code> 实例) 供该策略使用.</p>
</div>
<div class="sect5">
<h6 id="nsa-concurrency-control-parents"><a class="anchor" href="#nsa-concurrency-control-parents"></a>&lt;concurrency-control&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-session-management">session-management</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-concurrency-control-attributes"><a class="anchor" href="#nsa-concurrency-control-attributes"></a>&lt;concurrency-control&gt; 属性</h6>
<div id="nsa-concurrency-control-error-if-maximum-exceeded" class="ulist">
<ul>
<li>
<p><strong>error-if-maximum-exceeded</strong>
如果设置为 "true",则当用户尝试超过允许的最大会话数时,将引发 <code>SessionAuthenticationException</code>. 默认行为是使原始会话到期.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-expired-url" class="ulist">
<ul>
<li>
<p><strong>expired-url</strong>
如果用户尝试使用并发会话控制器已 "过期" 的会话,则该用户将被重定向到该 URL,因为该用户已超过允许的会话数,并已在其他位置再次登录.  除非设置了 <code>if-if-maximum-exceeded</code>,否则应设置.  如果未提供任何值,则到期消息将直接写回到响应中.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-expired-session-strategy-ref" class="ulist">
<ul>
<li>
<p><strong>expired-url</strong>
允许注入 ConcurrentSessionFilter 使用的 ExpiredSessionStrategy 实例</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-max-sessions" class="ulist">
<ul>
<li>
<p><strong>max-sessions</strong>
映射到 <code>ConcurrentSessionControlAuthenticationStrategy</code> 的 <code>maximumSessions</code> 属性. 指定 <code>-1</code> 作为支持无限会话的值.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-session-registry-alias" class="ulist">
<ul>
<li>
<p><strong>session-registry-alias</strong>
引用内部会话注册表以在自己的 bean 或管理界面中使用也很有用.  您可以使用 <code>session-registry-alias</code> 属性暴露内部 bean,为其提供一个名称,您可以在配置中的其他位置使用它.</p>
</li>
</ul>
</div>
<div id="nsa-concurrency-control-session-registry-ref" class="ulist">
<ul>
<li>
<p><strong>session-registry-ref</strong>
用户可以使用 <code>session-registry-ref</code> 属性提供自己的 <code>SessionRegistry</code> 实现.  其他并发会话控制 bean 将被连接起来以使用它.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-x509"><a class="anchor" href="#nsa-x509"></a>&lt;x509&gt;</h5>
<div class="paragraph">
<p>添加了对 X.509 身份验证的支持.  <code>X509AuthenticationFilter</code> 将添加到堆栈中,并将创建 <code>Http403ForbiddenEntryPoint</code> bean.  仅当不使用其他身份验证机制时才使用后者 (它的唯一功能是返回 HTTP 403 错误代码) .
还将创建一个 <code>PreAuthenticatedAuthenticationProvider</code>,它将用户权限的加载委派给 <code>UserDetailsService</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-x509-parents"><a class="anchor" href="#nsa-x509-parents"></a>&lt;x509&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-http">http</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-x509-attributes"><a class="anchor" href="#nsa-x509-attributes"></a>&lt;x509&gt; 属性</h6>
<div id="nsa-x509-authentication-details-source-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-details-source-ref</strong>
对 <code>AuthenticationDetailsSource</code> 的引用</p>
</li>
</ul>
</div>
<div id="nsa-x509-subject-principal-regex" class="ulist">
<ul>
<li>
<p><strong>subject-principal-regex</strong>
定义一个正则表达式,该正则表达式将用于从证书中提取用户名 (与 <code>UserDetailsService</code> 一起使用) .</p>
</li>
</ul>
</div>
<div id="nsa-x509-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
如果配置了多个实例,则允许特定的 <code>UserDetailsService</code> 与X.509一起使用. 如果未设置,将尝试自动查找并使用合适的实例.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-filter-chain-map"><a class="anchor" href="#nsa-filter-chain-map"></a>&lt;filter-chain-map&gt;</h5>
<div class="paragraph">
<p>用于通过 FilterChainMap 显式配置 FilterChainProxy 实例</p>
</div>
<div class="sect5">
<h6 id="nsa-filter-chain-map-attributes"><a class="anchor" href="#nsa-filter-chain-map-attributes"></a>&lt;filter-chain-map&gt; 属性</h6>
<div id="nsa-filter-chain-map-request-matcher" class="ulist">
<ul>
<li>
<p><strong>request-matcher</strong>
定义用于匹配传入请求的策略. 当前,选项为 <code>ant</code> (用于ant路径模式) ,<code>regex</code> 用于正则表达式,<code>ciRegex</code> 用于不区分大小写的正则表达式.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-filter-chain-map-children"><a class="anchor" href="#nsa-filter-chain-map-children"></a>&lt;filter-chain-map&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-filter-chain">filter-chain</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-filter-chain"><a class="anchor" href="#nsa-filter-chain"></a>&lt;filter-chain&gt;</h5>
<div class="paragraph">
<p>用于内部以定义特定的 URL 模式以及适用于与该模式匹配的 URL 的过滤器列表.  当在列表中组合多个过滤器链元素以配置 FilterChainProxy 时,最特定的模式必须放在列表的顶部,最普通的模式应放在底部.</p>
</div>
<div class="sect5">
<h6 id="nsa-filter-chain-parents"><a class="anchor" href="#nsa-filter-chain-parents"></a>&lt;filter-chain&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-filter-chain-map">filter-chain-map</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-filter-chain-attributes"><a class="anchor" href="#nsa-filter-chain-attributes"></a>&lt;filter-chain&gt; 属性</h6>
<div id="nsa-filter-chain-filters" class="ulist">
<ul>
<li>
<p><strong>filters</strong>
以逗号分隔的实现过滤器的 Spring bean 引用列表. 值 "none" 表示此 <code>FilterChain</code> 不应使用任何过滤器.</p>
</li>
</ul>
</div>
<div id="nsa-filter-chain-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong>
一种与<a href="#nsa-filter-chain-map-request-matcher">request-matcher</a> 结合创建 RequestMatcher 的模式</p>
</li>
</ul>
</div>
<div id="nsa-filter-chain-request-matcher-ref" class="ulist">
<ul>
<li>
<p><strong>request-matcher-ref</strong>
对 <code>RequestMatcher</code> 的引用,该引用将用于确定是否应调用 <code>filter</code> 属性中的任何 <code>Filter</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-filter-security-metadata-source"><a class="anchor" href="#nsa-filter-security-metadata-source"></a>&lt;filter-security-metadata-source&gt;</h5>
<div class="paragraph">
<p>用于显式配置 FilterSecurityMetadataSource bean 与 FilterSecurityInterceptor 一起使用.  通常仅在显式配置 FilterChainProxy 而不是使用 <code>&lt;http&gt;</code> 元素时才需要.  使用的拦截 URL 元素应仅包含模式,方法和访问属性.  其他任何情况都将导致配置错误.</p>
</div>
<div class="sect5">
<h6 id="nsa-filter-security-metadata-source-attributes"><a class="anchor" href="#nsa-filter-security-metadata-source-attributes"></a>&lt;filter-security-metadata-source&gt; 属性</h6>
<div id="nsa-filter-security-metadata-source-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
Bean 标识符,用于引用上下文中其他位置的 Bean.</p>
</li>
</ul>
</div>
<div id="nsa-filter-security-metadata-source-request-matcher" class="ulist">
<ul>
<li>
<p><strong>request-matcher</strong>
定义用于匹配传入请求的策略. 当前,选项为 <code>ant</code> (用于 ant 路径模式) ,<code>regex</code> 用于正则表达式,<code>ciRegex</code> 用于不区分大小写的正则表达式.</p>
</li>
</ul>
</div>
<div id="nsa-filter-security-metadata-source-use-expressions" class="ulist">
<ul>
<li>
<p><strong>use-expressions</strong>
允许在 <code>&lt;intercept-url&gt;</code> 元素的 <code>access</code> 属性中使用表达式,而不是传统的配置属性列表.  默认为 <code>true</code>.  如果启用,则每个属性应包含一个布尔表达式.  如果表达式的计算结果为 <code>true</code>,则将授予访问权限.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-filter-security-metadata-source-children"><a class="anchor" href="#nsa-filter-security-metadata-source-children"></a>&lt;filter-security-metadata-source&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-intercept-url">intercept-url</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-websocket-security"><a class="anchor" href="#nsa-websocket-security"></a>21.2.2. WebSocket Security</h4>
<div class="paragraph">
<p>Spring Security 4.0+ 提供了对消息授权的支持. 一个有用的具体示例是在基于 WebSocket 的应用程序中提供授权.</p>
</div>
<div class="sect4">
<h5 id="nsa-websocket-message-broker"><a class="anchor" href="#nsa-websocket-message-broker"></a>&lt;websocket-message-broker&gt;</h5>
<div class="paragraph">
<p>websocket-message-broker 元素具有两种不同的模式. 如果未指定<a href="#nsa-websocket-message-broker-id">websocket-message-broker@id</a>,则它将执行以下操作:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保任何 SimpAnnotationMethodMessageHandler 都将 AuthenticationPrincipalArgumentResolver 注册为自定义参数解析器.  这允许使用 <code>@AuthenticationPrincipal</code> 来解析当前 <code>Authentication</code> 的主体</p>
</li>
<li>
<p>确保已为 clientInboundChannel 自动注册 SecurityContextChannelInterceptor.  这将使用 Message 中找到的用户填充 SecurityContextHolder</p>
</li>
<li>
<p>确保 ChannelSecurityInterceptor 已向 clientInboundChannel 注册.  这允许为消息指定授权规则.</p>
</li>
<li>
<p>确保 CsrfChannelInterceptor 已在 clientInboundChannel 中注册.  这样可以确保仅启用来自原始域的请求.</p>
</li>
<li>
<p>确保已向 WebSocketHttpRequestHandler,TransportHandlingSockJsService 或 DefaultSockJsService 注册 CsrfTokenHandshakeInterceptor.  这样可以确保将来自 HttpServletRequest 的预期 CsrfToken 复制到 WebSocket 会话属性中.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果需要其他控制,则可以指定 ID,并将 ChannelSecurityInterceptor 分配给指定的 ID.  然后,可以手动完成与 Spring 的消息传递基础结构的所有连接.  这比较麻烦,但是可以更好地控制配置.</p>
</div>
<div class="sect5">
<h6 id="nsa-websocket-message-broker-attributes"><a class="anchor" href="#nsa-websocket-message-broker-attributes"></a>&lt;websocket-message-broker&gt; 属性</h6>
<div id="nsa-websocket-message-broker-id" class="ulist">
<ul>
<li>
<p><strong>id</strong> Bean 标识符,用于在上下文中的其他地方引用 <code>ChannelSecurityInterceptor</code> Bean.  如果指定,Spring Security 需要在 Spring Messaging 中进行显式配置.  如果未指定,Spring Security 将自动与消息传递基础结构集成,如<a href="#nsa-websocket-message-broker">&lt;websocket-message-broker&gt;</a>部分中所述</p>
</li>
</ul>
</div>
<div id="nsa-websocket-message-broker-same-origin-disabled" class="ulist">
<ul>
<li>
<p><strong>same-origin-disabled</strong> 禁用 Stomp header 中必须存在 CSRF 令牌的要求 (默认为 false) . 如果需要允许其他来源建立 SockJS 连接,则更改默认值很有用.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-websocket-message-broker-children"><a class="anchor" href="#nsa-websocket-message-broker-children"></a>&lt;websocket-message-broker&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-expression-handler">expression-handler</a></p>
</li>
<li>
<p><a href="#nsa-intercept-message">intercept-message</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-intercept-message"><a class="anchor" href="#nsa-intercept-message"></a>&lt;intercept-message&gt;</h5>
<div class="paragraph">
<p>定义消息的授权规则.</p>
</div>
<div class="sect5">
<h6 id="nsa-intercept-message-parents"><a class="anchor" href="#nsa-intercept-message-parents"></a>&lt;intercept-message&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-websocket-message-broker">websocket-message-broker</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-intercept-message-attributes"><a class="anchor" href="#nsa-intercept-message-attributes"></a>&lt;intercept-message&gt; 属性</h6>
<div id="nsa-intercept-message-pattern" class="ulist">
<ul>
<li>
<p><strong>pattern</strong> 在消息目标上匹配的基于 Ant 的模式. 例如,"/" 将任何消息与目标匹配;  "/admin/" 与目标以 "/admin/**" 开头的任何邮件匹配.</p>
</li>
</ul>
</div>
<div id="nsa-intercept-message-type" class="ulist">
<ul>
<li>
<p><strong>type</strong> 要匹配的消息类型. 有效值在 SimpMessageType 中定义 (即 CONNECT,CONNECT_ACK,HEARTBEAT,MESSAGE,SUBSCRIBE,UNSUBSCRIBE,DISCONNECT,DISCONNECT_ACK,OTHER) .</p>
</li>
</ul>
</div>
<div id="nsa-intercept-message-access" class="ulist">
<ul>
<li>
<p><strong>access</strong> 用于保护消息的表达式.  例如, "denyAll" 将拒绝访问所有匹配的消息;  "permitAll" 将授予对所有匹配消息的访问权限;  "hasRole('ADMIN') 要求当前用户具有匹配消息的角色 'ROLE_ADMIN'.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-authentication"><a class="anchor" href="#nsa-authentication"></a>21.2.3. Authentication Services</h4>
<div class="paragraph">
<p>在 Spring Security 3.0 之前,<code>AuthenticationManager</code> 是在内部自动注册的.  现在,您必须使用 <code>&lt;authentication-manager&gt;</code> 元素显式注册一个.  这将创建 Spring Security 的 <code>ProviderManager</code> 类的实例,该实例需要配置一个或多个 <code>AuthenticationProvider</code> 实例的列表.
这些可以使用命名空间提供的语法元素创建,也可以是标准 bean 定义,并使用 <code>authentication-provider</code> 元素标记为添加到列表中.</p>
</div>
<div class="sect4">
<h5 id="nsa-authentication-manager"><a class="anchor" href="#nsa-authentication-manager"></a>&lt;authentication-manager&gt;</h5>
<div class="paragraph">
<p>每个使用命名空间的 Spring Security 应用程序都必须在某处包含此元素.  它负责注册为应用程序提供身份验证服务的 <code>AuthenticationManager</code>.  创建 <code>AuthenticationProvider</code> 实例的所有元素都应该是该元素的子级.</p>
</div>
<div class="sect5">
<h6 id="nsa-authentication-manager-attributes"><a class="anchor" href="#nsa-authentication-manager-attributes"></a>&lt;authentication-manager&gt; 属性</h6>
<div id="nsa-authentication-manager-alias" class="ulist">
<ul>
<li>
<p><strong>alias</strong>
此属性使您可以定义内部实例的别名,以在您自己的配置中使用.</p>
</li>
</ul>
</div>
<div id="nsa-authentication-manager-erase-credentials" class="ulist">
<ul>
<li>
<p><strong>erase-credentials</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果设置为 <code>true</code>,则在验证用户身份之后,<code>AuthenticationManager</code> 将尝试清除返回的 Authentication 对象中的所有凭据数据.  从字面上看,它映射到 <a href="#servlet-authentication-providermanager"><code>ProviderManager</code></a> 的 <code>eraseCredentialsAfterAuthentication</code> 属性.</p>
</div>
<div id="nsa-authentication-manager-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
此属性允许您定义内部实例的 ID,以在您自己的配置中使用. 它与 alias 元素相同,但是使用 id 属性的元素提供了更一致的体验.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-authentication-manager-children"><a class="anchor" href="#nsa-authentication-manager-children"></a>&lt;authentication-manager&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-provider">authentication-provider</a></p>
</li>
<li>
<p><a href="#nsa-ldap-authentication-provider">ldap-authentication-provider</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-authentication-provider"><a class="anchor" href="#nsa-authentication-provider"></a>&lt;authentication-provider&gt;</h5>
<div class="paragraph">
<p>除非与 <code>ref</code> 属性一起使用,否则此元素是配置 <code>DaoAuthenticationProvider</code> 的简写.  <code>DaoAuthenticationProvider</code> 从 <code>UserDetailsService</code> 加载用户信息,并将用户名/密码组合与登录时提供的值进行比较.
可以通过使用可用的命名空间元素 (<code>jdbc-user-service</code> 或通过使用 <code>user-service-ref</code> 属性指向应用程序上下文中其他位置定义的bean) 来定义 <code>UserDetailsService</code> 实例.</p>
</div>
<div class="sect5">
<h6 id="nsa-authentication-provider-parents"><a class="anchor" href="#nsa-authentication-provider-parents"></a>&lt;authentication-provider&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-manager">authentication-manager</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-authentication-provider-attributes"><a class="anchor" href="#nsa-authentication-provider-attributes"></a>&lt;authentication-provider&gt; 属性</h6>
<div id="nsa-authentication-provider-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义对实现 <code>AuthenticationProvider</code> 的 Spring bean 的引用.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您已经编写了自己的 <code>AuthenticationProvider</code> 实现 (或者出于某种原因想要将 Spring Security 自己的实现之一配置为传统 Bean,则可以使用以下语法将其添加到 <code>ProviderManager</code> 的内部列表中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;security:authentication-manager&gt;
&lt;security:authentication-provider ref="myAuthenticationProvider" /&gt;
&lt;/security:authentication-manager&gt;
&lt;bean id="myAuthenticationProvider" class="com.something.MyAuthenticationProvider"/&gt;</code></pre>
</div>
</div>
<div id="nsa-authentication-provider-user-service-ref" class="ulist">
<ul>
<li>
<p><strong>user-service-ref</strong>
对实现 UserDetailsService 的 bean 的引用,该 UserDetailsService 可以使用标准 bean 元素或自定义 user-service 元素创建.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-authentication-provider-children"><a class="anchor" href="#nsa-authentication-provider-children"></a>&lt;authentication-provider&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-jdbc-user-service">jdbc-user-service</a></p>
</li>
<li>
<p><a href="#nsa-ldap-user-service">ldap-user-service</a></p>
</li>
<li>
<p><a href="#nsa-password-encoder">password-encoder</a></p>
</li>
<li>
<p><a href="#nsa-user-service">user-service</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-jdbc-user-service"><a class="anchor" href="#nsa-jdbc-user-service"></a>&lt;jdbc-user-service&gt;</h5>
<div class="paragraph">
<p>导致创建基于 JDBC 的 UserDetailsService.</p>
</div>
<div class="sect5">
<h6 id="nsa-jdbc-user-service-attributes"><a class="anchor" href="#nsa-jdbc-user-service-attributes"></a>&lt;jdbc-user-service&gt; 属性</h6>
<div id="nsa-jdbc-user-service-authorities-by-username-query" class="ulist">
<ul>
<li>
<p><strong>authorities-by-username-query</strong>
用于查询给定用户名的用户授予权限的 SQL 语句.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认是</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>select username, authority from authorities where username = ?</code></pre>
</div>
</div>
<div id="nsa-jdbc-user-service-cache-ref" class="ulist">
<ul>
<li>
<p><strong>cache-ref</strong>
定义对与 UserDetailsService 一起使用的缓存的引用.</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-data-source-ref" class="ulist">
<ul>
<li>
<p><strong>data-source-ref</strong>
提供所需表的数据源的Bean ID.</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-group-authorities-by-username-query" class="ulist">
<ul>
<li>
<p><strong>group-authorities-by-username-query</strong>
给定用户名的 SQL 语句,用于查询用户的组权限. 默认是</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>select
g.id, g.group_name, ga.authority
from
groups g, group_members gm, group_authorities ga
where
gm.username = ? and g.id = ga.group_id and g.id = gm.group_id</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
Bean 标识符,用于引用上下文中其他位置的 Bean.</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-role-prefix" class="ulist">
<ul>
<li>
<p><strong>role-prefix</strong>
一个非空字符串前缀,将添加到从持久性存储加载的角色字符串中 (默认为 "ROLE_") . 在默认为非空的情况下,将值 "none" 用于无前缀.</p>
</li>
</ul>
</div>
<div id="nsa-jdbc-user-service-users-by-username-query" class="ulist">
<ul>
<li>
<p><strong>users-by-username-query</strong>
用于查询用户名,密码和给定用户名的启用状态的 SQL 语句. 默认是</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>select username, password, enabled from users where username = ?</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-password-encoder"><a class="anchor" href="#nsa-password-encoder"></a>&lt;password-encoder&gt;</h5>
<div class="paragraph">
<p>如<a href="#authentication-password-storage">密码存储</a>中所述,可以选择将身份验证提供程序配置为使用密码编码器. 这将导致使用适当的 <code>PasswordEncoder</code> 实例注入 Bean.</p>
</div>
<div class="sect5">
<h6 id="nsa-password-encoder-parents"><a class="anchor" href="#nsa-password-encoder-parents"></a>&lt;password-encoder&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-provider">authentication-provider</a></p>
</li>
<li>
<p><a href="#nsa-password-compare">password-compare</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-password-encoder-attributes"><a class="anchor" href="#nsa-password-encoder-attributes"></a>&lt;password-encoder&gt; 属性</h6>
<div id="nsa-password-encoder-hash" class="ulist">
<ul>
<li>
<p><strong>hash</strong>
定义用于用户密码的哈希算法. 我们强烈建议您不要使用 MD4,因为它是一种非常弱的哈希算法.</p>
</li>
</ul>
</div>
<div id="nsa-password-encoder-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义对实现 <code>PasswordEncoder</code> 的 Spring bean 的引用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-user-service"><a class="anchor" href="#nsa-user-service"></a>&lt;user-service&gt;</h5>
<div class="paragraph">
<p>从属性文件或 "user"  子元素列表创建内存 UserDetailsService. 用户名在内部会转换为小写形式,以允许不区分大小写的查找,因此如果需要区分大小写,则不应使用此名称.</p>
</div>
<div class="sect5">
<h6 id="nsa-user-service-attributes"><a class="anchor" href="#nsa-user-service-attributes"></a>&lt;user-service&gt; 属性</h6>
<div id="nsa-user-service-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
Bean 标识符,用于引用上下文中其他位置的 Bean.</p>
</li>
</ul>
</div>
<div id="nsa-user-service-properties" class="ulist">
<ul>
<li>
<p><strong>properties</strong>
属性文件的位置,其中每一行的格式为</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>username=password,grantedAuthority[,grantedAuthority][,enabled|disabled]</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-user-service-children"><a class="anchor" href="#nsa-user-service-children"></a>&lt;user-service&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-user">user</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-user"><a class="anchor" href="#nsa-user"></a>&lt;user&gt;</h5>
<div class="paragraph">
<p>代表应用程序中的用户.</p>
</div>
<div class="sect5">
<h6 id="nsa-user-parents"><a class="anchor" href="#nsa-user-parents"></a>&lt;user&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-user-service">user-service</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-user-attributes"><a class="anchor" href="#nsa-user-attributes"></a>&lt;user&gt; 属性</h6>
<div id="nsa-user-authorities" class="ulist">
<ul>
<li>
<p><strong>authorities</strong>
授予用户的其他权限之一. 用逗号隔开 (但不能有空格) . 例如, "ROLE_USER,ROLE_ADMINISTRATOR"</p>
</li>
</ul>
</div>
<div id="nsa-user-disabled" class="ulist">
<ul>
<li>
<p><strong>disabled</strong>
可以设置为 "true" 以将帐户标记为禁用和不可用.</p>
</li>
</ul>
</div>
<div id="nsa-user-locked" class="ulist">
<ul>
<li>
<p><strong>locked</strong>
可以设置为 "true" 以将帐户标记为已锁定且无法使用.</p>
</li>
</ul>
</div>
<div id="nsa-user-name" class="ulist">
<ul>
<li>
<p><strong>name</strong>
分配给用户的用户名.</p>
</li>
</ul>
</div>
<div id="nsa-user-password" class="ulist">
<ul>
<li>
<p><strong>password</strong>
分配给用户的密码.  如果相应的身份验证提供程序支持哈希 (请记住要设置 "user-service" 元素的 "hash" 属性) ,则可以对此进行哈希处理.  在数据将不用于认证而仅用于访问权限的情况下,将忽略此属性.  如果省略,则命名空间将生成一个随机值,以防止其偶然用于身份验证.  不能为空. .</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-method-security"><a class="anchor" href="#nsa-method-security"></a>21.2.4. Method Security</h4>
<div class="sect4">
<h5 id="nsa-global-method-security"><a class="anchor" href="#nsa-global-method-security"></a>&lt;global-method-security&gt;</h5>
<div class="paragraph">
<p>该元素是添加对 Spring Security bean 上的安全方法的支持的主要方法.  可以使用 AspectJ 语法通过使用注解 (在接口或类级别定义) 或将一组切入点定义为子元素来保护方法.</p>
</div>
<div class="sect5">
<h6 id="nsa-global-method-security-attributes"><a class="anchor" href="#nsa-global-method-security-attributes"></a>&lt;global-method-security&gt; 属性</h6>
<div id="nsa-global-method-security-access-decision-manager-ref" class="ulist">
<ul>
<li>
<p><strong>access-decision-manager-ref</strong>
方法安全性使用与 Web 安全性相同的 <code>AccessDecisionManager</code> 配置,但是可以使用此属性来覆盖此方法. 默认情况下,<code>AffirmativeBased</code> 实现用于 <code>RoleVoter</code> 和 <code>AuthenticatedVoter</code>.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-authentication-manager-ref" class="ulist">
<ul>
<li>
<p><strong>authentication-manager-ref</strong>
对用于方法安全性的 <code>AuthenticationManager</code> 的引用.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-jsr250-annotations" class="ulist">
<ul>
<li>
<p><strong>jsr250-annotations</strong>
指定是否使用 JSR-250 样式属性 (例如  "RolesAllowed") .  这将需要 classpath 上的 <code>javax.annotation.security</code> 类.  将其设置为 <code>true</code> 还会向 <code>AccessDecisionManager</code> 中添加一个 <code>Jsr250Voter</code>,因此如果您正在使用自定义实现并希望使用这些注解,则需要确保执行此操作.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-metadata-source-ref" class="ulist">
<ul>
<li>
<p><strong>metadata-source-ref</strong>
可以提供一个外部 <code>MethodSecurityMetadataSource</code> 实例,该实例的优先级高于其他源 (例如默认注解) .</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-mode" class="ulist">
<ul>
<li>
<p><strong>mode</strong>
可以将此属性设置为 "aspectj" ,以指定应使用 AspectJ 代替默认的 Spring AOP. 必须使用 <code>spring-security-aspects</code> 模块中的 <code>AnnotationSecurityAspect</code> 来编织安全方法.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>需要特别注意的是,AspectJ 遵循 Java 的规则,即不继承接口上的注解.  这意味着在接口上定义安全性注解的方法将不安全.  相反,在使用 AspectJ 时,必须在类上放置 Security 注解.</p>
</div>
<div id="nsa-global-method-security-order" class="ulist">
<ul>
<li>
<p><strong>order</strong>
允许为方法安全性拦截器设置建议 "顺序".</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-pre-post-annotations" class="ulist">
<ul>
<li>
<p><strong>pre-post-annotations</strong>
指定是否应为此应用程序上下文启用对 Spring Security 的调用前后注解的使用 (@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) . 默认为 "disabled".</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-proxy-target-class" class="ulist">
<ul>
<li>
<p><strong>proxy-target-class</strong>
如果为 true,则将使用基于类的代理而不是基于接口的代理.</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-run-as-manager-ref" class="ulist">
<ul>
<li>
<p><strong>run-as-manager-ref</strong>
对可选 <code>RunAsManager</code> 实现的引用,将由配置的 <code>MethodSecurityInterceptor</code> 使用</p>
</li>
</ul>
</div>
<div id="nsa-global-method-security-secured-annotations" class="ulist">
<ul>
<li>
<p><strong>secured-annotations</strong>
指定是否为此应用程序上下文启用 Spring Security 的 <code>@Secured</code> 注解. 默认为 "disabled".</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-global-method-security-children"><a class="anchor" href="#nsa-global-method-security-children"></a>&lt;global-method-security&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-after-invocation-provider">after-invocation-provider</a></p>
</li>
<li>
<p><a href="#nsa-expression-handler">expression-handler</a></p>
</li>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
<li>
<p><a href="#nsa-protect-pointcut">protect-pointcut</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-after-invocation-provider"><a class="anchor" href="#nsa-after-invocation-provider"></a>&lt;after-invocation-provider&gt;</h5>
<div class="paragraph">
<p>此元素可用于装饰 <code>AfterInvocationProvider</code>,以供 <code>&lt;global-method-security&gt;</code> 命名空间维护的安全拦截器使用.  您可以在 <code>global-method-security</code> 元素中定义零个或多个元素,每个元素的 <code>ref</code> 属性均指向应用程序上下文中的 <code>AfterInvocationProvider</code> bean 实例.</p>
</div>
<div class="sect5">
<h6 id="nsa-after-invocation-provider-parents"><a class="anchor" href="#nsa-after-invocation-provider-parents"></a>&lt;after-invocation-provider&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-after-invocation-provider-attributes"><a class="anchor" href="#nsa-after-invocation-provider-attributes"></a>&lt;after-invocation-provider&gt; 属性</h6>
<div id="nsa-after-invocation-provider-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义对实现 <code>AfterInvocationProvider</code> 的 Spring bean 的引用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-pre-post-annotation-handling"><a class="anchor" href="#nsa-pre-post-annotation-handling"></a>&lt;pre-post-annotation-handling&gt;</h5>
<div class="paragraph">
<p>允许完全替换基于默认表达式的机制来处理 Spring Security 的调用前后注解 ((@PreFilter, @PreAuthorize, @PostFilter, @PostAuthorize) . 仅在启用这些注解的情况下适用.</p>
</div>
<div class="sect5">
<h6 id="nsa-pre-post-annotation-handling-parents"><a class="anchor" href="#nsa-pre-post-annotation-handling-parents"></a>&lt;pre-post-annotation-handling&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-pre-post-annotation-handling-children"><a class="anchor" href="#nsa-pre-post-annotation-handling-children"></a>&lt;pre-post-annotation-handling&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-invocation-attribute-factory">invocation-attribute-factory</a></p>
</li>
<li>
<p><a href="#nsa-post-invocation-advice">post-invocation-advice</a></p>
</li>
<li>
<p><a href="#nsa-pre-invocation-advice">pre-invocation-advice</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-invocation-attribute-factory"><a class="anchor" href="#nsa-invocation-attribute-factory"></a>&lt;invocation-attribute-factory&gt;</h5>
<div class="paragraph">
<p>定义 PrePostInvocationAttributeFactory 实例,该实例用于从带注解的方法中生成调用前后的元数据.</p>
</div>
<div class="sect5">
<h6 id="nsa-invocation-attribute-factory-parents"><a class="anchor" href="#nsa-invocation-attribute-factory-parents"></a>&lt;invocation-attribute-factory&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-invocation-attribute-factory-attributes"><a class="anchor" href="#nsa-invocation-attribute-factory-attributes"></a>&lt;invocation-attribute-factory&gt; 属性</h6>
<div id="nsa-invocation-attribute-factory-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义对 Spring bean ID 的引用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-post-invocation-advice"><a class="anchor" href="#nsa-post-invocation-advice"></a>&lt;post-invocation-advice&gt;</h5>
<div class="paragraph">
<p>使用 <code>&lt;pre-post-annotation-handling&gt;</code> 元素的 <code>ref</code> 作为 <code>PostInvocationAuthorizationAdvice</code> 自定义 <code>PostInvocationAdviceProvider</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-post-invocation-advice-parents"><a class="anchor" href="#nsa-post-invocation-advice-parents"></a>&lt;post-invocation-advice&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-post-invocation-advice-attributes"><a class="anchor" href="#nsa-post-invocation-advice-attributes"></a>&lt;post-invocation-advice&gt; 属性</h6>
<div id="nsa-post-invocation-advice-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义对 Spring bean ID 的引用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-pre-invocation-advice"><a class="anchor" href="#nsa-pre-invocation-advice"></a>&lt;pre-invocation-advice&gt;</h5>
<div class="paragraph">
<p>使用 <code>&lt;pre-post-annotation-handling&gt;</code> 元素的 <code>ref</code> 作为 <code>PreInvocationAuthorizationAdviceVoter</code> 自定义 <code>PreInvocationAuthorizationAdviceVoter</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-pre-invocation-advice-parents"><a class="anchor" href="#nsa-pre-invocation-advice-parents"></a>&lt;pre-invocation-advice&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-pre-post-annotation-handling">pre-post-annotation-handling</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-pre-invocation-advice-attributes"><a class="anchor" href="#nsa-pre-invocation-advice-attributes"></a>&lt;pre-invocation-advice&gt; 属性</h6>
<div id="nsa-pre-invocation-advice-ref" class="ulist">
<ul>
<li>
<p><strong>ref</strong>
定义对Spring bean ID的引用.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-protect-pointcut"><a class="anchor" href="#nsa-protect-pointcut"></a>Securing Methods using</h5>
<div class="paragraph">
<p><code>&lt;protect-pointcut&gt;</code> 可以使用 <code>&lt;protect-pointcut&gt;</code> 元素,而不是使用 <code>@Secured</code> 注解在单个方法或类的基础上定义安全属性,而可以跨服务层中的整个方法和接口集定义跨领域安全约束.  您可以在<a href="#ns-protect-pointcut">namespace introduction</a>找到一个示例.</p>
</div>
<div class="sect5">
<h6 id="nsa-protect-pointcut-parents"><a class="anchor" href="#nsa-protect-pointcut-parents"></a>&lt;protect-pointcut&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-global-method-security">global-method-security</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-protect-pointcut-attributes"><a class="anchor" href="#nsa-protect-pointcut-attributes"></a>&lt;protect-pointcut&gt; 属性</h6>
<div id="nsa-protect-pointcut-access" class="ulist">
<ul>
<li>
<p><strong>access</strong>
适用于与切入点匹配的所有方法的访问配置属性列表,例如 "ROLE_A,ROLE_B"</p>
</li>
</ul>
</div>
<div id="nsa-protect-pointcut-expression" class="ulist">
<ul>
<li>
<p><strong>expression</strong>
一个 AspectJ 表达式,包括 <code>execution</code> 关键字. 例如,<code>execution(int com.foo.TargetObject.countLength(String))</code> (不带引号) .</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-intercept-methods"><a class="anchor" href="#nsa-intercept-methods"></a>&lt;intercept-methods&gt;</h5>
<div class="paragraph">
<p>可以在 Bean 定义内使用,以向该 Bean 添加安全拦截器并为 Bean 的方法设置访问配置属性</p>
</div>
<div class="sect5">
<h6 id="nsa-intercept-methods-attributes"><a class="anchor" href="#nsa-intercept-methods-attributes"></a>&lt;intercept-methods&gt; 属性</h6>
<div id="nsa-intercept-methods-access-decision-manager-ref" class="ulist">
<ul>
<li>
<p><strong>access-decision-manager-ref</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>创建的方法安全拦截器将使用的可选 AccessDecisionManager bean ID.</p>
</div>
</div>
<div class="sect5">
<h6 id="nsa-intercept-methods-children"><a class="anchor" href="#nsa-intercept-methods-children"></a>&lt;intercept-methods&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-protect">protect</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-method-security-metadata-source"><a class="anchor" href="#nsa-method-security-metadata-source"></a>&lt;method-security-metadata-source&gt;</h5>
<div class="paragraph">
<p>创建一个 MethodSecurityMetadataSource 实例</p>
</div>
<div class="sect5">
<h6 id="nsa-method-security-metadata-source-attributes"><a class="anchor" href="#nsa-method-security-metadata-source-attributes"></a>&lt;method-security-metadata-source&gt; 属性</h6>
<div id="nsa-method-security-metadata-source-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
Bean 标识符,用于引用上下文中其他位置的 Bean.</p>
</li>
</ul>
</div>
<div id="nsa-method-security-metadata-source-use-expressions" class="ulist">
<ul>
<li>
<p><strong>use-expressions</strong>
允许在 <code>&lt;intercept-url&gt;</code> 元素的 <code>access</code> 属性中使用表达式,而不是传统的配置属性列表.  默认为 <code>false</code>.  如果启用,则每个属性应包含一个布尔表达式.  如果表达式的计算结果为 "true",则将授予访问权限.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-method-security-metadata-source-children"><a class="anchor" href="#nsa-method-security-metadata-source-children"></a>&lt;method-security-metadata-source&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-protect">protect</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-protect"><a class="anchor" href="#nsa-protect"></a>&lt;protect&gt;</h5>
<div class="paragraph">
<p>定义一个受保护的方法以及适用于该方法的访问控制配置属性. 强烈建议您不要将 "保护" 声明与 "global-method-security" 提供的任何服务混合使用.</p>
</div>
<div class="sect5">
<h6 id="nsa-protect-parents"><a class="anchor" href="#nsa-protect-parents"></a>&lt;protect&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-intercept-methods">intercept-methods</a></p>
</li>
<li>
<p><a href="#nsa-method-security-metadata-source">method-security-metadata-source</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-protect-attributes"><a class="anchor" href="#nsa-protect-attributes"></a>&lt;protect&gt; 属性</h6>
<div id="nsa-protect-access" class="ulist">
<ul>
<li>
<p><strong>access</strong>
适用于该方法的访问配置属性列表,例如 "ROLE_A,ROLE_B".</p>
</li>
</ul>
</div>
<div id="nsa-protect-method" class="ulist">
<ul>
<li>
<p><strong>method</strong>
方法名</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="nsa-ldap"><a class="anchor" href="#nsa-ldap"></a>21.2.5. LDAP Namespace 选项</h4>
<div class="paragraph">
<p>LDAP 在<a href="#servlet-authentication-ldap">其自己的章节中</a>进行了一些详细介绍.  我们将在此扩展它,并提供一些有关命名空间选项如何映射到 Spring Bean 的解释.  LDAP 实现广泛使用 Spring LDAP,因此熟悉该项目的API可能会有用.</p>
</div>
<div class="sect4">
<h5 id="nsa-ldap-server"><a class="anchor" href="#nsa-ldap-server"></a>Defining the LDAP Server using the</h5>
<div class="paragraph">
<p><code>&lt;ldap-server&gt;</code> 元素此元素设置一个供其他 LDAP Bean 使用的 Spring LDAP <code>ContextSource</code>,用于定义 LDAP 服务器的位置以及其他信息 (例如用户名和密码,如果不允许匿名访问) 用于连接到它.
它还可以用于创建嵌入式服务器以进行测试.   <a href="#servlet-authentication-ldap">LDAP 一章</a>介绍了这两个选项的语法详细信息.  实际的 <code>ContextSource</code> 实现是 <code>DefaultSpringSecurityContextSource</code>,它扩展了 Spring LDAP 的 <code>LdapContextSource</code> 类.
 <code>manager-dn</code> 和 <code>manager-password</code> 属性分别映射到后者的 <code>userDn</code> 和密码属性.</p>
</div>
<div class="paragraph">
<p>如果在应用程序上下文中仅定义了一个服务器,则其他 LDAP 命名空间定义的 Bean 将自动使用它.  否则,您可以为元素赋予 "id" 属性,并使用 <code>server-ref</code> 属性从其他命名空间 Bean 引用该元素.  如果要在其他传统 Spring Bean 中使用它,则实际上是 <code>ContextSource</code> 实例的 Bean ID.</p>
</div>
<div class="sect5">
<h6 id="nsa-ldap-server-attributes"><a class="anchor" href="#nsa-ldap-server-attributes"></a>&lt;ldap-server&gt; 属性</h6>
<div id="nsa-ldap-server-mode" class="ulist">
<ul>
<li>
<p><strong>mode</strong>
明确指定应使用哪个嵌入式 ldap 服务器. 值是固定的和无限制的. 默认情况下,将取决于该库在类路径中是否可用.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
Bean 标识符,用于引用上下文中其他位置的 Bean.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-ldif" class="ulist">
<ul>
<li>
<p><strong>ldif</strong>
明确指定一个 ldif 文件资源以加载到嵌入式 LDAP 服务器中.  ldif 应该是 Spring 资源模式 (即 <code>classpath:init.ldif</code>) .  默认值为 <code>classpath*:*.ldif</code></p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-manager-dn" class="ulist">
<ul>
<li>
<p><strong>manager-dn</strong>
"manager" 用户身份的用户名 (DN) ,将用于向 (非嵌入式) LDAP 服务器进行身份验证. 如果省略,将使用匿名访问.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-manager-password" class="ulist">
<ul>
<li>
<p><strong>manager-password</strong>
管理员DN的密码. 如果指定了 manager-dn,则这是必需的.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-port" class="ulist">
<ul>
<li>
<p><strong>port</strong>
指定 IP 端口号. 例如,用于配置嵌入式 LDAP 服务器. 默认值为 33389.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-root" class="ulist">
<ul>
<li>
<p><strong>root</strong>
嵌入式 LDAP 服务器的可选根后缀. 默认值为 "dc=springframework,dc=org"</p>
</li>
</ul>
</div>
<div id="nsa-ldap-server-url" class="ulist">
<ul>
<li>
<p><strong>url</strong>
不使用嵌入式LDAP服务器时,指定ldap服务器URL.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-ldap-authentication-provider"><a class="anchor" href="#nsa-ldap-authentication-provider"></a>&lt;ldap-authentication-provider&gt;</h5>
<div class="paragraph">
<p>此元素是创建 <code>LdapAuthenticationProvider</code> 实例的简写.  默认情况下,它将使用 <code>BindAuthenticator</code> 实例和 <code>DefaultAuthoritiesPopulator</code> 配置.  与所有命名空间身份验证提供程序一样,必须将其作为 <code>authentication-provider</code> 元素的子元素包括在内.</p>
</div>
<div class="sect5">
<h6 id="nsa-ldap-authentication-provider-parents"><a class="anchor" href="#nsa-ldap-authentication-provider-parents"></a>&lt;ldap-authentication-provider&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-authentication-manager">authentication-manager</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-ldap-authentication-provider-attributes"><a class="anchor" href="#nsa-ldap-authentication-provider-attributes"></a>&lt;ldap-authentication-provider&gt; 属性</h6>
<div id="nsa-ldap-authentication-provider-group-role-attribute" class="ulist">
<ul>
<li>
<p><strong>group-role-attribute</strong>
LDAP 属性名称,其中包含将在 Spring Security 中使用的角色名称. 映射到 <code>DefaultLdapAuthoritiesPopulator</code> 的 <code>groupRoleAttribute</code> 属性. 默认为 "cn".</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-group-search-base" class="ulist">
<ul>
<li>
<p><strong>group-search-base</strong>
组成员资格搜索的搜索基础. 映射到 <code>DefaultLdapAuthoritiesPopulator</code> 的 <code>groupSearchBase</code> 构造函数参数. 默认为 "" (从根目录搜索) .</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-group-search-filter" class="ulist">
<ul>
<li>
<p><strong>group-search-filter</strong>
组搜索过滤器. 映射到 <code>DefaultLdapAuthoritiesPopulator</code> 的 <code>groupSearchFilter</code> 属性. 默认为 ( <code>(uniqueMember={0})</code> ) . 替换的参数是用户的DN.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-role-prefix" class="ulist">
<ul>
<li>
<p><strong>role-prefix</strong>
非空字符串前缀,将添加到从持久性加载的角色字符串中. 映射到 <code>DefaultLdapAuthoritiesPopulator</code> 的 <code>rolePrefix</code> 属性. 默认为 "ROLE_". 在默认为非空的情况下,将值 "none" 用于无前缀.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-server-ref" class="ulist">
<ul>
<li>
<p><strong>server-ref</strong>
要使用的可选服务器. 如果省略,并且注册了默认的 LDAP 服务器 (使用没有 ID 的 &lt;ldap-server&gt;) ,则将使用该服务器.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-context-mapper-ref" class="ulist">
<ul>
<li>
<p><strong>user-context-mapper-ref</strong>
通过指定 UserDetailsContextMapper bean 来对加载的用户对象进行显式定制,该 bean 将与用户目录条目中的上下文信息一起调用</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-details-class" class="ulist">
<ul>
<li>
<p><strong>user-details-class</strong>
允许指定用户条目的 objectClass. 如果设置,框架将尝试将已定义类的标准属性加载到返回的 UserDetails 对象中</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-dn-pattern" class="ulist">
<ul>
<li>
<p><strong>user-dn-pattern</strong>
如果您的用户位于目录中的固定位置 (即您可以直接从用户名计算出 DN,而无需进行目录搜索) ,则可以使用此属性直接映射到 DN.  它直接映射到 <code>AbstractLdapAuthenticator</code> 的 <code>userDnPatterns</code> 属性.
 该值是用于构建用户 DN 的特定模式,例如 <code>uid={0},ou=people</code>.  键  <code>{0}</code> 必须存在,并将被用户名替换.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-search-base" class="ulist">
<ul>
<li>
<p><strong>user-search-base</strong>
用户搜索的搜索库.  默认为 "".  仅与 <code>user-search-filter</code> 一起使用.</p>
<div class="paragraph">
<p>如果需要执行搜索以在目录中找到用户,则可以设置这些属性来控制搜索.  <code>BindAuthenticator</code> 将使用 <code>FilterBasedLdapUserSearch</code> 配置,并且属性值直接映射到该 bean 的构造函数的前两个参数.
如果未设置这些属性,并且未提供任何 <code>user-dn-pattern</code> 作为替代,则默认搜索值为 <code>user-search-filter="(uid={0})"</code> 和 <code>user-search-base=""</code>  将会被使用.</p>
</div>
</li>
</ul>
</div>
<div id="nsa-ldap-authentication-provider-user-search-filter" class="ulist">
<ul>
<li>
<p><strong>user-search-filter</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>用于搜索用户的 LDAP 过滤器 (可选) .  例如 "(uid={0})".  替换的参数是用户的登录名.</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="paragraph">
<p>如果需要执行搜索以在目录中找到用户,则可以设置这些属性来控制搜索.  <code>BindAuthenticator</code> 将使用 <code>FilterBasedLdapUserSearch</code> 配置,并且属性值直接映射到该 bean 的构造函数的前两个参数.
如果未设置这些属性,并且未提供任何 <code>user-dn-pattern</code> 作为替代,则默认搜索值为 <code>user-search-filter="(uid={0})"</code> 和 <code>user-search-base=""</code> 将会被使用.</p>
</div>
</div>
<div class="sect5">
<h6 id="nsa-ldap-authentication-provider-children"><a class="anchor" href="#nsa-ldap-authentication-provider-children"></a>&lt;ldap-authentication-provider&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-password-compare">password-compare</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-password-compare"><a class="anchor" href="#nsa-password-compare"></a>&lt;password-compare&gt;</h5>
<div class="paragraph">
<p>用作 <code>&lt;ldap-provider&gt;</code> 的子元素,并将身份验证策略从 <code>BindAuthenticator</code> 切换到 <code>PasswordComparisonAuthenticator</code>.</p>
</div>
<div class="sect5">
<h6 id="nsa-password-compare-parents"><a class="anchor" href="#nsa-password-compare-parents"></a>&lt;password-compare&gt; 的父元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-ldap-authentication-provider">ldap-authentication-provider</a></p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-password-compare-attributes"><a class="anchor" href="#nsa-password-compare-attributes"></a>&lt;password-compare&gt; 属性</h6>
<div id="nsa-password-compare-hash" class="ulist">
<ul>
<li>
<p><strong>hash</strong>
定义用于用户密码的哈希算法. 我们强烈建议您不要使用 MD4,因为它是一种非常弱的哈希算法.</p>
</li>
</ul>
</div>
<div id="nsa-password-compare-password-attribute" class="ulist">
<ul>
<li>
<p><strong>password-attribute</strong>
目录中包含用户密码的属性. 默认为 "userPassword".</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="nsa-password-compare-children"><a class="anchor" href="#nsa-password-compare-children"></a>&lt;password-compare&gt; 的子元素</h6>
<div class="ulist">
<ul>
<li>
<p><a href="#nsa-password-encoder">password-encoder</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="nsa-ldap-user-service"><a class="anchor" href="#nsa-ldap-user-service"></a>&lt;ldap-user-service&gt;</h5>
<div class="paragraph">
<p>此元素配置 LDAP <code>UserDetailsService</code>.  使用的类是 <code>LdapUserDetailsService</code>,它是 <code>FilterBasedLdapUserSearch</code> 和 <code>DefaultLdapAuthoritiesPopulator</code> 的组合.  它支持的属性与 <code>&lt;ldap-provider&gt;</code> 中的用法相同.</p>
</div>
<div class="sect5">
<h6 id="nsa-ldap-user-service-attributes"><a class="anchor" href="#nsa-ldap-user-service-attributes"></a>&lt;ldap-user-service&gt; 属性</h6>
<div id="nsa-ldap-user-service-cache-ref" class="ulist">
<ul>
<li>
<p><strong>cache-ref</strong>
定义对与 UserDetailsService 一起使用的缓存的引用.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-group-role-attribute" class="ulist">
<ul>
<li>
<p><strong>group-role-attribute</strong>
LDAP 属性名称,其中包含将在 Spring Security 中使用的角色名称. 默认为 "cn".</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-group-search-base" class="ulist">
<ul>
<li>
<p><strong>group-search-base</strong>
组成员资格搜索的搜索基础. 默认为 "" (从根目录搜索) .</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-group-search-filter" class="ulist">
<ul>
<li>
<p><strong>group-search-filter</strong>
组搜索过滤器. 默认为 (uniqueMember={0}) . 替换的参数是用户的 DN.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-id" class="ulist">
<ul>
<li>
<p><strong>id</strong>
Bean 标识符,用于引用上下文中其他位置的 Bean.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-role-prefix" class="ulist">
<ul>
<li>
<p><strong>role-prefix</strong>
非空字符串前缀,将添加到从持久性存储 (例如 "ROLE_") 加载的角色字符串中. 在默认为非空的情况下,将值 "none" 用于无前缀.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-server-ref" class="ulist">
<ul>
<li>
<p><strong>server-ref</strong>
要使用的可选服务器. 如果省略,并且注册了默认的 LDAP 服务器 (使用没有 ID 的 &lt;ldap-server&gt;) ,则将使用该服务器.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-context-mapper-ref" class="ulist">
<ul>
<li>
<p><strong>user-context-mapper-ref</strong>
通过指定 UserDetailsContextMapper bean 允许显式自定义已加载的用户对象,该 bean 将与用户目录条目中的上下文信息一起调用</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-details-class" class="ulist">
<ul>
<li>
<p><strong>user-details-class</strong>
允许指定用户条目的 objectClass. 如果设置,框架将尝试将已定义类的标准属性加载到返回的 UserDetails 对象中</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-search-base" class="ulist">
<ul>
<li>
<p><strong>user-search-base</strong>
用户搜索的搜索库. 默认为 "". 仅与  <code>user-search-filter</code> 一起使用.</p>
</li>
</ul>
</div>
<div id="nsa-ldap-user-service-user-search-filter" class="ulist">
<ul>
<li>
<p><strong>user-search-filter</strong>
用于搜索用户的 LDAP 过滤器 (可选) . 例如 "(uid={0})". 替换的参数是用户的登录名.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="appendix-faq"><a class="anchor" href="#appendix-faq"></a>21.3. Spring Security常见问题解答</h3>
<div class="ulist">
<ul>
<li>
<p><a href="#appendix-faq-general-questions">一般问题</a></p>
</li>
<li>
<p><a href="#appendix-faq-common-problems">常见问题</a></p>
</li>
<li>
<p><a href="#appendix-faq-architecture">Spring 安全体系结构问题</a></p>
</li>
<li>
<p><a href="#appendix-faq-howto">常见的 "操作方法" 请求</a></p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="appendix-faq-general-questions"><a class="anchor" href="#appendix-faq-general-questions"></a>21.3.1. 一般问题</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#appendix-faq-other-concerns">Spring Security 会满足我所有的应用程序安全性要求吗? </a></p>
</li>
<li>
<p><a href="#appendix-faq-web-xml">为什么不仅仅使用 web.xml 安全性? </a></p>
</li>
<li>
<p><a href="#appendix-faq-requirements">需要哪些 Java 和 Spring Framework 版本? </a></p>
</li>
<li>
<p><a href="#appendix-faq-start-simple">我是 Spring Security 的新手,我需要构建一个支持通过 HTTPS 进行 CAS 单一登录的应用程序,同时允许对某些 URL 在本地进行基本身份验证,并针对多个后端用户信息源 (LDAP 和 JDBC) 进行身份验证.  我已经复制了一些找到的配置文件,但是没有用. </a></p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="appendix-faq-other-concerns"><a class="anchor" href="#appendix-faq-other-concerns"></a>Spring Security 会满足我所有的应用程序安全性要求吗?</h5>
<div class="paragraph">
<p>Spring Security 为您的身份验证和授权要求提供了一个非常灵活的框架,但是在构建安全应用程序时还需要考虑许多其他因素.  Web 应用程序容易受到各种您应该熟悉的攻击的攻击,最好在开始开发之前就进行攻击,因此您可以从一开始就在设计和编写代码时就牢记在心.  请访问 <a href="https://www.owasp.org/">OWASP web site</a>,以获取有关 Web 应用程序开发人员面临的主要问题的信息,以及可以对他们使用的对策.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-web-xml"><a class="anchor" href="#appendix-faq-web-xml"></a>为什么不仅仅使用 web.xml 安全性?</h5>
<div class="paragraph">
<p>假设您正在开发基于 Spring 的企业应用程序.  您通常需要解决四个安全问题: 身份验证,Web 请求安全性,服务层安全性 (即,实现业务逻辑的方法) 和域对象实例安全性 (即不同的域对象具有不同的权限) .  牢记以下典型要求:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>身份验证</em>: Servlet 规范提供了一种身份验证方法.  但是,您将需要配置容器以执行身份验证,这通常需要编辑特定于容器的 "realm" 设置.  这样就构成了不可移植的配置,如果您需要编写实际的 Java 类来实现容器的身份验证接口,则它甚至变得更加不可移植.
使用 Spring Security,您可以实现完全的可移植性-一直到 WAR 级别.  此外,Spring Security 还提供了经过生产验证的身份验证提供程序和机制,供您选择,这意味着您可以在部署时切换身份验证方法.  对于编写需要在未知目标环境中工作的产品的软件供应商而言,这特别有价值.</p>
</li>
<li>
<p><em>Web请求安全性:</em> Servlet 规范提供了一种保护请求 URI 的方法.  但是,这些 URI 只能以 Servlet 规范自己的受限 URI 路径格式表示.  Spring Security 提供了一种更为全面的方法.  例如,您可以使用 Ant 路径或正则表达式,可以考虑 URI 的部分,而不仅仅是请求的页面 (例如,可以考虑 HTTP GET 参数) ,并且可以实现自己的配置数据的运行时源.  这意味着您的 Web 请求安全性可以在 Webapp 的实际执行过程中动态更改.</p>
</li>
<li>
<p><em>服务层和域对象安全性:</em> Servlet 规范中缺少对服务层安全性或域对象实例安全性的支持,这表示对多层应用程序的严重限制.  通常,开发人员要么忽略这些要求,要么在其 MVC 控制器代码中实现安全逻辑 (或者更糟的是在视图内部) .  这种方法有严重的缺点:</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><em>关注点分离:</em> 授权是一个横切关注点,应照此实施.  MVC 控制器或实现授权代码的视图使测试控制器和授权逻辑更加困难,调试更加困难,并且通常会导致代码重复.</p>
</li>
<li>
<p><em>对富客户端和 Web 服务的支持:</em> 如果最终必须支持其他客户端类型,则嵌入在 Web 层中的任何授权代码都是不可重用的.  应该考虑到 Spring 远程出口商仅出口服务层 bean (而不是 MVC 控制器) .  这样,授权逻辑需要位于服务层中以支持多种客户端类型.</p>
</li>
<li>
<p><em>分层问题:</em> MVC 控制器或视图只是错误的体系结构层,无法实现有关服务层方法或域对象实例的授权决策.  尽管可以将主体传递到服务层以使其能够做出授权决策,但这样做会在每个服务层方法上引入一个附加参数.  一种更优雅的方法是使用 ThreadLocal 来容纳 Principal,尽管这可能会增加开发时间,以至于仅使用专用的安全框架就变得更加经济 (基于成本效益) .</p>
</li>
<li>
<p><em>授权代码质量:</em> Web 框架经常被提及为 "它们使做正确的事变得更容易,而做错事则更难".  安全框架是相同的,因为它们以抽象的方式设计用于多种用途.  从头开始编写自己的授权代码不会提供框架会提供的 "设计检查",而且内部授权代码通常将缺乏广泛部署,同行评审和新版本带来的改进.</p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>对于简单的应用程序,servlet 规范安全性可能就足够了.  尽管在 Web 容器可移植性,配置要求,有限的 Web 请求安全性以及不存在的服务层和域对象实例安全性的上下文中进行考虑,但很清楚的是,为什么开发人员经常寻求替代解决方案.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-requirements"><a class="anchor" href="#appendix-faq-requirements"></a>需要哪些 Java 和 Spring Framework 版本?</h5>
<div class="paragraph">
<p>Spring Security 3.0 和 3.1 至少需要 JDK 1.5,还至少需要 Spring 3.0.3.  理想情况下,您应该使用最新版本,以避免出现问题.</p>
</div>
<div class="paragraph">
<p>Spring Security 2.0.x 要求最低 JDK 版本为 1.4,并且是针对 Spring 2.0.x 构建的.  它也应该与使用 Spring 2.5.x 的应用程序兼容.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-start-simple"><a class="anchor" href="#appendix-faq-start-simple"></a>我是 Spring Security 的新手,我需要构建一个支持通过 HTTPS 进行 CAS 单一登录的应用程序,同时允许对某些 URL 在本地进行基本身份验证,并针对多个后端用户信息源 (LDAP 和 JDBC) 进行身份验证.  我已经复制了一些找到的配置文件,但是没有用.</h5>
<div class="paragraph">
<p>哪里出问题了?</p>
</div>
<div class="paragraph">
<p>或替代其他复杂方案&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>实际上,您需要先了解要使用的技术,然后才能成功使用它们构建应用程序.  安全性很复杂.  使用登录表单设置简单的配置,并使用 Spring Security 的命名空间来设置一些硬编码的用户,这是相当简单的.  转向使用支持的 JDBC 数据库也很容易.  但是,如果您尝试直接跳入这种复杂的部署方案,则几乎肯定会感到沮丧.  设置 CAS 之类的系统,配置 LDAP 服务器以及正确安装 SSL 证书所需的学习曲线有了很大的提高.  因此,您需要一次一步.</p>
</div>
<div class="paragraph">
<p>从 Spring Security 的角度来看,您应该做的第一件事是遵循网站上的 "入门" 指南.  这将带您完成一系列步骤,以启动并运行并了解框架的运行方式.  如果您使用的是您不熟悉的其他技术,则应进行一些研究,并尝试确保在将它们组合到复杂系统中之前可以单独使用它们.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="appendix-faq-common-problems"><a class="anchor" href="#appendix-faq-common-problems"></a>21.3.2. 常见问题</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>认证</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><a href="#appendix-faq-bad-credentials">当我尝试登录时,出现一条错误消息,提示"Bad Credentials".  怎么了?</a></p>
</li>
<li>
<p><a href="#appendix-faq-login-loop">当我尝试登录时,我的应用程序进入 "endless loop(无限循环)",这是怎么回事?</a></p>
</li>
<li>
<p><a href="#appendix-faq-anon-access-denied">我收到一条消息 "访问被拒绝 (用户是匿名用户) " 的异常. 怎么了?</a></p>
</li>
<li>
<p><a href="#appendix-faq-cached-secure-page">为什么即使我退出了应用程序,仍然可以看到受保护的页面?</a></p>
</li>
<li>
<p><a href="#auth-exception-credentials-not-found">我收到一条消息  "An Authentication object was not found in the SecurityContext" 的异常. 怎么了?</a></p>
</li>
<li>
<p><a href="#appendix-faq-ldap-authentication">我无法使用 LDAP 身份验证.</a></p>
</li>
</ol>
</div>
</li>
<li>
<p>会话管理</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><a href="#appendix-faq-concurrent-session-same-browser">我正在使用 Spring Security 的并发会话控制来防止用户一次登录多次.</a></p>
</li>
<li>
<p><a href="#appendix-faq-new-session-on-authentication">通过 Spring Security 进行身份验证时,为什么会话 ID 会更改?</a></p>
</li>
<li>
<p><a href="#appendix-faq-tomcat-https-session">我正在使用 Tomcat (或其他一些 servlet 容器) ,并且已为登录页面启用 HTTPS,然后再切换回 HTTP.</a></p>
</li>
<li>
<p><a href="#appendix-faq-session-listener-missing">我正在尝试使用并发会话控制支持,但是即使我确定我已经注销并且没有超出允许的会话,它也不允许我重新登录.</a></p>
</li>
<li>
<p><a href="#appendix-faq-unwanted-session-creation">通过将 create-session 属性设置为 never,即使我未配置,Spring Security 也会在某个地方创建会话.</a></p>
</li>
</ol>
</div>
</li>
<li>
<p>其他</p>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><a href="#appendix-faq-forbidden-csrf">执行POST时收到403 Forbidden</a></p>
</li>
<li>
<p><a href="#appendix-faq-no-security-on-forward">我正在使用RequestDispatcher将请求转发到另一个URL,但没有应用我的安全约束.</a></p>
</li>
<li>
<p><a href="#appendix-faq-method-security-in-web-context">我已经在应用程序上下文中添加了 Spring Security 的 &lt;global-method-security&gt; 元素,但是如果我在 Spring MVC 控制器bean (Struts 操作等) 中添加了安全注解,那么它们似乎没有效果.</a></p>
</li>
<li>
<p><a href="#appendix-faq-no-filters-no-context">我有一个已经通过身份验证的用户,但是当我在某些请求期间尝试访问 SecurityContextHolder 时,<code>Authentication</code> 为 null.</a></p>
</li>
<li>
<p><a href="#appendix-faq-method-security-with-taglib">使用 URL 属性时,授权 JSP 标记不遵守我的方法安全注解.</a></p>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="appendix-faq-bad-credentials"><a class="anchor" href="#appendix-faq-bad-credentials"></a>当我尝试登录时,出现一条错误消息,提示"Bad Credentials".  怎么了?</h5>
<div class="paragraph">
<p>这意味着认证失败.  并没有说明原因,因为最好避免提供可能有助于攻击者猜测帐户名或密码的详细信息.</p>
</div>
<div class="paragraph">
<p>这也意味着,如果您在论坛中提出此问题,除非您提供其他信息,否则您将无法获得答案.  与任何问题一样,您应该检查调试日志的输出,注意所有异常堆栈跟踪和相关消息.  在调试器中单步执行代码以查看身份验证失败的原因以及原因.
编写一个测试案例,在应用程序外部练习您的身份验证配置.  失败通常是由于数据库中存储的密码数据与用户输入的密码数据不同.  如果使用哈希密码,请确保存储在数据库中的值与应用程序中配置的 <code>PasswordEncoder</code> 产生的值完全相同.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-login-loop"><a class="anchor" href="#appendix-faq-login-loop"></a>当我尝试登录时,我的应用程序进入 "endless loop(无限循环)",这是怎么回事?</h5>
<div class="paragraph">
<p>无限循环和重定向到登录页面的常见用户问题是由于不小心将登录页面配置为 "安全" 资源引起的.  通过从安全过滤器链中排除登录页面或将其标记为需要 ROLE_ANONYMOUS,确保您的配置允许匿名访问登录页面.</p>
</div>
<div class="paragraph">
<p>如果您的 AccessDecisionManager 包含 AuthenticatedVoter,则可以使用属性 "IS_AUTHENTICATED_ANONYMOUSLY".  如果您使用标准命名空间配置设置,则该选项自动可用.</p>
</div>
<div class="paragraph">
<p>从 Spring Security 2.0.1 开始,当您使用基于命名空间的配置时,将在加载应用程序上下文时进行检查,并且如果登录页面似乎受到保护,则会记录一条警告消息.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-anon-access-denied"><a class="anchor" href="#appendix-faq-anon-access-denied"></a>我收到一条消息 "访问被拒绝 (用户是匿名用户) " 的异常. 怎么了?</h5>
<div class="paragraph">
<p>这是调试级别的消息,它在匿名用户首次尝试访问受保护的资源时发生.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DEBUG [ExceptionTranslationFilter] - Access is denied (user is anonymous); redirecting to authentication entry point
org.springframework.security.AccessDeniedException: Access is denied
at org.springframework.security.vote.AffirmativeBased.decide(AffirmativeBased.java:68)
at org.springframework.security.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:262)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是正常现象,无需担心.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-cached-secure-page"><a class="anchor" href="#appendix-faq-cached-secure-page"></a>为什么即使我退出了应用程序,仍然可以看到受保护的页面?</h5>
<div class="paragraph">
<p>造成这种情况的最常见原因是您的浏览器已经缓存了该页面,并且您看到的是从浏览器缓存中检索到的副本.  通过检查浏览器是否确实在发送请求来验证这一点 (检查服务器访问日志,调试日志或使用合适的浏览器调试插件,例如 Firefox 的 "Tamper Data") .  这与 Spring Security 无关,您应该配置应用程序或服务器以设置适当的 Cache-Control 响应头.  请注意,永远不会缓存 SSL 请求.</p>
</div>
</div>
<div class="sect4">
<h5 id="auth-exception-credentials-not-found"><a class="anchor" href="#auth-exception-credentials-not-found"></a>我收到一条消息  "An Authentication object was not found in the SecurityContext" 的异常. 怎么了?</h5>
<div class="paragraph">
<p>这是另一条调试级别消息,该消息在匿名用户首次尝试访问受保护的资源时出现,但是在您的过滤器链配置中没有 <code>AnonymousAuthenticationFilter</code> 时出现.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>DEBUG [ExceptionTranslationFilter] - Authentication exception occurred; redirecting to authentication entry point
org.springframework.security.AuthenticationCredentialsNotFoundException:
                            An Authentication object was not found in the SecurityContext
at org.springframework.security.intercept.AbstractSecurityInterceptor.credentialsNotFound(AbstractSecurityInterceptor.java:342)
at org.springframework.security.intercept.AbstractSecurityInterceptor.beforeInvocation(AbstractSecurityInterceptor.java:254)</code></pre>
</div>
</div>
<div class="paragraph">
<p>这是正常现象,无需担心.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-ldap-authentication"><a class="anchor" href="#appendix-faq-ldap-authentication"></a>我无法使用 LDAP 身份验证.</h5>
<div class="paragraph">
<p>我的配置有什么问题?</p>
</div>
<div class="paragraph">
<p>请注意,LDAP 目录的权限通常不允许您读取用户密码.  因此,通常无法使用 <a href="#appendix-faq-what-is-userdetailservice">什么是 <code>UserDetailsService</code></a>这一节,Spring Security 将存储的密码与用户提交的密码进行比较.  最常见的方法是使用 LDAP "绑定",这是 <a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol">the LDAP protocol</a>支持的操作之一.
通过这种方法,Spring Security 通过尝试以用户身份验证目录来验证密码.</p>
</div>
<div class="paragraph">
<p>LDAP 认证最常见的问题是缺乏对目录服务器树结构和配置的了解.  不同公司的情况会有所不同,因此您必须自己找出来.  在将 Spring Security LDAP 配置添加到应用程序之前,最好使用标准 Java LDAP 代码 (不涉及 Spring Security) 编写一个简单的测试,并确保您可以使其首先工作.  例如,要验证用户身份,可以使用以下代码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void ldapAuthenticationIsSuccessful() throws Exception {
        Hashtable&lt;String,String&gt; env = new Hashtable&lt;String,String&gt;();
        env.put(Context.SECURITY_AUTHENTICATION, "simple");
        env.put(Context.SECURITY_PRINCIPAL, "cn=joe,ou=users,dc=mycompany,dc=com");
        env.put(Context.PROVIDER_URL, "ldap://mycompany.com:389/dc=mycompany,dc=com");
        env.put(Context.SECURITY_CREDENTIALS, "joespassword");
        env.put(Context.INITIAL_CONTEXT_FACTORY, "com.sun.jndi.ldap.LdapCtxFactory");

        InitialLdapContext ctx = new InitialLdapContext(env, null);

}
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="会话管理"><a class="anchor" href="#会话管理"></a>会话管理</h5>
<div class="paragraph">
<p>会话管理问题是论坛问题的常见来源.  如果您正在开发 Java Web 应用程序,则应了解如何在 Servlet 容器和用户浏览器之间维护会话.  您还应该了解安全和非安全 Cookie 的区别,以及使用 HTTP/HTTPS 以及在两者之间进行切换的含义.  Spring Security 与维护会话或提供会话标识符无关.  这完全由 servlet 容器处理.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-concurrent-session-same-browser"><a class="anchor" href="#appendix-faq-concurrent-session-same-browser"></a>我正在使用 Spring Security 的并发会话控制来防止用户一次登录多次.</h5>
<div class="paragraph">
<p>登录后打开另一个浏览器窗口时,并不会阻止我再次登录.  为什么我可以多次登录?</p>
</div>
<div class="paragraph">
<p>浏览器通常每个浏览器实例维护一个会话.  您不能一次有两个单独的会话.  因此,如果您再次在另一个窗口或选项卡中登录,那么您将在同一会话中重新进行身份验证.  服务器对标签,窗口或浏览器实例一无所知.  它所看到的只是 HTTP 请求,并根据它们所包含的 JSESSIONID cookie 的值将它们与特定会话相关联.  当用户在会话期间进行身份验证时,Spring Security 的并发会话控件会检查其拥有的其他已身份验证会话的数量.  如果它们已经通过同一会话进行了身份验证,则重新身份验证将无效.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-new-session-on-authentication"><a class="anchor" href="#appendix-faq-new-session-on-authentication"></a>通过 Spring Security 进行身份验证时,为什么会话 ID 会更改?</h5>
<div class="paragraph">
<p>使用默认配置,Spring Security 在用户认证时更改会话 ID.  如果您使用的是 Servlet 3.1 或更高版本的容器,则只需更改会话 ID.  如果您使用的是较旧的容器,Spring Security 将使现有会话无效,创建一个新会话,并将会话数据传输到新会话.  以这种方式改变会话标识符可以防止 "会话固定" 攻击.  您可以在网上和参考手册中找到有关此内容的更多信息.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-tomcat-https-session"><a class="anchor" href="#appendix-faq-tomcat-https-session"></a>我正在使用 Tomcat (或其他一些 servlet 容器) ,并且已为登录页面启用 HTTPS,然后再切换回 HTTP.</h5>
<div class="paragraph">
<p>它不起作用-经过身份验证后,我只能回到登录页面.</p>
</div>
<div class="paragraph">
<p>发生这种情况是因为在 HTTPS下创建的会话 (会话 cookie 标记为 "安全") 无法随后在 HTTP 下使用.  浏览器不会将 cookie 发送回服务器,并且任何会话状态都将丢失 (包括安全上下文信息) .  首先使用HTTP启动会话应该可以,因为会话 cookie 不会被标记为安全.
但是,Spring Security 的会话固定保护可能会对此产生干扰,因为它会导致通常使用安全标志将新的会话 ID Cookie 发送回用户的浏览器.
要解决此问题,您可以禁用 <a href="https://docs.spring.io/spring-security/site/docs/3.1.x/reference/springsecurity-single.html#ns-session-fixation">会话固定保护</a> ,但是在较新的 Servlet 容器中,您也可以配置会话 cookie,使其从不使用安全标志.  请注意,在 HTTP 和 HTTPS 之间切换通常不是一个好主意,因为任何完全使用 HTTP 的应用程序都容易受到中间人攻击.
为了真正确保安全,用户应开始使用 HTTPS 访问您的站点并继续使用它,直到注销为止.  即使从通过 HTTP 访问的页面上单击 HTTPS 链接也可能存在风险.  如果您需要更多说服力,请查看 <a href="https://www.thoughtcrime.org/software/sslstrip/">sslstrip</a>之类的工具.</p>
</div>
</div>
<div class="sect4">
<h5 id="我没有在http和https之间切换但是我的会话仍然丢失"><a class="anchor" href="#我没有在http和https之间切换但是我的会话仍然丢失"></a>我没有在HTTP和HTTPS之间切换,但是我的会话仍然丢失</h5>
<div class="paragraph">
<p>通过交换会话 cookie 或向 URL 添加 <code>jsessionid</code> 参数来维护会话 (如果使用 JSTL 输出 URL,或者在 URL 上调用 <code>HttpServletResponse.encodeUrl</code> (例如,在重定向之前) ,则会自动发生.  禁用 cookie,并且您不重写 URL 以包含 <code>jsessionid</code>,则会话将丢失. 请注意,出于安全原因,首选使用 cookie,因为它不会在 URL 中暴露会话信息.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-session-listener-missing"><a class="anchor" href="#appendix-faq-session-listener-missing"></a>我正在尝试使用并发会话控制支持,但是即使我确定我已经注销并且没有超出允许的会话,它也不允许我重新登录.</h5>
<div class="paragraph">
<p>确保已将监听器添加到 <code>web.xml</code> 文件. 必须确保在会话被销毁时通知 Spring Security 会话注册表. 没有它,会话信息将不会从注册表中删除.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-xml" data-lang="xml">&lt;listener&gt;
        &lt;listener-class&gt;org.springframework.security.web.session.HttpSessionEventPublisher&lt;/listener-class&gt;
&lt;/listener&gt;</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-unwanted-session-creation"><a class="anchor" href="#appendix-faq-unwanted-session-creation"></a>通过将 create-session 属性设置为 never,即使我未配置,Spring Security 也会在某个地方创建会话.</h5>
<div class="paragraph">
<p>这通常意味着用户的应用程序正在某个地方创建会话,但是他们不知道该会话.  最常见的罪魁祸首是 JSP.  许多人不知道 JSP 默认创建会话.  为了防止 JSP 创建会话,请在页面顶部添加指令 <code>&lt;%@ page session="false" %&gt;</code> .</p>
</div>
<div class="paragraph">
<p>如果在确定创建会话的位置时遇到麻烦,可以添加一些调试代码来跟踪位置.  一种方法是将 <code>javax.servlet.http.HttpSessionListener</code> 添加到您的应用程序,该应用程序在 <code>sessionCreated</code> 方法中调用 <code>Thread.dumpStack()</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-forbidden-csrf"><a class="anchor" href="#appendix-faq-forbidden-csrf"></a>执行POST时收到403 Forbidden</h5>
<div class="paragraph">
<p>如果为 HTTP POST 返回了 HTTP 403 Forbidden,但对于 HTTP GET 适用,则该问题很可能与 <a href="https://docs.spring.io/spring-security/site/docs/3.2.x/reference/htmlsingle/#csrf">CSRF</a>有关. 提供 CSRF 令牌或禁用 CSRF 保护 (不建议) .</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-no-security-on-forward"><a class="anchor" href="#appendix-faq-no-security-on-forward"></a>我正在使用RequestDispatcher将请求转发到另一个URL,但没有应用我的安全约束.</h5>
<div class="paragraph">
<p>过滤器默认情况下不应用于转发或包含.  如果您确实希望将安全过滤器应用于转发和/或包含,则必须使用 <code>&lt;dispatcher&gt;</code> 元素 (<code>&lt;filter-mapping&gt;</code> 的子元素) 在 <code>web.xml</code> 中显式配置这些过滤器.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-method-security-in-web-context"><a class="anchor" href="#appendix-faq-method-security-in-web-context"></a>我已经在应用程序上下文中添加了 Spring Security 的 &lt;global-method-security&gt; 元素,但是如果我在 Spring MVC 控制器bean (Struts 操作等) 中添加了安全注解,那么它们似乎没有效果.</h5>
<div class="paragraph">
<p>在 Spring Web 应用程序中,保存用于调度程序 Servlet 的 Spring MVC bean 的应用程序上下文通常与主应用程序上下文分开.  它通常在名为 <code>myapp-servlet.xml</code> 的文件中定义,其中 "myapp" 是在 <code>web.xml</code> 中分配给 Spring <code>DispatcherServlet</code> 的名称.
一个应用程序可以有多个 <code>DispatcherServlet</code>,每个都有自己独立的应用程序上下文.  这些 "子" 上下文中的 Bean 对应用程序的其余部分不可见.  "父" 应用程序上下文由您在 <code>web.xml</code> 中定义的 <code>ContextLoaderListener</code> 加载,并且对所有子上下文可见.
通常在此父上下文中定义安全性配置,包括 <code>&lt;global-method-security&gt;</code> 元素) .  结果,由于无法从 <code>DispatcherServlet</code> 上下文中看到这些 bean,因此不会强制应用到这些 Web bean 中的方法的任何安全性约束.  您需要将 <code>&lt;global-method-security&gt;</code> 声明移至 Web 上下文,
或者将要保护的 bean 移至主应用程序上下文.</p>
</div>
<div class="paragraph">
<p>通常,我们建议在服务层而不是单个 Web 控制器上应用方法安全性.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-no-filters-no-context"><a class="anchor" href="#appendix-faq-no-filters-no-context"></a>我有一个已经通过身份验证的用户,但是当我在某些请求期间尝试访问 SecurityContextHolder 时,<code>Authentication</code> 为 null.</h5>
<div class="paragraph">
<p>为什么看不到用户信息?</p>
</div>
<div class="paragraph">
<p>如果使用与 URL 模式匹配的 <code>&lt;intercept-url&gt;</code> 元素中的属性 <code>filter ='none'</code> 从安全过滤器链中排除了该请求,则不会为该请求填充 <code>SecurityContextHolder</code>.  检查调试日志以查看请求是否正在通过过滤器链.   (您正在阅读调试日志,对吗? ) .</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-method-security-with-taglib"><a class="anchor" href="#appendix-faq-method-security-with-taglib"></a>使用 URL 属性时,授权 JSP 标记不遵守我的方法安全注解.</h5>
<div class="paragraph">
<p>当使用 <code>&lt;sec:authorize&gt;</code> 中的 <code>url</code> 属性时,方法安全性不会隐藏链接,因为我们不能轻易反向工程哪个 URL 映射到哪个控制器端点,因为控制器可以依赖 header,当前用户等来确定要调用的方法.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="appendix-faq-architecture"><a class="anchor" href="#appendix-faq-architecture"></a>21.3.3. Spring Security Architecture Questions</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#appendix-faq-where-is-class-x">我怎么知道 X 属于哪个包类?</a></p>
</li>
<li>
<p><a href="#appendix-faq-namespace-to-bean-mapping">命名空间元素如何映射到常规 bean 配置?</a></p>
</li>
<li>
<p><a href="#appendix-faq-role-prefix">"ROLE_" 是什么意思,为什么我在角色名称上需要它?</a></p>
</li>
<li>
<p><a href="#appendix-faq-what-dependencies">我如何知道要添加到我的应用程序中的哪些依赖才能与 Spring Security 一起使用?</a></p>
</li>
<li>
<p><a href="#appendix-faq-apacheds-deps">运行嵌入式 ApacheDS LDAP 服务器需要什么依赖?</a></p>
</li>
<li>
<p><a href="#appendix-faq-what-is-userdetailservice">什么是 UserDetailsService,我需要一个吗?</a></p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="appendix-faq-where-is-class-x"><a class="anchor" href="#appendix-faq-where-is-class-x"></a>我怎么知道 X 属于哪个包类?</h5>
<div class="paragraph">
<p>定位类的最佳方法是在 IDE 中安装 Spring Security 源代码.  该发行版包括项目分成的每个模块的源 jar.  将它们添加到项目源路径中,然后您可以直接导航到 Spring Security 类 (在 Eclipse 中为 <code>Ctrl-Shift-T</code>) .  这也使调试更加容易,并允许您通过直接查看异常发生的地方来查看异常情况,从而对异常进行故障排除.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-namespace-to-bean-mapping"><a class="anchor" href="#appendix-faq-namespace-to-bean-mapping"></a>命名空间元素如何映射到常规 bean 配置?</h5>
<div class="paragraph">
<p>在参考指南的命名空间附录中,概述了由命名空间创建的 bean.  在 <a href="https://spring.io/blog/2010/03/06/behind-the-spring-security-namespace/">blog.springsource.com</a> 上还有一篇详细的博客文章,名为 "Spring Security 命名空间的背后".
如果想知道全部细节,那么代码在 Spring Security 3.0 发行版的 <code>spring-security-config</code> 模块中.  您可能应该先阅读标准Spring Framework 参考文档中有关命名空间解析的章节.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-role-prefix"><a class="anchor" href="#appendix-faq-role-prefix"></a>"ROLE_" 是什么意思,为什么我在角色名称上需要它?</h5>
<div class="paragraph">
<p>Spring Security 具有基于投票者的架构,这意味着访问决策由一系列 <code>AccessDecisionVoters</code> 做出.  投票者根据为安全资源指定的 "配置属性" (例如方法调用) 进行操作.
使用这种方法,并非所有属性都可能与所有选民相关,并且选民需要知道何时应该忽略属性 (弃权) 以及何时应该投票基于属性值授予或拒绝访问权限.  最常见的投票者是 <code>RoleVoter</code>,默认情况下,只要找到带有 "ROLE_" 前缀的属性,投票者便会投票.  它将属性 (例如 "ROLE_USER") 与当前用户已分配的权限名称进行简单比较.  如果找到匹配项 (它们具有称为 "ROLE_USER" 的权限) ,则投票批准授予访问权限,否则投票拒绝访问.</p>
</div>
<div class="paragraph">
<p>可以通过设置 <code>RoleVoter</code> 的 <code>rolePrefix</code> 属性来更改前缀.  如果只需要在应用程序中使用角色,而无需其他自定义投票者,则可以将前缀设置为空字符串,在这种情况下,<code>RoleVoter</code> 会将所有属性视为角色.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-what-dependencies"><a class="anchor" href="#appendix-faq-what-dependencies"></a>我如何知道要添加到我的应用程序中的哪些依赖才能与 Spring Security 一起使用?</h5>
<div class="paragraph">
<p>这将取决于您使用的功能以及所开发的应用程序类型.  使用 Spring Security 3.0,将项目 jar 分为明显不同的功能区域,因此可以很容易地从应用程序需求中确定所需的 Spring Security jar.
所有应用程序都将需要 <code>spring-security-core</code> jar.  如果您要开发网络应用程序,则需要 <code>spring-security-web</code> jar.  如果您使用的是安全命名空间配置,则需要 <code>spring-security-config</code> jar; 要获得 LDAP 支持,则需要 <code>spring-security-ldap</code> jar等.</p>
</div>
<div class="paragraph">
<p>对于第三方 jar,情况并不总是那么明显.  一个好的起点是从预先构建的示例应用程序 <code>WEB-INF/lib</code> 目录之一复制那些目录.  对于基本应用程序,您可以从教程示例开始.  如果要对嵌入式测试服务器使用 LDAP,请以 LDAP 示例为起点.
参考手册还包括 <a href="https://static.springsource.org/spring-security/site/docs/3.1.x/reference/springsecurity-single.html#appendix-dependencies">附录</a>  列出了每个 Spring 的第一级依赖 安全模块,其中包含有关它们是否可选以及所需功能的一些信息.</p>
</div>
<div class="paragraph">
<p>如果您正在使用 maven 构建项目,则将适当的 Spring Security 模块作为依赖添加到 <code>pom.xml</code> 中,将自动提取框架所需的核心 jar.  如果需要,任何在 Spring Security POM 文件中标记为 "可选" 的文件都必须添加到您自己的 <code>pom.xml</code> 文件中.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-apacheds-deps"><a class="anchor" href="#appendix-faq-apacheds-deps"></a>运行嵌入式 ApacheDS LDAP 服务器需要什么依赖?</h5>
<div class="paragraph">
<p>如果使用的是 Maven,则需要将以下内容添加到 pom 依赖中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>&lt;dependency&gt;
        &lt;groupId&gt;org.apache.directory.server&lt;/groupId&gt;
        &lt;artifactId&gt;apacheds-core&lt;/artifactId&gt;
        &lt;version&gt;1.5.5&lt;/version&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
        &lt;groupId&gt;org.apache.directory.server&lt;/groupId&gt;
        &lt;artifactId&gt;apacheds-server-jndi&lt;/artifactId&gt;
        &lt;version&gt;1.5.5&lt;/version&gt;
        &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The other required jars should be pulled in transitively.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-what-is-userdetailservice"><a class="anchor" href="#appendix-faq-what-is-userdetailservice"></a>什么是 UserDetailsService,我需要一个吗?</h5>
<div class="paragraph">
<p><code>UserDetailsService</code> 是 DAO 接口,用于加载特定于用户帐户的数据.  除了加载该数据以供框架中的其他组件使用外,它没有其他功能.  它不负责验证用户身份.  使用用户名/密码组合对用户进行身份验证通常由 <code>DaoAuthenticationProvider</code> 执行,该服务注入了 <code>UserDetailsService</code>,以允许它加载用户的密码 (和其他数据) ,以便将其与提交的值进行比较.
请注意,如果您使用的是 LDAP,<a href="#appendix-faq-ldap-authentication">则此方法可能不起作用</a>.</p>
</div>
<div class="paragraph">
<p>如果要自定义身份验证过程,则应自己实现 <code>AuthenticationProvider</code>.  请参阅此 <a href="https://spring.io/blog/2010/08/02/spring-security-in-google-app-engine/">博客文章</a>,以获取将 Spring Security 身份验证与 Google App Engine 集成的示例.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="appendix-faq-howto"><a class="anchor" href="#appendix-faq-howto"></a>21.3.4. 常见的 "操作方法" 请求</h4>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><a href="#appendix-faq-extra-login-fields">我需要登录的信息不仅仅是用户名.</a></p>
</li>
<li>
<p><a href="#appendix-faq-matching-url-fragments">在只有所请求的 URL 的片段值不同的地方 (e.g./foo#bar and /foo#blah?) ,我如何应用不同的拦截URL约束?</a></p>
</li>
<li>
<p><a href="#appendix-faq-request-details-in-user-service">如何在 UserDetailsService 中访问用户的IP地址 (或其他网络请求数据) ?</a></p>
</li>
<li>
<p><a href="#appendix-faq-access-session-from-user-service">如何从UserDetailsService访问HttpSession?</a></p>
</li>
<li>
<p><a href="#appendix-faq-password-in-user-service">如何在UserDetailsService中访问用户密码?</a></p>
</li>
<li>
<p><a href="#appendix-faq-dynamic-url-metadata">如何动态定义应用程序中的安全 URL?</a></p>
</li>
<li>
<p><a href="#appendix-faq-ldap-authorities">如何针对LDAP进行身份验证,但如何从数据库中加载用户角色?</a></p>
</li>
<li>
<p><a href="#appendix-faq-namespace-post-processor">我想修改由命名空间创建的 bean 的属性,但是架构中没有任何东西可以支持它.</a></p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="appendix-faq-extra-login-fields"><a class="anchor" href="#appendix-faq-extra-login-fields"></a>我需要登录的信息不仅仅是用户名.</h5>
<div class="paragraph">
<p>如何添加对额外登录字段 (例如公司名称) 的支持?</p>
</div>
<div class="paragraph">
<p>这个问题在 Spring Security 论坛中反复出现,因此您可以通过搜索 存档 (或通过 google) 在那里找到更多信息.</p>
</div>
<div class="paragraph">
<p>提交的登录信息由 <code>UsernamePasswordAuthenticationFilter</code> 的实例处理.  您将需要自定义此类以处理额外的数据字段.  一种选择是使用您自己的自定义认证令牌类 (而不是标准的 <code>UsernamePasswordAuthenticationToken</code>) ,另一种选择是简单地将多余的字段与用户名连接起来 (例如,使用 ":" 作为分隔符) ,并将其传递给 <code>username</code> 属性 的 <code>UsernamePasswordAuthenticationToken</code>.</p>
</div>
<div class="paragraph">
<p>您还需要自定义实际的身份验证过程.  例如,如果使用的是自定义身份验证令牌类,则必须编写 <code>AuthenticationProvider</code> 来处理它 (或扩展标准的 <code>DaoAuthenticationProvider</code>) .  如果已串联字段,则可以实现自己的 <code>UserDetailsService</code>,将其拆分并加载适当的用户数据以进行身份验证.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-matching-url-fragments"><a class="anchor" href="#appendix-faq-matching-url-fragments"></a>在只有所请求的 URL 的片段值不同的地方 (e.g./foo#bar and /foo#blah?) ,我如何应用不同的拦截URL约束?</h5>
<div class="paragraph">
<p>您无法执行此操作,因为该片段不会从浏览器传输到服务器. 从服务器的角度来看,上述网址是相同的. 这是 GWT 用户的常见问题.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-request-details-in-user-service"><a class="anchor" href="#appendix-faq-request-details-in-user-service"></a>如何在 UserDetailsService 中访问用户的IP地址 (或其他网络请求数据) ?</h5>
<div class="paragraph">
<p>显然,您不能 (不求助于线程局部变量) ,因为提供给界面的唯一信息就是用户名.  而不是实现 <code>UserDetailsService</code>,应直接实现 <code>AuthenticationProvider</code> 并从提供的 <code>Authentication</code> 令牌中提取信息.</p>
</div>
<div class="paragraph">
<p>在标准的 Web 设置中,<code>Authentication</code> 对象上的 <code>getDetails()</code> 方法将返回 <code>WebAuthenticationDetails</code> 的实例.  如果需要其他信息,可以将自定义 <code>AuthenticationDetailsSource</code> 注入正在使用的身份验证过滤器中.  如果使用命名空间 (例如,使用 <code>&lt;form-login&gt;</code> 元素) ,则应删除该元素,并用 <code>&lt;custom-filter&gt;</code> 声明替换它,该声明指向显式配置的 <code>UsernamePasswordAuthenticationFilter</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-access-session-from-user-service"><a class="anchor" href="#appendix-faq-access-session-from-user-service"></a>如何从UserDetailsService访问HttpSession?</h5>
<div class="paragraph">
<p>您不能,因为 <code>UserDetailsService</code> 不了解 Servlet API.  如果要存储自定义用户数据,则应自定义返回的 <code>UserDetails</code> 对象.  然后可以通过本地线程的 <code>SecurityContextHolder</code> 在任何时候访问它.  调用 <code>SecurityContextHolder.getContext().getAuthentication().getPrincipal()</code> 将返回此自定义对象.</p>
</div>
<div class="paragraph">
<p>如果您确实需要访问该会话,则必须通过自定义 Web 层来完成.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-password-in-user-service"><a class="anchor" href="#appendix-faq-password-in-user-service"></a>如何在UserDetailsService中访问用户密码?</h5>
<div class="paragraph">
<p>您不能 (也不应该) . 您可能会误解其目的. 请参阅<a href="#appendix-faq-what-is-userdetailservice">什么是 UserDetailsService?</a></p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-dynamic-url-metadata"><a class="anchor" href="#appendix-faq-dynamic-url-metadata"></a>如何动态定义应用程序中的安全 URL?</h5>
<div class="paragraph">
<p>人们经常问如何在数据库中而不是在应用程序上下文中存储安全 URL 和安全元数据属性之间的映射.</p>
</div>
<div class="paragraph">
<p>您应该问自己的第一件事是您是否真的需要这样做.  如果应用程序需要安全保护,则还要求根据定义的策略对安全性进行彻底测试.  在将其推广到生产环境之前,可能需要进行审核和验收测试.  一个安全意识强的组织应该意识到,通过更改配置数据库中的一两行,可以在运行时修改安全设置,
可以立即消除其辛苦的测试过程的好处.  如果考虑到这一点 (可能在应用程序中使用多层安全性) ,那么 Spring Security 允许您完全自定义安全性元数据的来源.  您可以选择使其完全动态.</p>
</div>
<div class="paragraph">
<p>方法和 Web 安全都受 <code>AbstractSecurityInterceptor</code> 的子类保护,该子类配置有 <code>SecurityMetadataSource</code>,可以从 <code>SourceMSource</code> 获取特定方法或过滤器调用的元数据.  对于 Web 安全,拦截器类是 <code>FilterSecurityInterceptor</code>,它使用标记接口 <code>FilterInvocationSecurityMetadataSource</code>.
它操作的 "受保护对象" 类型 <code>是FilterInvocation</code>.  使用的默认实现 (在命名空间 <code>&lt;http&gt;</code> 中,并且在显式配置拦截器时) 都将 URL 模式列表及其对应的 "配置属性" 列表 (<code>ConfigAttribute</code> 的实例) 存储在内存映射中.</p>
</div>
<div class="paragraph">
<p>要从备用源加载数据,必须使用显式声明的安全过滤器链 (通常是 Spring Security 的 <code>FilterChainProxy</code>) 才能自定义 <code>FilterSecurityInterceptor</code> bean.  您不能使用命名空间.  然后,您将实现 <code>FilterInvocationSecurityMetadataSource</code> 以根据需要为特定的 FilterInvocation <sup class="footnote">[<a id="_footnoteref_16" class="footnote" href="#_footnotedef_16" title="View footnote.">16</a>]</sup> 加载数据.  一个非常基本的轮廓如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MyFilterSecurityMetadataSource implements FilterInvocationSecurityMetadataSource {

    public List&lt;ConfigAttribute&gt; getAttributes(Object object) {
        FilterInvocation fi = (FilterInvocation) object;
            String url = fi.getRequestUrl();
            String httpMethod = fi.getRequest().getMethod();
            List&lt;ConfigAttribute&gt; attributes = new ArrayList&lt;ConfigAttribute&gt;();

            // Lookup your database (or other source) using this information and populate the
            // list of attributes

            return attributes;
    }

    public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() {
        return null;
    }

    public boolean supports(Class&lt;?&gt; clazz) {
        return FilterInvocation.class.isAssignableFrom(clazz);
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多信息,请查看 <code>DefaultFilterInvocationSecurityMetadataSource</code> 的代码.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-ldap-authorities"><a class="anchor" href="#appendix-faq-ldap-authorities"></a>如何针对LDAP进行身份验证,但如何从数据库中加载用户角色?</h5>
<div class="paragraph">
<p><code>LdapAuthenticationProvider</code> bean (在 Spring Security 中处理普通的 LDAP 身份验证) 配置有两个单独的策略接口,一个用于执行身份验证,另一个用于加载用户权限,分别称为 <code>LdapAuthenticator</code> 和 <code>LdapAuthoritiesPopulator</code>.  <code>DefaultLdapAuthoritiesPopulator</code> 从 LDAP 目录加载用户权限,并具有各种配置参数,使您可以指定如何检索这些权限.</p>
</div>
<div class="paragraph">
<p>要改为使用 JDBC,您可以使用适合您的模式的任何 SQL 自己实现接口:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class MyAuthoritiesPopulator implements LdapAuthoritiesPopulator {
    @Autowired
    JdbcTemplate template;

    List&lt;GrantedAuthority&gt; getGrantedAuthorities(DirContextOperations userData, String username) {
        List&lt;GrantedAuthority&gt; = template.query("select role from roles where username = ?",
                                                                                                new String[] {username},
                                                                                                new RowMapper&lt;GrantedAuthority&gt;() {
            /**
             *  We're assuming here that you're using the standard convention of using the role
             *  prefix "ROLE_" to mark attributes which are supported by Spring Security's RoleVoter.
             */
            public GrantedAuthority mapRow(ResultSet rs, int rowNum) throws SQLException {
                return new SimpleGrantedAuthority("ROLE_" + rs.getString(1);
            }
        }
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后,您可以将这种类型的 bean 添加到您的应用程序上下文中,并将其注入 <code>LdapAuthenticationProvider</code>.  在参考手册的 LDAP 章节中有关使用显式 Spring Bean 配置 LDAP 的部分中对此进行了介绍.  请注意,在这种情况下,您不能使用命名空间进行配置.  您还应该向 Javadoc 查询相关的类和接口.</p>
</div>
</div>
<div class="sect4">
<h5 id="appendix-faq-namespace-post-processor"><a class="anchor" href="#appendix-faq-namespace-post-processor"></a>我想修改由命名空间创建的 bean 的属性,但是架构中没有任何东西可以支持它.</h5>
<div class="paragraph">
<p>除了放弃使用命名空间外,我还能做什么?</p>
</div>
<div class="paragraph">
<p>命名空间功能是有意限制的,因此无法涵盖使用普通 bean 可以做的所有事情.  如果您想做一些简单的事情,例如修改 Bean 或注入其他依赖,则可以通过在配置中添加 BeanPostProcessor 来实现.  更多信息可以在 <a href="https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/htmlsingle/spring-framework-reference.html#beans-factory-extension-bpp">Spring 参考手册</a>中找到.
为了做到这一点,您需要对创建哪些 bean 有一点了解,因此您还应该阅读上述问题中有关 <a href="#appendix-faq-namespace-to-bean-mapping">命名空间如何映射到 Spring bean</a>的博客文章.</p>
</div>
<div class="paragraph">
<p>通常,您需要将所需的功能添加到 <code>BeanPostProcessor</code> 的 <code>postProcessBeforeInitialization</code> 方法中.  假设您要自定义 <code>UsernamePasswordAuthenticationFilter</code> (由 <code>form-login</code> 元素创建) 所使用的 <code>AuthenticationDetailsSource</code>.
您想要从请求中提取一个名为 <code>CUSTOM_HEADER</code> 的特定 header,并在验证用户身份时使用它.  处理器类如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class BeanPostProcessor implements BeanPostProcessor {

        public Object postProcessAfterInitialization(Object bean, String name) {
                if (bean instanceof UsernamePasswordAuthenticationFilter) {
                        System.out.println("********* Post-processing " + name);
                        ((UsernamePasswordAuthenticationFilter)bean).setAuthenticationDetailsSource(
                                        new AuthenticationDetailsSource() {
                                                public Object buildDetails(Object context) {
                                                        return ((HttpServletRequest)context).getHeader("CUSTOM_HEADER");
                                                }
                                        });
                }
                return bean;
        }

        public Object postProcessBeforeInitialization(Object bean, String name) {
                return bean;
        }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后,您将在应用程序上下文中注册此 bean.  Spring 将在应用程序上下文中定义的 bean 上自动调用它.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="reactive-应用程序" class="sect0"><a class="anchor" href="#reactive-应用程序"></a>Reactive 应用程序</h1>
<div class="sect1">
<h2 id="jc-webflux"><a class="anchor" href="#jc-webflux"></a>22. WebFlux Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 的 WebFlux 支持依赖于 <code>WebFilter</code>,并且对 Spring WebFlux 和 Spring WebFlux.Fn 相同. 您可以找到一些示例程序来演示以下代码:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hello WebFlux <a href="https://github.com/spring-projects/spring-security/master//boot/hellowebflux">hellowebflux</a></p>
</li>
<li>
<p>Hello WebFlux.Fn <a href="https://github.com/spring-projects/spring-security/master//boot/hellowebfluxfn">hellowebfluxfn</a></p>
</li>
<li>
<p>Hello WebFlux Method <a href="https://github.com/spring-projects/spring-security/master//boot/hellowebflux-method">hellowebflux-method</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="最小化-webflux-security-配置"><a class="anchor" href="#最小化-webflux-security-配置"></a>22.1. 最小化 WebFlux Security 配置</h3>
<div class="paragraph">
<p>您可以在下面找到最小的 WebFlux 安全配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 178. Minimal WebFlux Security Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

    @Bean
    public MapReactiveUserDetailsService userDetailsService() {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("user")
            .roles("USER")
            .build();
        return new MapReactiveUserDetailsService(user);
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@EnableWebFluxSecurity
class HelloWebfluxSecurityConfig {

    @Bean
    fun userDetailsService(): ReactiveUserDetailsService {
        val userDetails = User.withDefaultPasswordEncoder()
                .username("user")
                .password("user")
                .roles("USER")
                .build()
        return MapReactiveUserDetailsService(userDetails)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此配置提供表单和 http 基本身份验证,设置授权以要求经过身份验证的用户访问任何页面,设置默认登录页面和默认注销页面,设置与安全性相关的 HTTP header,CSRF 保护等.</p>
</div>
</div>
<div class="sect2">
<h3 id="显式-webflux-security-配置"><a class="anchor" href="#显式-webflux-security-配置"></a>22.2. 显式 WebFlux Security 配置</h3>
<div class="paragraph">
<p>您可以在下面找到最小WebFlux安全配置的显式版本:</p>
</div>
<div class="exampleblock">
<div class="title">Example 179. Explicit WebFlux Security Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableWebFluxSecurity
public class HelloWebfluxSecurityConfig {

    @Bean
    public MapReactiveUserDetailsService userDetailsService() {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("user")
            .roles("USER")
            .build();
        return new MapReactiveUserDetailsService(user);
    }

    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http
            .authorizeExchange(exchanges -&gt; exchanges
                .anyExchange().authenticated()
            )
            .httpBasic(withDefaults())
            .formLogin(withDefaults());
        return http.build();
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Configuration
@EnableWebFluxSecurity
class HelloWebfluxSecurityConfig {

    @Bean
    fun userDetailsService(): ReactiveUserDetailsService {
        val userDetails = User.withDefaultPasswordEncoder()
                .username("user")
                .password("user")
                .roles("USER")
                .build()
        return MapReactiveUserDetailsService(userDetails)
    }

    @Bean
    fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
        return http {
            authorizeExchange {
                authorize(anyExchange, authenticated)
            }
            formLogin { }
            httpBasic { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该配置显式设置与最小配置相同的所有内容. 在这里,您可以轻松地更改默认值.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="防止利用漏洞"><a class="anchor" href="#防止利用漏洞"></a>23. 防止利用漏洞</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="webflux-csrf"><a class="anchor" href="#webflux-csrf"></a>23.1. WebFlux环境的跨站点请求伪造 (CSRF)</h3>
<div class="paragraph">
<p>本节讨论 Spring Security 对 WebFlux 环境的<a href="#csrf">Cross Site Request Forgery (CSRF)</a> 支持.</p>
</div>
<div class="sect3">
<h4 id="webflux-csrf-using"><a class="anchor" href="#webflux-csrf-using"></a>23.1.1. 使用Spring Security CSRF保护</h4>
<div class="paragraph">
<p>下面概述了使用 Spring Security 的 CSRF 保护的步骤:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-csrf-idempotent">使用正确的 HTTP 动词</a></p>
</li>
<li>
<p><a href="#webflux-csrf-configure">配置 CSRF 保护</a></p>
</li>
<li>
<p><a href="#webflux-csrf-include">包括 CSRF 令牌</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="webflux-csrf-idempotent"><a class="anchor" href="#webflux-csrf-idempotent"></a>使用正确的HTTP动词</h5>
<div class="paragraph">
<p>防御 CSRF 攻击的第一步是确保您的网站使用正确的 HTTP 动词. <a href="#csrf-protection-idempotent">安全方法必须是幂等</a>的中对此进行了详细介绍.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-csrf-configure"><a class="anchor" href="#webflux-csrf-configure"></a>配置CSRF保护</h5>
<div class="paragraph">
<p>下一步是在您的应用程序中配置 Spring Security 的 CSRF 保护. 默认情况下,Spring Security 的 CSRF 保护处于启用状态,但是您可能需要自定义配置. 以下是一些常见的自定义项.</p>
</div>
<div class="sect5">
<h6 id="webflux-csrf-configure-custom-repository"><a class="anchor" href="#webflux-csrf-configure-custom-repository"></a>自定义 CsrfTokenRepository</h6>
<div class="paragraph">
<p>默认情况下,Spring Security 使用 <code>WebSessionServerCsrfTokenRepository</code> 将所需的CSRF令牌存储在 <code>WebSession</code> 中.  在某些情况下,用户将需要配置自定义 <code>ServerCsrfTokenRepository</code>.  例如,可能需要将 <code>CsrfToken</code> 持久保存在 cookie 中以支持<a href="#webflux-csrf-include-ajax-auto">基于JavaScript 的应用程序</a>.</p>
</div>
<div class="paragraph">
<p>默认情况下,<code>CookieServerCsrfTokenRepository</code> 将写入名为 <code>XSRF-TOKEN</code> 的cookie,并从名为 <code>X-XSRF-TOKEN</code> 头或HTTP参数 <code>_csrf</code> 中读取它.  这些默认值来自 <a href="https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection">AngularJS</a></p>
</div>
<div class="paragraph">
<p>您可以使用以下命令在 Java 配置中配置 <code>CookieCsrfTokenRepository</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 180. Store CSRF Token in a Cookie</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .csrf(csrf -&gt; csrf.csrfTokenRepository(CookieServerCsrfTokenRepository.withHttpOnlyFalse()))
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        csrf {
            csrfTokenRepository = CookieServerCsrfTokenRepository.withHttpOnlyFalse()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该示例显式设置 <code>cookieHttpOnly=false</code>.  这是允许 JavaScript (即 AngularJS) 读取它所必需的.  如果您不需要直接使用 JavaScript 读取 Cookie 的功能,建议省略 <code>cookieHttpOnly = false</code>  (通过使用 <code>new CookieServerCsrfTokenRepository()</code> 代替) 以提高安全性.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="webflux-csrf-configure-disable"><a class="anchor" href="#webflux-csrf-configure-disable"></a>禁用 CSRF 保护</h6>
<div class="paragraph">
<p>默认情况下,CSRF 保护处于启用状态. 但是, <a href="#csrf-when">如果对您的应用程序有意义</a>,则禁用 CSRF 保护很简单.  下面的 Java 配置将禁用 CSRF 保护.</p>
</div>
<div class="exampleblock">
<div class="title">Example 181. Disable CSRF Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .csrf(csrf -&gt; csrf.disable()))
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        csrf {
            disable()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-csrf-include"><a class="anchor" href="#webflux-csrf-include"></a>包括 CSRF 令牌</h5>
<div class="paragraph">
<p>为了使<a href="#csrf-protection-stp">同步器令牌模式</a>免受 CSRF 攻击,我们必须在 HTTP 请求中包括实际的 CSRF 令牌.  这必须包含在请求的一部分 (即表单参数,HTTP 头等) 中,浏览器不会自动将其包含在 HTTP 请求中.</p>
</div>
<div class="paragraph">
<p>Spring Security 的 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/server/csrf/CsrfWebFilter.html">CsrfWebFilter</a>暴露了 <code>Mono&lt;CsrfToken&gt;</code> 作为 <code>ServerWebExchange</code> 属性,
名为 <code>org.springframework.security.web.server.csrf.CsrfToken</code>.  这意味着任何视图技术都可以访问 <code>Mono&lt;CsrfToken&gt;</code> 以将期望的令牌暴露为<a href="#webflux-csrf-include-form-attr">form</a>或<a href="#webflux-csrf-include-ajax-meta">meta tag</a>.</p>
</div>
<div id="webflux-csrf-include-subscribe" class="paragraph">
<p>如果您的视图技术无法提供简单的方法来订阅 <code>Mono&lt;CsrfToken&gt;</code>,则常见的模式是使用 Spring 的 <code>@ControllerAdvice</code> 直接暴露 <code>CsrfToken</code>.  例如,以下代码会将 CsrfToken 放置在 Spring Security 的<a href="#webflux-csrf-include-form-auto">CsrfRequestDataValueProcessor</a> 用来自动包含 CSRF 令牌作为隐藏输入的默认属性名称 (<code>_csrf</code>) 上.</p>
</div>
<div class="exampleblock">
<div class="title">Example 182. <code>CsrfToken</code> as <code>@ModelAttribute</code></div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@ControllerAdvice
public class SecurityControllerAdvice {
    @ModelAttribute
    Mono&lt;CsrfToken&gt; csrfToken(ServerWebExchange exchange) {
        Mono&lt;CsrfToken&gt; csrfToken = exchange.getAttribute(CsrfToken.class.getName());
        return csrfToken.doOnSuccess(token -&gt; exchange.getAttributes()
                .put(CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME, token));
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@ControllerAdvice
class SecurityControllerAdvice {
    @ModelAttribute
    fun csrfToken(exchange: ServerWebExchange): Mono&lt;CsrfToken&gt; {
        val csrfToken: Mono&lt;CsrfToken&gt;? = exchange.getAttribute(CsrfToken::class.java.name)
        return csrfToken!!.doOnSuccess { token -&gt;
            exchange.attributes[CsrfRequestDataValueProcessor.DEFAULT_CSRF_ATTR_NAME] = token
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>幸运的是,Thymeleaf 提供了无需任何额外工作即可运行的 <a href="#webflux-csrf-include-form-auto">集成</a> .</p>
</div>
<div class="sect5">
<h6 id="webflux-csrf-include-form"><a class="anchor" href="#webflux-csrf-include-form"></a>Form URL Encoded</h6>
<div class="paragraph">
<p>为了post HTML 表单,CSRF 令牌必须作为隐藏域包含在表单中. 例如,呈现的 HTML 可能如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 183. CSRF Token HTML</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;input type="hidden"
    name="_csrf"
    value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>接下来,我们将讨论将 CSRF 令牌作为隐藏输入包含在内的各种方式.</p>
</div>
<div class="sect6">
<h7 id="webflux-csrf-include-form-auto"><a class="anchor" href="#webflux-csrf-include-form-auto"></a>自动包含 CSRF 令牌</h7>
<div class="paragraph">
<p>Spring Security 的 CSRF 支持通过其 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html">CsrfRequestDataValueProcessor</a>与 Spring 的 <a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/reactive/result/view/RequestDataValueProcessor.html">RequestDataValueProcessor</a>集成.
为了使 <code>CsrfRequestDataValueProcessor</code> 正常工作,必须预订 <code>Mono&lt;CsrfToken&gt;</code>,并且必须将 <code>CsrfToken</code> 作为与 <a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/reactive/result/view/CsrfRequestDataValueProcessor.html#DEFAULT_CSRF_ATTR_NAME">DEFAULT_CSRF_ATTR_NAME</a> 匹配的<a href="#webflux-csrf-include-subscribe">属性暴露</a>.</p>
</div>
<div class="paragraph">
<p>幸运的是,Thymeleaf 通过与 <code>RequestDataValueProcessor</code> 集成为您提供照顾所有 <a href="https://www.thymeleaf.org/doc/tutorials/2.1/thymeleafspring.html#integration-with-requestdatavalueprocessor">样板的支持</a> ,以确保具有不安全 HTTP 方法 (即发布) 的表单将自动包含实际的 CSRF 令牌.</p>
</div>
</div>
<div class="sect6">
<h7 id="webflux-csrf-include-form-attr"><a class="anchor" href="#webflux-csrf-include-form-attr"></a>CsrfToken 请求属性</h7>
<div class="paragraph">
<p>如果在请求中包括实际 CSRF 令牌的 <a href="#webflux-csrf-include">其他选项</a>不起作用,则可以利用 <code>Mono&lt;CsrfToken&gt;</code> 作为名为 <code>org.springframework.security.web.server.csrf.CsrfToken</code> 的 <code>ServerWebExchange</code> <a href="#webflux-csrf-include">属性暴露</a>的事实.  .</p>
</div>
<div class="paragraph">
<p>下面的 Thymeleaf 示例假定您在名为 <code>_csrf</code> 的属性上<a href="#webflux-csrf-include-subscribe">暴露</a> <code>CsrfToken</code>.</p>
</div>
<div class="exampleblock">
<div class="title">Example 184. CSRF Token in Form with Request Attribute</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form th:action="@{/logout}"
    method="post"&gt;
&lt;input type="submit"
    value="Log out" /&gt;
&lt;input type="hidden"
    th:name="${_csrf.parameterName}"
    th:value="${_csrf.token}"/&gt;
&lt;/form&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="webflux-csrf-include-ajax"><a class="anchor" href="#webflux-csrf-include-ajax"></a>Ajax 和JSON 请求</h6>
<div class="paragraph">
<p>如果使用的是 JSON,则无法在 HTTP 参数内提交 CSRF 令牌.  相反,您可以在 HTTP 头中提交令牌.</p>
</div>
<div class="paragraph">
<p>在以下各节中,我们将讨论在基于 JavaScript 的应用程序中将 CSRF 令牌作为 HTTP 请求头包括在内的各种方式.</p>
</div>
<div class="sect6">
<h7 id="webflux-csrf-include-ajax-auto"><a class="anchor" href="#webflux-csrf-include-ajax-auto"></a>自动包含</h7>
<div class="paragraph">
<p>可以轻松<a href="#webflux-csrf-configure-custom-repository">configured</a> Spring Security 将期望的 CSRF 令牌存储在 cookie 中. 通过将期望的 CSRF 存储在 cookie 中,像 <a href="https://docs.angularjs.org/api/ng/service/$http#cross-site-request-forgery-xsrf-protection">AngularJS</a>这样的 JavaScript 框架将自动在 HTTP 请求头中包含实际的 CSRF 令牌.</p>
</div>
</div>
<div class="sect6">
<h7 id="webflux-csrf-include-ajax-meta"><a class="anchor" href="#webflux-csrf-include-ajax-meta"></a>元标签</h7>
<div class="paragraph">
<p>在<a href="#webflux-csrf-include-form-auto">Cookie 中暴露</a>CSRF 的另一种方式是将CSRF令牌包含在您的 <code>meta</code> 标签.  HTML 可能看起来像这样:</p>
</div>
<div class="exampleblock">
<div class="title">Example 185. CSRF meta tag HTML</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html&gt;
&lt;head&gt;
    &lt;meta name="_csrf" content="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/&gt;
    &lt;meta name="_csrf_header" content="X-CSRF-TOKEN"/&gt;
    &lt;!-- ... --&gt;
&lt;/head&gt;
&lt;!-- ... --&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一旦元标记包含 CSRF 令牌,JavaScript 代码就会读取元标记并将 CSRF 令牌作为请求头包含在内. 如果您使用的是 jQuery,则可以通过以下方式完成:</p>
</div>
<div class="exampleblock">
<div class="title">Example 186. AJAX send CSRF Token</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-javascript" data-lang="javascript">$(function () {
    var token = $("meta[name='_csrf']").attr("content");
    var header = $("meta[name='_csrf_header']").attr("content");
    $(document).ajaxSend(function(e, xhr, options) {
        xhr.setRequestHeader(header, token);
    });
});</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>下面的示例假定您在名为 <code>_csrf</code> 的属性上<a href="#webflux-csrf-include-subscribe">暴露</a> <code>CsrfToken</code>. 下面显示了使用 Thymeleaf 进行此操作的示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 187. CSRF meta tag JSP</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;html&gt;
&lt;head&gt;
    &lt;meta name="_csrf" th:content="${_csrf.token}"/&gt;
    &lt;!-- default header name is X-CSRF-TOKEN --&gt;
    &lt;meta name="_csrf_header" th:content="${_csrf.headerName}"/&gt;
    &lt;!-- ... --&gt;
&lt;/head&gt;
&lt;!-- ... --&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-csrf-considerations"><a class="anchor" href="#webflux-csrf-considerations"></a>23.1.2. CSRF 注意事项</h4>
<div class="paragraph">
<p>实施针对 CSRF 攻击的防护时,需要考虑一些特殊注意事项.  本节讨论与 WebFlux 环境有关的注意事项.  请参阅<a href="#csrf-considerations">CSRF 注意事项</a>一节,以进行更一般的讨论.</p>
</div>
<div class="sect4">
<h5 id="webflux-considerations-csrf-login"><a class="anchor" href="#webflux-considerations-csrf-login"></a>登录</h5>
<div class="paragraph">
<p><a href="#csrf-considerations-login">要求 CSRF 进行登录请求</a>很重要,以防止伪造登录尝试.  Spring Security 的 WebFlux 支持是开箱即用的.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-considerations-csrf-logout"><a class="anchor" href="#webflux-considerations-csrf-logout"></a>注销</h5>
<div class="paragraph">
<p><a href="#csrf-considerations-logout">要求 CSRF 进行注销请求</a> 很重要,以防止伪造注销尝试.  默认情况下,Spring Security 的 <code>LogoutWebFilter</code> 仅处理 HTTP 发布请求.  这样可以确保注销需要 CSRF 令牌,并且恶意用户不能强制注销用户.</p>
</div>
<div class="paragraph">
<p>最简单的方法是使用表单注销.  如果您确实需要链接,则可以使用 JavaScript 来使链接执行 POST (即可能以隐藏形式) .  对于禁用了 JavaScript 的浏览器,您可以选择使该链接将用户带到将执行 POST 的注销确认页面.</p>
</div>
<div class="paragraph">
<p>如果您确实想在注销时使用 HTTP GET,则可以这样做,但是请记住,通常不建议这样做.  例如,以下 Java 配置将使用 URL 执行 <code>/logout</code> 通过任何 HTTP 方法请求注销:</p>
</div>
<div class="exampleblock">
<div class="title">Example 188. Log out with HTTP GET</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .logout(logout -&gt; logout.requiresLogout(new PathPatternParserServerWebExchangeMatcher("/logout")))
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        logout {
            requiresLogout = PathPatternParserServerWebExchangeMatcher("/logout")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-considerations-csrf-timeouts"><a class="anchor" href="#webflux-considerations-csrf-timeouts"></a>CSRF 和会话超时</h5>
<div class="paragraph">
<p>默认情况下,Spring Security 将 CSRF 令牌存储在 <code>WebSession</code> 中.  这可能会导致会话到期的情况,这意味着没有期望的 CSRF 令牌进行验证.</p>
</div>
<div class="paragraph">
<p>我们已经讨论了会话超时的<a href="#csrf-considerations-login">一般解决方案</a>.  本节讨论与 WebFlux 支持有关的 CSRF 超时的详细信息.</p>
</div>
<div class="paragraph">
<p>更改期望的 CSRF 令牌在 cookie 中的存储很简单.  有关详细信息,请参阅 <a href="#webflux-csrf-configure-custom-repository">自定义 <code>CsrfTokenRepository</code></a> 部分.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-csrf-considerations-multipart"><a class="anchor" href="#webflux-csrf-considerations-multipart"></a>Multipart (文件上传)</h5>
<div class="paragraph">
<p>我们<a href="#csrf-considerations-multipart">已经讨论</a> 了如何保护分段请求 (文件上传) 免受 CSRF 攻击如何导致 <a href="https://en.wikipedia.org/wiki/Chicken_or_the_egg">鸡和蛋的问题</a>. 本节讨论如何实现将 CSRF 令牌放置在 WebFlux 应用程序的<a href="#webflux-csrf-considerations-multipart-body">body</a> 和<a href="#webflux-csrf-considerations-multipart-url">url</a> 中.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有关在 Spring 上使用多部分表单的更多信息,请参见 Spring 参考的 <a href="https://docs.spring.io/spring/docs/5.2.x/spring-framework-reference/web-reactive.html#webflux-multipart">Multipart Data</a> 部分.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="webflux-csrf-considerations-multipart-body"><a class="anchor" href="#webflux-csrf-considerations-multipart-body"></a>将 CSRF 令牌放入body 中</h6>
<div class="paragraph">
<p>我们<a href="#csrf-considerations-multipart">已经讨论</a>了将 CSRF 令牌放入正文中的取舍.
在 WebFlux 应用程序中,可以使用以下配置进行配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 189. Enable obtaining CSRF token from multipart/form-data</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .csrf(csrf -&gt; csrf.tokenFromMultipartDataEnabled(true))
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        csrf {
            tokenFromMultipartDataEnabled = true
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="webflux-csrf-considerations-multipart-url"><a class="anchor" href="#webflux-csrf-considerations-multipart-url"></a>将CSRF令牌放入URL</h6>
<div class="paragraph">
<p>我们 <a href="#csrf-considerations-multipart">已经讨论</a>了在 URL 中放置 CSRF 令牌的权衡.  由于 CsrfToken 是作为 <code>ServerHttpRequest</code>  <a href="#webflux-csrf-include">请求属性</a>暴露的,因此我们可以使用它来创建带有 CSRF 令牌的 <code>action</code>.  Thymeleaf 的示例如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 190. CSRF Token in Action</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">&lt;form method="post"
    th:action="@{/upload(${_csrf.parameterName}=${_csrf.token})}"
    enctype="multipart/form-data"&gt;</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-csrf-considerations-override-method"><a class="anchor" href="#webflux-csrf-considerations-override-method"></a>HiddenHttpMethodFilter</h5>
<div class="paragraph">
<p>我们 <a href="#csrf-considerations-override-method">已经讨论</a> 了重写HTTP方法.</p>
</div>
<div class="paragraph">
<p>在 Spring WebFlux 应用程序中,使用 <a href="https://docs.spring.io/spring-framework/docs/5.2.x/javadoc-api/org/springframework/web/filter/reactive/HiddenHttpMethodFilter.html">HiddenHttpMethodFilter</a> 重写 HTTP 方法.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-headers"><a class="anchor" href="#webflux-headers"></a>23.2. 安全HTTP响应头</h3>
<div class="paragraph">
<p><a href="#headers">Security HTTP Response Headers</a>可用于提高 Web 应用程序的安全性.  本节专门针对基于 WebFlux 的安全 HTTP 响应提供支持.</p>
</div>
<div class="sect3">
<h4 id="webflux-headers-default"><a class="anchor" href="#webflux-headers-default"></a>23.2.1. 默认安全头</h4>
<div class="paragraph">
<p>Spring Security 提供了一组默认的  <a href="#headers-default">default set of Security HTTP Response Headers</a>  ,以提供安全的默认值.  虽然这些头中的每一个均被视为最佳实践,但应注意,并非所有客户端都使用这些头,因此鼓励进行额外的测试.</p>
</div>
<div class="paragraph">
<p>您可以自定义特定的标题.  例如,假设您希望使用默认值,但您希望为 <a href="#servlet-headers-frame-options">X-Frame-Options</a> 指定 <code>SAMEORIGIN</code>.</p>
</div>
<div class="paragraph">
<p>您可以使用以下配置轻松完成此操作:</p>
</div>
<div class="exampleblock">
<div class="title">Example 191. Customize Default Security Headers</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -&gt; headers
            .frameOptions(frameOptions -&gt; frameOptions
                .mode(Mode.SAMEORIGIN)
            )
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            frameOptions {
                mode = Mode.SAMEORIGIN
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您不想添加默认值,并且希望对应使用的内容进行明确控制,则可以禁用默认值.下面提供了这种配置的示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 192. Disable HTTP Security Response Headers</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -&gt; headers.disable());
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            disable()
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-cache-control"><a class="anchor" href="#webflux-headers-cache-control"></a>23.2.2. Cache Control</h4>
<div class="paragraph">
<p>Spring Security 默认包含 <a href="#headers-cache-control">Cache Control</a> 头.</p>
</div>
<div class="paragraph">
<p>但是,如果您实际上想缓存特定的响应,则您的应用程序可以有选择地调用 <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/http/server/reactive/ServerHttpResponse.html">ServerHttpResponse</a>  来覆盖 Spring Security 设置的 header.  这对于确保正确缓存 CSS,JavaScript 和图片之类的内容很有用.</p>
</div>
<div class="paragraph">
<p>使用 Spring WebFluxZz 时,通常在您的配置中完成.  有关如何执行此操作的详细信息,请参见 Spring 参考文档的  <a href="https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources">静态资源</a> 部分.</p>
</div>
<div class="paragraph">
<p>如有必要,您还可以禁用 Spring Security 的缓存控制 HTTP 响应头.</p>
</div>
<div class="exampleblock">
<div class="title">Example 193. Cache Control Disabled</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -&gt; headers
            .cache(cache -&gt; cache.disable())
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            cache {
                disable()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-content-type-options"><a class="anchor" href="#webflux-headers-content-type-options"></a>23.2.3. Content Type 选项</h4>
<div class="paragraph">
<p>Spring Security 默认包含  <a href="#headers-content-type-options">Content-Type</a> 头.  但是,您可以使用以下命令将其禁用:</p>
</div>
<div class="exampleblock">
<div class="title">Example 194. Content Type Options Disabled</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -&gt; headers
            .contentTypeOptions(contentTypeOptions -&gt; contentTypeOptions.disable())
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentTypeOptions {
                disable()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-hsts"><a class="anchor" href="#webflux-headers-hsts"></a>23.2.4. HTTP Strict Transport Security (HSTS)</h4>
<div class="paragraph">
<p>Spring Security 默认提供严格传输安全头.  但是,您可以显式自定义结果.  例如,以下是为 HSTS 显式提供的示例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 195. Strict Transport Security</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -&gt; headers
            .hsts(hsts -&gt; hsts
                .includeSubdomains(true)
                .preload(true)
                .maxAge(Duration.ofDays(365))
            )
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            hsts {
                includeSubdomains = true
                preload = true
                maxAge = Duration.ofDays(365)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-frame-options"><a class="anchor" href="#webflux-headers-frame-options"></a>23.2.5. X-Frame-Options</h4>
<div class="paragraph">
<p>默认情况下,Spring Security 使用  <a href="#headers-frame-options">X-Frame-Options</a> 禁用 iframe 中的渲染.</p>
</div>
<div class="paragraph">
<p>您可以使用以下方法自定义框架选项以在使用相同的 origin:</p>
</div>
<div class="exampleblock">
<div class="title">Example 196. X-Frame-Options: SAMEORIGIN</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -&gt; headers
            .frameOptions(frameOptions -&gt; frameOptions
                .mode(SAMEORIGIN)
            )
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            frameOptions {
                mode = SAMEORIGIN
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-xss-protection"><a class="anchor" href="#webflux-headers-xss-protection"></a>23.2.6. X-XSS-Protection</h4>
<div class="paragraph">
<p>默认情况下,Spring Security 指示浏览器使用 <a href="#headers-xss-protection">X-XSS-Protection header</a> 阻止反射的 XSS 攻击.
您可以使用以下配置禁用 <code>X-XSS-Protection</code>:</p>
</div>
<div class="exampleblock">
<div class="title">Example 197. X-XSS-Protection Customization</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -&gt; headers
            .xssProtection(xssProtection -&gt; xssProtection.disable())
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            xssProtection {
                disable()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-csp"><a class="anchor" href="#webflux-headers-csp"></a>23.2.7. Content Security Policy (CSP)</h4>
<div class="paragraph">
<p>Spring Security 默认情况下不会添加  <a href="#headers-csp">Content Security Policy</a>,因为没有应用程序的上下文就无法知道合理的默认值.  Web 应用程序作者必须声明安全策略以强制执行和/或监视受保护的资源.</p>
</div>
<div class="paragraph">
<p>例如,给定以下安全策略:</p>
</div>
<div class="exampleblock">
<div class="title">Example 198. Content Security Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-http" data-lang="http">Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以使用配置启用 CSP 头,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 199. Content Security Policy</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -&gt; headers
            .contentSecurityPolicy(policy -&gt; policy
                .policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
            )
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentSecurityPolicy {
                policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要启用 CSP <code>report-only</code> 头，请提供以下配置：</p>
</div>
<div class="exampleblock">
<div class="title">Example 200. Content Security Policy Report Only</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -&gt; headers
            .contentSecurityPolicy(policy -&gt; policy
                .policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
                .reportOnly()
            )
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            contentSecurityPolicy {
                policyDirectives = "script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
                reportOnly = true
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-referrer"><a class="anchor" href="#webflux-headers-referrer"></a>23.2.8. 推荐人策略</h4>
<div class="paragraph">
<p>Spring Security 默认情况下不添加  <a href="#headers-referrer">Referrer Policy</a> 头.  您可以使用配置启用 Referrer Policy  头,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 201. Referrer Policy Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -&gt; headers
            .referrerPolicy(referrer -&gt; referrer
                .policy(ReferrerPolicy.SAME_ORIGIN)
            )
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            referrerPolicy {
                policy = ReferrerPolicy.SAME_ORIGIN
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-headers-feature"><a class="anchor" href="#webflux-headers-feature"></a>23.2.9. Feature Policy (功能策略)</h4>
<div class="paragraph">
<p>Spring Security 默认不添加  <a href="#headers-feature">Feature Policy</a>  头.  以下  <code>Feature-Policy</code>  头:</p>
</div>
<div class="exampleblock">
<div class="title">Example 202. Feature-Policy Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>Feature-Policy: geolocation 'self'</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以使用配置启用 Feature-Policy 头,如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 203. Feature-Policy Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .headers(headers -&gt; headers
            .featurePolicy("geolocation 'self'")
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        headers {
            featurePolicy("geolocation 'self'")
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-headers-clear-site-data"><a class="anchor" href="#webflux-headers-clear-site-data"></a>配置内容安全策略</h5>
<div class="paragraph">
<p>Spring Security 默认情况下不添加<a href="#headers-clear-site-data">Clear-Site-Data</a>  头.  以下 Clear-Site-Data 头:</p>
</div>
<div class="exampleblock">
<div class="title">Example 204. Clear-Site-Data Example</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre>Clear-Site-Data: "cache", "cookies"</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>可以使用以下配置在注销时发送:</p>
</div>
<div class="exampleblock">
<div class="title">Example 205. Clear-Site-Data Configuration</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    ServerLogoutHandler securityContext = new SecurityContextServerLogoutHandler();
    ClearSiteDataServerHttpHeadersWriter writer = new ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES);
    ServerLogoutHandler clearSiteData = new HeaderWriterServerLogoutHandler(writer);
    DelegatingServerLogoutHandler logoutHandler = new DelegatingServerLogoutHandler(securityContext, clearSiteData);

    http
        // ...
        .logout()
            .logoutHandler(logoutHandler);
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    val securityContext: ServerLogoutHandler = SecurityContextServerLogoutHandler()
    val writer = ClearSiteDataServerHttpHeadersWriter(CACHE, COOKIES)
    val clearSiteData: ServerLogoutHandler = HeaderWriterServerLogoutHandler(writer)
    val customLogoutHandler = DelegatingServerLogoutHandler(securityContext, clearSiteData)

    return http {
        // ...
        logout {
            logoutHandler = customLogoutHandler
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-http"><a class="anchor" href="#webflux-http"></a>23.3. HTTP</h3>
<div class="paragraph">
<p>所有基于 HTTP 的通信都应使用 <a href="#http">using TLS</a> 保护.</p>
</div>
<div class="paragraph">
<p>您可以在下面找到有关协助 HTTPS 使用的 WebFlux 特定功能的详细信息.</p>
</div>
<div class="sect3">
<h4 id="webflux-http-redirect"><a class="anchor" href="#webflux-http-redirect"></a>23.3.1. 重定向 HTTPS</h4>
<div class="paragraph">
<p>如果客户端使用 HTTP 而不是 HTTPS 发出请求,则可以将 Spring Security 配置为重定向到 HTTPS.</p>
</div>
<div class="paragraph">
<p>例如,以下 Java 配置会将所有 HTTP 请求重定向到 HTTPS:</p>
</div>
<div class="exampleblock">
<div class="title">Example 206. Redirect to HTTPS</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .redirectToHttps(withDefaults());
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        redirectToHttps { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该配置可以轻松地包装在 if 语句中,仅在生产中打开.或者,可以通过查找仅在生产中发生的请求的属性来启用它.例如,如果生产环境添加了名为 <code>X-Forwarded-Proto</code> 的请求头,则可以使用以下 Java 配置:</p>
</div>
<div class="exampleblock">
<div class="title">Example 207. Redirect to HTTPS when X-Forwarded</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .redirectToHttps(redirect -&gt; redirect
            .httpsRedirectWhen(e -&gt; e.getRequest().getHeaders().containsKey("X-Forwarded-Proto"))
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        redirectToHttps {
            httpsRedirectWhen {
                it.request.headers.containsKey("X-Forwarded-Proto")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-hsts"><a class="anchor" href="#webflux-hsts"></a>23.3.2. 严格的安全传输</h4>
<div class="paragraph">
<p>Spring Security 提供对严格传输安全的支持,并默认启用它.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-http-proxy-server"><a class="anchor" href="#webflux-http-proxy-server"></a>23.3.3. 代理服务器配置</h4>
<div class="paragraph">
<p>Spring Security 与 <a href="#http-proxy-server">代理服务器集成</a>.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-oauth2"><a class="anchor" href="#webflux-oauth2"></a>24. OAuth2 WebFlux</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 为响应式应用程序提供了 OAuth2 和 WebFlux 集成.</p>
</div>
<div class="sect2">
<h3 id="webflux-oauth2-login"><a class="anchor" href="#webflux-oauth2-login"></a>24.1. OAuth 2.0 Login</h3>
<div class="paragraph">
<p>OAuth 2.0 登录功能为应用程序提供了让用户可以在提供了 OAuth 2.0 (例如 GitHub) 或 OpenID Connect 1.0 (例如 Google) 协议的第三方平台,使用平台现有帐户登录该应用程序的功能.  OAuth 2.0 登录实现了以下用例: "使用 Google 登录" 或 "使用 GitHub 登录".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
OAuth 2.0 登录是通过使用 <a href="https://tools.ietf.org/html/rfc6748#section-4.1">OAuth 2.0 Authorization Framework</a> 和 <a href="https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">OpenID Connect Core 1.0</a>.中指定的授权码授权来实现的.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="webflux-oauth2-login-sample"><a class="anchor" href="#webflux-oauth2-login-sample"></a>24.1.1. Spring Boot 2.0 示例</h4>
<div class="paragraph">
<p>Spring Boot 2.x 为 OAuth 2.0 登录带来了完整的自动配置功能.</p>
</div>
<div class="paragraph">
<p>本部分显示了如何使用 Google 作为身份验证提供程序来配置 <a href="https://github.com/spring-projects/spring-security/master//boot/oauth2login"><strong>OAuth 2.0 Login sample</strong></a>,并涵盖以下主题:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-oauth2-login-sample-setup">初始设置</a></p>
</li>
<li>
<p><a href="#webflux-oauth2-login-sample-redirect">设置重定向 URI</a></p>
</li>
<li>
<p><a href="#webflux-oauth2-login-sample-config">配置 <code>application.yml</code></a></p>
</li>
<li>
<p><a href="#webflux-oauth2-login-sample-start">启动应用程序</a></p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="webflux-oauth2-login-sample-setup"><a class="anchor" href="#webflux-oauth2-login-sample-setup"></a>初始设置</h5>
<div class="paragraph">
<p>要使用 Google 的 OAuth 2.0 身份验证系统登录,您必须在 Google API 控制台中设置一个项目以获得 OAuth 2.0 凭据.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="https://developers.google.com/identity/protocols/OpenIDConnect">Google&#8217;s OAuth 2.0 实现</a> 符合 <a href="https://openid.net/connect/">OpenID Connect 1.0</a> 规范,并且已通过 <a href="https://openid.net/certification/">OpenID Certified</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>请按照设置 <a href="https://developers.google.com/identity/protocols/OpenIDConnect">OpenID Connect</a>  (需要翻墙才能访问,链接打开是 Google 的开发者平台控制台) 部分开始的 OpenID Connect 页面上的说明进行操作.</p>
</div>
<div class="paragraph">
<p>完成 "获取 OAuth 2.0 凭据" 说明后,您应该拥有一个新的 OAuth 客户端,其凭据由 Client ID 和 Client Secret.组成.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2-login-sample-redirect"><a class="anchor" href="#webflux-oauth2-login-sample-redirect"></a>设置重定向URI</h5>
<div class="paragraph">
<p>重定向 URI 是用户的在通过 Google 身份验证并在授权页面上同意 (<em>(<a href="#oauth2login-sample-initial-setup">在上一步中创建</a>)</em>) OAuth 客户端的访问权限后,由 Google 重定向的回调链接地址</p>
</div>
<div class="paragraph">
<p>在 设置重定向 URI 子章节中,确保将  <strong>Authorized redirect URIs</strong> 字段设置为 <code><a href="http://localhost:8080/login/oauth2/code/google" class="bare">localhost:8080/login/oauth2/code/google</a></code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
默认重定向 URI 模板为 <code>{baseUrl}/login/oauth2/code/{registrationId}</code>..  <strong><em>registrationId</em></strong> 是 <a href="#oauth2Client-client-registration">ClientRegistration</a> 的唯一标识符.
</td>
</tr>
</table>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
如果 OAuth 客户端在代理服务器 (例如: Nginx) 后面运行,建议检查<a href="#http-proxy-server">代理服务器配置</a>以确保正确配置了应用程序.  另外,请参阅 <code>redirect-uri</code> 支持的<a href="#oauth2Client-auth-code-redirect-uri"><code>URI</code> 模板变量</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2-login-sample-config"><a class="anchor" href="#webflux-oauth2-login-sample-config"></a>Configure <code>application.yml</code></h5>
<div class="paragraph">
<p>现在,您有了 Google 的新 OAuth 客户端,您需要配置应用程序以将 OAuth 客户端用于身份验证流程.  为此:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>转到 <code>application.yml</code> 并设置以下配置:</p>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:   <i class="conum" data-value="1"></i><b>(1)</b>
          google:   <i class="conum" data-value="2"></i><b>(2)</b>
            client-id: google-client-id
            client-secret: google-client-secret</code></pre>
</div>
</div>
<div class="exampleblock">
<div class="title">Example 208. OAuth 客户端属性</div>
<div class="content">
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>spring.security.oauth2.client.registration</code> 是 OAuth 客户端属性的基本属性前缀.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>基本属性前缀后面是<a href="#oauth2Client-client-registration">ClientRegistration</a>的 ID,例如 google</td>
</tr>
</table>
</div>
</div>
</div>
</li>
<li>
<p>将 <code>client-id</code> 和 <code>client-secret</code> 属性中的值替换为您先前创建的OAuth 2.0凭据.</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2-login-sample-start"><a class="anchor" href="#webflux-oauth2-login-sample-start"></a>启动应用程序</h5>
<div class="paragraph">
<p>启动 Spring Boot 2.0 示例并转到 <code><a href="http://localhost:8080" class="bare">localhost:8080</a></code>.  然后,您将会被重定向到默认自动生成的登录页面,该页面显示Google的链接.</p>
</div>
<div class="paragraph">
<p>单击 Google 链接,然后您将重定向到 Google 进行身份验证.</p>
</div>
<div class="paragraph">
<p>在使用您的 Google 帐户凭据进行身份验证之后,显示给您的下一页是 <strong>Allow</strong> 页面.   <strong>Allow</strong> 页面要求您允许或拒绝之前创建的 OAuth 客户端的访问权限.  点击 <strong>Allow</strong> 以授权 OAuth 客户端访问您的电子邮件地址和基本个人资料信息.</p>
</div>
<div class="paragraph">
<p>此时,OAuth 客户端将从 <a href="https://openid.net/specs/openid-connect-core-1_0.html#UserInfo">UserInfo Endpoint</a> 检索您的电子邮件地址和基本个人资料信息,并建立经过身份验证的会话.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2-login-openid-provider-configuration"><a class="anchor" href="#webflux-oauth2-login-openid-provider-configuration"></a>24.1.2. 使用OpenID提供程序配置</h4>
<div class="paragraph">
<p>对于知名的提供商,Spring Security 为 OAuth 授权提供商的配置提供了必要的默认值.  如果您正在使用支持 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">OpenID Provider Configuration</a> 或 <a href="https://tools.ietf.org/html/rfc8414#section-3">授权服务器</a>,
则可以使用 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse">OpenID Provider Configuration Response</a>的 <code>issuer-uri</code> 来配置应用程序.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">spring:
  security:
    oauth2:
      client:
        provider:
          keycloak:
            issuer-uri: https://idp.example.com/auth/realms/demo
        registration:
          keycloak:
            client-id: spring-security
            client-secret: 6cea952f-10d0-4d00-ac79-cc865820dc2c</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>issuer-uri</code> 指示Spring Security依次查询端点 <code><a href="https://idp.example.com/auth/realms/demo/.well-known/openid-configuration" class="bare">idp.example.com/auth/realms/demo/.well-known/openid-configuration</a></code>, <code><a href="https://idp.example.com/.well-known/openid-configuration/auth/realms/demo" class="bare">idp.example.com/.well-known/openid-configuration/auth/realms/demo</a></code>, or  <code><a href="https://idp.example.com/.well-known/oauth-authorization-server/auth/realms/demo" class="bare">idp.example.com/.well-known/oauth-authorization-server/auth/realms/demo</a></code> 来发现配置.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Spring Security 将一次查询一个端点,并在第一个端点发出 200 响应时停止.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>client-id</code> 和 <code>client-secret</code> 链接到提供程序,因为 <code>keycloak</code> 用于提供程序和注册.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2-login-explicit"><a class="anchor" href="#webflux-oauth2-login-explicit"></a>24.1.3. 显式 OAuth2 登录配置</h4>
<div class="paragraph">
<p>最小的 OAuth2 登录配置如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 209. Minimal OAuth2 Login</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ReactiveClientRegistrationRepository clientRegistrations() {
    ClientRegistration clientRegistration = ClientRegistrations
            .fromIssuerLocation("https://idp.example.com/auth/realms/demo")
            .clientId("spring-security")
            .clientSecret("6cea952f-10d0-4d00-ac79-cc865820dc2c")
            .build();
    return new InMemoryReactiveClientRegistrationRepository(clientRegistration);
}

@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .oauth2Login(withDefaults());
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun clientRegistrations(): ReactiveClientRegistrationRepository {
    val clientRegistration: ClientRegistration = ClientRegistrations
            .fromIssuerLocation("https://idp.example.com/auth/realms/demo")
            .clientId("spring-security")
            .clientSecret("6cea952f-10d0-4d00-ac79-cc865820dc2c")
            .build()
    return InMemoryReactiveClientRegistrationRepository(clientRegistration)
}

@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        oauth2Login { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>其他配置选项如下所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 210. Advanced OAuth2 Login</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .oauth2Login(oauth2 -&gt; oauth2
            .authenticationConverter(converter)
            .authenticationManager(manager)
            .authorizedClientRepository(authorizedClients)
            .clientRegistrationRepository(clientRegistrations)
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        oauth2Login {
            authenticationConverter = converter
            authenticationManager = manager
            authorizedClientRepository = authorizedClients
            clientRegistrationRepository = clientRegistration
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您可以注册 <code>GrantedAuthoritiesMapper</code> <code>@Bean</code> 使其自动应用于默认配置， 如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 211. GrantedAuthoritiesMapper Bean</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public GrantedAuthoritiesMapper userAuthoritiesMapper() {
    ...
}

@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        // ...
        .oauth2Login(withDefaults());
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun userAuthoritiesMapper(): GrantedAuthoritiesMapper {
   // ...
}

@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        oauth2Login { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webflux-oauth2-client"><a class="anchor" href="#webflux-oauth2-client"></a>24.2. OAuth2 客户端</h3>
<div class="paragraph">
<p>Spring Security 的 OAuth 支持允许无需身份验证即可获取访问令牌.  Spring Boot 的基本配置如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">spring:
  security:
    oauth2:
      client:
        registration:
          github:
            client-id: replace-with-client-id
            client-secret: replace-with-client-secret
            scope: read:user,public_repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>您将需要用在 GitHub 注册的值替换 <code>client-id</code> 和 <code>client-secret</code>.</p>
</div>
<div class="paragraph">
<p>下一步是指示 Spring Security 您希望充当 OAuth2 客户端,以便获取访问令牌.</p>
</div>
<div class="exampleblock">
<div class="title">Example 212. OAuth2 Client</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain configure(ServerHttpSecurity http) throws Exception {
    http
        // ...
        .oauth2Client(withDefaults());
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        // ...
        oauth2Client { }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>您现在可以利用 Spring Security 的第 26 章 <a href="#webclient">WebClient</a>或<a href="#webflux-roac">@RegisteredOAuth2AuthorizedClient</a>  支持来获取和使用访问令牌.</p>
</div>
</div>
<div class="sect2">
<h3 id="webflux-oauth2-resource-server"><a class="anchor" href="#webflux-oauth2-resource-server"></a>24.3. OAuth 2.0 资源服务器</h3>
<div class="paragraph">
<p>Spring Security 支持使用两种形式的 OAuth 2.0 <a href="https://tools.ietf.org/html/rfc6750.html">Bearer Tokens</a> 来保护端点:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://tools.ietf.org/html/rfc7519">JWT</a></p>
</li>
<li>
<p>Opaque Tokens</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在应用程序将其权限管理委派给 <a href="https://tools.ietf.org/html/rfc6749">授权服务器</a>  (例如 Okta 或 Ping Identity) 的情况下,这很方便.  资源服务器可以咨询该授权服务器以授权请求.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://github.com/spring-projects/spring-security/master/">Spring Security 仓库</a> 中提供了 <a href="https://github.com/spring-projects/spring-security/master//boot/oauth2resourceserver-webflux"><strong>JWTs</strong></a> 的完整工作示例.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="webflux-oauth2resourceserver-jwt-minimaldependencies"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-minimaldependencies"></a>24.3.1. JWT 的最小配置</h4>
<div class="paragraph">
<p>大多数资源服务器支持都收集在 <code>spring-security-oauth2-resource-server</code> 中.
但是,<code>spring-security-oauth2-jose</code> 中支持对JWT进行解码和验证,这意味着,对于拥有支持 JWT 编码的 Bearer Token 的工作资源服务器而言,两者都是必需的.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2resourceserver-jwt-minimalconfiguration"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-minimalconfiguration"></a>24.3.2. JWT 的最小配置</h4>
<div class="paragraph">
<p>使用 <a href="https://spring.io/projects/spring-boot">Spring Boot</a> 时,将应用程序配置为资源服务器包括两个基本步骤.  首先,包括所需的依赖,其次,指示授权服务器的位置.</p>
</div>
<div class="sect4">
<h5 id="指定授权服务器-2"><a class="anchor" href="#指定授权服务器-2"></a>指定授权服务器</h5>
<div class="paragraph">
<p>在 Spring Boot 应用程序中,要指定要使用的授权服务器,只需执行以下操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yml" data-lang="yml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com/issuer</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code><a href="https://idp.example.com/issuer" class="bare">idp.example.com/issuer</a></code> 是授权服务器将颁发的JWT令牌的 <code>iss</code> 声明中包含的值.  资源服务器将使用此属性进行进一步的自我配置,发现授权服务器的公钥,然后验证传入的JWT.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
要使用 <code>issuer-uri</code> 属性,还必须确保 <code><a href="https://idp.example.com/issuer/.well-known/openid-configuration" class="bare">idp.example.com/issuer/.well-known/openid-configuration</a></code>, <code><a href="https://idp.example.com/.well-known/openid-configuration/issuer" class="bare">idp.example.com/.well-known/openid-configuration/issuer</a></code>, 或  <code><a href="https://idp.example.com/.well-known/oauth-authorization-server/issuer" class="bare">idp.example.com/.well-known/oauth-authorization-server/issuer</a></code> 是授权服务器支持的端点.
此端点称为 <a href="https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig">Provider Configuration</a>  端点或授权服务器 <a href="https://tools.ietf.org/html/rfc8414#section-3">Authorization Server Metadata</a> 端点.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>就是这样！</p>
</div>
</div>
<div class="sect4">
<h5 id="启动预期-2"><a class="anchor" href="#启动预期-2"></a>启动预期</h5>
<div class="paragraph">
<p>使用此属性和这些依赖时,资源服务器将自动配置自身以验证 JWT 编码的 Bearer 令牌.</p>
</div>
<div class="paragraph">
<p>它通过确定性的启动过程来实现:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>点击提供者配置或授权服务器元数据端点,处理 <code>jwks_url</code> 属性的响应</p>
</li>
<li>
<p>配置验证策略以查询 <code>jwks_url</code> 以获取有效的公共密钥</p>
</li>
<li>
<p>配置验证策略,以根据 <code><a href="https://idp.example.com" class="bare">idp.example.com</a></code> 验证每个JWT的 <code>iss</code> 声明.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>此过程的结果是,授权服务器必须启动并接收请求,才能成功启动资源服务器.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
如果在资源服务器查询授权服务器时授权服务器已关闭 (给出适当的超时) ,则启动将失败.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="运行时预期-3"><a class="anchor" href="#运行时预期-3"></a>运行时预期</h5>
<div class="paragraph">
<p>应用程序启动后,资源服务器将尝试处理任何包含 <code>Authorization: Bearer</code>  头的请求:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-html" data-lang="html">GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要指示了此方案,资源服务器就会尝试根据 Bearer Token 规范处理请求.</p>
</div>
<div class="paragraph">
<p>给定格式正确的JWT,资源服务器将:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在启动期间根据从 <code>jwks_url</code> 端点获取并与 JWTs 请求头匹配的公钥验证其签名</p>
</li>
<li>
<p>验证 JWT 的 <code>exp</code> 和 <code>nbf</code> 时间戳以及 JWT 的 <code>iss</code> 声明,以及</p>
</li>
<li>
<p>将每个范围映射到具有前缀 <code>SCOPE_</code> 的权限.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
当授权服务器提供新的密钥时,Spring Security 将自动旋转用于验证 JWT 令牌的密钥.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>默认情况下,生成的  <code>Authentication#getPrincipal</code> 是 Spring Security <code>Jwt</code> 对象,并且  <code>Authentication#getName</code> 映射到 JWT 的 <code>sub</code> 属性 (如果存在) .</p>
</div>
<div class="paragraph">
<p>从这里,考虑跳到:</p>
</div>
<div class="paragraph">
<p><a href="#webflux-oauth2resourceserver-jwt-jwkseturi">如何在不使资源服务器启动受限于授权服务器的可用性的情况下进行配置</a></p>
</div>
<div class="paragraph">
<p><a href="#webflux-oauth2resourceserver-jwt-sansboot">如何在没有 Spring Boot 的情况下进行配置</a></p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-jwkseturi"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-jwkseturi"></a>直接指定授权服务器JWK设置Uri</h5>
<div class="paragraph">
<p>如果授权服务器不支持任何配置端点,或者如果资源服务器必须能够独立于授权服务器启动,那么还可以提供 <code>jwk-set-uri</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com
          jwk-set-uri: https://idp.example.com/.well-known/jwks.json</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
JWK Set uri 尚未标准化,但通常可以在授权服务器的文档中找到
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>因此,资源服务器在启动时不会对授权服务器执行 ping 操作.  我们仍然指定 <code>issuer-uri</code>,以便 Resource Server 仍然验证传入 JWT 上的 <code>iss</code> 声明.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
此属性也可以直接在<a href="#webflux-oauth2resourceserver-jwt-jwkseturi-dsl">DSL</a>上提供.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-sansboot"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-sansboot"></a>覆盖或替换引导自动配置</h5>
<div class="paragraph">
<p>Spring Boot 代表 Resource Server 生成了两个 <code>@Bean</code>.</p>
</div>
<div class="paragraph">
<p>第一个是 <code>SecurityWebFilterChain</code>,它将应用程序配置为资源服务器. 当包含 <code>spring-security-oauth2-jose</code> 时,此 <code>SecurityWebFilterChain</code> 看起来像:</p>
</div>
<div class="exampleblock">
<div class="title">Example 213. Resource Server SecurityWebFilterChain</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        .authorizeExchange(exchanges -&gt; exchanges
            .anyExchange().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerSpec::jwt)
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果应用程序未暴露 <code>SecurityWebFilterChain</code> Bean,则 Spring Boot 将暴露以上默认的 bean.</p>
</div>
<div class="paragraph">
<p>替换它就像在应用程序中暴露 Bean 一样简单:</p>
</div>
<div class="exampleblock">
<div class="title">Example 214. Replacing SecurityWebFilterChain</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        .authorizeExchange(exchanges -&gt; exchanges
            .pathMatchers("/message/**").hasAuthority("SCOPE_message:read")
            .anyExchange().authenticated()
        )
        .oauth2ResourceServer(oauth2 -&gt; oauth2
            .jwt(withDefaults())
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize("/message/**", hasAuthority("SCOPE_message:read"))
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以上要求 <code>message.read</code> 的范围: 以 <code>/messages/</code> 开头的所有 URL.</p>
</div>
<div class="paragraph">
<p><code>oauth2ResourceServer</code> DSL 上的方法还将覆盖或替换自动配置.</p>
</div>
<div class="paragraph">
<p>例如,第二个 <code>@Bean</code> Spring Boot 创建的是 <code>ReactiveJwtDecoder</code>,它将 String 令牌解码为经过验证的 <code>Jwt</code> 实例:</p>
</div>
<div class="exampleblock">
<div class="title">Example 215. ReactiveJwtDecoder</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return ReactiveJwtDecoders.fromIssuerLocation(issuerUri);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return ReactiveJwtDecoders.fromIssuerLocation(issuerUri)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
调用 <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/jwt/ReactiveJwtDecoders.html#fromIssuerLocation-java.lang.String-">ReactiveJwtDecoders#fromIssuerLocation</a></code> 会调用提供者配置或授权服务器元数据端点,以 扩展 JWK 设置 Uri.  如果该应用程序未暴露 <code>ReactiveJwtDecoder</code> Bean,则 Spring Boot 将暴露上述默认值.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>可以使用 <code>jwkSetUri()</code> 覆盖其配置,也可以使用 <code>decoder()</code> 替换其配置.</p>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-jwkseturi-dsl"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-jwkseturi-dsl"></a>使用 <code>jwkSetUri()</code></h6>
<div class="paragraph">
<p>授权服务器的 JWK 设置 Uri 可以配置为 <a href="#webflux-oauth2resourceserver-jwt-jwkseturi">配置属性</a> ,也可以在 DSL 中提供:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        .authorizeExchange(exchanges -&gt; exchanges
            .anyExchange().authenticated()
        )
        .oauth2ResourceServer(oauth2 -&gt; oauth2
            .jwt(jwt -&gt; jwt
                .jwkSetUri("https://idp.example.com/.well-known/jwks.json")
            )
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt {
                jwkSetUri = "https://idp.example.com/.well-known/jwks.json"
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>jwkSetUri()</code> 优先于任何配置属性.</p>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-decoder-dsl"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-dsl"></a>使用 <code>decoder()</code></h6>
<div class="paragraph">
<p>比 <code>jwkSetUri()</code>  更强大的是 <code>decoder()</code>,它将完全替代 <code>JwtDecoder</code> 的所有 Boot 自动配置:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        .authorizeExchange(exchanges -&gt; exchanges
            .anyExchange().authenticated()
        )
        .oauth2ResourceServer(oauth2 -&gt; oauth2
            .jwt(jwt -&gt; jwt
                .decoder(myCustomDecoder())
            )
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt {
                jwtDecoder = myCustomDecoder()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当需要更深入的配置 (例如<a href="#webflux-oauth2resourceserver-jwt-validation">validation</a>) 时,这非常方便.</p>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-decoder-bean"><a class="anchor" href="#webflux-oauth2resourceserver-decoder-bean"></a>暴露一个 <code>ReactiveJwtDecoder</code> <code>@Bean</code></h6>
<div class="paragraph">
<p>或者,暴露 <code>ReactiveJwtDecoder</code>  <code>@Bean</code> 与 <code>decoder()</code> 具有相同的效果:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withJwkSetUri(jwkSetUri).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return ReactiveJwtDecoders.fromIssuerLocation(issuerUri)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2resourceserver-jwt-decoder-algorithm"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-algorithm"></a>24.3.3. 配置可信算法</h4>
<div class="paragraph">
<p>默认情况下,<code>NimbusReactiveJwtDecoder</code> 以及资源服务器将仅使用RS256信任和验证令牌.</p>
</div>
<div class="paragraph">
<p>您可以通过<a href="#webflux-oauth2resourceserver-jwt-boot-algorithm">Spring Boot</a> 或  <a href="#webflux-oauth2resourceserver-jwt-decoder-builder"><code>NimbusJwtDecoder</code> 构建器</a>对此进行自定义.</p>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-boot-algorithm"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-boot-algorithm"></a>通过 Spring Boot</h5>
<div class="paragraph">
<p>设置算法的最简单方法是作为属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jws-algorithm: RS512
          jwk-set-uri: https://idp.example.org/.well-known/jwks.json</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-decoder-builder"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-builder"></a>使用 Builder</h5>
<div class="paragraph">
<p>但是,为了获得更大的功能,我们可以使用 <code>NimbusReactiveJwtDecoder</code> 附带的构建器:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>多次调用 <code>jwsAlgorithm</code> 会将 <code>NimbusReactiveJwtDecoder</code> 配置为信任多个算法,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或者,您可以调用 <code>jwsAlgorithms</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms(algorithms -&gt; {
                    algorithms.add(RS512);
                    algorithms.add(ES512);
            }).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms {
                it.add(RS512)
                it.add(ES512)
            }
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-decoder-public-key"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-public-key"></a>信任单个非对称密钥</h5>
<div class="paragraph">
<p>比使用 JWK Set 端点备份资源服务器更简单的方法是对RSA公钥进行硬编码. 可以通过<a href="#oauth2resourceserver-jwt-decoder-public-key-boot">Spring Boot</a> 或<a href="#oauth2resourceserver-jwt-decoder-public-key-builder">使用 Builder</a>提供公共密钥.</p>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-decoder-public-key-boot"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-public-key-boot"></a>通过 Spring Boot</h6>
<div class="paragraph">
<p>通过 Spring Boot 指定密钥非常简单.
密钥的位置可以这样指定:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          public-key-location: classpath:my-key.pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者,为了进行更复杂的查找,可以对 <code>RsaKeyConversionServicePostProcessor</code> 进行后置处理:</p>
</div>
<div class="exampleblock">
<div class="title">Example 216. BeanFactoryPostProcessor</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
BeanFactoryPostProcessor conversionServiceCustomizer() {
    return beanFactory -&gt;
        beanFactory.getBean(RsaKeyConversionServicePostProcessor.class)
                .setResourceLoader(new CustomResourceLoader());
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun conversionServiceCustomizer(): BeanFactoryPostProcessor {
    return BeanFactoryPostProcessor { beanFactory: ConfigurableListableBeanFactory -&gt;
        beanFactory.getBean&lt;RsaKeyConversionServicePostProcessor&gt;()
                .setResourceLoader(CustomResourceLoader())
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>指定密钥的位置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">key.location: hfds://my-key.pub</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后自动装配值:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Value("${key.location}")
RSAPublicKey key;
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Value("\${key.location}")
val key: RSAPublicKey? = null</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-decoder-public-key-builder"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-public-key-builder"></a>使用 Builder</h6>
<div class="paragraph">
<p>要直接连接 <code>RSAPublicKey</code>,只需使用适当的 <code>NimbusJwtDecoder</code> builder,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withPublicKey(this.key).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withPublicKey(key).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-decoder-secret-key"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-decoder-secret-key"></a>信任单个对称密钥</h5>
<div class="paragraph">
<p>使用单个对称密钥也很简单. 您可以简单地加载 <code>SecretKey</code> 并使用适当的 <code>NimbusJwtDecoder</code> 构建器,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ReactiveJwtDecoder jwtDecoder() {
    return NimbusReactiveJwtDecoder.withSecretKey(this.key).build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    return NimbusReactiveJwtDecoder.withSecretKey(this.key).build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-authorization"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-authorization"></a>配置授权</h5>
<div class="paragraph">
<p>从 OAuth 2.0 授权服务器发出的JWT通常具有 <code>scope</code> 或 <code>scp</code> 属性,指示其被授予的作用域 (或权限) ,例如:</p>
</div>
<div class="paragraph">
<p><code>{ &#8230;&#8203;, "scope" : "messages contacts"}</code></p>
</div>
<div class="paragraph">
<p>在这种情况下,资源服务器将尝试将这些作用域强制为已授予权限的列表,并为每个作用域添加字符串 "SCOPE_" 作为前缀.</p>
</div>
<div class="paragraph">
<p>这意味着为了保护具有从 JWT 扩展的作用域的端点或方法,相应的表达式应包含以下前缀:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        .authorizeExchange(exchanges -&gt; exchanges
            .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
            .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
            .anyExchange().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerSpec::jwt);
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
            authorize("/messages/**", hasAuthority("SCOPE_messages"))
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或类似地具有方法安全性:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasAuthority('SCOPE_messages')")
public Flux&lt;Message&gt; getMessages(...) {}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@PreAuthorize("hasAuthority('SCOPE_messages')")
fun getMessages(): Flux&lt;Message&gt; { }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-authorization-extraction"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-authorization-extraction"></a>手动提取权限</h6>
<div class="paragraph">
<p>但是,在许多情况下,此默认设置不足.
例如,某些授权服务器不使用 <code>scope</code> 属性,而是使用自己的自定义属性.
或者,在其他时候,资源服务器可能需要将属性或属性组成调整为内部化的权限.</p>
</div>
<div class="paragraph">
<p>为此,DSL暴露了 <code>jwtAuthenticationConverter()</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        .authorizeExchange(exchanges -&gt; exchanges
            .anyExchange().authenticated()
        )
        .oauth2ResourceServer(oauth2 -&gt; oauth2
            .jwt(jwt -&gt; jwt
                .jwtAuthenticationConverter(grantedAuthoritiesExtractor())
            )
        );
    return http.build();
}

Converter&lt;Jwt, Mono&lt;AbstractAuthenticationToken&gt;&gt; grantedAuthoritiesExtractor() {
    JwtAuthenticationConverter jwtAuthenticationConverter =
            new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter
            (new GrantedAuthoritiesExtractor());
    return new ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            jwt {
                jwtAuthenticationConverter = grantedAuthoritiesExtractor()
            }
        }
    }
}

fun grantedAuthoritiesExtractor(): Converter&lt;Jwt, Mono&lt;AbstractAuthenticationToken&gt;&gt; {
    val jwtAuthenticationConverter = JwtAuthenticationConverter()
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(GrantedAuthoritiesExtractor())
    return ReactiveJwtAuthenticationConverterAdapter(jwtAuthenticationConverter)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>负责将 <code>Jwt</code> 转换为 <code>Authentication</code>. 作为其配置的一部分,我们可以提供一个辅助转换器,从 <code>Jwt</code> 到授权的 <code>Collection</code>.</p>
</div>
<div class="paragraph">
<p>最终的转换器可能类似于下面的 <code>GrantedAuthoritiesExtractor</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">static class GrantedAuthoritiesExtractor
        implements Converter&lt;Jwt, Collection&lt;GrantedAuthority&gt;&gt; {

    public Collection&lt;GrantedAuthority&gt; convert(Jwt jwt) {
        Collection&lt;?&gt; authorities = (Collection&lt;?&gt;)
                jwt.getClaims().getOrDefault("mycustomclaim", Collections.emptyList());

        return authorities.stream()
                .map(Object::toString)
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">internal class GrantedAuthoritiesExtractor : Converter&lt;Jwt, Collection&lt;GrantedAuthority&gt;&gt; {
    override fun convert(jwt: Jwt): Collection&lt;GrantedAuthority&gt; {
        val authorities: List&lt;Any&gt; = jwt.claims
                .getOrDefault("mycustomclaim", emptyList&lt;Any&gt;()) as List&lt;Any&gt;
        return authorities
                .map { it.toString() }
                .map { SimpleGrantedAuthority(it) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>为了获得更大的灵活性,DSL 支持使用实现  <code>Converter&lt;Jwt, Mono&lt;AbstractAuthenticationToken&gt;&gt;</code> 的任何类完全替换该转换器:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">static class CustomAuthenticationConverter implements Converter&lt;Jwt, Mono&lt;AbstractAuthenticationToken&gt;&gt; {
    public AbstractAuthenticationToken convert(Jwt jwt) {
        return Mono.just(jwt).map(this::doConversion);
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">internal class CustomAuthenticationConverter : Converter&lt;Jwt, Mono&lt;AbstractAuthenticationToken&gt;&gt; {
    override fun convert(jwt: Jwt): Mono&lt;AbstractAuthenticationToken&gt; {
        return Mono.just(jwt).map(this::doConversion)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-jwt-validation"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-validation"></a>配置验证</h5>
<div class="paragraph">
<p>使用 <a href="#webflux-oauth2resourceserver-jwt-minimalconfiguration">Spring Boot 最小配置</a>,  (指示授权服务器的 issuer uri) ,Resource Server将默认验证 <code>iss</code> 声明以及 <code>exp</code> 和 <code>nbf</code> 时间戳声明.</p>
</div>
<div class="paragraph">
<p>在需要自定义验证的情况下,资源服务器附带两个标准验证器,并且还接受自定义 <code>OAuth2TokenValidator</code> 实例.</p>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-jwt-validation-clockskew"><a class="anchor" href="#webflux-oauth2resourceserver-jwt-validation-clockskew"></a>自定义时间戳验证</h6>
<div class="paragraph">
<p>JWT 通常具有有效期窗口,该窗口的开始在 <code>nbf</code> 声明中指示,而结束在 <code>exp</code> 声明中指示.</p>
</div>
<div class="paragraph">
<p>但是,每台服务器都会经历时钟漂移,这可能导致令牌在一个服务器上已经过期,而在另一台服务器上没有过期. 随着分布式系统中服务器数量的增加,这可能会导致某些实现上的不良反应.</p>
</div>
<div class="paragraph">
<p>资源服务器使用 <code>JwtTimestampValidator</code> 验证令牌的有效性窗口,并且可以将它配置为 <code>ClockSkew</code> 来缓解上述问题:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
     NimbusReactiveJwtDecoder jwtDecoder = (NimbusReactiveJwtDecoder)
             ReactiveJwtDecoders.fromIssuerLocation(issuerUri);

     OAuth2TokenValidator&lt;Jwt&gt; withClockSkew = new DelegatingOAuth2TokenValidator&lt;&gt;(
            new JwtTimestampValidator(Duration.ofSeconds(60)),
            new IssuerValidator(issuerUri));

     jwtDecoder.setJwtValidator(withClockSkew);

     return jwtDecoder;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    val jwtDecoder = ReactiveJwtDecoders.fromIssuerLocation(issuerUri) as NimbusReactiveJwtDecoder
    val withClockSkew: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(
            JwtTimestampValidator(Duration.ofSeconds(60)),
            JwtIssuerValidator(issuerUri))
    jwtDecoder.setJwtValidator(withClockSkew)
    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
默认情况下,资源服务器将时钟偏差配置为 30 秒.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-validation-custom"><a class="anchor" href="#webflux-oauth2resourceserver-validation-custom"></a>配置自定义验证器</h6>
<div class="paragraph">
<p>使用 <code>OAuth2TokenValidator</code> API 为 <code>aud</code> 声明添加检查很简单:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class AudienceValidator implements OAuth2TokenValidator&lt;Jwt&gt; {
    OAuth2Error error = new OAuth2Error("invalid_token", "The required audience is missing", null);

    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        if (jwt.getAudience().contains("messaging")) {
            return OAuth2TokenValidatorResult.success();
        } else {
            return OAuth2TokenValidatorResult.failure(error);
        }
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class AudienceValidator : OAuth2TokenValidator&lt;Jwt&gt; {
    var error: OAuth2Error = OAuth2Error("invalid_token", "The required audience is missing", null)
    override fun validate(jwt: Jwt): OAuth2TokenValidatorResult {
        return if (jwt.audience.contains("messaging")) {
            OAuth2TokenValidatorResult.success()
        } else {
            OAuth2TokenValidatorResult.failure(error)
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>然后,要添加到资源服务器中,只需指定 <code>ReactiveJwtDecoder</code> 实例即可:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
    NimbusReactiveJwtDecoder jwtDecoder = (NimbusReactiveJwtDecoder)
            ReactiveJwtDecoders.fromIssuerLocation(issuerUri);

    OAuth2TokenValidator&lt;Jwt&gt; audienceValidator = new AudienceValidator();
    OAuth2TokenValidator&lt;Jwt&gt; withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);
    OAuth2TokenValidator&lt;Jwt&gt; withAudience = new DelegatingOAuth2TokenValidator&lt;&gt;(withIssuer, audienceValidator);

    jwtDecoder.setJwtValidator(withAudience);

    return jwtDecoder;
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun jwtDecoder(): ReactiveJwtDecoder {
    val jwtDecoder = ReactiveJwtDecoders.fromIssuerLocation(issuerUri) as NimbusReactiveJwtDecoder
    val audienceValidator: OAuth2TokenValidator&lt;Jwt&gt; = AudienceValidator()
    val withIssuer: OAuth2TokenValidator&lt;Jwt&gt; = JwtValidators.createDefaultWithIssuer(issuerUri)
    val withAudience: OAuth2TokenValidator&lt;Jwt&gt; = DelegatingOAuth2TokenValidator(withIssuer, audienceValidator)
    jwtDecoder.setJwtValidator(withAudience)
    return jwtDecoder
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-minimaldependencies"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-minimaldependencies"></a>Introspection 最小配置</h5>
<div class="paragraph">
<p>如 <a href="#webflux-oauth2resourceserver-jwt-minimaldependencies">JWT 的最小配置</a> 中所述， 大多数资源服务器支持都在 <code>spring-security-oauth2-resource-server</code> 中. 但是， 除非提供了自定义的 <a href="#webflux-oauth2resourceserver-opaque-introspector-bean"><code>ReactiveOpaqueTokenIntrospector</code></a>,否则资源服务器将回退到 <code>ReactiveOpaqueTokenIntrospector</code>.  这意味着 <code>spring-security-oauth2-resource-server</code> 和 <code>oauth2-oidc-sdk</code> 都是必需的， 以使支持不透明承载令牌的最小资源服务器正常工作.  为了确定 <code>oauth2-oidc-sdk</code> 的正确版本， 请参考 <code>spring-security-oauth2-resource-server</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-minimalconfiguration"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-minimalconfiguration"></a>Introspection 最小配置</h5>
<div class="paragraph">
<p>通常,opaque token 可以通过授权服务器托管的 <a href="https://tools.ietf.org/html/rfc7662">OAuth 2.0 Introspection Endpoint</a>进行验证. 当需要撤销时,这可能很方便.</p>
</div>
<div class="paragraph">
<p>使用 <a href="https://spring.io/projects/spring-boot">Spring Boot</a> 时,将应用程序配置为使用内省的资源服务器包括两个基本步骤. 首先,包括所需的依赖性,其次,指示内省端点详细信息.</p>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-opaque-introspectionuri"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-introspectionuri"></a>指定授权服务器</h6>
<div class="paragraph">
<p>要指定内省端点的位置,只需执行以下操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">security:
  oauth2:
    resourceserver:
      opaque-token:
        introspection-uri: https://idp.example.com/introspect
        client-id: client
        client-secret: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code><a href="https://idp.example.com/introspect" class="bare">idp.example.com/introspect</a></code> 是授权服务器托管的内省端点,而 <code>client-id</code> 和 <code>client-secret</code> 是击中该端点所需的凭据.</p>
</div>
<div class="paragraph">
<p>资源服务器将使用这些属性进一步进行自我配置,并随后验证传入的 JWT.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
使用内省时,授权服务器的字眼就是法律.  如果授权服务器响应令牌是有效的,那么令牌是有效的.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>就是这样！</p>
</div>
</div>
<div class="sect5">
<h6 id="启动时预期-2"><a class="anchor" href="#启动时预期-2"></a>启动时预期</h6>
<div class="paragraph">
<p>使用此属性和这些依赖时,资源服务器将自动配置自身以验证不透明承载令牌.</p>
</div>
<div class="paragraph">
<p>该启动过程比 JWT 的启动过程简单得多,因为不需要发现端点,也不需要添加其他验证规则.</p>
</div>
</div>
<div class="sect5">
<h6 id="运行时预期-4"><a class="anchor" href="#运行时预期-4"></a>运行时预期</h6>
<div class="paragraph">
<p>应用程序启动后,资源服务器将尝试处理任何包含 <code>Authorization: Bearer</code> 头的请求:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-http" data-lang="http">GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this</code></pre>
</div>
</div>
<div class="paragraph">
<p>只要指示了此方案,资源服务器就会尝试根据 Bearer Token 规范处理请求.</p>
</div>
<div class="paragraph">
<p>给定一个不透明的令牌,资源服务器将</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用提供的凭据和令牌查询提供的内省端点</p>
</li>
<li>
<p>检查响应是否为  <code>{ 'active' : true }</code>  属性</p>
</li>
<li>
<p>将每个范围映射到具有前缀 <code>SCOPE_</code> 的权限</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>默认情况下,生成的  <code>Authentication#getPrincipal</code> 是Spring Security   <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/core/OAuth2AuthenticatedPrincipal.html">OAuth2AuthenticatedPrincipal</a></code>  对象,并且 <code>Authentication#getName</code> 映射到令牌的 <code>sub</code> 属性 (如果存在) .</p>
</div>
<div class="paragraph">
<p>从这里,您可能要跳转到:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="#webflux-oauth2resourceserver-opaque-attributes">查找身份验证后的属性</a></p>
</li>
<li>
<p><a href="#webflux-oauth2resourceserver-opaque-authorization-extraction">手动提取权限</a></p>
</li>
<li>
<p><a href="#webflux-oauth2resourceserver-opaque-jwt-introspector">对 JWT 使用内省</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-attributes"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-attributes"></a>查找身份验证后的属性</h5>
<div class="paragraph">
<p>令牌通过身份验证后,将在 <code>SecurityContext</code> 中设置 <code>BearerTokenAuthentication</code> 的实例.</p>
</div>
<div class="paragraph">
<p>这意味着在配置中使用 <code>@EnableWebFlux</code> 时,它可以在 <code>@Controller</code> 方法中使用:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/foo")
public Mono&lt;String&gt; foo(BearerTokenAuthentication authentication) {
    return Mono.just(authentication.getTokenAttributes().get("sub") + " is the subject");
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/foo")
fun foo(authentication: BearerTokenAuthentication): Mono&lt;String&gt; {
    return Mono.just(authentication.tokenAttributes["sub"].toString() + " is the subject")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>由于 <code>BearerTokenAuthentication</code> 拥有 <code>OAuth2AuthenticatedPrincipal</code>,这也意味着它也可用于控制器方法:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/foo")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OAuth2AuthenticatedPrincipal principal) {
    return Mono.just(principal.getAttribute("sub") + " is the subject");
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/foo")
fun foo(@AuthenticationPrincipal principal: OAuth2AuthenticatedPrincipal): Mono&lt;String&gt; {
    return Mono.just(principal.getAttribute&lt;Any&gt;("sub").toString() + " is the subject")
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="通过-spel-查找属性-2"><a class="anchor" href="#通过-spel-查找属性-2"></a>通过 SpEL 查找属性</h6>
<div class="paragraph">
<p>当然,这也意味着可以通过 SpEL 访问属性.</p>
</div>
<div class="paragraph">
<p>例如,如果使用 <code>@EnableReactiveMethodSecurity</code> 以便可以使用 <code>@PreAuthorize</code> 注解,则可以执行以下操作:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("principal?.attributes['sub'] == 'foo'")
public Mono&lt;String&gt; forFoosEyesOnly() {
    return Mono.just("foo");
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@PreAuthorize("principal.attributes['sub'] == 'foo'")
fun forFoosEyesOnly(): Mono&lt;String&gt; {
    return Mono.just("foo")
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-sansboot"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-sansboot"></a>覆盖或替换自动配置</h5>
<div class="paragraph">
<p>Spring Boot 代表 Resource Server 生成了两个 <code>@Bean</code>.</p>
</div>
<div class="paragraph">
<p>第一个是将应用程序配置为资源服务器的 <code>SecurityWebFilterChain</code>. 使用 Opaque Token 时,此 <code>SecurityWebFilterChain</code> 如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
    http
        .authorizeExchange(exchanges -&gt; exchanges
            .anyExchange().authenticated()
        )
        .oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::opaqueToken)
    return http.build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果应用程序未暴露 <code>SecurityWebFilterChain</code> Bean,则Spring Boot将暴露上述默认值.</p>
</div>
<div class="paragraph">
<p>替换它就像在应用程序中暴露 Bean 一样简单:</p>
</div>
<div class="exampleblock">
<div class="title">Example 217. Replacing SecurityWebFilterChain</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebFluxSecurity
public class MyCustomSecurityConfiguration {
    @Bean
    SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http
            .authorizeExchange(exchanges -&gt; exchanges
                .pathMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspector(myIntrospector())
                )
            );
        return http.build();
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize("/messages/**", hasAuthority("SCOPE_message:read"))
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken {
                introspector = myIntrospector()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>以上要求 <code>message:read</code> 的范围: 以 <code>/messages/</code> 开头的所有URL.</p>
</div>
<div class="paragraph">
<p><code>oauth2ResourceServer</code> DSL 上的方法还将覆盖或替换自动配置.</p>
</div>
<div class="paragraph">
<p>例如,第二个 <code>@Bean</code> Spring Boot 创建的是一个 <code>ReactiveOpaqueTokenIntrospector</code>,它将 <code>String</code> 令牌解码为 <code>OAuth2AuthenticatedPrincipal</code> 的经过验证的实例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ReactiveOpaqueTokenIntrospector introspector() {
    return new NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun introspector(): ReactiveOpaqueTokenIntrospector {
    return NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果应用程序未暴露 <code>ReactiveOpaqueTokenIntrospector</code> Bean,则 Spring Boot 将暴露以上默认的 bean.</p>
</div>
<div class="paragraph">
<p>可以使用 <code>introspectionUri()</code> 和 <code>introspectionClientCredentials()</code> 覆盖其配置,也可以使用 <code>introspector()</code> 替换其配置.</p>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-opaque-introspectionuri-dsl"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-introspectionuri-dsl"></a>使用 <code>introspectionUri()</code></h6>
<div class="paragraph">
<p>授权服务器的 Introspection Uri 可以配置为<a href="#webflux-oauth2resourceserver-opaque-introspectionuri">,配置属性</a>,也可以在 DSL 中提供:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebFluxSecurity
public class DirectlyConfiguredIntrospectionUri {
    @Bean
    SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http
            .authorizeExchange(exchanges -&gt; exchanges
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspectionUri("https://idp.example.com/introspect")
                    .introspectionClientCredentials("client", "secret")
                )
            );
        return http.build();
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken {
                introspectionUri = "https://idp.example.com/introspect"
                introspectionClientCredentials("client", "secret")
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>使用 <code>introspectionUri()</code> 优先于任何配置属性.</p>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-opaque-introspector-dsl"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-introspector-dsl"></a>使用 <code>introspector()</code></h6>
<div class="paragraph">
<p>比 <code>introspectionUri()</code> 更强大的是 <code>introspector()</code> ,它将完全替代 <code>ReactiveOpaqueTokenIntrospector</code> 的所有Boot 自动配置:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebFluxSecurity
public class DirectlyConfiguredIntrospector {
    @Bean
    SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http
            .authorizeExchange(exchanges -&gt; exchanges
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(oauth2 -&gt; oauth2
                .opaqueToken(opaqueToken -&gt; opaqueToken
                    .introspector(myCustomIntrospector())
                )
            );
        return http.build();
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken {
                introspector = myCustomIntrospector()
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当需要更深入的配置 (例如<a href="#webflux-oauth2resourceserver-opaque-authorization-extraction">权限映射</a> 或 <a href="#webflux-oauth2resourceserver-opaque-jwt-introspector">JWT 吊销</a>时,这很方便.</p>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-opaque-introspector-bean"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-introspector-bean"></a>暴露 <code>ReactiveOpaqueTokenIntrospector</code> <code>@Bean</code></h6>
<div class="paragraph">
<p>或者,暴露 <code>ReactiveOpaqueTokenIntrospector</code>  <code>@Bean</code> 与 <code>introspector()</code> 具有相同的效果:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ReactiveOpaqueTokenIntrospector introspector() {
    return new NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun introspector(): ReactiveOpaqueTokenIntrospector {
    return NimbusReactiveOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret)
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-authorization"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-authorization"></a>配置授权</h5>
<div class="paragraph">
<p>OAuth 2.0 内省端点通常会返回一个 <code>scope</code> 属性,指示其被授予的范围 (或权限) ,例如:</p>
</div>
<div class="paragraph">
<p><code>{ &#8230;&#8203;, "scope" : "messages contacts"}</code></p>
</div>
<div class="paragraph">
<p>在这种情况下,资源服务器将尝试将这些作用域强制为已授予权限的列表,并为每个作用域添加字符串 "SCOPE_" 作为前缀.</p>
</div>
<div class="paragraph">
<p>这意味着要保护具有不透明令牌 扩展 范围的端点或方法,相应的表达式应包含以下前缀:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebFluxSecurity
public class MappedAuthorities {
    @Bean
    SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http
            .authorizeExchange(exchange -&gt; exchange
                .pathMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .pathMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyExchange().authenticated()
            )
            .oauth2ResourceServer(ServerHttpSecurity.OAuth2ResourceServerSpec::opaqueToken);
        return http.build();
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
    return http {
        authorizeExchange {
            authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
            authorize("/messages/**", hasAuthority("SCOPE_messages"))
            authorize(anyExchange, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken { }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>或类似地具有方法安全性:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@PreAuthorize("hasAuthority('SCOPE_messages')")
public Flux&lt;Message&gt; getMessages(...) {}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@PreAuthorize("hasAuthority('SCOPE_messages')")
fun getMessages(): Flux&lt;Message&gt; { }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect5">
<h6 id="webflux-oauth2resourceserver-opaque-authorization-extraction"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-authorization-extraction"></a>手动提取权限</h6>
<div class="paragraph">
<p>默认情况下,Opaque Token 支持将从内省响应中提取范围声明,并将其解析为各个 <code>GrantedAuthority</code> 实例.</p>
</div>
<div class="paragraph">
<p>例如,如果内省响应为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
    "active" : true,
    "scope" : "message:read message:write"
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后,资源服务器将生成具有两个权限的  <code>Authentication</code> ,一个权限用于  <code>message:read</code> ,另一个权限用于 <code>message:write</code>.</p>
</div>
<div class="paragraph">
<p>当然,这可以使用自定义的 <code>ReactiveOpaqueTokenIntrospector</code> 进行自定义,该 <code>ReactiveOpaqueTokenIntrospector</code> 查看属性集并以自己的方式进行转换:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class CustomAuthoritiesOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {
    private ReactiveOpaqueTokenIntrospector delegate =
            new NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");

    public Mono&lt;OAuth2AuthenticatedPrincipal&gt; introspect(String token) {
        return this.delegate.introspect(token)
                .map(principal -&gt; new DefaultOAuth2AuthenticatedPrincipal(
                        principal.getName(), principal.getAttributes(), extractAuthorities(principal)));
    }

    private Collection&lt;GrantedAuthority&gt; extractAuthorities(OAuth2AuthenticatedPrincipal principal) {
        List&lt;String&gt; scopes = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE);
        return scopes.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class CustomAuthoritiesOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {
    private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    override fun introspect(token: String): Mono&lt;OAuth2AuthenticatedPrincipal&gt; {
        return delegate.introspect(token)
                .map { principal: OAuth2AuthenticatedPrincipal -&gt;
                    DefaultOAuth2AuthenticatedPrincipal(
                            principal.name, principal.attributes, extractAuthorities(principal))
                }
    }

    private fun extractAuthorities(principal: OAuth2AuthenticatedPrincipal): Collection&lt;GrantedAuthority&gt; {
        val scopes = principal.getAttribute&lt;List&lt;String&gt;&gt;(OAuth2IntrospectionClaimNames.SCOPE)
        return scopes
                .map { SimpleGrantedAuthority(it) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此后,可以通过将其暴露为 <code>@Bean</code> 来简单地配置此自定义内省器:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ReactiveOpaqueTokenIntrospector introspector() {
    return new CustomAuthoritiesOpaqueTokenIntrospector();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun introspector(): ReactiveOpaqueTokenIntrospector {
    return CustomAuthoritiesOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-jwt-introspector"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-jwt-introspector"></a>对 JWT 使用内省</h5>
<div class="paragraph">
<p>一个常见的问题是内省是否与 JWT 兼容.
Spring Security 的 Opaque 令牌支持被设计为不关心令牌的格式-它将很乐意将任何令牌传递给提供的内省端点.</p>
</div>
<div class="paragraph">
<p>因此,假设您有一个要求,如果 JWT 被吊销,则要求您在每个请求中与授权服务器进行核对.</p>
</div>
<div class="paragraph">
<p>即使您为令牌使用 JWT 格式,您的验证方法也是内省的,这意味着您想要执行以下操作:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        opaque-token:
          introspection-uri: https://idp.example.org/introspection
          client-id: client
          client-secret: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,得到的  <code>Authentication</code> 将是 <code>BearerTokenAuthentication</code>.
相应的 <code>OAuth2AuthenticatedPrincipal</code> 中的任何属性将是内省端点返回的任何属性.</p>
</div>
<div class="paragraph">
<p>但是,可以说,奇怪的是,内省端点仅返回令牌是否处于 active 状态.
怎么办?</p>
</div>
<div class="paragraph">
<p>在这种情况下,您可以创建一个自定义的 <code>ReactiveOpaqueTokenIntrospector</code>,它仍然会命中端点,但是随后更新返回的主体以将JWT声明作为属性:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class JwtOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {
    private ReactiveOpaqueTokenIntrospector delegate =
            new NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private ReactiveJwtDecoder jwtDecoder = new NimbusReactiveJwtDecoder(new ParseOnlyJWTProcessor());

    public Mono&lt;OAuth2AuthenticatedPrincipal&gt; introspect(String token) {
        return this.delegate.introspect(token)
                .flatMap(principal -&gt; this.jwtDecoder.decode(token))
                .map(jwt -&gt; new DefaultOAuth2AuthenticatedPrincipal(jwt.getClaims(), NO_AUTHORITIES));
    }

    private static class ParseOnlyJWTProcessor implements Converter&lt;JWT, Mono&lt;JWTClaimsSet&gt;&gt; {
        public Mono&lt;JWTClaimsSet&gt; convert(JWT jwt) {
            try {
                return Mono.just(jwt.getJWTClaimsSet());
            } catch (Exception ex) {
                return Mono.error(ex);
            }
        }
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class JwtOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {
    private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val jwtDecoder: ReactiveJwtDecoder = NimbusReactiveJwtDecoder(ParseOnlyJWTProcessor())
    override fun introspect(token: String): Mono&lt;OAuth2AuthenticatedPrincipal&gt; {
        return delegate.introspect(token)
                .flatMap { jwtDecoder.decode(token) }
                .map { jwt: Jwt -&gt; DefaultOAuth2AuthenticatedPrincipal(jwt.claims, NO_AUTHORITIES) }
    }

    private class ParseOnlyJWTProcessor : Converter&lt;JWT, Mono&lt;JWTClaimsSet&gt;&gt; {
        override fun convert(jwt: JWT): Mono&lt;JWTClaimsSet&gt; {
            return try {
                Mono.just(jwt.jwtClaimsSet)
            } catch (e: Exception) {
                Mono.error(e)
            }
        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>此后,可以通过将其暴露为 <code>@Bean</code> 来简单地配置此自定义内省器:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public ReactiveOpaqueTokenIntrospector introspector() {
    return new JwtOpaqueTokenIntropsector();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun introspector(): ReactiveOpaqueTokenIntrospector {
    return JwtOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-oauth2resourceserver-opaque-userinfo"><a class="anchor" href="#webflux-oauth2resourceserver-opaque-userinfo"></a>调用 <code>/userinfo</code> 端点</h5>
<div class="paragraph">
<p>一般来说,资源服务器不在乎底层用户,而在乎已授予的权限.</p>
</div>
<div class="paragraph">
<p>就是说,有时将授权声明绑定到用户可能很有价值.</p>
</div>
<div class="paragraph">
<p>如果应用程序还使用 <code>spring-security-oauth2-client</code> 并设置了适当的 <code>ClientRegistrationRepository</code>,则使用自定义的 <code>OpaqueTokenIntrospector</code> 非常简单.</p>
</div>
<div class="paragraph">
<p>下面的实现实现了三件事:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>委托内省端点确认令牌的有效性</p>
</li>
<li>
<p>查找与 <code>/userinfo</code> 端点关联的适当的客户端注册</p>
</li>
<li>
<p>调用并返回来自 <code>/userinfo</code> 端点的响应</p>
</li>
</ul>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class UserInfoOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {
    private final ReactiveOpaqueTokenIntrospector delegate =
            new NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final ReactiveOAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; oauth2UserService =
            new DefaultReactiveOAuth2UserService();

    private final ReactiveClientRegistrationRepository repository;

    // ... constructor

    @Override
    public Mono&lt;OAuth2AuthenticatedPrincipal&gt; introspect(String token) {
        return Mono.zip(this.delegate.introspect(token), this.repository.findByRegistrationId("registration-id"))
                .map(t -&gt; {
                    OAuth2AuthenticatedPrincipal authorized = t.getT1();
                    ClientRegistration clientRegistration = t.getT2();
                    Instant issuedAt = authorized.getAttribute(ISSUED_AT);
                    Instant expiresAt = authorized.getAttribute(OAuth2IntrospectionClaimNames.EXPIRES_AT);
                    OAuth2AccessToken accessToken = new OAuth2AccessToken(BEARER, token, issuedAt, expiresAt);
                    return new OAuth2UserRequest(clientRegistration, accessToken);
                })
                .flatMap(this.oauth2UserService::loadUser);
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class UserInfoOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {
    private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val oauth2UserService: ReactiveOAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; = DefaultReactiveOAuth2UserService()
    private val repository: ReactiveClientRegistrationRepository? = null

    // ... constructor
    override fun introspect(token: String?): Mono&lt;OAuth2AuthenticatedPrincipal&gt; {
        return Mono.zip&lt;OAuth2AuthenticatedPrincipal, ClientRegistration&gt;(delegate.introspect(token), repository!!.findByRegistrationId("registration-id"))
                .map&lt;OAuth2UserRequest&gt; { t: Tuple2&lt;OAuth2AuthenticatedPrincipal, ClientRegistration&gt; -&gt;
                    val authorized = t.t1
                    val clientRegistration = t.t2
                    val issuedAt: Instant? = authorized.getAttribute(ISSUED_AT)
                    val expiresAt: Instant? = authorized.getAttribute(OAuth2IntrospectionClaimNames.EXPIRES_AT)
                    val accessToken = OAuth2AccessToken(BEARER, token, issuedAt, expiresAt)
                    OAuth2UserRequest(clientRegistration, accessToken)
                }
                .flatMap { userRequest: OAuth2UserRequest -&gt; oauth2UserService.loadUser(userRequest) }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果您不使用 <code>spring-security-oauth2-client</code>,它仍然非常简单.  您只需要使用您自己的 <code>WebClient</code> 实例调用 <code>/userinfo</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">public class UserInfoOpaqueTokenIntrospector implements ReactiveOpaqueTokenIntrospector {
    private final ReactiveOpaqueTokenIntrospector delegate =
            new NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final WebClient rest = WebClient.create();

    @Override
    public Mono&lt;OAuth2AuthenticatedPrincipal&gt; introspect(String token) {
        return this.delegate.introspect(token)
                .map(this::makeUserInfoRequest);
    }
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">class UserInfoOpaqueTokenIntrospector : ReactiveOpaqueTokenIntrospector {
    private val delegate: ReactiveOpaqueTokenIntrospector = NimbusReactiveOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val rest: WebClient = WebClient.create()

    override fun introspect(token: String): Mono&lt;OAuth2AuthenticatedPrincipal&gt; {
        return delegate.introspect(token)
                .map(this::makeUserInfoRequest)
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>无论哪种方式,在创建 <code>ReactiveOpaqueTokenIntrospector</code> 之后,都应该将其发布为 <code>@Bean</code> 来覆盖默认值:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ReactiveOpaqueTokenIntrospector introspector() {
    return new UserInfoOpaqueTokenIntrospector();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun introspector(): ReactiveOpaqueTokenIntrospector {
    return UserInfoOpaqueTokenIntrospector()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2resourceserver-multitenancy"><a class="anchor" href="#webflux-oauth2resourceserver-multitenancy"></a>24.3.4. 多租户</h4>
<div class="paragraph">
<p>当存在多种验证承载令牌的策略时,资源服务器被视为多租户,并以某些租户标识符为关键字.</p>
</div>
<div class="paragraph">
<p>例如,您的资源服务器可能接受来自两个不同授权服务器的承载令牌.  或者,您的授权服务器可能代表多个发行者.</p>
</div>
<div class="paragraph">
<p>在每种情况下,都需要完成两件事,并且要与选择的方式进行权衡:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>解析租户</p>
</li>
<li>
<p>传播租户</p>
</li>
</ol>
</div>
<div class="sect4">
<h5 id="通过-claim-解析租户-2"><a class="anchor" href="#通过-claim-解析租户-2"></a>通过 Claim 解析租户</h5>
<div class="paragraph">
<p>区分租户的一种方法是通过 issuer claim.  由于签发者的声明伴随着已签名的 JWT,因此可以通过 <code>JwtIssuerReactiveAuthenticationManagerResolver</code> 来完成,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">JwtIssuerReactiveAuthenticationManagerResolver authenticationManagerResolver = new JwtIssuerReactiveAuthenticationManagerResolver
    ("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo");

http
    .authorizeExchange(exchanges -&gt; exchanges
        .anyExchange().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val customAuthenticationManagerResolver = JwtIssuerReactiveAuthenticationManagerResolver("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo")

return http {
    authorizeExchange {
        authorize(anyExchange, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这很好,因为发布者端点是延迟加载的.  实际上,仅当发送带有相应发行者的第一个请求时,才会实例化相应的 <code>JwtReactiveAuthenticationManager</code>.  这样就可以启动应用程序,而与启动并可用的那些授权服务器无关.</p>
</div>
<div class="sect5">
<h6 id="动态租户-2"><a class="anchor" href="#动态租户-2"></a>动态租户</h6>
<div class="paragraph">
<p>当然,您可能不想在每次添加新租户时都重新启动应用程序.  在这种情况下,可以使用 <code>ReactiveAuthenticationManager</code> 实例的仓库配置 <code>JwtIssuerReactiveAuthenticationManagerResolver</code>,您可以在运行时对其进行编辑,如下所示:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">private Mono&lt;ReactiveAuthenticationManager&gt; addManager(
        Map&lt;String, ReactiveAuthenticationManager&gt; authenticationManagers, String issuer) {

    return Mono.fromCallable(() -&gt; ReactiveJwtDecoders.fromIssuerLocation(issuer))
            .subscribeOn(Schedulers.boundedElastic())
            .map(JwtReactiveAuthenticationManager::new)
            .doOnNext(authenticationManager -&gt; authenticationManagers.put(issuer, authenticationManager));
}

// ...

JwtIssuerReactiveAuthenticationManagerResolver authenticationManagerResolver =
        new JwtIssuerReactiveAuthenticationManagerResolver(authenticationManagers::get);

http
    .authorizeExchange(exchanges -&gt; exchanges
        .anyExchange().authenticated()
    )
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">private fun addManager(
        authenticationManagers: MutableMap&lt;String, ReactiveAuthenticationManager&gt;, issuer: String): Mono&lt;JwtReactiveAuthenticationManager&gt; {
    return Mono.fromCallable { ReactiveJwtDecoders.fromIssuerLocation(issuer) }
            .subscribeOn(Schedulers.boundedElastic())
            .map { jwtDecoder: ReactiveJwtDecoder -&gt; JwtReactiveAuthenticationManager(jwtDecoder) }
            .doOnNext { authenticationManager: JwtReactiveAuthenticationManager -&gt; authenticationManagers[issuer] = authenticationManager }
}

// ...

var customAuthenticationManagerResolver = JwtIssuerReactiveAuthenticationManagerResolver(authenticationManagers::get)
return http {
    authorizeExchange {
        authorize(anyExchange, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,您可以使用给定 issuer 的策略来构造 <code>JwtIssuerReactiveAuthenticationManagerResolver</code>,以获取 <code>ReactiveAuthenticationManager</code>.  这种方法使我们可以在运行时从仓库中添加和删除元素 (如片段中的 <code>Map</code> 所示) .</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
仅选择任何 issuer 并从中构造 <code>ReactiveAuthenticationManager</code> 是不安全的.  issuer 应该是代码可以从允许的 issuers 列表之类的受信任来源进行验证的发行者.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-oauth2resourceserver-bearertoken-resolver"><a class="anchor" href="#webflux-oauth2resourceserver-bearertoken-resolver"></a>24.3.5. Bearer Token Resolution</h4>
<div class="paragraph">
<p>默认情况下， 资源服务器在 <code>Authorization</code>  头中查找承载令牌. 但是， 可以自定义.</p>
</div>
<div class="paragraph">
<p>例如， 您可能需要从自定义头中读取承载令牌.
为此， 您可以将 <code>ServerBearerTokenAuthenticationConverter</code> 的实例连接到 DSL， 如以下示例所示:</p>
</div>
<div class="exampleblock">
<div class="title">Example 218. Custom Bearer Token Header</div>
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">ServerBearerTokenAuthenticationConverter converter = new ServerBearerTokenAuthenticationConverter();
converter.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION);
http
    .oauth2ResourceServer(oauth2 -&gt; oauth2
        .bearerTokenConverter(converter)
    );
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val converter = ServerBearerTokenAuthenticationConverter()
converter.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION)
return http {
    oauth2ResourceServer {
        bearerTokenConverter = converter
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bearer-token-传播"><a class="anchor" href="#bearer-token-传播"></a>24.3.6. Bearer Token 传播</h4>
<div class="paragraph">
<p>现在您已经拥有了一个 Bearer 令牌,将它传递给下游服务可能会很方便.
使用 <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/server/resource/web/reactive/function/client/ServerBearerExchangeFilterFunction.html">ServerBearerExchangeFilterFunction</a></code> 非常简单,您可以在以下示例中看到它:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public WebClient rest() {
    return WebClient.builder()
            .filter(new ServerBearerExchangeFilterFunction())
            .build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun rest(): WebClient {
    return WebClient.builder()
            .filter(ServerBearerExchangeFilterFunction())
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当上述 <code>WebClient</code> 用于执行请求时,Spring Security 将查找当前的 <code>Authentication</code> 并提取任何 <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/core/AbstractOAuth2Token.html">AbstractOAuth2Token</a></code>  凭据.  然后,它将在授权请求头中传递该令牌.</p>
</div>
<div class="paragraph">
<p>例如:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono(String.class)
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono&lt;String&gt;()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>将调用  <code><a href="https://other-service.example.com/endpoint" class="bare">other-service.example.com/endpoint</a></code>, 为您添加 Bearer 令牌 <code>Authorization</code>  请求头.</p>
</div>
<div class="paragraph">
<p>在您需要覆盖此行为的地方,您可以自己提供请求头,这很简单,例如:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers(headers -&gt; headers.setBearerAuth(overridingToken))
        .retrieve()
        .bodyToMono(String.class)
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers { it.setBearerAuth(overridingToken) }
        .retrieve()
        .bodyToMono&lt;String&gt;()</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,过滤器将回退并将请求转发到 Web 过滤器链的其余部分.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
与 <a href="https://docs.spring.io/spring-security/site/docs/current-SNAPSHOT/api/org/springframework/security/oauth2/client/web/reactive/function/client/ServletOAuth2AuthorizedClientExchangeFilterFunction.html">OAuth 2.0 Client filter function</a>功能不同,此过滤器功能不会在令牌过期时尝试更新令牌.  要获得此级别的支持,请使用 OAuth 2.0 客户端过滤器.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webflux-roac"><a class="anchor" href="#webflux-roac"></a>25. @RegisteredOAuth2AuthorizedClient</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 允许使用 <code>@ RegisteredOAuth2AuthorizedClient</code> 解析访问令牌.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 <a href="https://github.com/spring-projects/spring-security/master//boot/oauth2webclient-webflux"><strong>OAuth 2.0 WebClient WebFlux sample</strong></a> 中可以找到一个有效的示例.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>将 Spring Security 配置为 <a href="#webflux-oauth2-login">OAuth2 Login</a>  或作为<a href="#webflux-oauth2-client">OAuth2 Client</a> 后,可以使用以下方法解析 <code>OAuth2AuthorizedClient</code>:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/explicit")
Mono&lt;String&gt; explicit(@RegisteredOAuth2AuthorizedClient("client-id") OAuth2AuthorizedClient authorizedClient) {
    // ...
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/explicit")
fun explicit(@RegisteredOAuth2AuthorizedClient("client-id") authorizedClient: OAuth2AuthorizedClient?): Mono&lt;String&gt; {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>它集成到 Spring Security 中以提供以下功能:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Security 将自动刷新过期的令牌(如果存在刷新令牌)</p>
</li>
<li>
<p>如果请求访问令牌但不存在,则 Spring Security 将自动请求访问令牌.</p>
<div class="ulist">
<ul>
<li>
<p>对于 <code>authorization_code</code>,这涉及执行重定向,然后重播原始请求</p>
</li>
<li>
<p>对于 <code>client_credentials</code>,只需请求并保存令牌</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果用户使用 <code>oauth2Login()</code> 进行了身份验证,则 <code>client-id</code> 是可选的.  例如,以下将起作用:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/implicit")
Mono&lt;String&gt; implicit(@RegisteredOAuth2AuthorizedClient OAuth2AuthorizedClient authorizedClient) {
    // ...
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/implicit")
fun implicit(@RegisteredOAuth2AuthorizedClient authorizedClient: OAuth2AuthorizedClient?): Mono&lt;String&gt; {
    // ...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果用户始终使用 OAuth2 登录进行身份验证,并且需要来自同一授权服务器的访问令牌,这将非常方便.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reactive-x509"><a class="anchor" href="#reactive-x509"></a>26. Reactive X.509 认证</h2>
<div class="sectionbody">
<div class="paragraph">
<p>与 <a href="#servlet-x509">Servlet X.509 authentication</a> 身份验证类似,响应式 x509 身份验证过滤器允许从客户端提供的证书中提取身份验证令牌.</p>
</div>
<div class="paragraph">
<p>以下是 Reactive x509 安全配置的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
    http
        .x509(withDefaults())
        .authorizeExchange(exchanges -&gt; exchanges
            .anyExchange().permitAll()
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在以上配置中,当未提供 <code>principalExtractor</code> 和 <code>authenticationManager</code> 时,将使用默认值.  默认的主体提取器是 <code>SubjectDnX509PrincipalExtractor</code>,它从客户端提供的证书中提取CN (公用名) 字段.  默认的身份验证管理器是 <code>ReactivePreAuthenticatedAuthenticationManager</code>,它执行用户帐户验证,检查是否存在具有由 <code>principalExtractor</code> 提取的名称的用户帐户,并且该帐户没有被锁定,禁用或过期.</p>
</div>
<div class="paragraph">
<p>下一个示例演示如何覆盖这些默认值.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
    SubjectDnX509PrincipalExtractor principalExtractor =
            new SubjectDnX509PrincipalExtractor();

    principalExtractor.setSubjectDnRegex("OU=(.*?)(?:,|$)");

    ReactiveAuthenticationManager authenticationManager = authentication -&gt; {
        authentication.setAuthenticated("Trusted Org Unit".equals(authentication.getName()));
        return Mono.just(authentication);
    };

    http
        .x509(x509 -&gt; x509
            .principalExtractor(principalExtractor)
            .authenticationManager(authenticationManager)
        )
        .authorizeExchange(exchanges -&gt; exchanges
            .anyExchange().authenticated()
        );
    return http.build();
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在此示例中,从客户端证书的 OU 字段而不是 CN 提取用户名,并且根本不执行使用 <code>ReactiveUserDetailsService</code> 的帐户查找.  相反,如果提供的证书颁发给名为 "受信任的组织单位" 的 OU,则将对请求进行身份验证.</p>
</div>
<div class="paragraph">
<p>有关配置 Netty 和 <code>WebClient</code> 或 <code>curl</code> 命令行工具以使用双向 TLS 并启用 X.509 身份验证的示例,请参阅 <a href="https://github.com/spring-projects/spring-security/tree/master/samples/boot/webflux-x509" class="bare">github.com/spring-projects/spring-security/tree/master/samples/boot/webflux-x509</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="webclient"><a class="anchor" href="#webclient"></a>27. WebClient</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>以下文档适用于 Reactive 环境. 对于 Servlet 环境,请参阅 <a href="#oauth2Client-webclient-servlet">Servlet 环境的WebClient</a> .</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Spring Framework 内置了对设置 Bearer 令牌的支持.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">webClient.get()
    .headers(h -&gt; h.setBearerAuth(token))
    ...
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">webClient.get()
    .headers { it.setBearerAuth(token) }
    ...</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>Spring Security 在此支持的基础上提供了更多好处:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Spring Security 将自动刷新过期的令牌(如果存在刷新令牌)</p>
</li>
<li>
<p>如果请求访问令牌但不存在,则 Spring Security 将自动请求访问令牌.</p>
<div class="ulist">
<ul>
<li>
<p>对于 <code>authorization_code</code>,这涉及执行重定向,然后重播原始请求</p>
</li>
<li>
<p>对于 <code>client_credentials</code>,只需请求并保存令牌</p>
</li>
</ul>
</div>
</li>
<li>
<p>支持透明地包含当前OAuth令牌或显式选择应使用的令牌的功能.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="webclient-setup"><a class="anchor" href="#webclient-setup"></a>27.1. WebClient OAuth2 Setup</h3>
<div class="paragraph">
<p>第一步是确保正确设置 <code>WebClient</code>. 下面是在完全响应式的环境中设置 <code>WebClient</code> 的示例:</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
WebClient webClient(ReactiveClientRegistrationRepository clientRegistrations,
        ServerOAuth2AuthorizedClientRepository authorizedClients) {
    ServerOAuth2AuthorizedClientExchangeFilterFunction oauth =
            new ServerOAuth2AuthorizedClientExchangeFilterFunction(clientRegistrations, authorizedClients);
    // (optional) explicitly opt into using the oauth2Login to provide an access token implicitly
    // oauth.setDefaultOAuth2AuthorizedClient(true);
    // (optional) set a default ClientRegistration.registrationId
    // oauth.setDefaultClientRegistrationId("client-registration-id");
    return WebClient.builder()
            .filter(oauth)
            .build();
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@Bean
fun webClient(clientRegistrations: ReactiveClientRegistrationRepository,
              authorizedClients: ServerOAuth2AuthorizedClientRepository): WebClient {
    val oauth = ServerOAuth2AuthorizedClientExchangeFilterFunction(clientRegistrations, authorizedClients)
    // (optional) explicitly opt into using the oauth2Login to provide an access token implicitly
    // oauth.setDefaultOAuth2AuthorizedClient(true)
    // (optional) set a default ClientRegistration.registrationId
    // oauth.setDefaultClientRegistrationId("client-registration-id")
    return WebClient.builder()
            .filter(oauth)
            .build()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webclient-implicit"><a class="anchor" href="#webclient-implicit"></a>27.2. 隐式 OAuth2AuthorizedClient</h3>
<div class="paragraph">
<p>如果我们在设置中将 <code>defaultOAuth2AuthorizedClient</code> 设置为 <code>true</code>,并且使用 oauth2Login(即 OIDC) 对用户进行身份验证,则当前身份验证将用于自动提供访问令牌.  或者,如果我们将 <code>defaultClientRegistrationId</code> 设置为有效的 <code>ClientRegistration</code> ID,则使用该注册来提供访问令牌.  这很方便,但是在并非所有端点都应获取访问令牌的环境中,这很危险(您可能为端点提供了错误的访问令牌) .</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Mono&lt;String&gt; body = this.webClient
        .get()
        .uri(this.uri)
        .retrieve()
        .bodyToMono(String.class);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val body: Mono&lt;String&gt; = webClient
        .get()
        .uri(this.uri)
        .retrieve()
        .bodyToMono()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webclient-explicit"><a class="anchor" href="#webclient-explicit"></a>27.3. 显式 OAuth2AuthorizedClient</h3>
<div class="paragraph">
<p>通过在请求属性上设置 <code>OAuth2AuthorizedClient</code>,可以显式提供它.  在下面的示例中,我们使用 Spring WebFlux 或 Spring MVC 参数解析器支持来解析 <code>OAuth2AuthorizedClient</code>.  但是,如何解析 <code>OAuth2AuthorizedClient</code> 并不重要.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/explicit")
Mono&lt;String&gt; explicit(@RegisteredOAuth2AuthorizedClient("client-id") OAuth2AuthorizedClient authorizedClient) {
    return this.webClient
            .get()
            .uri(this.uri)
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono(String.class);
}
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">@GetMapping("/explicit")
fun explicit(@RegisteredOAuth2AuthorizedClient("client-id") authorizedClient: OAuth2AuthorizedClient?): Mono&lt;String&gt; {
    return this.webClient
            .get()
            .uri(uri)
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono()
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="webclient-clientregistrationid"><a class="anchor" href="#webclient-clientregistrationid"></a>27.4. clientRegistrationId</h3>
<div class="paragraph">
<p>或者,可以在请求属性上指定 <code>clientRegistrationId</code>,然后 <code>WebClient</code> 会尝试查找 <code>OAuth2AuthorizedClient</code>.  如果找不到,将自动获取一个.</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock primary">
<div class="title">Java</div>
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Mono&lt;String&gt; body = this.webClient
        .get()
        .uri(this.uri)
        .attributes(clientRegistrationId("client-id"))
        .retrieve()
        .bodyToMono(String.class);
</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Kotlin</div>
<div class="content">
<pre class="highlight"><code class="language-kotlin" data-lang="kotlin">val body: Mono&lt;String&gt; = this.webClient
        .get()
        .uri(uri)
        .attributes(clientRegistrationId("client-id"))
        .retrieve()
        .bodyToMono()</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jc-erms"><a class="anchor" href="#jc-erms"></a>28. EnableReactiveMethodSecurity</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 使用 <a href="https://projectreactor.io/docs/core/release/reference/#context">Reactor&#8217;s Context</a>  支持方法安全性,该上下文是使用 <code>ReactiveSecurityContextHolder</code> 设置的. 例如,这演示了如何检索当前登录用户的消息.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为此,方法的返回类型必须是 <code>org.reactivestreams.Publisher</code>(即 <code>Mono/Flux</code>) . 这是与 Reactor 的上下文集成的必要条件.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Authentication authentication = new TestingAuthenticationToken("user", "password", "ROLE_USER");

Mono&lt;String&gt; messageByUsername = ReactiveSecurityContextHolder.getContext()
    .map(SecurityContext::getAuthentication)
    .map(Authentication::getName)
    .flatMap(this::findMessageByUsername)
    // In a WebFlux application the `subscriberContext` is automatically setup using `ReactorContextWebFilter`
    .subscriberContext(ReactiveSecurityContextHolder.withAuthentication(authentication));

StepVerifier.create(messageByUsername)
    .expectNext("Hi user")
    .verifyComplete();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <code>this::findMessageByUsername</code> 定义为:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Mono&lt;String&gt; findMessageByUsername(String username) {
    return Mono.just("Hi " + username);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面是在响应式应用程序中使用方法安全性时的最小方法安全性配置.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableReactiveMethodSecurity
public class SecurityConfig {
    @Bean
    public MapReactiveUserDetailsService userDetailsService() {
        User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
        UserDetails rob = userBuilder.username("rob")
            .password("rob")
            .roles("USER")
            .build();
        UserDetails admin = userBuilder.username("admin")
            .password("admin")
            .roles("USER","ADMIN")
            .build();
        return new MapReactiveUserDetailsService(rob, admin);
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>考虑以下: class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Component
public class HelloWorldMessageService {
    @PreAuthorize("hasRole('ADMIN')")
    public Mono&lt;String&gt; findMessage() {
        return Mono.just("Hello World!");
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>结合上面的配置,<code>@PreAuthorize("hasRole('ADMIN')")</code> 将确保 <code>findByMessage</code> 仅由具有 <code>ADMIN</code> 角色的用户调用.  重要的是要注意,标准方法安全性中的任何表达式都适用于 <code>@EnableReactiveMethodSecurity</code>.
但是,目前我们仅支持表达式的 <code>Boolean</code> or <code>boolean</code> 的返回类型.  这意味着该表达式不能阻塞.</p>
</div>
<div class="paragraph">
<p>与 <a href="#jc-webflux">第21章WebFlux Security集成</a>时,Spring Security会根据已认证的用户自动建立Reactor上下文.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@EnableWebFluxSecurity
@EnableReactiveMethodSecurity
public class SecurityConfig {

    @Bean
    SecurityWebFilterChain springWebFilterChain(ServerHttpSecurity http) throws Exception {
        return http
            // Demonstrate that method security works
            // Best practice to use both for defense in depth
            .authorizeExchange(exchanges -&gt; exchanges
                .anyExchange().permitAll()
            )
            .httpBasic(withDefaults())
            .build();
    }

    @Bean
    MapReactiveUserDetailsService userDetailsService() {
        User.UserBuilder userBuilder = User.withDefaultPasswordEncoder();
        UserDetails rob = userBuilder.username("rob")
            .password("rob")
            .roles("USER")
            .build();
        UserDetails admin = userBuilder.username("admin")
            .password("admin")
            .roles("USER","ADMIN")
            .build();
        return new MapReactiveUserDetailsService(rob, admin);
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可以在 <a href="https://github.com/spring-projects/spring-security/master//javaconfig/hellowebflux-method">hellowebflux-method</a> 中找到完整的示例</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="test-webflux"><a class="anchor" href="#test-webflux"></a>29. Reactive 测试支持</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="test-erms"><a class="anchor" href="#test-erms"></a>29.1. 测试 Reactive 方法安全</h3>
<div class="paragraph">
<p>例如,我们可以使用与<a href="#jc-erms">第 18.1 节 "测试方法安全性"</a> 中相同的设置和注解来测试  <a href="#test-method">第 27 章 <code>EnableReactiveMethodSecurity</code> 中</a>的示例. 这是我们可以做的最简化的示例:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@ContextConfiguration(classes = HelloWebfluxMethodApplication.class)
public class HelloWorldMessageServiceTests {
    @Autowired
    HelloWorldMessageService messages;

    @Test
    public void messagesWhenNotAuthenticatedThenDenied() {
        StepVerifier.create(this.messages.findMessage())
            .expectError(AccessDeniedException.class)
            .verify();
    }

    @Test
    @WithMockUser
    public void messagesWhenUserThenDenied() {
        StepVerifier.create(this.messages.findMessage())
            .expectError(AccessDeniedException.class)
            .verify();
    }

    @Test
    @WithMockUser(roles = "ADMIN")
    public void messagesWhenAdminThenOk() {
        StepVerifier.create(this.messages.findMessage())
            .expectNext("Hello World!")
            .verifyComplete();
    }
}
</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="test-webtestclient"><a class="anchor" href="#test-webtestclient"></a>29.2. WebTestClientSupport</h3>
<div class="paragraph">
<p>Spring Security 提供了与 <code>WebTestClient</code> 的集成. 基本设置如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@RunWith(SpringRunner.class)
@ContextConfiguration(classes = HelloWebfluxMethodApplication.class)
public class HelloWebfluxMethodApplicationTests {
    @Autowired
    ApplicationContext context;

    WebTestClient rest;

    @Before
    public void setup() {
        this.rest = WebTestClient
            .bindToApplicationContext(this.context)
            // add Spring Security test Support
            .apply(springSecurity())
            .configureClient()
            .filter(basicAuthentication())
            .build();
    }
    // ...
}
</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="认证"><a class="anchor" href="#认证"></a>29.2.1. 认证</h4>
<div class="paragraph">
<p>将 Spring Security 支持应用于 <code>WebTestClient</code> 之后,我们可以使用注解或 <code>mutateWith</code> 支持. 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Test
public void messageWhenNotAuthenticated() throws Exception {
    this.rest
        .get()
        .uri("/message")
        .exchange()
        .expectStatus().isUnauthorized();
}

// --- WithMockUser ---

@Test
@WithMockUser
public void messageWhenWithMockUserThenForbidden() throws Exception {
    this.rest
        .get()
        .uri("/message")
        .exchange()
        .expectStatus().isEqualTo(HttpStatus.FORBIDDEN);
}

@Test
@WithMockUser(roles = "ADMIN")
public void messageWhenWithMockAdminThenOk() throws Exception {
    this.rest
        .get()
        .uri("/message")
        .exchange()
        .expectStatus().isOk()
        .expectBody(String.class).isEqualTo("Hello World!");
}

// --- mutateWith mockUser ---

@Test
public void messageWhenMutateWithMockUserThenForbidden() throws Exception {
    this.rest
        .mutateWith(mockUser())
        .get()
        .uri("/message")
        .exchange()
        .expectStatus().isEqualTo(HttpStatus.FORBIDDEN);
}

@Test
public void messageWhenMutateWithMockAdminThenOk() throws Exception {
    this.rest
        .mutateWith(mockUser().roles("ADMIN"))
        .get()
        .uri("/message")
        .exchange()
        .expectStatus().isOk()
        .expectBody(String.class).isEqualTo("Hello World!");
}
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="csrf-支持"><a class="anchor" href="#csrf-支持"></a>29.2.2. CSRF 支持</h4>
<div class="paragraph">
<p>Spring Security 还为使用 <code>WebTestClient</code> 的 CSRF 提供测试支持. 例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">this.rest
    // provide a valid CSRF token
    .mutateWith(csrf())
    .post()
    .uri("/login")
    ...
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oauth2"><a class="anchor" href="#webflux-testing-oauth2"></a>29.2.3. 测试 OAuth 2.0</h4>
<div class="paragraph">
<p>当涉及到 OAuth 2.0 时,仍然可以使用前面介绍的相同原理: 最终,它取决于您所测试的方法期望  <code>SecurityContextHolder</code>  能做什么.</p>
</div>
<div class="paragraph">
<p>例如,对于如下所示的控制器:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(Principal user) {
    return Mono.just(user.getName());
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有关于 OAuth2 的特定信息,因此您可能只需使用  <a href="#test-erms">使用 <code>@WithMockUser</code></a>  就可以了.</p>
</div>
<div class="paragraph">
<p>但是,如果您的控制器绑定 Spring Security 的 OAuth 2.0 支持的一些情况,例如:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OidcUser user) {
    return Mono.just(user.getIdToken().getSubject());
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后 Spring Security 的测试支持将派上用场.</p>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oidc-login"><a class="anchor" href="#webflux-testing-oidc-login"></a>29.2.4. 测试 OIDC Login</h4>
<div class="paragraph">
<p>使用 Spring MVC Test 测试上述方法需要使用授权服务器模拟某种授权流程. 当然,这将是一项艰巨的任务,但是,Spring Security 的 OAuth 2.0 Client 测试支持可以帮助删除大部分样板代码.</p>
</div>
<div class="paragraph">
<p>例如,我们可以使用  <code>SecurityMockServerConfigurers#oidcLogin</code> 方法告诉 Spring Security 包含默认的 <code>OidcUser</code>,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockOidcLogin()).get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使用的 <code>MockHttpServletRequest</code> 创建关联的 <code>OidcUser</code> ,该 <code>OidcUser</code> 包括的一个模拟的 <code>OidcIdToken</code>,模拟 <code>OidcUserInfo</code> 和一个模拟的授权集合.</p>
</div>
<div class="paragraph">
<p>具体来说,它将包括一个 <code>OidcIdToken</code>,并为用户设置了一个 claim</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(user.getIdToken().getClaim("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>没有 claims 的 <code>OidcUserInfo</code> :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(user.getUserInfo().getClaims()).isEmpty();</code></pre>
</div>
</div>
<div class="paragraph">
<p>和只有一个权限 <code>SCOPE_read</code> 的权限集合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security 做了必要的工作,以确保 <code>OidcUser</code> 实例可用于  <a href="#mvc-authentication-principal"><code>@AuthenticationPrincipal</code> 注解</a>.</p>
</div>
<div class="paragraph">
<p>此外,它还将 <code>OidcUser</code> 链接到 <code>OAuth2AuthorizedClient</code> 的简单实例,并将其注入模拟的 <code>ServerOAuth2AuthorizedClientRepository</code> 中. 如果您的测试 <a href="#webflux-testing-oauth2-client">使用 <code>@RegisteredOAuth2AuthorizedClient</code> 注解</a>,则此方法很方便.</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-oidc-login-authorities"><a class="anchor" href="#webflux-testing-oidc-login-authorities"></a>配置权限</h5>
<div class="paragraph">
<p>在许多情况下,您的方法受到过滤器或安全方法的保护,并且需要您的身份验证具有某些授予的权限才能允许该请求.</p>
</div>
<div class="paragraph">
<p>在这种情况下,您可以使用 <code>authorities()</code> 方法提供所需的已授予权限:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockOidcLogin()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oidc-login-claims"><a class="anchor" href="#webflux-testing-oidc-login-claims"></a>配置 Claims</h5>
<div class="paragraph">
<p>尽管授予的权限在整个 Spring Security 中非常普遍,但在 OAuth 2.0 方面我们也有主张.</p>
</div>
<div class="paragraph">
<p>举例来说,假设您有一个 <code>user_id</code> 声明,该声明指出了系统中的用户 ID. 您可以像在控制器中那样访问它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OidcUser oidcUser) {
    String userId = oidcUser.getIdToken().getClaim("user_id");
    // ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,您需要使用  <code>idToken()</code>  方法指定该声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockOidcLogin()
        .idToken(token -&gt; token.claim("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>因为 <code>OidcUser</code> 从 <code>OidcIdToken</code> 收集了其 claims.</p>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oidc-login-user"><a class="anchor" href="#webflux-testing-oidc-login-user"></a>其他配置</h5>
<div class="paragraph">
<p>还有其他方法可用于进一步配置身份验证. 它仅取决于您的控制器需要什么数据:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>userInfo(OidcUserInfo.Builder)</code> - 配置 <code>OidcUserInfo</code> 实例</p>
</li>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - 使用已有 <code>ClientRegistration</code> 关联 <code>OAuth2AuthorizedClient</code></p>
</li>
<li>
<p><code>oidcUser(OidcUser)</code> - 用于配置完整的 <code>OidcUser</code> 实例</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您:
1. 有自己的 <code>OidcUser</code> 的实现,
2. 需要更改 name 属性</p>
</div>
<div class="paragraph">
<p>例如,假设您的授权服务器在 <code>user_name</code> claim 中发送主体名称,而不在 <code>sub</code> claim 中发送主体名称. 在这种情况下,您可以手动配置 <code>OidcUser</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OidcUser oidcUser = new DefaultOidcUser(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

client
    .mutateWith(mockOidcLogin().oidcUser(oidcUser))
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oauth2-login"><a class="anchor" href="#webflux-testing-oauth2-login"></a>29.2.5. 测试 OAuth 2.0 登录</h4>
<div class="paragraph">
<p>与 <a href="#webflux-testing-oidc-login">测试 OIDC 登录</a> 一样,测试 OAuth 2.0 登录也面临着类似需要模拟授权流程挑战. 因此,Spring Security 还对非 OIDC 用例提供了测试支持.</p>
</div>
<div class="paragraph">
<p>假设我们有一个控制器,可以将登录用户作为 <code>OAuth2User</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    return Mono.just(oauth2User.getAttribute("sub"));
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,我们可以告诉 Spring Security 使用  <code>SecurityMockServerConfigurers#oauth2User</code> 方法包含一个默认的 <code>OAuth2User</code>,就像这样</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockOAuth2Login())
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使用 <code>OAuth2User</code> 配置关联的 <code>MockHttpServletRequest</code>,该 <code>OAuth2User</code> 包括简单的属性映射和已授予权限的集合.</p>
</div>
<div class="paragraph">
<p>具体来说,它将包括一个带有 <code>sub</code>/<code>user</code> 的键值对:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat((String) user.getAttribute("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>和只有一个权限 <code>SCOPE_read</code> 的权限集合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(user.getAuthorities()).hasSize(1);
assertThat(user.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security 做了必要的工作,以确保 <code>OAuth2User</code> 实例可用于  <a href="#mvc-authentication-principal"><code>@AuthenticationPrincipal</code> 注解</a>.</p>
</div>
<div class="paragraph">
<p>此外,它还将 <code>OAuth2User</code> 链接到 <code>OAuth2AuthorizedClient</code> 的简单实例,并注入 <code>ServerOAuth2AuthorizedClientRepository</code> 中. 如果您的测试使用 <a href="#webflux-testing-oauth2-client">使用 <code>@RegisteredOAuth2AuthorizedClient</code> 注解</a> ,则这会很方便.</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-login-authorities"><a class="anchor" href="#webflux-testing-oauth2-login-authorities"></a>配置权限</h5>
<div class="paragraph">
<p>在许多情况下,您的方法受到过滤器或安全方法的保护,并且需要 <code>Authentication</code> 具有某些授予的权限才能允许该请求.</p>
</div>
<div class="paragraph">
<p>在这种情况下,您可以使用 <code>authorities()</code> 方法提供所需的已授予权限:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockOAuth2Login()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-login-claims"><a class="anchor" href="#webflux-testing-oauth2-login-claims"></a>配置 Claims</h5>
<div class="paragraph">
<p>尽管授予的权限在整个 Spring Security 中非常普遍,但在 OAuth 2.0 方面我们也有主张.</p>
</div>
<div class="paragraph">
<p>举例来说,假设您有一个 <code>user_id</code> 声明,该声明指出了系统中的用户 ID. 您可以像在控制器中那样访问它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@AuthenticationPrincipal OAuth2User oauth2User) {
    String userId = oauth2User.getAttribute("user_id");
    // ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,您需要使用  <code>attributes()</code> 方法指定该属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockOAuth2Login()
        .attributes(attrs -&gt; attrs.put("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-login-user"><a class="anchor" href="#webflux-testing-oauth2-login-user"></a>其他配置</h5>
<div class="paragraph">
<p>还有其他方法可用于进一步配置身份验证. 它仅取决于您的控制器需要什么数据:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - 使用已有 <code>ClientRegistration</code> 关联 <code>OAuth2AuthorizedClient</code></p>
</li>
<li>
<p><code>oidcUser(OAuth2User)</code> - 用于配置完整的 <code>OAuth2User</code> 实例</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您:
1. 有自己的 <code>OAuth2User</code> 的实现,
2. 需要更改 name 属性</p>
</div>
<div class="paragraph">
<p>例如,假设您的授权服务器在 <code>user_name</code> claim 中发送主体名称,而不在 <code>sub</code> claim 中发送主体名称. 在这种情况下,您可以手动配置 <code>OAuth2User</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">OAuth2User oauth2User = new DefaultOAuth2User(
        AuthorityUtils.createAuthorityList("SCOPE_message:read"),
        Collections.singletonMap("user_name", "foo_user"),
        "user_name");

client
    .mutateWith(mockOAuth2Login().oauth2User(oauth2User))
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-oauth2-client"><a class="anchor" href="#webflux-testing-oauth2-client"></a>29.2.6. 测试 OAuth 2.0 客户端</h4>
<div class="paragraph">
<p>与用户的身份验证方式无关,对于正在测试的请求,您可能还有其他令牌和客户端注册在起作用. 例如,您的控制器可能依赖于客户端凭据授予来获取与用户完全不相关的令牌:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    return this.webClient.get()
        .attributes(oauth2AuthorizedClient(authorizedClient))
        .retrieve()
        .bodyToMono(String.class);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用授权服务器模拟此握手可能很麻烦. 相反,可以使用 <code>SecurityMockServerConfigurers#oauth2Client</code> 将 <code>OAuth2AuthorizedClient</code> 添加到模拟的 <code>ServerOAuth2AuthorizedClientRepository</code> 中:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockOAuth2Client("my-app"))
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将创建一个具有简单 <code>ClientRegistration</code>,<code>OAuth2AccessToken</code> 和资源所有者名称的 <code>OAuth2AuthorizedClient</code>.</p>
</div>
<div class="paragraph">
<p>具体来说,它将包括一个 <code>ClientRegistration</code>,其客户端ID为 "test-client",客户端密码为 "test-secret":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(authorizedClient.getClientRegistration().getClientId()).isEqualTo("test-client");
assertThat(authorizedClient.getClientRegistration().getClientSecret()).isEqualTo("test-secret");</code></pre>
</div>
</div>
<div class="paragraph">
<p>资源所有者名字 "user":</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(authorizedClient.getPrincipalName()).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>OAuth2AccessToken</code> 只包含一个权限, <code>read</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(authorizedClient.getAccessToken().getScopes()).hasSize(1);
assertThat(authorizedClient.getAccessToken().getScopes()).containsExactly("read");</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以在控制器方法中使用 <code>@RegisteredOAuth2AuthorizedClient</code> 正常检索客户端.</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-client-scopes"><a class="anchor" href="#webflux-testing-oauth2-client-scopes"></a>配置 Scopes</h5>
<div class="paragraph">
<p>在许多情况下,OAuth 2.0 访问令牌都带有一组范围.如果您的控制器检查了这些,如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(@RegisteredOAuth2AuthorizedClient("my-app") OAuth2AuthorizedClient authorizedClient) {
    Set&lt;String&gt; scopes = authorizedClient.getAccessToken().getScopes();
    if (scopes.contains("message:read")) {
        return this.webClient.get()
            .attributes(oauth2AuthorizedClient(authorizedClient))
            .retrieve()
            .bodyToMono(String.class);
    }
    // ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后您可以使用  <code>accessToken()</code> 方法配置范围:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockOAuth2Client("my-app")
        .accessToken(new OAuth2AccessToken(BEARER, "token", null, null, Collections.singleton("message:read"))))
    )
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-oauth2-client-registration"><a class="anchor" href="#webflux-testing-oauth2-client-registration"></a>其他配置</h5>
<div class="paragraph">
<p>还有其他方法可用于进一步配置身份验证. 它仅取决于您的控制器需要什么数据:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>principalName(String)</code> - 资源所有者名字</p>
</li>
<li>
<p><code>clientRegistration(Consumer&lt;ClientRegistration.Builder&gt;)</code> - 用于配置相关的 <code>ClientRegistration</code></p>
</li>
<li>
<p><code>clientRegistration(ClientRegistration)</code> - 配置完整的 <code>ClientRegistration</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果您想使用真实的 <code>ClientRegistration</code>,那么最后一个方便</p>
</div>
<div class="paragraph">
<p>例如,假设您要使用 <code>application.yml</code> 中定义的 <code>ClientRegistration</code> .</p>
</div>
<div class="paragraph">
<p>在这种情况下,您的测试可以自动连接 <code>ClientRegistrationRepository</code> 并查找您的测试所需的一个:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Autowired
ReactiveClientRegistrationRepository clientRegistrationRepository;

// ...

client
    .mutateWith(mockOAuth2Client()
        .clientRegistration(this.clientRegistrationRepository.findByRegistrationId("facebook"))
    )
    .get().uri("/exchange").exchange();
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-jwt"><a class="anchor" href="#webflux-testing-jwt"></a>29.2.7. 测试 JWT 认证</h4>
<div class="paragraph">
<p>为了在资源服务器上发出授权请求,您需要一个承载令牌.  如果为JWT配置了资源服务器,则这意味着需要对承载令牌进行签名,然后根据 JWT 规范进行编码.  所有这些都可能令人生畏,尤其是当这不是您的测试重点时.</p>
</div>
<div class="paragraph">
<p>幸运的是,您可以通过多种简单的方法来克服此困难,并使您的测试专注于授权而不是表示承载令牌.  我们现在来看其中两个:</p>
</div>
<div class="sect4">
<h5 id="mockjwt-webtestclientconfigurer"><a class="anchor" href="#mockjwt-webtestclientconfigurer"></a><code>mockJwt() WebTestClientConfigurer</code></h5>
<div class="paragraph">
<p>第一种方法是通过 <code>WebTestClientConfigurer</code>. 其中最简单的如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockJwt()).get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>要做的就是创建一个模拟的 <code>Jwt</code>,将其正确地通过任何身份验证 API 传递,以便您的授权机制可以对其进行验证.</p>
</div>
<div class="paragraph">
<p>默认情况下,它创建的 <code>JWT</code> 具有以下特征:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">{
  "headers" : { "alg" : "none" },
  "claims" : {
    "sub" : "user",
    "scope" : "read"
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>经过测试的结果是,<code>Jwt</code> 将通过以下方式通过:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">assertThat(jwt.getTokenValue()).isEqualTo("token");
assertThat(jwt.getHeaders().get("alg")).isEqualTo("none");
assertThat(jwt.getSubject()).isEqualTo("sub");
GrantedAuthority authority = jwt.getAuthorities().iterator().next();
assertThat(authority.getAuthority()).isEqualTo("read");
</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然可以配置这些值.</p>
</div>
<div class="paragraph">
<p>可以使用其相应方法配置任何标题或声明:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(jwt(jwt -&gt; jwt.header("kid", "one")
        .claim("iss", "https://idp.example.org")))
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(jwt(jwt -&gt; jwt.claims(claims -&gt; claims.remove("scope"))))
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>scope</code> 和 <code>scp</code> 声明在这里的处理方式与它们在普通承载令牌请求中的处理方式相同.  但是,可以通过提供测试所需的 <code>GrantedAuthority</code> 实例的列表来覆盖它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(jwt().authorities(new SimpleGrantedAuthority("SCOPE_messages")))
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者,如果您有一个自定义的 <code>Jwt</code>   <code>Collection&lt;GrantedAuthority&gt;</code> 转换器,则还可以使用它来导出授权:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(jwt().authorities(new MyConverter()))
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>您还可以指定一个完整的 <code>Jwt</code>,为此 <code><a href="https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/oauth2/jwt/Jwt.Builder.html">Jwt.Builder</a></code> 非常方便:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .claim("scope", "read");

client
    .mutateWith(jwt(jwt))
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="authentication-webtestclientconfigurer"><a class="anchor" href="#authentication-webtestclientconfigurer"></a><code>authentication()</code> <code>WebTestClientConfigurer</code></h5>
<div class="paragraph">
<p>第二种方法是使用 <code>authentication()</code> <code>Mutator</code>.  本质上,您可以实例化自己的 <code>JwtAuthenticationToken</code> 并在测试中提供它,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .build();
Collection&lt;GrantedAuthority&gt; authorities = AuthorityUtils.createAuthorityList("SCOPE_read");
JwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities);

client
    .mutateWith(authentication(token))
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意,作为替代方法,您还可以使用 <code>@MockBean</code> 注解来模拟 <code>ReactiveJwtDecoder</code> bean本身.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="webflux-testing-opaque-token"><a class="anchor" href="#webflux-testing-opaque-token"></a>29.2.8. 测试 Opaque Token 认证</h4>
<div class="paragraph">
<p>与 <a href="#webflux-testing-jwt">JWTs</a> 相似,不透明令牌需要授权服务器才能验证其有效性,这会使测试更加困难. 为了解决这个问题,Spring Security 提供了对不透明令牌的测试支持.</p>
</div>
<div class="paragraph">
<p>假设我们有一个控制器,可以将身份验证作为 <code>BearerTokenAuthentication</code> 进行检索:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(BearerTokenAuthentication authentication) {
    return Mono.just((String) authentication.getTokenAttributes("sub"));
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,我们可以使用 <code>SecurityMockServerConfigurers#opaqueToken</code>  方法告诉 Spring Security 包含默认的 <code>BearerTokenAuthentication</code>,如下所示:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockOpaqueToken())
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使用 <code>BearerTokenAuthentication</code> 配置关联的 <code>MockHttpServletRequest</code>,该 <code>BearerTokenAuthentication</code> 包括简单的 <code>OAuth2AuthenticatedPrincipal</code>,属性映射和授予的权限集合.</p>
</div>
<div class="paragraph">
<p>具体来说,它将包括一个带有 <code>sub</code>/<code>user</code> 键值对:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat((String) token.getTokenAttributes().get("sub")).isEqualTo("user");</code></pre>
</div>
</div>
<div class="paragraph">
<p>和只有一个权限 <code>SCOPE_read</code> 的权限集合:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-json" data-lang="json">assertThat(token.getAuthorities()).hasSize(1);
assertThat(token.getAuthorities()).containsExactly(new SimpleGrantedAuthority("SCOPE_read"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Spring Security 做了必要的工作,以确保 <code>BearerTokenAuthentication</code> 实例可用于您的控制器方法.</p>
</div>
<div class="sect4">
<h5 id="webflux-testing-opaque-token-authorities"><a class="anchor" href="#webflux-testing-opaque-token-authorities"></a>配置权限</h5>
<div class="paragraph">
<p>在许多情况下,您的方法受到过滤器或安全方法的保护,并且需要 <code>Authentication</code> 具有某些授予的权限才能允许该请求.</p>
</div>
<div class="paragraph">
<p>在这种情况下,您可以使用 <code>authorities()</code> 方法提供所需的已授予权限:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockOpaqueToken()
        .authorities(new SimpleGrantedAuthority("SCOPE_message:read"))
    )
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-opaque-token-attributes"><a class="anchor" href="#webflux-testing-opaque-token-attributes"></a>配置 Claims</h5>
<div class="paragraph">
<p>尽管授予的权限在整个 Spring Security 中非常普遍,但在 OAuth 2.0 方面我们也有主张.</p>
</div>
<div class="paragraph">
<p>举例来说,假设您有一个 <code>user_id</code> 声明,该声明指出了系统中的用户 ID. 您可以像在控制器中那样访问它:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@GetMapping("/endpoint")
public Mono&lt;String&gt; foo(BearerTokenAuthentication authentication) {
    String userId = (String) authentication.getTokenAttributes().get("user_id");
    // ...
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下,您需要使用  <code>attributes()</code> 方法指定该属性:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">client
    .mutateWith(mockOpaqueToken()
        .attributes(attrs -&gt; attrs.put("user_id", "1234"))
    )
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="webflux-testing-opaque-token-principal"><a class="anchor" href="#webflux-testing-opaque-token-principal"></a>其他配置</h5>
<div class="paragraph">
<p>还有其他方法可用于进一步配置身份验证. 它仅取决于您的控制器需要什么数据:</p>
</div>
<div class="paragraph">
<p><code>principal(OAuth2AuthenticatedPrincipal)</code> 就是这样的一种,您可以使用它来配置作为 <code>BearerTokenAuthentication</code> 基础的完整 <code>OAuth2AuthenticatedPrincipal</code> 实例.</p>
</div>
<div class="paragraph">
<p>如果您:
1. 有自己的 <code>OAuth2AuthenticatedPrincipal</code> 实现, 或者
2. 想指定 principal 名字</p>
</div>
<div class="paragraph">
<p>例如,假设您的授权服务器在 <code>user_name</code> claim 中发送主体名称,而不在 <code>sub</code> claim 中发送主体名称. 在这种情况下,您可以手动配置 <code>OAuth2AuthenticatedPrincipal</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Map&lt;String, Object&gt; attributes = Collections.singletonMap("user_name", "foo_user");
OAuth2AuthenticatedPrincipal principal = new DefaultOAuth2AuthenticatedPrincipal(
        (String) attributes.get("user_name"),
        attributes,
        AuthorityUtils.createAuthorityList("SCOPE_message:read"));

client
    .mutateWith(mockOpaqueToken().principal(principal))
    .get().uri("/endpoint").exchange();
</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意,作为使用  <code>mockOpaqueToken()</code> 测试支持的替代方法,您还可以使用 <code>@MockBean</code> 注解来模拟 <code>OpaqueTokenIntrospector</code> bean本身.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="rsocket"><a class="anchor" href="#rsocket"></a>30. RSocket Security</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Spring Security 的 RSocket 支持依赖于 <code>SocketAcceptorInterceptor</code>.  安全性的主要入口点位 于 <code>PayloadSocketAcceptorInterceptor</code> 中,该接口使 RSocket API 适应于允许使用 <code>PayloadInterceptor</code> 实现拦截 <code>PayloadExchange</code> 的问题.</p>
</div>
<div class="paragraph">
<p>您可以找到一些示例程序来演示以下代码:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hello RSocket <a href="https://github.com/spring-projects/spring-security/master//boot/hellorsocket">hellorsocket</a></p>
</li>
<li>
<p><a href="https://github.com/rwinch/spring-flights/tree/security">Spring Flights</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="最小的-rsocket-安全配置"><a class="anchor" href="#最小的-rsocket-安全配置"></a>30.1. 最小的 RSocket 安全配置</h3>
<div class="paragraph">
<p>您可以在下面找到最小的 RSocket 安全配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Configuration
@EnableRSocketSecurity
public class HelloRSocketSecurityConfig {

    @Bean
    public MapReactiveUserDetailsService userDetailsService() {
        UserDetails user = User.withDefaultPasswordEncoder()
            .username("user")
            .password("user")
            .roles("USER")
            .build();
        return new MapReactiveUserDetailsService(user);
    }
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>此配置启用<a href="#rsocket-authentication-simple">simple authentication</a>,并设置 <a href="#rsocket-authorization">rsocket-authorization</a>  以要求经过身份验证的用户才能进行任何请求.</p>
</div>
</div>
<div class="sect2">
<h3 id="adding-securitysocketacceptorinterceptor"><a class="anchor" href="#adding-securitysocketacceptorinterceptor"></a>30.2. Adding SecuritySocketAcceptorInterceptor</h3>
<div class="paragraph">
<p>为了使 Spring Security 正常工作,我们需要将 <code>SecuritySocketAcceptorInterceptor</code> 应用于 <code>ServerRSocketFactory</code>.  这就是将我们使用 RSocket 基础结构创建的 <code>PayloadSocketAcceptorInterceptor</code> 连接起来的原因.
在 Spring Boot 应用程序中,这是通过 <code>RSocketSecurityAutoConfiguration</code> 通过以下代码自动完成的.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ServerRSocketFactoryProcessor springSecurityRSocketSecurity(
        SecuritySocketAcceptorInterceptor interceptor) {
    return builder -&gt; builder.addSocketAcceptorPlugin(interceptor);
}
</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-authentication"><a class="anchor" href="#rsocket-authentication"></a>30.3. RSocket 认证</h3>
<div class="paragraph">
<p>RSocket 身份验证是通过 <code>AuthenticationPayloadInterceptor</code> 来执行的,该 <code>AuthenticationPayloadInterceptor</code> 充当调用 <code>ReactiveAuthenticationManager</code> 实例的控制器.</p>
</div>
<div class="sect3">
<h4 id="rsocket-authentication-setup-vs-request"><a class="anchor" href="#rsocket-authentication-setup-vs-request"></a>30.3.1. 设置时的身份验证与请求时间</h4>
<div class="paragraph">
<p>通常,认证可以在建立时间和/或请求时间进行.</p>
</div>
<div class="paragraph">
<p>在某些情况下,设置时进行身份验证是有意义的.  常见的情况是单个用户(即移动连接) 利用 RSocket 连接时.  在这种情况下,只有一个用户可以利用该连接,因此可以在连接时进行一次身份验证.</p>
</div>
<div class="paragraph">
<p>在共享 RSocket 连接的情况下,有必要在每个请求上发送凭据.  例如,作为下游服务连接到 RSocket 服务器的 Web 应用程序将建立所有用户利用的单个连接.  在这种情况下,如果 RSocket 服务器需要根据 Web 应用程序的用户凭据执行授权,则每个请求都是有意义的.</p>
</div>
<div class="paragraph">
<p>在某些情况下,设置和按请求进行身份验证是有意义的.  考虑一个如上所述的 Web 应用程序.  如果我们需要限制与 Web 应用程序本身的连接,则可以在连接时提供具有 <code>SETUP</code> 权限的凭据.  这样,每个用户将具有不同的权限,但没有 SETUP 权限.  这意味着单个用户可以发出请求,但不能建立其他连接.</p>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-authentication-simple"><a class="anchor" href="#rsocket-authentication-simple"></a>30.3.2. Simple Authentication</h4>
<div class="paragraph">
<p>Spring Security 对 RSocket 的 <a href="https://github.com/rsocket/rsocket/blob/5920ed374d008abb712cb1fd7c9d91778b2f4a68/Extensions/Security/Simple.md">Simple Authentication Metadata Extension</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>基本身份验证草稿演变为简单身份验证,仅支持向后兼容.
请参阅  <code>RSocketSecurity.basicAuthentication(Customizer)</code> 进行设置.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>RSocket 接收器可以使用 <code>AuthenticationPayloadExchangeConverter</code> 来对凭据进行解码 而
<code>AuthenticationPayloadExchangeConverter</code> 可以使用 DSL 的 <code>simpleAuthentication</code> 部分自动设置.
可以在下面找到显式配置.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
PayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) {
    rsocket
        .authorizePayload(authorize -&gt;
            authorize
                    .anyRequest().authenticated()
                    .anyExchange().permitAll()
        )
        .simpleAuthentication(Customizer.withDefaults());
    return rsocket.build();
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>RSocket 发送者可以使用 <code>SimpleAuthenticationEncoder</code> 发送凭证,该凭证可以添加到 Spring 的 <code>RSocketStrategies</code> 中.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">RSocketStrategies.Builder strategies = ...;
strategies.encoder(new SimpleAuthenticationEncoder());
</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以使用它在设置中向接收者发送用户名和密码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MimeType authenticationMimeType =
    MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());
UsernamePasswordMetadata credentials = new UsernamePasswordMetadata("user", "password");
Mono&lt;RSocketRequester&gt; requester = RSocketRequester.builder()
    .setupMetadata(credentials, authenticationMimeType)
    .rsocketStrategies(strategies.build())
    .connectTcp(host, port);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以使用它在设置中向接收方发送用户名和密码:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">Mono&lt;RSocketRequester&gt; requester;
UsernamePasswordMetadata credentials = new UsernamePasswordMetadata("user", "password");

public Mono&lt;AirportLocation&gt; findRadar(String code) {
    return this.requester.flatMap(req -&gt;
        req.route("find.radar.{code}", code)
            .metadata(credentials, authenticationMimeType)
            .retrieveMono(AirportLocation.class)
    );
}
</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="rsocket-authentication-jwt"><a class="anchor" href="#rsocket-authentication-jwt"></a>30.3.3. JWT</h4>
<div class="paragraph">
<p>Spring Security 对 RSocket 的 <a href="https://github.com/rsocket/rsocket/blob/5920ed374d008abb712cb1fd7c9d91778b2f4a68/Extensions/Security/Bearer.md">Bearer Token Authentication Metadata Extension</a>.
支持以对 JWT 进行身份验证(确定 JWT 有效) 的形式出现,然后使用 JWT 做出授权决策.</p>
</div>
<div class="paragraph">
<p>RSocket 接收器可以使用 <code>BearerPayloadExchangeConverter</code> 解码凭据,而 <code>BearerPayloadExchangeConverter</code> 使用 DSL 的 <code>jwt</code> 部分自动设置.  可以在下面找到示例配置:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
PayloadSocketAcceptorInterceptor rsocketInterceptor(RSocketSecurity rsocket) {
    rsocket
        .authorizePayload(authorize -&gt;
            authorize
                .anyRequest().authenticated()
                .anyExchange().permitAll()
        )
        .jwt(Customizer.withDefaults());
    return rsocket.build();
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>上面的配置取决于是否存在 <code>ReactiveJwtDecoder</code> <code>@Bean</code>. 在发行人处创建一个示例的示例如下:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">@Bean
ReactiveJwtDecoder jwtDecoder() {
    return ReactiveJwtDecoders
        .fromIssuerLocation("https://example.com/auth/realms/demo");
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>RSocket 发送方不需要执行任何特殊操作即可发送令牌,因为该值只是一个简单的 String. 例如,可以在设置时发送令牌:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MimeType authenticationMimeType =
    MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());
BearerTokenMetadata token = ...;
Mono&lt;RSocketRequester&gt; requester = RSocketRequester.builder()
    .setupMetadata(token, authenticationMimeType)
    .connectTcp(host, port);
</code></pre>
</div>
</div>
<div class="paragraph">
<p>替代地或附加地,可以在请求中发送令牌.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">MimeType authenticationMimeType =
    MimeTypeUtils.parseMimeType(WellKnownMimeType.MESSAGE_RSOCKET_AUTHENTICATION.getString());
Mono&lt;RSocketRequester&gt; requester;
BearerTokenMetadata token = ...;

public Mono&lt;AirportLocation&gt; findRadar(String code) {
    return this.requester.flatMap(req -&gt;
        req.route("find.radar.{code}", code)
            .metadata(token, authenticationMimeType)
            .retrieveMono(AirportLocation.class)
    );
}
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="rsocket-authorization"><a class="anchor" href="#rsocket-authorization"></a>30.4. RSocket 授权</h3>
<div class="paragraph">
<p>RSocket 授权是通过 <code>AuthorizationPayloadInterceptor</code> 执行的,<code>AuthorizationPayloadInterceptor</code> 充当调用 <code>ReactiveAuthorizationManager</code> 实例的控制器.  DSL 可用于基于 <code>PayloadExchange</code> 设置授权规则.  可以在下面找到示例配置:</p>
</div>
<div id="source" class="listingblock">
<div class="content">
<pre>rsocket
    .authorizePayload(authorize -&gt;
        authz
            .setup().hasRole("SETUP") <i class="conum" data-value="1"></i><b>(1)</b>
            .route("fetch.profile.me").authenticated() <i class="conum" data-value="2"></i><b>(2)</b>
            .matcher(payloadExchange -&gt; isMatch(payloadExchange)) <i class="conum" data-value="3"></i><b>(3)</b>
                .hasRole("CUSTOM")
            .route("fetch.profile.{username}") <i class="conum" data-value="4"></i><b>(4)</b>
                .access((authentication, context) -&gt; checkFriends(authentication, context))
            .anyRequest().authenticated() <i class="conum" data-value="5"></i><b>(5)</b>
            .anyExchange().permitAll() <i class="conum" data-value="6"></i><b>(6)</b>
    )</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>建立连接需要权限 <code>ROLE_SETUP</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>如果路由为 <code>fetch.profile.me</code>,则授权仅要求对用户进行身份验证</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在此规则中,我们设置了一个自定义匹配器,其中的授权要求用户具有权限 <code>ROLE_CUSTOM</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>此规则利用自定义授权.  匹配器用名称  <code>username</code> 表示变量,该变量在 <code>context</code> 中可用.  自定义授权规则在 <code>checkFriends</code> 方法中暴露.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>此规则可确保没有规则的请求将要求对用户进行身份验证.  请求是包含元数据的地方.  它不会包括其他有效载荷.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>该规则可确保任何人都没有规则的任何交换.  在此示例中,这意味着没有元数据的有效负载没有授权规则.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>重要的是要了解授权规则是按顺序执行的.  仅匹配的第一个授权规则将被调用.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes">
<hr>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. The modules <code>apacheds-core</code>, <code>apacheds-core-entry</code>, <code>apacheds-protocol-shared</code>, <code>apacheds-protocol-ldap</code> and <code>apacheds-server-jndi</code> are required.
</div>
<div class="footnote" id="_footnotedef_2">
<a href="#_footnoteref_2">2</a>. 也可以使用DNS查找来获取服务器的IP地址.  目前尚不支持此功能,但希望在以后的版本中可用.
</div>
<div class="footnote" id="_footnotedef_3">
<a href="#_footnoteref_3">3</a>. . 如果存储库包含安全上下文,则过滤器不执行任何操作. 如果不是,并且线程本地 <code>SecurityContext</code> 包含 (非匿名) 身份验证对象,则过滤器将假定它们已由堆栈中的先前过滤器进行了身份验证.  然后它将调用配置的 <code>SessionAuthenticationStrategy</code>.
</div>
<div class="footnote" id="_footnotedef_4">
<a href="#_footnoteref_4">4</a>. 本质上,用户名不包含在cookie中,以防止不必要地暴露有效的登录名.  本文的评论部分对此进行了讨论.
</div>
<div class="footnote" id="_footnotedef_5">
<a href="#_footnoteref_5">5</a>. 这里不应该将 key 属性的使用提供任何真正的安全性. 这只是一个簿记练习. 如果在可能进行身份验证的客户端构造 "Authentication" 对象(例如使用RMI调用) 的情况下共享一个包含 "AnonymousAuthenticationProvider" 的 "ProviderManager",则恶意客户端可以提交 "AnonymousAuthenticationToken".  它自己创建的(具有选择的用户名和权限列表) . 如果 "密钥" 是可猜测的或可以被发现,那么令牌将被匿名提供者接受. 正常使用情况下这不是问题,但是如果您使用的是 RMI,则最好使用自定义的 "ProviderManager",它会省略匿名提供程序,而不是共享用于HTTP身份验证机制的提供程序.
</div>
<div class="footnote" id="_footnotedef_6">
<a href="#_footnoteref_6">6</a>. 当浏览器不支持cookie且将 <code>jsessionid</code> 参数附加到分号后的URL时,您可能已经看到了. 但是,RFC允许这些参数出现在URL的任何路径段中
</div>
<div class="footnote" id="_footnotedef_7">
<a href="#_footnoteref_7">7</a>. 一旦请求离开 <code>FilterChainProxy</code>,原始值将被返回,因此对于应用程序仍然可用.
</div>
<div class="footnote" id="_footnotedef_8">
<a href="#_footnoteref_8">8</a>. 因此,例如,原始请求路径 <code>/secure;hack=1/somefile.html;hack=2</code> 将作为  <code>/secure/somefile.html</code> 返回.
</div>
<div class="footnote" id="_footnotedef_9">
<a href="#_footnoteref_9">9</a>. Spring Security 2.0的遗留选项也受支持,但不建议使用
</div>
<div class="footnote" id="_footnotedef_10">
<a href="#_footnoteref_10">10</a>. 您可以在 pass:specialcharacters,macros [<a href="#servlet-authentication-ldap">LDAP 认证</a>
</div>
<div class="footnote" id="_footnotedef_11">
<a href="#_footnoteref_11">11</a>. 请参阅有关通行证的部分: 特殊字符,宏[<a href="#servlet-httpfirewall"><code>HttpFirewall</code></a>
</div>
<div class="footnote" id="_footnotedef_12">
<a href="#_footnoteref_12">12</a>. access 属性中逗号分隔值的解释取决于所使用的 <code><a href="#ns-access-manager">AccessDecisionManager</a></code> 的实现.
</div>
<div class="footnote" id="_footnotedef_13">
<a href="#_footnoteref_13">13</a>. 有关如何从 <code>web.xml</code> 中设置映射的信息,请参见 <a href="#ns-web-xml">introductory chapter</a>
</div>
<div class="footnote" id="_footnotedef_14">
<a href="#_footnoteref_14">14</a>. 此功能实际上只是为了方便起见而提供的,并不打算用于生产 (在该功能中,将选择一种查看技术,并可用于呈现自定义的登录页面) .  类 <code>DefaultLoginPageGeneratingFilter</code> 负责呈现登录页面,并在需要时提供用于普通表单登录和/或 OpenID 的登录表单.
</div>
<div class="footnote" id="_footnotedef_15">
<a href="#_footnoteref_15">15</a>. 这不会影响 <code>PersistentTokenBasedRememberMeServices</code> 的使用,因为令牌存储在服务器端.
</div>
<div class="footnote" id="_footnotedef_16">
<a href="#_footnoteref_16">16</a>. FilterInvocation 对象包含 HttpServletRequest,因此您可以获取 URL 或任何其他相关信息,并根据这些信息来决定返回的属性列表将包含哪些内容.
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-09-13 15:53:13 +0800
</div>
</div>
</div>
  </div>
</div>
</body>
</html>
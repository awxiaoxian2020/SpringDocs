Processors 既是一种特别的发布者(`Publisher`)又是一种订阅者(`Subscriber`). 那意味着你可以 `subscribe` 一个 `Processor`(通常它们会实现 `Flux`),也可以调用相关方法来手动 插入数据到序列,或终止序列.

Processor 有多种类型,它们都有特别的语义规则,但是在你研究它们之前,最好问一下 自己如下几个问题:

= 我是否需要使用 Processor?
多数情况下,你应该进行避免使用 `Processor`,它们较难正确使用,主要用于一些特殊场景下.

如果你觉得 `Processor` 适合你的使用场景,请首先看一下是否尝试过以下两种替代方式:

. 是否有一个或多个操作符的组合能够满足需求? (See <<which-operator>>.)
. <<producing,"`generator`">> 操作符是否能解决问题? (通常这些操作符 可以用来桥接非响应式的 API,它们提供了一个 "`sink`",在生成数据流序列方面, 概念上类似于 `Processor`)

如果看了以上替代方案,你仍然觉得需要一个 `Processor`,阅读 现有的 <<processor-overview>> 这一节来了解一下不同的实现吧.

= 使用 `Sink` 门面对象来线程安全地生成流
比起直接使用 Reactor 的 `Processors`,更好的方式是通过调用一次 `sink()` 来得到 `Processor` 的 `Sink`.

`FluxProcessor` 的 sink 是线程安全的"生产者(producer),因此能够在应用程序中 多线程并发地生成数据.例如,一个线程安全的序列化(serialized)的 sink 能够通过 `UnicastProcessor` 创建:

====
[source,java]
----
UnicastProcessor<Integer> processor = UnicastProcessor.create();
FluxSink<Integer> sink = processor.sink(overflowStrategy);
----
====

多个生产者线程可以并发地生成数据到以下的序列化 sink.

====
[source,java]
----
sink.next(n);
----
====

WARNING: Despite the `FluxSink` being adapted for multi-threaded *manual* feeding
of the `Processor`, it is not possible to mix the subscriber approach with the
sink approach: You have to either subscribe your `FluxProcessor` to a source
`Publisher` or feed it manually though its `FluxSink`.

根据 `Processor` 及其配置,`next` 产生的溢出有两种可能的处理方式:

* 一个无限的 processor 通过丢弃或缓存自行处理溢出
* 一个有限的 `processor` 阻塞在 `IGNORE` 策略,或将 `overflowStrategy` 应用于 `sink`.

[[processor-overview]]
= 现有的 Processors 总览
Reactor Core 内置多种 `Processor`.这些 processor 具有不同的语法,大概分为三类. 下边简要介绍一下这三种 processor:

* *direct(直接的)* (`DirectProcessor` 和 `UnicastProcessor`): 这些 processors 只能通过直接 调用 `Sink` 的方法来推送数据.
* *synchronous(同步的)* (`EmitterProcessor` 和 `ReplayProcessor`): 这些 processors 既可以 直接调用 Sink 方法来推送数据,也可以通过订阅到一个上游的发布者来同步地产生数据.

TIP: 将事件发布到不同线程上的一种方法是将 `EmitterProcessor` 与 `publishOn(Scheduler)` 结合使用. 例如,替代以前的 `TopicProcessor`,该 `TopicProcessor` 使用的是不安全操作, 并已在3.3.0中移至 https://github.com/reactor/reactor-addons/tree/master/reactor-extra/src/main/java/reactor/extra/processor[reactor-extra] 中.

== Direct Processor

Direct `Processor` 可以将信号分发给零到多个订阅者(`Subscribers`).它是最容易实例化的,使用静态方法 `DirectProcessor#create()` 即可.另一方面,它的不足是无法处理背压.
所以,当 `DirectProcessor` 推送的是 N 个元素,而至少有一个订阅者的请求个数少于 N 的时候,就会发出一个 `IllegalStateException`.

一旦 `Processor` 终止(通常通过调用它的 Sink 的 `error(Throwable)` 或 `complete()` 方法), 虽然它允许更多的订阅者订阅它,但是会立即向它们重新发送终止信号.

== Unicast Processor

`UnicastProcessor` 可以使用一个内置的缓存来处理背压.代价就是它最多只能有一个订阅者 `Subscriber`.

`UnicastProcessor` 有多种选项,因此提供多种不同的 `create` 静态方法.例如,它默认是 无限的(unbounded) : 如果你在在订阅者还没有请求数据的情况下让它推送数据,它会缓存所有数据.

可以通过提供一个自定义的 `Queue` 的具体实现传递给 `create` 工厂方法来改变默认行为.如果给出的队列是 有限的(bounded), 并且缓存已满,而且未收到下游的请求,processor 会拒绝推送数据.

在上边 有限的 例子中,还可以在构造 processor 的时候提供一个回调方法,这个回调方法可以在每一个 被拒绝推送的元素上调用,从而让开发者有机会清理这些元素

== Emitter Processor

`EmitterProcessor` 能够向多个订阅者发送数据,并且可以对每一个订阅者进行背压处理.它本身也可以订阅一个 `Publisher` 并同步获得数据.

最初如果没有订阅者,它仍然允许推送一些数据到缓存,缓存大小由 `bufferSize` 定义. 之后如果仍然没有订阅者订阅它并消费数据,对 `onNext` 的调用会阻塞,直到有订阅者接入 (这时只能并发地订阅了).

因此第一个 `订阅者` 会收到最多 `bufferSize` 个元素.然而之后, processor 不会重新发送(replay) 数据给后续的订阅者.这些后续接入的订阅者只能获取到它们开始订阅 之后 推送的数据.
这个内部的 缓存会继续用于背压的目的.

默认情况下,如果所有的订阅者都取消了(基本意味着它们都不再订阅(un-subscribed)了), 它会清空内部缓存,并且不再接受更多的订阅者.这一点可以通过 `create` 静态工厂方法的 `autoCancel` 参数来配置.

== Replay Processor

`ReplayProcessor` 会缓存直接通过自身的 `Sink` 推送的元素,以及来自上游发布者的元素, 并且后来的订阅者也会收到重发(`replay`)的这些元素.

可以通过多种配置方式创建它:

* 缓存一个元素 (`cacheLast`).
* 缓存一定个数的历史元素 (`create(int)`) 或 所有的历史元素 (`create()`).
* 缓存基于时间窗期间内的元素 (`createTimeout(Duration)`).
* 缓存基于历史个数和时间窗的元素 (`createSizeOrTimeout(int, Duration)`).

//TODO == MonoProcessor

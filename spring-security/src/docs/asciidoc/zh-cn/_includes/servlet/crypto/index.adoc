[[crypto]]
= Spring Security 加密 模块


[[spring-security-crypto-introduction]]
== 简介
Spring Security Crypto模块提供对对称加密,密钥生成和密码编码的支持.  该代码作为核心模块的一部分分发,但与任何其他Spring Security(或Spring) 代码无关.


[[spring-security-crypto-encryption]]
== Encryptors(加密器)
`Encryptors` 类提供了用于构造对称加密器的工厂方法.  使用此类,您可以创建 `ByteEncryptor` 来以原始 `byte[]` 形式加密数据.  您还可以构造 `TextEncryptor` 来加密文本字符串.  加密器是线程安全的.

[[spring-security-crypto-encryption-bytes]]
=== BytesEncryptor
使用 `Encryptors.stronger` 工厂方法来构造 `BytesEncryptor`:

[source,java]
----
Encryptors.stronger("password", "salt");
----

"stronger" 加密方法是使用 Galois Counter Mode (GCM) 的256位AES. 它使用PKCS#5的PBKDF2(基于密码的密钥扩展功能#2) 的密钥. 此方法需要 Java6. 用于生成 SecretKey 的密码应保存在安全的地方,并且不能共享.  如果您的加密数据遭到破坏,该盐可用于防止针对密钥的字典攻击.  还应用了16字节的随机初始化向量,因此每个加密的消息都是唯一的.

提供的盐应采用十六进制编码的字符串形式,并且是随机的,并且长度至少为8个字节.  可以使用KeyGenerator生成这种盐:

[source,java]
----
String salt = KeyGenerators.string().generateKey(); // generates a random 8-byte salt that is then hex-encoded
----

用户还可以使用 standard 加密方法,即  Cipher Block Chaining (CBC) 模式下的 256 位 AES. 此模式未经  https://en.wikipedia.org/wiki/Authenticated_encryption[authenticated],不提供有关数据真实性的任何保证. 为了获得更安全的选择,用户应首选 `Encryptors.stronger`.

[[spring-security-crypto-encryption-text]]
=== TextEncryptor
使用 `Encryptors.text` 工厂方法构造一个标准的 `TextEncryptor`:

[source,java]
----

Encryptors.text("password", "salt");
----

TextEncryptor使用标准的BytesEncryptor来加密文本数据.  加密结果以十六进制编码的字符串形式返回,以便于存储在文件系统或数据库中.

使用Encryptors.queryableText工厂方法构造一个 "queryable" TextEncryptor:

[source,java]
----
Encryptors.queryableText("password", "salt");
----

可查询的 TextEncryptor与标准 TextEncryptor 之间的区别与初始化向量(iv) 处理有关.  可查询 TextEncryptor#encrypt 操作中使用的iv是共享的或常量,并且不会随机生成.  这意味着多次加密相同的文本将始终产生相同的加密结果.  这不太安全,但是对于需要查询的加密数据来说是必需的.  可查询的加密文本的一个示例是OAuth apiKey.

[[spring-security-crypto-keygenerators]]
== 密钥生成器
KeyGenerators类为构造不同类型的密钥生成器提供了许多便利的工厂方法.  使用此类,您可以创建一个 BytesKeyGenerator 来生成byte []键.  您还可以构造一个StringKeyGenerator来生成字符串键.  KeyGenerators是线程安全的.

=== BytesKeyGenerator
使用 `KeyGenerators.secureRandom` 工厂方法来生成由 SecureRandom 实例支持的 BytesKeyGenerator:

[source,java]
----
BytesKeyGenerator generator = KeyGenerators.secureRandom();
byte[] key = generator.generateKey();
----

默认密钥长度为8个字节. 还有一个KeyGenerators.secureRandom变体,可以控制密钥长度:

[source,java]
----
KeyGenerators.secureRandom(16);
----

使用KeyGenerators.shared工厂方法构造一个BytesKeyGenerator,该每次调用总是返回相同的密钥:

[source,java]
----
KeyGenerators.shared(16);
----

=== StringKeyGenerator
使用KeyGenerators.string工厂方法来构造一个8字节的SecureRandom KeyGenerator,该十六进制将每个密钥编码为字符串:

[source,java]
----
KeyGenerators.string();
----

[[spring-security-crypto-passwordencoders]]
== Password Encoding
spring-security-crypto模块的密码软件包提供了对密码编码的支持.  `PasswordEncoder` 是中央服务接口,具有以下签名:

[source,java]
----
public interface PasswordEncoder {

String encode(String rawPassword);

boolean matches(String rawPassword, String encodedPassword);
}
----

如果rawPassword一旦编码,等于已编码的Password,则matchs方法返回true.  此方法旨在支持基于密码的身份验证方案.

`BCryptPasswordEncoder` 实现使用广泛支持的 "bcrypt" 算法来对密码进行哈希处理.  Bcrypt使用一个随机的16字节盐值,并且是一种故意慢速的算法,目的是阻止密码破解者.  可以使用 "strength" 参数调整它所做的工作量,该参数的取值范围为4到31. 值越高,计算散列所需的工作就越多.  默认值为10. 您可以在已部署的系统中更改此值,而不会影响现有密码,因为该值也存储在编码的哈希中.

[source,java]
----

// Create an encoder with strength 16
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder(16);
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
----

`Pbkdf2PasswordEncoder` 实现使用PBKDF2算法对密码进行哈希处理.  为了破解密码破解,PBKDF2是一种故意缓慢的算法,应调整为大约0.5秒以验证系统上的密码.


[source,java]
----

// Create an encoder with all the defaults
Pbkdf2PasswordEncoder encoder = new Pbkdf2PasswordEncoder();
String result = encoder.encode("myPassword");
assertTrue(encoder.matches("myPassword", result));
----

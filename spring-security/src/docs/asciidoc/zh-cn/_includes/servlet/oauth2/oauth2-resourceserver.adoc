[[oauth2resourceserver]]
== OAuth 2.0 资源服务器
:figures: {image-resource}/servlet/oauth2
:icondir: {image-resource}/icons

Spring Security 支持使用两种形式的 OAuth 2.0 https://tools.ietf.org/html/rfc6750.html[Bearer Tokens] 来保护端点:

* https://tools.ietf.org/html/rfc7519[JWT]
* Opaque Tokens

在应用程序将其权限管理委派给 https://tools.ietf.org/html/rfc6749[授权服务器]  (例如Okta或Ping Identity) 的情况下,这很方便.  资源服务器可以咨询该授权服务器以授权请求.

本节详细介绍了 Spring Security 如何提供对 OAuth 2.0 的支持 https://tools.ietf.org/html/rfc6750.html[Bearer Tokens].

[NOTE]
====
Spring Security {gh-samples-url}[Spring Security repository] 中提供了  {gh-samples-url}/boot/oauth2resourceserver[JWTs] 和 {gh-samples-url}/boot/oauth2resourceserver-opaque[Opaque Tokens] 的示例.
====

让我们看一下 Bearer Token Authentication 在 Spring Security 中的工作方式. 首先， 我们看到， 与 <<servlet-authentication-basic,Basic Authentication>> 一样， https://tools.ietf.org/html/rfc7235#section-4.1[WWW-Authenticate] 头被发送回未经身份验证的客户端.

.Sending WWW-Authenticate Header
image::{figures}/bearerauthenticationentrypoint.png[]

上图基于我们的 <<servlet-securityfilterchain,`SecurityFilterChain`>>  图.

image:{icondir}/number_1.png[] 首先， 用户向 `/private` 资源请求未经身份验证的请求.

image:{icondir}/number_2.png[] Spring Security 的 <<servlet-authorization-filtersecurityinterceptor,`FilterSecurityInterceptor`>> 通过抛出 `AccessDeniedException` 异常来表示未经身份验证的请求被拒绝. .

image:{icondir}/number_3.png[] 由于用户未经身份验证, <<servlet-exceptiontranslationfilter,`ExceptionTranslationFilter`>> 启动身份验证.配置的 <<servlet-authentication-authenticationentrypoint,`AuthenticationEntryPoint`>> 是 {security-api-url}org/springframework/security/oauth2/server/resource/authentication/BearerTokenAuthenticationEntryPoint.html[`BearerTokenAuthenticationEntryPoint`] 的实例 它发送了一个 WWW-Authenticate header.
`RequestCache` 通常是 `NullRequestCache` 它不保存请求， 因为客户端能够重播最初请求的请求.

当客户端收到 `WWW-Authenticate: Bearer` header 时， 它知道如何重新处理 bearer token.  下面是处理的承 bearer token 的流程.

[[oauth2resourceserver-authentication-bearertokenauthenticationfilter]]
.Authenticating Bearer Token
image::{figures}/bearertokenauthenticationfilter.png[]

The figure builds off our <<servlet-securityfilterchain,`SecurityFilterChain`>> diagram.

image:{icondir}/number_1.png[] 当用户提交他们的 bearer token 时, `BearerTokenAuthenticationFilter` 会创建一个 `BearerTokenAuthenticationToken` .它是通过从 `HttpServletRequest`  中提取令牌的一种 <<servlet-authentication-authentication,`Authentication`>> .

image:{icondir}/number_2.png[] 接下来, `HttpServletRequest` 将传递给 `AuthenticationManagerResolver`, 用于选择 `AuthenticationManager`.  `BearerTokenAuthenticationToken` 将被传递到已验证的 `AuthenticationManager` 中.
`AuthenticationManager` 看起来依赖与您配置的是 <<oauth2resourceserver-jwt-minimalconfiguration,JWT>> 或 <<oauth2resourceserver-opaque-minimalconfiguration,opaque token>>.

image:{icondir}/number_3.png[] 如果身份验证失败， 则失败

* <<servlet-authentication-securitycontextholder>> 被清除.
* 调用 `AuthenticationEntryPoint` 以触发再次发送的 WWW-Authenticate header.

image:{icondir}/number_4.png[] 如果身份验证成功， 则成功.

* 在 <<servlet-authentication-securitycontextholder>> 设置 <<servlet-authentication-authentication>>.
* `BearerTokenAuthenticationFilter` 调用 `FilterChain.doFilter(request,response)` 继续应用程序逻辑的其余部分. .

[[oauth2resourceserver-jwt-minimalconfiguration]]
=== JWT 的最小配置

使用 https://spring.io/projects/spring-boot[Spring Boot] 时,将应用程序配置为资源服务器包括两个基本步骤.  首先,包括所需的依赖,其次,指示授权服务器的位置.

==== 指定授权服务器

在Spring Boot应用程序中,要指定要使用的授权服务器,只需执行以下操作:

[source,yml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com/issuer
----

其中 `https://idp.example.com/issuer` 是授权服务器将颁发的JWT令牌的 `iss` 声明中包含的值.  资源服务器将使用此属性进行进一步的自我配置,发现授权服务器的公钥,然后验证传入的JWT.

[NOTE]
要使用 `issuer-uri` 属性,还必须确保 `https://idp.example.com/issuer/.well-known/openid-configuration`, `https://idp.example.com/.well-known/openid-configuration/issuer`, 或  `https://idp.example.com/.well-known/oauth-authorization-server/issuer` 是授权服务器支持的端点.
此端点称为 https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig[Provider Configuration]  端点或授权服务器 https://tools.ietf.org/html/rfc8414#section-3[Authorization Server Metadata] 端点.


就是这样！

==== 启动预期

使用此属性和这些依赖时,资源服务器将自动配置自身以验证JWT编码的 Bearer 令牌.

它通过确定性的启动过程来实现:



1. 点击提供者配置或授权服务器元数据端点,处理 `jwks_url` 属性的响应
2. 配置验证策略以查询 `jwks_url` 以获取有效的公共密钥
3. 配置验证策略,以根据 `https://idp.example.com` 验证每个JWT的 `iss` 声明.

此过程的结果是,授权服务器必须启动并接收请求,才能成功启动资源服务器.

[NOTE]
如果在资源服务器查询授权服务器时授权服务器已关闭 (给出适当的超时) ,则启动将失败.

==== 运行时预期

应用程序启动后,资源服务器将尝试处理任何包含 `Authorization: Bearer`  头的请求:

[source,html]
----
GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this
----

只要指示了此方案,资源服务器就会尝试根据Bearer Token规范处理请求.

给定格式正确的JWT,资源服务器将:



1. 在启动期间根据从 `jwks_url` 端点获取并与JWTs header 匹配的公钥验证其签名
2. 验证JWT的 `exp` 和 `nbf` 时间戳以及 JWT 的 `iss` 声明,以及
3. 将每个范围映射到具有前缀 `SCOPE_` 的权限.

[NOTE]
当授权服务器提供新的密钥时,Spring Security 将自动旋转用于验证 JWTs 令牌的密钥.

默认情况下,生成的  `Authentication#getPrincipal` 是 Spring Security `Jwt` 对象,并且  `Authentication#getName` 映射到JWT的 `sub` 属性 (如果存在) .

从这里,考虑跳到:

* <<oauth2resourceserver-jwt-architecture,How JWT Authentication Works>>
* <<oauth2resourceserver-jwt-jwkseturi,How to Configure without tying Resource Server startup to an authorization server's availability>>
* <<oauth2resourceserver-jwt-sansboot,How to Configure without Spring Boot>>

[[oauth2resourceserver-jwt-architecture]]
=== JWT Authentication 如何工作

接下来， 让我们看看 Spring Security 用于支持基于 Servlet 的应用程序的 https://tools.ietf.org/html/rfc7519[JWT] 身份验证的架构组件， 如我们刚刚看到的应用程序.

{security-api-url}org/springframework/security/oauth2/server/resource/authentication/JwtAuthenticationProvider.html[`JwtAuthenticationProvider`] 是一个 <<servlet-authentication-authenticationprovider,`AuthenticationProvider`>> 的进一步实现， <<oauth2resourceserver-jwt-decoder,`JwtDecoder`>> 和 <<oauth2resourceserver-jwt-authorization-extraction,`JwtAuthenticationConverter`>> 进行身份验证 JWT.

让我们来看看 `JwtAuthenticationProvider` 如何在 Spring Security 中工作.  该图解释了 <<oauth2resourceserver-authentication-bearertokenauthenticationfilter,Reading the Bearer Token>> 中的 <<servlet-authentication-authenticationmanager,`AuthenticationManager`>> 的详细信息.

.`JwtAuthenticationProvider` Usage
image::{figures}/jwtauthenticationprovider.png[]

读取承载令牌的身份验证过滤器将BearerTokenauthentInceStokentToken传递给AuthenticationManager， 该验证管理器由ProviderManager实现.

ProviderManager配置为使用jwtauthenticationProvider类型的AuthenticationProvider.

使用jwtdecoder， jwtauthenticationProvider Provide， 验证并验证JWT.

JwtauthenticationProvider然后使用jwtauthenticationConverter将JWT转换为授予权限的集合.

当身份验证成功时， 返回的身份验证是jwtauthenticationToken类型， 并且具有由配置的jwtdecoder返回的jwt的主体.  最终， 返回的jwtauthenticationtokent将通过身份验证过滤器设置在SecurityContextholder上.

image:{icondir}/number_1.png[] <<oauth2resourceserver-authentication-bearertokenauthenticationfilter,Reading the Bearer Token>> 的 authentication `Filter` 将 `BearerTokenAuthenticationToken` 传递给由 <<servlet-authentication-providermanager,`ProviderManager`>>. 实现的 `AuthenticationManager`.

image:{icondir}/number_2.png[] `ProviderManager` 配置为使用 `JwtAuthenticationProvider` 类型的<<servlet-authentication-authenticationprovider>>.

[[oauth2resourceserver-jwt-architecture-jwtdecoder]]
image:{icondir}/number_3.png[] `JwtAuthenticationProvider` 使用 <<oauth2resourceserver-jwt-decoder,`JwtDecoder`>> decodes, verifies, and validates the `Jwt`.

[[oauth2resourceserver-jwt-architecture-jwtauthenticationconverter]]
image:{icondir}/number_4.png[] 然后,`JwtAuthenticationProvider` 使用 <<oauth2resourceserver-jwt-authorization-extraction,`JwtAuthenticationConverter`>> 将 `Jwt` 转换为已授予权限的集合.

image:{icondir}/number_5.png[] 当身份验证成功时， 返回的 <<servlet-authentication-authentication,`Authentication`>> 类型为 `JwtAuthenticationToken` 并且具有由配置的 `JwtDecoder` 返回的 `Jwt` 主体.
最终， 返回的 `JwtAuthenticationToken` 将通过身份验证 `Filter` 设置在 <<servlet-authentication-securitycontextholder,`SecurityContextHolder`>>上.


[[oauth2resourceserver-jwt-jwkseturi]]
=== 直接指定授权服务器 JWK 设置 Uri

如果授权服务器不支持任何配置端点,或者如果资源服务器必须能够独立于授权服务器启动,那么还可以提供 `jwk-set-uri`:

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: https://idp.example.com
          jwk-set-uri: https://idp.example.com/.well-known/jwks.json
----

[NOTE]
JWK Set uri尚未标准化,但通常可以在授权服务器的文档中找到

因此,资源服务器在启动时不会对授权服务器执行ping操作.  我们仍然指定 `issuer-uri`,以便Resource Server仍然验证传入JWT上的 `iss` 声明.

[NOTE]
此属性也可以直接在<<oauth2resourceserver-jwt-jwkseturi-dsl,DSL>>上提供.

[[oauth2resourceserver-jwt-sansboot]]
=== 覆盖或替换引导自动配置

Spring Boot代表Resource Server生成了两个 `@Bean`.

第一个是将应用程序配置为资源服务器的 `WebSecurityConfigurerAdapter`.  当包含 `spring-security-oauth2-jose` 时,此 `WebSecurityConfigurerAdapter` 看起来像:

.Default JWT Configuration
====
.Java
[source,java,role="primary"]
----
protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -> authorize
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        oauth2ResourceServer {
            jwt { }
        }
    }
}
----
====

如果应用程序未暴露 `WebSecurityConfigurerAdapter` Bean,则Spring Boot将暴露上述默认值.

替换它就像在应用程序中暴露Bean一样简单:

.Custom JWT Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwtAuthenticationConverter(myConverter())
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("SCOPE_message:read"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwtAuthenticationConverter = myConverter()
                }
            }
        }
    }
}
----
====

以上要求 `message:read` 的范围: 以 `/messages/` 开头的所有URL.

`oauth2ResourceServer` DSL上的方法还将覆盖或替换自动配置.

[[oauth2resourceserver-jwt-decoder]]
例如,第二个 `@Bean` Spring Boot 创建的是 `JwtDecoder`,它将 `String` 令牌解码为经过验证的 `Jwt` 实例:


.JWT Decoder
====
.Java
[source,java,role="primary"]
----
@Bean
public JwtDecoder jwtDecoder() {
    return JwtDecoders.fromIssuerLocation(issuerUri);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    return JwtDecoders.fromIssuerLocation(issuerUri)
}
----
====


[NOTE]
调用  `{security-api-url}org/springframework/security/oauth2/jwt/JwtDecoders.html#fromIssuerLocation-java.lang.String-[JwtDecoders#fromIssuerLocation]` 是调用提供者配置或授权服务器元数据端点以扩展 JWK 设置 Uri 的过程.

如果该应用程序未暴露 `JwtDecoder` Bean,则Spring Boot将暴露上述默认值.

可以使用 `jwkSetUri()` 覆盖其配置,也可以使用 `decoder()` 替换其配置.

或者,如果您根本不使用Spring Boot,那么这两个组件-过滤器链和 `JwtDecoder` 可以在XML中指定.

过滤器链的指定如下:

.Default JWT Configuration
====
.Xml
[source,xml,role="primary"]
----
<http>
    <intercept-uri pattern="/**" access="authenticated"/>
    <oauth2-resource-server>
        <jwt decoder-ref="jwtDecoder"/>
    </oauth2-resource-server>
</http>
----
====

And the `JwtDecoder` like so:

.JWT Decoder
====
.Xml
[source,xml,role="primary"]
----
<bean id="jwtDecoder"
        class="org.springframework.security.oauth2.jwt.JwtDecoders"
        factory-method="fromIssuerLocation">
    <constructor-arg value="${spring.security.oauth2.resourceserver.jwt.jwk-set-uri}"/>
</bean>
----
====

[[oauth2resourceserver-jwt-jwkseturi-dsl]]
==== 使用 `jwkSetUri()`

授权服务器的JWK设置Uri可以配置为<<oauth2resourceserver-jwt-jwkseturi,as a configuration property>>,也可以在DSL中提供:

.JWK Set Uri Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwkSetUri("https://idp.example.com/.well-known/jwks.json")
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class DirectlyConfiguredJwkSetUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwkSetUri = "https://idp.example.com/.well-known/jwks.json"
                }
            }
        }
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/**" access="authenticated"/>
    <oauth2-resource-server>
        <jwt jwk-set-uri="https://idp.example.com/.well-known/jwks.json"/>
    </oauth2-resource-server>
</http>
----
====

使用 `jwkSetUri()` 优先于任何配置属性.

[[oauth2resourceserver-jwt-decoder-dsl]]
==== 使用 `decoder()`

比 `jwkSetUri()` 更强大的是 `decoder()`,它将完全替代 <<oauth2resourceserver-jwt-architecture-jwtdecoder,`JwtDecoder`>> 的所有 Boot 自动配置:

.JWT Decoder Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class DirectlyConfiguredJwtDecoder extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .decoder(myCustomDecoder())
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class DirectlyConfiguredJwtDecoder : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt {
                    jwtDecoder = myCustomDecoder()
                }
            }
        }
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/**" access="authenticated"/>
    <oauth2-resource-server>
        <jwt decoder-ref="myCustomDecoder"/>
    </oauth2-resource-server>
</http>
----
====


当需要进行更深入的配置 (例如<<oauth2resourceserver-jwt-validation,validation>>,<<oauth2resourceserver-jwt-claimsetmapping,mapping>>或<<oauth2resourceserver-jwt-timeouts,request timeouts>>) 时,这非常方便.

[[oauth2resourceserver-jwt-decoder-bean]]
==== 暴露  `JwtDecoder` `@Bean`

或者,暴露 <<oauth2resourceserver-jwt-architecture-jwtdecoder,`JwtDecoder`>> `@Bean` 与  `decoder()` 具有相同的效果:

====
.Java
[source,java,role="primary"]
----
@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()
}
----
====

[[oauth2resourceserver-jwt-decoder-algorithm]]
=== 配置可信算法

默认情况下,`NimbusJwtDecoder` 以及资源服务器将仅使用 `RS256` 信任和验证令牌.

您可以通过<<oauth2resourceserver-jwt-boot-algorithm,Spring Boot>>,<<oauth2resourceserver-jwt-decoder-builder,NimbusJwtDecoder Builder>>或从<<oauth2resourceserver-jwt-decoder-jwk-response,JWK Set response>>中对此进行自定义.

[[oauth2resourceserver-jwt-boot-algorithm]]
==== 通过Spring Boot

设置算法的最简单方法是作为属性:

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jws-algorithm: RS512
          jwk-set-uri: https://idp.example.org/.well-known/jwks.json
----

[[oauth2resourceserver-jwt-decoder-builder]]
==== 使用 Builder

但是,为了获得更大的功能,我们可以使用 `NimbusJwtDecoder` 附带的 Builder:

====
.Java
[source,java,role="primary"]
----
@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).build()
}
----
====

多次调用 `jwsAlgorithm` 会将 `NimbusJwtDecoder` 配置为信任多个算法,如下所示:

====
.Java
[source,java,role="primary"]
----
@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithm(RS512).jwsAlgorithm(ES512).build()
}
----
====

或者,您可以调用 `jwsAlgorithms`:

====
.Java
[source,java,role="primary"]
----
@Bean
JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms(algorithms -> {
                    algorithms.add(RS512);
                    algorithms.add(ES512);
            }).build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(this.jwkSetUri)
            .jwsAlgorithms {
                it.add(RS512)
                it.add(ES512)
            }.build()
}
----
====

[[oauth2resourceserver-jwt-decoder-jwk-response]]
==== 来自 JWK Set 的回复

由于 Spring Security 的 JWT 支持基于 Nimbus,因此您也可以使用其所有出色的功能.

例如,Nimbus有一个 `JWSKeySelector` 实现,它将基于JWK Set URI响应选择算法集.
您可以使用它生成 `NimbusJwtDecoder`,如下所示:

====
.Java
[source,java,role="primary"]
----
@Bean
public JwtDecoder jwtDecoder() {
    // makes a request to the JWK Set endpoint
    JWSKeySelector<SecurityContext> jwsKeySelector =
            JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(this.jwkSetUrl);

    DefaultJWTProcessor<SecurityContext> jwtProcessor =
            new DefaultJWTProcessor<>();
    jwtProcessor.setJWSKeySelector(jwsKeySelector);

    return new NimbusJwtDecoder(jwtProcessor);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    // makes a request to the JWK Set endpoint
    val jwsKeySelector: JWSKeySelector<SecurityContext> = JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL<SecurityContext>(this.jwkSetUrl)
    val jwtProcessor: DefaultJWTProcessor<SecurityContext> = DefaultJWTProcessor()
    jwtProcessor.jwsKeySelector = jwsKeySelector
    return NimbusJwtDecoder(jwtProcessor)
}
----
====

[[oauth2resourceserver-jwt-decoder-public-key]]
=== 信任单个非对称密钥

比使用JWK Set端点备份资源服务器更简单的方法是对RSA公钥进行硬编码. 可以通过<<oauth2resourceserver-jwt-decoder-public-key-boot,Spring Boot>>或<<oauth2resourceserver-jwt-decoder-public-key-builder,使用Builder>>提供公共密钥.

[[oauth2resourceserver-jwt-decoder-public-key-boot]]
==== 通过 Spring Boot

通过 Spring Boot 指定密钥非常简单.
密钥的位置可以这样指定:

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          public-key-location: classpath:my-key.pub
----

或者,为了进行更复杂的查找,可以对 `RsaKeyConversionServicePostProcessor` 进行后置处理:

====
.Java
[source,java,role="primary"]
----
@Bean
BeanFactoryPostProcessor conversionServiceCustomizer() {
    return beanFactory ->
        beanFactory.getBean(RsaKeyConversionServicePostProcessor.class)
                .setResourceLoader(new CustomResourceLoader());
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun conversionServiceCustomizer(): BeanFactoryPostProcessor {
    return BeanFactoryPostProcessor { beanFactory ->
        beanFactory.getBean<RsaKeyConversionServicePostProcessor>()
                .setResourceLoader(CustomResourceLoader())
    }
}
----
====

指定密钥的位置:

```yaml
key.location: hfds://my-key.pub
```

然后自动装配值:

====
.Java
[source,java,role="primary"]
----
@Value("${key.location}")
RSAPublicKey key;
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Value("\${key.location}")
val key: RSAPublicKey? = null
----
====


[[oauth2resourceserver-jwt-decoder-public-key-builder]]
==== 使用 Builder

要直接连接 `RSAPublicKey`,只需使用适当的 `NimbusJwtDecoder` builder,如下所示:

====
.Java
[source,java,role="primary"]
----
@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withPublicKey(this.key).build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withPublicKey(this.key).build()
}
----
====

[[oauth2resourceserver-jwt-decoder-secret-key]]
=== 信任单个对称密钥

使用单个对称密钥也很简单. 您可以简单地加载 `SecretKey` 并使用适当的 `NimbusJwtDecoder` 构建器,如下所示:

====
.Java
[source,java,role="primary"]
----
@Bean
public JwtDecoder jwtDecoder() {
    return NimbusJwtDecoder.withSecretKey(this.key).build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    return NimbusJwtDecoder.withSecretKey(key).build()
}
----
====


[[oauth2resourceserver-jwt-authorization]]
=== 配置授权

从OAuth 2.0授权服务器发出的JWT通常具有 `scope` 或 `scp` 属性,指示其被授予的作用域 (或权限) ,例如:

`{ ..., "scope" : "messages contacts"}`

在这种情况下,资源服务器将尝试将这些作用域强制为已授予权限的列表,并为每个作用域添加字符串 "SCOPE_" 作为前缀.

这意味着为了保护具有从JWT扩展的作用域的端点或方法,相应的表达式应包含以下前缀:


.Authorization Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class DirectlyConfiguredJwkSetUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::jwt);
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class DirectlyConfiguredJwkSetUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
                authorize("/messages/**", hasAuthority("SCOPE_messages"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                jwt { }
            }
        }
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/>
    <intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/>
    <oauth2-resource-server>
        <jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"/>
    </oauth2-resource-server>
</http>
----
====


或类似地具有方法安全性:

[source,java]
----
@PreAuthorize("hasAuthority('SCOPE_messages')")
public List<Message> getMessages(...) {}
----

[[oauth2resourceserver-jwt-authorization-extraction]]
==== 手动提取权限

但是,在许多情况下,此默认设置不足.例如,某些授权服务器不使用 `scope` 属性,而是使用自己的自定义属性.或者,在其他时候,资源服务器可能需要将属性或属性组成调整为内部化的权限.

为此， Spring Security 使用 `JwtAuthenticationConverter`， 负责 <<oauth2resourceserver-jwt-architecture-jwtauthenticationconverter,将 `Jwt` 转换为 `Authentication`>>.  默认情况下， Spring Security 将使用 `JWTAuthenticationConverter` 的默认实例 `JwtAuthenticationProvider` 来引导.

作为配置 `JWTAuthenticationConverter` 的一部分， 我们可以提供一个辅助转换器,从 `Jwt` 到授权的 `Collection`.

假设您的授权服务器在称为授权的自定义声明中传达了授权， 称为权限. 在这种情况下,您可以配置 <<oauth2resourceserver-jwt-architecture-jwtauthenticationconverter,`JwtAuthenticationConverter`>>  应该检查的声明,如下所示:

.Authorities Claim Configuration
====
.Java
[source,java,role="primary"]
----
@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
    grantedAuthoritiesConverter.setAuthoritiesClaimName("authorities");

    JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
    return jwtAuthenticationConverter;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
    val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter()
    grantedAuthoritiesConverter.setAuthoritiesClaimName("authorities")

    val jwtAuthenticationConverter = JwtAuthenticationConverter()
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter)
    return jwtAuthenticationConverter
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/>
    <intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/>
    <oauth2-resource-server>
        <jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"
                jwt-authentication-converter-ref="jwtAuthenticationConverter"/>
    </oauth2-resource-server>
</http>

<bean id="jwtAuthenticationConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter">
    <property name="jwtGrantedAuthoritiesConverter" ref="jwtGrantedAuthoritiesConverter"/>
</bean>

<bean id="jwtGrantedAuthoritiesConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter">
    <property name="authoritiesClaimName" value="authorities"/>
</bean>
----
====

您还可以将权限前缀配置为不同. 您可以像这样将其更改为 `ROLE_` 而不是在每个权限前面加上 `SCOPE_`:

.Authorities Prefix Configuration
====
.Java
[source,java,role="primary"]
----
@Bean
public JwtAuthenticationConverter jwtAuthenticationConverter() {
    JwtGrantedAuthoritiesConverter grantedAuthoritiesConverter = new JwtGrantedAuthoritiesConverter();
    grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_");

    JwtAuthenticationConverter jwtAuthenticationConverter = new JwtAuthenticationConverter();
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter);
    return jwtAuthenticationConverter;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtAuthenticationConverter(): JwtAuthenticationConverter {
    val grantedAuthoritiesConverter = JwtGrantedAuthoritiesConverter()
    grantedAuthoritiesConverter.setAuthorityPrefix("ROLE_")

    val jwtAuthenticationConverter = JwtAuthenticationConverter()
    jwtAuthenticationConverter.setJwtGrantedAuthoritiesConverter(grantedAuthoritiesConverter)
    return jwtAuthenticationConverter
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/>
    <intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/>
    <oauth2-resource-server>
        <jwt jwk-set-uri="https://idp.example.org/.well-known/jwks.json"
                jwt-authentication-converter-ref="jwtAuthenticationConverter"/>
    </oauth2-resource-server>
</http>

<bean id="jwtAuthenticationConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationConverter">
    <property name="jwtGrantedAuthoritiesConverter" ref="jwtGrantedAuthoritiesConverter"/>
</bean>

<bean id="jwtGrantedAuthoritiesConverter"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtGrantedAuthoritiesConverter">
    <property name="authorityPrefix" value="ROLE_"/>
</bean>
----
====

或者,可以通过调用 `JwtGrantedAuthoritiesConverter#setAuthorityPrefix("")` 来完全删除该前缀.

为了获得更大的灵活性,DSL支持使用实现  `Converter<Jwt, AbstractAuthenticationToken>` 的任何类完全替换该转换器:

====
.Java
[source,java,role="primary"]
----
static class CustomAuthenticationConverter implements Converter<Jwt, AbstractAuthenticationToken> {
    public AbstractAuthenticationToken convert(Jwt jwt) {
        return new CustomAuthenticationToken(jwt);
    }
}

// ...

@EnableWebSecurity
public class CustomAuthenticationConverterConfig extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    .jwtAuthenticationConverter(new CustomAuthenticationConverter())
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
internal class CustomAuthenticationConverter : Converter<Jwt, AbstractAuthenticationToken> {
    override fun convert(jwt: Jwt): AbstractAuthenticationToken {
        return CustomAuthenticationToken(jwt)
    }
}

// ...

@EnableWebSecurity
class CustomAuthenticationConverterConfig : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
       http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
           oauth2ResourceServer {
               jwt {
                   jwtAuthenticationConverter = CustomAuthenticationConverter()
               }
           }
        }
    }
}
----
====

[[oauth2resourceserver-jwt-validation]]
=== 配置验证

使用<<oauth2resourceserver-jwt-minimalconfiguration,Spring Boot 最小配置>> (指示授权服务器的 issuer uri) ,Resource Server将默认验证 `iss` 声明以及 `exp` 和 `nbf` 时间戳声明.

在需要自定义验证的情况下,资源服务器附带两个标准验证器,并且还接受自定义 `OAuth2TokenValidator` 实例.

[[oauth2resourceserver-jwt-validation-clockskew]]
==== 自定义时间戳验证

JWT通常具有有效期窗口,该窗口的开始在 `nbf` 声明中指示,而结束在 `exp` 声明中指示.

但是,每台服务器都会经历时钟漂移,这可能导致令牌在一个服务器上已经过期,而在另一台服务器上没有过期. 随着分布式系统中服务器数量的增加,这可能会导致某些实现上的不良反应.

资源服务器使用 `JwtTimestampValidator` 验证令牌的有效性窗口,并且可以将它配置为 `ClockSkew` 来缓解上述问题:

====
.Java
[source,java,role="primary"]
----
@Bean
JwtDecoder jwtDecoder() {
     NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
             JwtDecoders.fromIssuerLocation(issuerUri);

     OAuth2TokenValidator<Jwt> withClockSkew = new DelegatingOAuth2TokenValidator<>(
            new JwtTimestampValidator(Duration.ofSeconds(60)),
            new JwtIssuerValidator(issuerUri));

     jwtDecoder.setJwtValidator(withClockSkew);

     return jwtDecoder;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder

    val withClockSkew: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(
            JwtTimestampValidator(Duration.ofSeconds(60)),
            JwtIssuerValidator(issuerUri))

    jwtDecoder.setJwtValidator(withClockSkew)

    return jwtDecoder
}
----
====

[NOTE]
默认情况下,资源服务器将时钟偏差配置为 30 秒.

[[oauth2resourceserver-jwt-validation-custom]]
==== 配置自定义验证器

使用 `OAuth2TokenValidator` API为 `aud` 声明添加检查很简单:

====
.Java
[source,java,role="primary"]
----
OAuth2TokenValidator<Jwt> audienceValidator() {
    return new JwtClaimValidator<List<String>>(AUD, aud -> aud.contains("messaging"));
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
fun audienceValidator(): OAuth2TokenValidator<Jwt?> {
    return JwtClaimValidator<List<String>>(AUD) { aud -> aud.contains("messaging") }
}
----
====

或者,为了获得更多控制权,您可以实现自己的 `OAuth2TokenValidator`:

====
.Java
[source,java,role="primary"]
----
static class AudienceValidator implements OAuth2TokenValidator<Jwt> {
    OAuth2Error error = new OAuth2Error("custom_code", "Custom error message", null);

    @Override
    public OAuth2TokenValidatorResult validate(Jwt jwt) {
        if (jwt.getAudience().contains("messaging")) {
            return OAuth2TokenValidatorResult.success();
        } else {
            return OAuth2TokenValidatorResult.failure(error);
        }
    }
}

// ...

OAuth2TokenValidator<Jwt> audienceValidator() {
    return new AudienceValidator();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
internal class AudienceValidator : OAuth2TokenValidator<Jwt> {
    var error: OAuth2Error = OAuth2Error("custom_code", "Custom error message", null)

    override fun validate(jwt: Jwt): OAuth2TokenValidatorResult {
        return if (jwt.audience.contains("messaging")) {
            OAuth2TokenValidatorResult.success()
        } else {
            OAuth2TokenValidatorResult.failure(error)
        }
    }
}

// ...

fun audienceValidator(): OAuth2TokenValidator<Jwt> {
    return AudienceValidator()
}
----
====

然后,要添加到资源服务器中,只需指定 <<oauth2resourceserver-jwt-architecture-jwtdecoder,`JwtDecoder`>> 实例即可:

====
.Java
[source,java,role="primary"]
----
@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = (NimbusJwtDecoder)
        JwtDecoders.fromIssuerLocation(issuerUri);

    OAuth2TokenValidator<Jwt> audienceValidator = audienceValidator();
    OAuth2TokenValidator<Jwt> withIssuer = JwtValidators.createDefaultWithIssuer(issuerUri);
    OAuth2TokenValidator<Jwt> withAudience = new DelegatingOAuth2TokenValidator<>(withIssuer, audienceValidator);

    jwtDecoder.setJwtValidator(withAudience);

    return jwtDecoder;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = JwtDecoders.fromIssuerLocation(issuerUri) as NimbusJwtDecoder

    val audienceValidator = audienceValidator()
    val withIssuer: OAuth2TokenValidator<Jwt> = JwtValidators.createDefaultWithIssuer(issuerUri)
    val withAudience: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(withIssuer, audienceValidator)

    jwtDecoder.setJwtValidator(withAudience)

    return jwtDecoder
}
----
====

[[oauth2resourceserver-jwt-claimsetmapping]]
=== 配置 Claim (声明)集映射

Spring Security使用 https://bitbucket.org/connect2id/nimbus-jose-jwt/wiki/Home[Nimbus] 库来解析JWT并验证其签名.  因此,Spring Security受制于Nimbus对每个字段值以及如何将每个字段强制转换为Java类型的解释.

例如,由于Nimbus仍与Java 7兼容,因此它不使用 `Instant` 来表示时间戳字段.

而且完全有可能使用其他库或进行JWT处理,这可能会自行做出需要调整的决定.

或者,很简单,出于特定于域的原因,资源服务器可能希望从JWT中添加或删除声明.

为此,资源服务器支持将JWT声明集与 `MappedJwtClaimSetConverter` 映射.

[[oauth2resourceserver-jwt-claimsetmapping-singleclaim]]
==== 自定义单个 Claim 的转换

默认情况下,`MappedJwtClaimSetConverter` 将尝试将 claims 强制为以下类型:

|============
| Claim | Java Type
| `aud` | `Collection<String>`
| `exp` | `Instant`
| `iat` | `Instant`
| `iss` | `String`
| `jti` | `String`
| `nbf` | `Instant`
| `sub` | `String`
|============

可以使用  `MappedJwtClaimSetConverter.withDefaults` 配置单个声明的转化策略:

====
.Java
[source,java,role="primary"]
----
@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();

    MappedJwtClaimSetConverter converter = MappedJwtClaimSetConverter
            .withDefaults(Collections.singletonMap("sub", this::lookupUserIdBySub));
    jwtDecoder.setClaimSetConverter(converter);

    return jwtDecoder;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()

    val converter = MappedJwtClaimSetConverter
            .withDefaults(mapOf("sub" to this::lookupUserIdBySub))
    jwtDecoder.setClaimSetConverter(converter)

    return jwtDecoder
}
----
====

这将保留所有默认值,除了它将覆盖 `sub` 的默认声明转换器.

[[oauth2resourceserver-jwt-claimsetmapping-add]]
==== 添加一个 Claim

`MappedJwtClaimSetConverter` 也可以用于添加自定义声明,例如,以适应现有系统:

====
.Java
[source,java,role="primary"]
----
MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("custom", custom -> "value"));
----

.Kotlin
[source,kotlin,role="secondary"]
----
MappedJwtClaimSetConverter.withDefaults(mapOf("custom" to Converter<Any, String> { "value" }))
----
====

[[oauth2resourceserver-jwt-claimsetmapping-remove]]
==== 删除一个 Claim

使用相同的API删除声明也很简单:

====
.Java
[source,java,role="primary"]
----
MappedJwtClaimSetConverter.withDefaults(Collections.singletonMap("legacyclaim", legacy -> null));
----

.Kotlin
[source,kotlin,role="secondary"]
----
MappedJwtClaimSetConverter.withDefaults(mapOf("legacyclaim" to Converter<Any, Any> { null }))
----
====

[[oauth2resourceserver-jwt-claimsetmapping-rename]]
==== 重命名一个 Claim

在更复杂的场景中,例如一次查询多个声明或重命名一个声明,资源服务器接受任何实现 `Converter<Map<String, Object>, Map<String,Object>>` 的类:

====
.Java
[source,java,role="primary"]
----
public class UsernameSubClaimAdapter implements Converter<Map<String, Object>, Map<String, Object>> {
    private final MappedJwtClaimSetConverter delegate =
            MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap());

    public Map<String, Object> convert(Map<String, Object> claims) {
        Map<String, Object> convertedClaims = this.delegate.convert(claims);

        String username = (String) convertedClaims.get("user_name");
        convertedClaims.put("sub", username);

        return convertedClaims;
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
class UsernameSubClaimAdapter : Converter<Map<String, Any?>, Map<String, Any?>> {
    private val delegate = MappedJwtClaimSetConverter.withDefaults(Collections.emptyMap())
    override fun convert(claims: Map<String, Any?>): Map<String, Any?> {
        val convertedClaims = delegate.convert(claims)
        val username = convertedClaims["user_name"] as String
        convertedClaims["sub"] = username
        return convertedClaims
    }
}
----
====

然后,可以像平常一样提供实例:

====
.Java
[source,java,role="primary"]
----
@Bean
JwtDecoder jwtDecoder() {
    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build();
    jwtDecoder.setClaimSetConverter(new UsernameSubClaimAdapter());
    return jwtDecoder;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(): JwtDecoder {
    val jwtDecoder: NimbusJwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).build()
    jwtDecoder.setClaimSetConverter(UsernameSubClaimAdapter())
    return jwtDecoder
}
----
====


[[oauth2resourceserver-jwt-timeouts]]
=== 配置超时

默认情况下,资源服务器使用30秒钟的连接和套接字超时来与授权服务器进行协调.

在某些情况下,这可能太短了.  此外,它没有考虑退避和发现等更复杂的模式.

为了调整资源服务器连接到授权服务器的方式,`NimbusJwtDecoder` 接受 `RestOperations` 的实例:

====
.Java
[source,java,role="primary"]
----
@Bean
public JwtDecoder jwtDecoder(RestTemplateBuilder builder) {
    RestOperations rest = builder
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build();

    NimbusJwtDecoder jwtDecoder = NimbusJwtDecoder.withJwkSetUri(jwkSetUri).restOperations(rest).build();
    return jwtDecoder;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(builder: RestTemplateBuilder): JwtDecoder {
    val rest: RestOperations = builder
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build()
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri).restOperations(rest).build()
}
----
====

同样默认情况下， 资源服务器在内存中将授权服务器的 JWK 设置缓存 5 分钟， 您可能需要对其进行调整.
此外， 它没有考虑更复杂的缓存模式， 例如失效或使用共享缓存.

为了调整资源服务器缓存 JWK set 的方式， `NimbusJwtDecoder` 接受 `Cache` 的实例:

====
.Java
[source,java,role="primary"]
----
@Bean
public JwtDecoder jwtDecoder(CacheManager cacheManager) {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri)
            .cache(cacheManager.getCache("jwks"))
            .build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(cacheManager: CacheManager): JwtDecoder {
    return NimbusJwtDecoder.withJwkSetUri(jwkSetUri)
            .cache(cacheManager.getCache("jwks"))
            .build()
}
----
====

当给定一个 `Cache` 时， 资源服务器将使用 JWK Set Uri 作为键， 并使用 JWK Set JSON 作为值.

NOTE: Spring 不是缓存提供者， 因此您需要确保包括适当的依赖项， 例如 `spring-boot-starter-cache` 和您最喜欢的缓存提供者.

NOTE: 无论是 socket 超时还是缓存超时， 您都可以直接使用 Nimbus.
为此， 请记住， `NimbusJwtDecoder` 附带了一个采用 Nimbus 的 `JWTProcessor` 的构造函数.

[[oauth2resourceserver-opaque-minimaldependencies]]
=== Minimal Dependencies for Introspection
如 <<oauth2resourceserver-jwt-minimalconfiguration,JWT 的最小配置>> 中所述， 大多数资源服务器支持都在 `spring-security-oauth2-resource-server` 中. 但是， 除非提供了自定义的 <<oauth2resourceserver-opaque-introspector,`OpaqueTokenIntrospector`>>,否则资源服务器将回退到 `NimbusOpaqueTokenIntrospector`.  这意味着 `spring-security-oauth2-resource-server` 和 `oauth2-oidc-sdk` 都是必需的， 以使支持不透明承载令牌的最小资源服务器正常工作.  为了确定 `oauth2-oidc-sdk` 的正确版本， 请参考 `spring-security-oauth2-resource-server`.


[[oauth2resourceserver-opaque-minimalconfiguration]]
===  Introspection 最小配置

通常,opaque token 可以通过授权服务器托管的 https://tools.ietf.org/html/rfc7662[OAuth 2.0 Introspection Endpoint]进行验证. 当需要撤销时,这可能很方便.

使用 https://spring.io/projects/spring-boot[Spring Boot] 时,将应用程序配置为使用内省的资源服务器包括两个基本步骤. 首先,包括所需的依赖性,其次,指示内省端点详细信息.

[[oauth2resourceserver-opaque-introspectionuri]]
==== 指定授权服务器

要指定内省端点的位置,只需执行以下操作:

[source,yaml]
----
security:
  oauth2:
    resourceserver:
      opaque-token:
        introspection-uri: https://idp.example.com/introspect
        client-id: client
        client-secret: secret
----

其中 `https://idp.example.com/introspect` 是授权服务器托管的内省端点,而 `client-id` 和 `client-secret` 是击中该端点所需的凭据.

资源服务器将使用这些属性进一步进行自我配置,并随后验证传入的JWT.

[NOTE]
使用内省时,授权服务器的字眼就是法律.  如果授权服务器响应令牌是有效的,那么令牌是有效的.

就是这样！

==== 启动时预期

使用此属性和这些依赖时,资源服务器将自动配置自身以验证不透明承载令牌.

该启动过程比JWT的启动过程简单得多,因为不需要发现端点,也不需要添加其他验证规则.

==== 运行时预期

应用程序启动后,资源服务器将尝试处理任何包含 `Authorization: Bearer` 头的请求:

```http
GET / HTTP/1.1
Authorization: Bearer some-token-value # Resource Server will process this
```

只要指示了此方案,资源服务器就会尝试根据Bearer Token规范处理请求.

给定一个不透明的令牌,资源服务器将

1. 使用提供的凭据和令牌查询提供的内省端点
2. 检查响应是否为  `{ 'active' : true }`  属性
3. 将每个作用域映射到具有前缀 `SCOPE_` 的权限

默认情况下,生成的  `Authentication#getPrincipal` 是Spring Security   `{security-api-url}org/springframework/security/oauth2/core/OAuth2AuthenticatedPrincipal.html[OAuth2AuthenticatedPrincipal]`  对象,并且 `Authentication#getName` 映射到令牌的 `sub` 属性 (如果存在) .

从这里,您可能要跳转到:

* <<oauth2resourceserver-opaque-architecture>>
* <<oauth2resourceserver-opaque-attributes,查找身份验证后的属性>>
* <<oauth2resourceserver-opaque-authorization-extraction,手动提取权限>>
* <<oauth2resourceserver-opaque-jwt-introspector,对JWT使用内省>>

[[oauth2resourceserver-opaque-architecture]]
=== Opaque Token Authentication 是如何工作的

接下来， 让我们看看 Spring Security 用于支持基于 Servlet 的应用程序中的 https://tools.ietf.org/html/rfc7662[opaque token] 身份验证的架构组件， 如我们刚看到的应用程序.

{security-api-url}org/springframework/security/oauth2/server/resource/authentication/OpaqueTokenAuthenticationProvider.html[`OpaqueTokenAuthenticationProvider`] 是一个 <<servlet-authentication-authenticationprovider,`AuthenticationProvider`>> 的进一步实现， 它利用 <<oauth2resourceserver-opaque-introspector,`OpaqueTokenIntrospector`>> 来验证不透明令牌.

让我们来看看 `OpaqueTokenAuthenticationProvider` 如何在 Spring Security 范围内工作.  该图解释了<<oauth2resourceserver-authentication-bearertokenauthenticationfilter,Reading the Bearer Token>> 中的 <<servlet-authentication-authenticationmanager,`AuthenticationManager`>>  的详细信息.

.`OpaqueTokenAuthenticationProvider` Usage
image::{figures}/opaquetokenauthenticationprovider.png[]


OpaqueTokenauthenticationProvider内部opaque令牌， 并使用OpaqueTokentRospector添加授予的权限.  验证成功后， 返回的身份验证是BearerTokenAuthentication类型， 并且具有由已配置的OpaqueTokentRospector返回的OAuth2authenticationPrincipal的主体.  最终， 将通过认证过滤器在SecurityContextholder上设置返回的bearertokenauthing.

image:{icondir}/number_1.png[] <<oauth2resourceserver-authentication-bearertokenauthenticationfilter,读取 Bearer Token>> 身份验证 `Filter` 将 `BearerTokenAuthenticationToken` 传递给实现了 `AuthenticationManager` 的 <<servlet-authentication-providermanager,`ProviderManager`>>.

image:{icondir}/number_2.png[] `ProviderManager` 配置为使用 `OpaqueTokenAuthenticationProvider` 类型的 <<servlet-authentication-authenticationprovider>>.

[[oauth2resourceserver-opaque-architecture-introspector]]
image:{icondir}/number_3.png[] `OpaqueTokenAuthenticationProvider` 内置 opaque token,  并使用 <<oauth2resourceserver-opaque-introspector,`OpaqueTokenIntrospector`>> 添加授予的权限.  验证成功后， 返回的 <<servlet-authentication-authentication,`Authentication`>> 对象为 `BearerTokenAuthentication` 并且具有由已配置的 <<oauth2resourceserver-opaque-introspector,`OpaqueTokenIntrospector`>> 返回 `OAuth2AuthenticatedPrincipal` .
最终， 将通过认证过滤器在 <<servlet-authentication-securitycontextholder,`SecurityContextHolder`>> 上设置返回的 `BearerTokenAuthentication`.

[[oauth2resourceserver-opaque-attributes]]
=== 查找身份验证后的属性

令牌通过身份验证后,将在 `SecurityContext` 中设置 `BearerTokenAuthentication` 的实例.

这意味着在配置中使用 `@EnableWebMvc` 时,它可以在 `@Controller` 方法中使用:

====
.Java
[source,java,role="primary"]
----
@GetMapping("/foo")
public String foo(BearerTokenAuthentication authentication) {
    return authentication.getTokenAttributes().get("sub") + " is the subject";
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@GetMapping("/foo")
fun foo(authentication: BearerTokenAuthentication): String {
    return authentication.tokenAttributes["sub"].toString() + " is the subject"
}
----
====

由于 `BearerTokenAuthentication` 拥有 `OAuth2AuthenticatedPrincipal`,这也意味着它也可用于控制器方法:

====
.Java
[source,java,role="primary"]
----
@GetMapping("/foo")
public String foo(@AuthenticationPrincipal OAuth2AuthenticatedPrincipal principal) {
    return principal.getAttribute("sub") + " is the subject";
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@GetMapping("/foo")
fun foo(@AuthenticationPrincipal principal: OAuth2AuthenticatedPrincipal): String {
    return principal.getAttribute<Any>("sub").toString() + " is the subject"
}
----
====

==== 通过 SpEL 查找属性

当然,这也意味着可以通过 SpEL 访问属性.

例如,如果使用 `@EnableGlobalMethodSecurity` 以便可以使用 `@PreAuthorize` 注解,则可以执行以下操作:


====
.Java
[source,java,role="primary"]
----
@PreAuthorize("principal?.attributes['sub'] == 'foo'")
public String forFoosEyesOnly() {
    return "foo";
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@PreAuthorize("principal?.attributes['sub'] == 'foo'")
fun forFoosEyesOnly(): String {
    return "foo"
}
----
====


[[oauth2resourceserver-opaque-sansboot]]
=== 覆盖或替换自动配置

Spring Boot 代表 Resource Server 生成了两个 `@Bean`.

第一个是将应用程序配置为资源服务器的 `WebSecurityConfigurerAdapter`. 使用 Opaque Token 时,此 `WebSecurityConfigurerAdapter` 如下所示:

.Default Opaque Token Configuration
====
.Java
[source,java,role="primary"]
----
protected void configure(HttpSecurity http) {
    http
        .authorizeRequests(authorize -> authorize
            .anyRequest().authenticated()
        )
        .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
override fun configure(http: HttpSecurity) {
    http {
        authorizeRequests {
            authorize(anyRequest, authenticated)
        }
        oauth2ResourceServer {
            opaqueToken { }
        }
    }
}
----
====

如果应用程序未暴露 `WebSecurityConfigurerAdapter` Bean,则Spring Boot将暴露上述默认值.

替换它就像在应用程序中暴露Bean一样简单:

.Custom Opaque Token Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class MyCustomSecurityConfiguration extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_message:read")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .opaqueToken(opaqueToken -> opaqueToken
                    .introspector(myIntrospector())
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class MyCustomSecurityConfiguration : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize("/messages/**", hasAuthority("SCOPE_message:read"))
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspector = myIntrospector()
                }
            }
        }
    }
}
----
====

以上要求 `message:read` 的作用域: 以 `/messages/` 开头的所有URL.

`oauth2ResourceServer` DSL上的方法还将覆盖或替换自动配置.

[[oauth2resourceserver-opaque-introspector]]
例如,第二个 `@Bean` Spring Boot创建的是一个 `OpaqueTokenIntrospector`,它将 `String` 令牌解码为 `OAuth2AuthenticatedPrincipal` 的经过验证的实例:

====
.Java
[source,java,role="primary"]
----
@Bean
public OpaqueTokenIntrospector introspector() {
    return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun introspector(): OpaqueTokenIntrospector {
    return NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret)
}
----
====

如果应用程序未暴露 <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> Bean,则 Spring Boot 将暴露以上默认的 bean.

可以使用 `introspectionUri()` 和 `introspectionClientCredentials()` 覆盖其配置,也可以使用 `introspector()` 替换其配置.

或者,如果您根本不使用 Spring Boot,那么这两个组件-过滤器链和 <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>>  都可以用XML指定.

过滤器链的指定如下:

.Default Opaque Token Configuration
====
.Xml
[source,xml,role="primary"]
----
<http>
    <intercept-uri pattern="/**" access="authenticated"/>
    <oauth2-resource-server>
        <opaque-token introspector-ref="opaqueTokenIntrospector"/>
    </oauth2-resource-server>
</http>
----
====

<<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> 如下:

.Opaque Token Introspector
====
.Xml
[source,xml,role="primary"]
----
<bean id="opaqueTokenIntrospector"
        class="org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector">
    <constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.introspection_uri}"/>
    <constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.client_id}"/>
    <constructor-arg value="${spring.security.oauth2.resourceserver.opaquetoken.client_secret}"/>
</bean>
----
====

[[oauth2resourceserver-opaque-introspectionuri-dsl]]
==== 使用 `introspectionUri()`


授权服务器的 Introspection Uri 可以配置为 <<oauth2resourceserver-opaque-introspectionuri,配置属性>>,也可以在 DSL 中提供:

.Introspection URI Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class DirectlyConfiguredIntrospectionUri extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .opaqueToken(opaqueToken -> opaqueToken
                    .introspectionUri("https://idp.example.com/introspect")
                    .introspectionClientCredentials("client", "secret")
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class DirectlyConfiguredIntrospectionUri : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspectionUri = "https://idp.example.com/introspect"
                    introspectionClientCredentials("client", "secret")
                }
            }
        }
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<bean id="opaqueTokenIntrospector"
        class="org.springframework.security.oauth2.server.resource.introspection.NimbusOpaqueTokenIntrospector">
    <constructor-arg value="https://idp.example.com/introspect"/>
    <constructor-arg value="client"/>
    <constructor-arg value="secret"/>
</bean>
----
====

使用 `introspectionUri()` 优先于任何配置属性.

[[oauth2resourceserver-opaque-introspector-dsl]]
==== 使用 `introspector()`

比 `introspectionUri()` 更强大的是 `introspector()` ,它将完全替代 <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> 的所有 Boot 自动配置:

.Introspector Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class DirectlyConfiguredIntrospector extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorize -> authorize
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .opaqueToken(opaqueToken -> opaqueToken
                    .introspector(myCustomIntrospector())
                )
            );
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class DirectlyConfiguredIntrospector : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
        http {
            authorizeRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2ResourceServer {
                opaqueToken {
                    introspector = myCustomIntrospector()
                }
            }
        }
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/**" access="authenticated"/>
    <oauth2-resource-server>
        <opaque-token introspector-ref="myCustomIntrospector"/>
    </oauth2-resource-server>
</http>
----
====

当需要更深入的配置 (例如<<oauth2resourceserver-opaque-authorization-extraction,权限映射>>, <<oauth2resourceserver-opaque-jwt-introspector,JWT吊销>>, 或 <<oauth2resourceserver-opaque-timeouts,请求超时>>) 时,这很方便.

[[oauth2resourceserver-opaque-introspector-bean]]
==== 暴露 `OpaqueTokenIntrospector` `@Bean`

或者,暴露  <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>>   `@Bean` 与 `introspector()` 具有相同的效果:

[source,java]
----
@Bean
public OpaqueTokenIntrospector introspector() {
    return new NimbusOpaqueTokenIntrospector(introspectionUri, clientId, clientSecret);
}
----

[[oauth2resourceserver-opaque-authorization]]
=== 配置授权

OAuth 2.0内省端点通常会返回一个 `scope` 属性,指示其被授予的作用域 (或权限) ,例如:

`{ ..., "scope" : "messages contacts"}`

在这种情况下,资源服务器将尝试将这些作用域强制为已授予权限的列表,并为每个作用域添加字符串 "SCOPE_" 作为前缀.

这意味着要保护具有不透明令牌扩展范围的端点或方法,相应的表达式应包含以下前缀:

.Authorization Opaque Token Configuration
====
.Java
[source,java,role="primary"]
----
@EnableWebSecurity
public class MappedAuthorities extends WebSecurityConfigurerAdapter {
    protected void configure(HttpSecurity http) {
        http
            .authorizeRequests(authorizeRequests -> authorizeRequests
                .mvcMatchers("/contacts/**").hasAuthority("SCOPE_contacts")
                .mvcMatchers("/messages/**").hasAuthority("SCOPE_messages")
                .anyRequest().authenticated()
            )
            .oauth2ResourceServer(OAuth2ResourceServerConfigurer::opaqueToken);
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@EnableWebSecurity
class MappedAuthorities : WebSecurityConfigurerAdapter() {
    override fun configure(http: HttpSecurity) {
       http {
            authorizeRequests {
                authorize("/contacts/**", hasAuthority("SCOPE_contacts"))
                authorize("/messages/**", hasAuthority("SCOPE_messages"))
                authorize(anyRequest, authenticated)
            }
           oauth2ResourceServer {
               opaqueToken { }
           }
        }
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <intercept-uri pattern="/contacts/**" access="hasAuthority('SCOPE_contacts')"/>
    <intercept-uri pattern="/messages/**" access="hasAuthority('SCOPE_messages')"/>
    <oauth2-resource-server>
        <opaque-token introspector-ref="opaqueTokenIntrospector"/>
    </oauth2-resource-server>
</http>
----
====

或类似地具有方法安全性:

====
.Java
[source,java,role="primary"]
----
@PreAuthorize("hasAuthority('SCOPE_messages')")
public List<Message> getMessages(...) {}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@PreAuthorize("hasAuthority('SCOPE_messages')")
fun getMessages(): List<Message?> {}
----
====


[[oauth2resourceserver-opaque-authorization-extraction]]
==== 手动提取权限

默认情况下,Opaque Token 支持将从内省响应中提取范围声明,并将其解析为各个 `GrantedAuthority` 实例.

例如,如果内省响应为:

[source,json]
----
{
    "active" : true,
    "scope" : "message:read message:write"
}
----

然后,资源服务器将生成具有两个权限的  `Authentication` ,一个权限用于  `message:read` ,另一个权限用于 `message:write`.

当然,这可以使用自定义的 <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> 进行自定义,该 `OpaqueTokenIntrospector` 查看属性集并以自己的方式进行转换:

====
.Java
[source,java,role="primary"]
----
public class CustomAuthoritiesOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");

    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);
        return new DefaultOAuth2AuthenticatedPrincipal(
                principal.getName(), principal.getAttributes(), extractAuthorities(principal));
    }

    private Collection<GrantedAuthority> extractAuthorities(OAuth2AuthenticatedPrincipal principal) {
        List<String> scopes = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE);
        return scopes.stream()
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
class CustomAuthoritiesOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val principal: OAuth2AuthenticatedPrincipal = delegate.introspect(token)
        return DefaultOAuth2AuthenticatedPrincipal(
                principal.name, principal.attributes, extractAuthorities(principal))
    }

    private fun extractAuthorities(principal: OAuth2AuthenticatedPrincipal): Collection<GrantedAuthority> {
        val scopes: List<String> = principal.getAttribute(OAuth2IntrospectionClaimNames.SCOPE)
        return scopes
                .map { SimpleGrantedAuthority(it) }
    }
}
----
====

此后,可以通过将其暴露为 `@Bean` 来简单地配置此自定义内省器:

====
.Java
[source,java,role="primary"]
----
@Bean
public OpaqueTokenIntrospector introspector() {
    return new CustomAuthoritiesOpaqueTokenIntrospector();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun introspector(): OpaqueTokenIntrospector {
    return CustomAuthoritiesOpaqueTokenIntrospector()
}
----
====

[[oauth2resourceserver-opaque-timeouts]]
=== 配置超时

默认情况下,资源服务器使用30秒钟的连接和套接字超时来与授权服务器进行协调.

在某些情况下,这可能太短了.
此外,它不考虑退避和发现等更复杂的模式.

为了调整资源服务器连接到授权服务器的方式,`NimbusOpaqueTokenIntrospector` 接受 `RestOperations` 的实例:

====
.Java
[source,java,role="primary"]
----
@Bean
public OpaqueTokenIntrospector introspector(RestTemplateBuilder builder, OAuth2ResourceServerProperties properties) {
    RestOperations rest = builder
            .basicAuthentication(properties.getOpaquetoken().getClientId(), properties.getOpaquetoken().getClientSecret())
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build();

    return new NimbusOpaqueTokenIntrospector(introspectionUri, rest);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun introspector(builder: RestTemplateBuilder, properties: OAuth2ResourceServerProperties): OpaqueTokenIntrospector? {
    val rest: RestOperations = builder
            .basicAuthentication(properties.opaquetoken.clientId, properties.opaquetoken.clientSecret)
            .setConnectTimeout(Duration.ofSeconds(60))
            .setReadTimeout(Duration.ofSeconds(60))
            .build()
    return NimbusOpaqueTokenIntrospector(introspectionUri, rest)
}
----
====


[[oauth2resourceserver-opaque-jwt-introspector]]
=== 对JWT使用内省

一个常见的问题是内省是否与 JWT 兼容.
Spring Security 的 Opaque 令牌支持被设计为不关心令牌的格式-它将很乐意将任何令牌传递给提供的内省端点.

因此,假设您有一个要求,如果 JWT 被吊销,则要求您在每个请求中与授权服务器进行核对.

即使您为令牌使用JWT格式,您的验证方法也是内省的,这意味着您想要执行以下操作:

[source,yaml]
----
spring:
  security:
    oauth2:
      resourceserver:
        opaque-token:
          introspection-uri: https://idp.example.org/introspection
          client-id: client
          client-secret: secret
----

在这种情况下,得到的  `Authentication` 将是 `BearerTokenAuthentication`.
相应的 `OAuth2AuthenticatedPrincipal` 中的任何属性将是内省端点返回的任何属性.

但是,可以说,奇怪的是,内省端点仅返回令牌是否处于 active 状态.
怎么办?

在这种情况下,您可以创建一个自定义的 <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> ,它仍然会命中端点,但是随后更新返回的主体以将JWT声明作为属性:

====
.Java
[source,java,role="primary"]
----
public class JwtOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private JwtDecoder jwtDecoder = new NimbusJwtDecoder(new ParseOnlyJWTProcessor());

    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal principal = this.delegate.introspect(token);
        try {
            Jwt jwt = this.jwtDecoder.decode(token);
            return new DefaultOAuth2AuthenticatedPrincipal(jwt.getClaims(), NO_AUTHORITIES);
        } catch (JwtException ex) {
            throw new OAuth2IntrospectionException(ex);
        }
    }

    private static class ParseOnlyJWTProcessor extends DefaultJWTProcessor<SecurityContext> {
    	JWTClaimsSet process(SignedJWT jwt, SecurityContext context)
                throws JOSEException {
            return jwt.getJWTClaimsSet();
        }
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
class JwtOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val jwtDecoder: JwtDecoder = NimbusJwtDecoder(ParseOnlyJWTProcessor())
    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val principal = delegate.introspect(token)
        return try {
            val jwt: Jwt = jwtDecoder.decode(token)
            DefaultOAuth2AuthenticatedPrincipal(jwt.claims, NO_AUTHORITIES)
        } catch (ex: JwtException) {
            throw OAuth2IntrospectionException(ex.message)
        }
    }

    private class ParseOnlyJWTProcessor : DefaultJWTProcessor<SecurityContext>() {
        override fun process(jwt: SignedJWT, context: SecurityContext): JWTClaimsSet {
            return jwt.jwtClaimsSet
        }
    }
}
----
====

此后,可以通过将其暴露为 `@Bean` 来简单地配置此自定义内省器:

====
.Java
[source,java,role="primary"]
----
@Bean
public OpaqueTokenIntrospector introspector() {
    return new JwtOpaqueTokenIntrospector();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun introspector(): OpaqueTokenIntrospector {
    return JwtOpaqueTokenIntrospector()
}
----
====

[[oauth2resourceserver-opaque-userinfo]]
=== 调用 `/userinfo` 端点

一般来说,资源服务器不在乎底层用户,而在乎已授予的权限.

就是说,有时将授权声明绑定到用户可能很有价值.

如果应用程序还使用 `spring-security-oauth2-client` 并设置了适当的 `ClientRegistrationRepository`,则使用自定义的 <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> 非常简单.  下面的实现实现了三件事:

* 委托内省端点确认令牌的有效性
* 查找与 `/userinfo` 端点关联的适当的客户端注册
* 调用并返回来自 `/userinfo` 端点的响应

====
.Java
[source,java,role="primary"]
----
public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private final OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final OAuth2UserService oauth2UserService = new DefaultOAuth2UserService();

    private final ClientRegistrationRepository repository;

    // ... constructor

    @Override
    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);
        Instant issuedAt = authorized.getAttribute(ISSUED_AT);
        Instant expiresAt = authorized.getAttribute(EXPIRES_AT);
        ClientRegistration clientRegistration = this.repository.findByRegistrationId("registration-id");
        OAuth2AccessToken token = new OAuth2AccessToken(BEARER, token, issuedAt, expiresAt);
        OAuth2UserRequest oauth2UserRequest = new OAuth2UserRequest(clientRegistration, token);
        return this.oauth2UserService.loadUser(oauth2UserRequest);
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
class UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val oauth2UserService = DefaultOAuth2UserService()
    private val repository: ClientRegistrationRepository? = null

    // ... constructor

    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val authorized = delegate.introspect(token)
        val issuedAt: Instant? = authorized.getAttribute(ISSUED_AT)
        val expiresAt: Instant? = authorized.getAttribute(EXPIRES_AT)
        val clientRegistration: ClientRegistration = repository!!.findByRegistrationId("registration-id")
        val accessToken = OAuth2AccessToken(BEARER, token, issuedAt, expiresAt)
        val oauth2UserRequest = OAuth2UserRequest(clientRegistration, accessToken)
        return oauth2UserService.loadUser(oauth2UserRequest)
    }
}
----
====

如果您不使用 `spring-security-oauth2-client`,它仍然非常简单.  您只需要使用您自己的 `WebClient` 实例调用 `/userinfo`:

====
.Java
[source,java,role="primary"]
----
public class UserInfoOpaqueTokenIntrospector implements OpaqueTokenIntrospector {
    private final OpaqueTokenIntrospector delegate =
            new NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret");
    private final WebClient rest = WebClient.create();

    @Override
    public OAuth2AuthenticatedPrincipal introspect(String token) {
        OAuth2AuthenticatedPrincipal authorized = this.delegate.introspect(token);
        return makeUserInfoRequest(authorized);
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
class UserInfoOpaqueTokenIntrospector : OpaqueTokenIntrospector {
    private val delegate: OpaqueTokenIntrospector = NimbusOpaqueTokenIntrospector("https://idp.example.org/introspect", "client", "secret")
    private val rest: WebClient = WebClient.create()

    override fun introspect(token: String): OAuth2AuthenticatedPrincipal {
        val authorized = delegate.introspect(token)
        return makeUserInfoRequest(authorized)
    }
}
----
====


无论哪种方式,在创建  <<oauth2resourceserver-opaque-architecture-introspector,`OpaqueTokenIntrospector`>> 之后,都应该将其发布为 `@Bean` 来覆盖默认值:

====
.Java
[source,java,role="primary"]
----
@Bean
OpaqueTokenIntrospector introspector() {
    return new UserInfoOpaqueTokenIntrospector(...);
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun introspector(): OpaqueTokenIntrospector {
    return UserInfoOpaqueTokenIntrospector(...)
}
----
====

[[oauth2reourceserver-opaqueandjwt]]
=== 同时支持 JWT 和 Opaque Token

在某些情况下,您可能需要访问两种令牌.  例如,您可能支持多个租户,其中一个租户发布JWT,其他租户发布不透明令牌.

如果必须在请求时做出此决定,则可以使用 `AuthenticationManagerResolver` 来实现,如下所示:

====
.Java
[source,java,role="primary"]
----
@Bean
AuthenticationManagerResolver<HttpServletRequest> tokenAuthenticationManagerResolver() {
    BearerTokenResolver bearerToken = new DefaultBearerTokenResolver();
    JwtAuthenticationProvider jwt = jwt();
    OpaqueTokenAuthenticationProvider opaqueToken = opaqueToken();

    return request -> {
        if (useJwt(request)) {
            return jwt::authenticate;
        } else {
            return opaqueToken::authenticate;
        }
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun tokenAuthenticationManagerResolver(): AuthenticationManagerResolver<HttpServletRequest> {
    val bearerToken: BearerTokenResolver = DefaultBearerTokenResolver()
    val jwt: JwtAuthenticationProvider = jwt()
    val opaqueToken: OpaqueTokenAuthenticationProvider = opaqueToken()

    return AuthenticationManagerResolver { request ->
        if (useJwt(request)) {
            AuthenticationManager { jwt.authenticate(it) }
        } else {
            AuthenticationManager { opaqueToken.authenticate(it) }
        }
    }
}
----
====

NOTE: `useJwt(HttpServletRequest)` 的实现可能取决于诸如路径之类的自定义请求..

然后在DSL中指定此 `AuthenticationManagerResolver`:

.Authentication Manager Resolver
====
.Java
[source,java,role="primary"]
----
http
    .authorizeRequests(authorize -> authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -> oauth2
        .authenticationManagerResolver(this.tokenAuthenticationManagerResolver)
    );
----

.Kotlin
[source,kotlin,role="secondary"]
----
http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = tokenAuthenticationManagerResolver()
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <oauth2-resource-server authentication-manager-resolver-ref="tokenAuthenticationManagerResolver"/>
</http>
----
====

[[oauth2resourceserver-multitenancy]]
=== 多租户

当存在多种验证承载令牌的策略时,资源服务器被视为多租户,并以某些租户标识符为关键字.

例如,您的资源服务器可能接受来自两个不同授权服务器的承载令牌.  或者,您的授权服务器可能代表多个发行者.

在每种情况下,都需要完成两件事,并且要与选择的方式进行权衡:

1. 解析租户
2. 传播租户

==== 通过 Claim 解析租户

区分租户的一种方法是通过 issuer claim.  由于签发者的声明伴随着已签名的JWT,因此可以通过 `JwtIssuerAuthenticationManagerResolver` 来完成,如下所示:

.Multitenancy Tenant by JWT Claim
====
.Java
[source,java,role="primary"]
----
JwtIssuerAuthenticationManagerResolver authenticationManagerResolver = new JwtIssuerAuthenticationManagerResolver
    ("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo");

http
    .authorizeRequests(authorize -> authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -> oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );
----

.Kotlin
[source,kotlin,role="secondary"]
----
val customAuthenticationManagerResolver = JwtIssuerAuthenticationManagerResolver
    ("https://idp.example.org/issuerOne", "https://idp.example.org/issuerTwo")
http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <oauth2-resource-server authentication-manager-resolver-ref="authenticationManagerResolver"/>
</http>

<bean id="authenticationManagerResolver"
        class="org.springframework.security.oauth2.server.resource.authentication.JwtIssuerAuthenticationManagerResolver">
    <constructor-arg>
        <list>
            <value>https://idp.example.org/issuerOne</value>
            <value>https://idp.example.org/issuerTwo</value>
        </list>
    </constructor-arg>
</bean>
----
====

这很好,因为发布者端点是延迟加载的.  实际上,仅当发送带有相应发行者的第一个请求时,才会实例化相应的 `JwtAuthenticationProvider`.  这样就可以启动应用程序,而与启动并可用的那些授权服务器无关.

===== 动态租户

当然,您可能不想在每次添加新租户时都重新启动应用程序.  在这种情况下,可以使用 `AuthenticationManager` 实例的存储库配置 `JwtIssuerAuthenticationManagerResolver`,您可以在运行时对其进行编辑,如下所示:

====
.Java
[source,java,role="primary"]
----
private void addManager(Map<String, AuthenticationManager> authenticationManagers, String issuer) {
	JwtAuthenticationProvider authenticationProvider = new JwtAuthenticationProvider
	        (JwtDecoders.fromIssuerLocation(issuer));
	authenticationManagers.put(issuer, authenticationProvider::authenticate);
}

// ...

JwtIssuerAuthenticationManagerResolver authenticationManagerResolver =
        new JwtIssuerAuthenticationManagerResolver(authenticationManagers::get);

http
    .authorizeRequests(authorize -> authorize
        .anyRequest().authenticated()
    )
    .oauth2ResourceServer(oauth2 -> oauth2
        .authenticationManagerResolver(authenticationManagerResolver)
    );
----

.Kotlin
[source,kotlin,role="secondary"]
----
private fun addManager(authenticationManagers: MutableMap<String, AuthenticationManager>, issuer: String) {
    val authenticationProvider = JwtAuthenticationProvider(JwtDecoders.fromIssuerLocation(issuer))
    authenticationManagers[issuer] = AuthenticationManager {
        authentication: Authentication? -> authenticationProvider.authenticate(authentication)
    }
}

// ...

val customAuthenticationManagerResolver: JwtIssuerAuthenticationManagerResolver =
    JwtIssuerAuthenticationManagerResolver(authenticationManagers::get)
http {
    authorizeRequests {
        authorize(anyRequest, authenticated)
    }
    oauth2ResourceServer {
        authenticationManagerResolver = customAuthenticationManagerResolver
    }
}
----
====

在这种情况下,您可以使用给定 issuer 的策略来构造 `JwtIssuerAuthenticationManagerResolver`,以获取 `AuthenticationManager`.  这种方法使我们可以在运行时从存储库中添加和删除元素 (如片段中的 `Map` 所示) .

NOTE: 仅选择任何 issuer 并从中构造 `AuthenticationManager` 是不安全的.  issuer 应该是代码可以从允许的 issuers 的受信任来源进行验证的发行者.

===== 仅解析一次 Claim

您可能已经观察到,这种策略虽然简单,但是却存在一个折衷,即JWT由 `AuthenticationManagerResolver` 解析一次,然后由  <<oauth2resourceserver-jwt-architecture-jwtdecoder,`JwtDecoder`>> 解析.

通过直接使用Nimbus的 `JWTClaimSetAwareJWSKeySelector` 配置  <<oauth2resourceserver-jwt-architecture-jwtdecoder,`JwtDecoder`>> 可以减轻这种额外的解析:

====
.Java
[source,java,role="primary"]
----
@Component
public class TenantJWSKeySelector
    implements JWTClaimSetAwareJWSKeySelector<SecurityContext> {

	private final TenantRepository tenants; <1>
	private final Map<String, JWSKeySelector<SecurityContext>> selectors = new ConcurrentHashMap<>(); <2>

	public TenantJWSKeySelector(TenantRepository tenants) {
		this.tenants = tenants;
	}

	@Override
	public List<? extends Key> selectKeys(JWSHeader jwsHeader, JWTClaimsSet jwtClaimsSet, SecurityContext securityContext)
			throws KeySourceException {
		return this.selectors.computeIfAbsent(toTenant(jwtClaimsSet), this::fromTenant)
				.selectJWSKeys(jwsHeader, securityContext);
	}

	private String toTenant(JWTClaimsSet claimSet) {
		return (String) claimSet.getClaim("iss");
	}

	private JWSKeySelector<SecurityContext> fromTenant(String tenant) {
		return Optional.ofNullable(this.tenantRepository.findById(tenant)) <3>
		        .map(t -> t.getAttrbute("jwks_uri"))
				.map(this::fromUri)
				.orElseThrow(() -> new IllegalArgumentException("unknown tenant"));
	}

	private JWSKeySelector<SecurityContext> fromUri(String uri) {
		try {
			return JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(new URL(uri)); <4>
		} catch (Exception ex) {
			throw new IllegalArgumentException(ex);
		}
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Component
class TenantJWSKeySelector(tenants: TenantRepository) : JWTClaimSetAwareJWSKeySelector<SecurityContext> {
    private val tenants: TenantRepository <1>
    private val selectors: MutableMap<String, JWSKeySelector<SecurityContext>> = ConcurrentHashMap() <2>

    init {
        this.tenants = tenants
    }

    fun selectKeys(jwsHeader: JWSHeader?, jwtClaimsSet: JWTClaimsSet, securityContext: SecurityContext): List<Key?> {
        return selectors.computeIfAbsent(toTenant(jwtClaimsSet)) { tenant: String -> fromTenant(tenant) }
                .selectJWSKeys(jwsHeader, securityContext)
    }

    private fun toTenant(claimSet: JWTClaimsSet): String {
        return claimSet.getClaim("iss") as String
    }

    private fun fromTenant(tenant: String): JWSKeySelector<SecurityContext> {
        return Optional.ofNullable(this.tenants.findById(tenant)) <3>
                .map { t -> t.getAttrbute("jwks_uri") }
                .map { uri: String -> fromUri(uri) }
                .orElseThrow { IllegalArgumentException("unknown tenant") }
    }

    private fun fromUri(uri: String): JWSKeySelector<SecurityContext?> {
        return try {
            JWSAlgorithmFamilyJWSKeySelector.fromJWKSetURL(URL(uri)) <4>
        } catch (ex: Exception) {
            throw IllegalArgumentException(ex)
        }
    }
}
----
====
<1> 租户信息的假想来源
<2> `JWKKeySelector` 的缓存,由租户标识符输入
<3> 查找租户比简单地即时计算JWK Set端点更安全-查找充当租户白名单
<4> 通过从JWK Set端点返回的密钥类型创建一个 `JWSKeySelector` -此处的延迟查找意味着您不需要在启动时配置所有租户

上面的按键选择器由许多按键选择器组成.
它根据JWT中的 `iss` 声明选择要使用的键选择器.

NOTE: 要使用此方法,请确保将授权服务器配置为包括声明集作为令牌签名的一部分.
没有这个,您就不能保证发行人不会被坏演员改变.

接下来,我们可以构造一个 `JWTProcessor`:

====
.Java
[source,java,role="primary"]
----
@Bean
JWTProcessor jwtProcessor(JWTClaimSetJWSKeySelector keySelector) {
	ConfigurableJWTProcessor<SecurityContext> jwtProcessor =
            new DefaultJWTProcessor();
	jwtProcessor.setJWTClaimSetJWSKeySelector(keySelector);
	return jwtProcessor;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtProcessor(keySelector: JWTClaimsSetAwareJWSKeySelector<SecurityContext>): JWTProcessor<SecurityContext> {
    val jwtProcessor = DefaultJWTProcessor<SecurityContext>()
    jwtProcessor.jwtClaimsSetAwareJWSKeySelector = keySelector
    return jwtProcessor
}
----
====

如您所见,将租户意识降低到此级别的权衡是更多配置.
我们还有一点.

接下来,我们仍然要确保您正在验证发行人.
但是,由于每个JWT的颁发者可能有所不同,因此,您还需要一个支持租户的验证器:

====
.Java
[source,java,role="primary"]
----
@Component
public class TenantJwtIssuerValidator implements OAuth2TokenValidator<Jwt> {
	private final TenantRepository tenants;
	private final Map<String, JwtIssuerValidator> validators = new ConcurrentHashMap<>();

	public TenantJwtIssuerValidator(TenantRepository tenants) {
		this.tenants = tenants;
	}

	@Override
	public OAuth2TokenValidatorResult validate(Jwt token) {
		return this.validators.computeIfAbsent(toTenant(token), this::fromTenant)
				.validate(token);
	}

	private String toTenant(Jwt jwt) {
		return jwt.getIssuer();
	}

	private JwtIssuerValidator fromTenant(String tenant) {
		return Optional.ofNullable(this.tenants.findById(tenant))
		        .map(t -> t.getAttribute("issuer"))
				.map(JwtIssuerValidator::new)
				.orElseThrow(() -> new IllegalArgumentException("unknown tenant"));
	}
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Component
class TenantJwtIssuerValidator(tenants: TenantRepository) : OAuth2TokenValidator<Jwt> {
    private val tenants: TenantRepository
    private val validators: MutableMap<String, JwtIssuerValidator> = ConcurrentHashMap()
    override fun validate(token: Jwt): OAuth2TokenValidatorResult {
        return validators.computeIfAbsent(toTenant(token)) { tenant: String -> fromTenant(tenant) }
                .validate(token)
    }

    private fun toTenant(jwt: Jwt): String {
        return jwt.issuer.toString()
    }

    private fun fromTenant(tenant: String): JwtIssuerValidator {
        return Optional.ofNullable(tenants.findById(tenant))
                .map({ t -> t.getAttribute("issuer") })
                .map({ JwtIssuerValidator() })
                .orElseThrow({ IllegalArgumentException("unknown tenant") })
    }

    init {
        this.tenants = tenants
    }
}
----
====

现在我们有了一个可以识别租户的处理器和一个可以识别租户的验证器,我们可以继续创建 <<oauth2resourceserver-jwt-architecture-jwtdecoder,`JwtDecoder`>> 了:

====
.Java
[source,java,role="primary"]
----
@Bean
JwtDecoder jwtDecoder(JWTProcessor jwtProcessor, OAuth2TokenValidator<Jwt> jwtValidator) {
	NimbusJwtDecoder decoder = new NimbusJwtDecoder(processor);
	OAuth2TokenValidator<Jwt> validator = new DelegatingOAuth2TokenValidator<>
			(JwtValidators.createDefault(), this.jwtValidator);
	decoder.setJwtValidator(validator);
	return decoder;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun jwtDecoder(jwtProcessor: JWTProcessor<SecurityContext>?, jwtValidator: OAuth2TokenValidator<Jwt>?): JwtDecoder {
    val decoder = NimbusJwtDecoder(jwtProcessor)
    val validator: OAuth2TokenValidator<Jwt> = DelegatingOAuth2TokenValidator(JwtValidators.createDefault(), jwtValidator)
    decoder.setJwtValidator(validator)
    return decoder
}
----
====

我们已经结束了有关解决租户的讨论.

如果选择按请求材料解决租户,则需要确保以相同的方式访问下游资源服务器.
例如,如果要按子域进行解析,则需要使用相同的子域来寻址下游资源服务器.

但是,如果您通过不记名令牌中的声明解决该问题,请继续阅读以了解<<oauth2resourceserver-bearertoken-resolver,Spring Security's support for bearer token propagation>>.

[[oauth2resourceserver-bearertoken-resolver]]
=== Bearer Token 解析

默认情况下,资源服务器在 `Authorization` 头中查找 bearer 令牌.
但是,可以通过两种方式进行自定义.

==== 从自定义请求头读取 bearer 令牌

例如,您可能需要从自定义请求头读取 bearer 令牌
为此,您可以将 `DefaultBearerTokenResolver` 实例连接到 DSL,如以下示例所示:

.Custom Bearer Token Header
====
.Java
[source,java,role="primary"]
----
@Bean
BearerTokenResolver bearerTokenResolver() {
    DefaultBearerTokenResolver bearerTokenResolver = new DefaultBearerTokenResolver();
    bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION);
    return bearerTokenResolver;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun bearerTokenResolver(): BearerTokenResolver {
    val bearerTokenResolver = DefaultBearerTokenResolver()
    bearerTokenResolver.setBearerTokenHeaderName(HttpHeaders.PROXY_AUTHORIZATION)
    return bearerTokenResolver
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <oauth2-resource-server bearer-token-resolver-ref="bearerTokenResolver"/>
</http>

<bean id="bearerTokenResolver"
        class="org.springframework.security.oauth2.server.resource.web.DefaultBearerTokenResolver">
    <property name="bearerTokenHeaderName" value="Proxy-Authorization"/>
</bean>
----
====

或者， 在提供者同时使用自定义 header 头和值的情况下， 可以改用 `HeaderBearerTokenResolver`.

==== 从表单参数读取 bearer 令牌

或者,您可能希望从表单参数中读取令牌,可以通过配置 `DefaultBearerTokenResolver` 来完成,如下所示:

.Form Parameter Bearer Token
====
.Java
[source,java,role="primary"]
----
DefaultBearerTokenResolver resolver = new DefaultBearerTokenResolver();
resolver.setAllowFormEncodedBodyParameter(true);
http
    .oauth2ResourceServer(oauth2 -> oauth2
        .bearerTokenResolver(resolver)
    );
----

.Kotlin
[source,kotlin,role="secondary"]
----
val resolver = DefaultBearerTokenResolver()
resolver.setAllowFormEncodedBodyParameter(true)
http {
    oauth2ResourceServer {
        bearerTokenResolver = resolver
    }
}
----

.Xml
[source,xml,role="secondary"]
----
<http>
    <oauth2-resource-server bearer-token-resolver-ref="bearerTokenResolver"/>
</http>

<bean id="bearerTokenResolver"
        class="org.springframework.security.oauth2.server.resource.web.HeaderBearerTokenResolver">
    <property name="allowFormEncodedBodyParameter" value="true"/>
</bean>
----
====

=== Bearer Token 传递

现在您已经拥有了一个 Bearer 令牌,将它传递给下游服务可能会很方便.
使用 `{security-api-url}org/springframework/security/oauth2/server/resource/web/reactive/function/client/ServletBearerExchangeFilterFunction.html[ServletBearerExchangeFilterFunction]` 非常简单,您可以在以下示例中看到它:

====
.Java
[source,java,role="primary"]
----
@Bean
public WebClient rest() {
    return WebClient.builder()
            .filter(new ServletBearerExchangeFilterFunction())
            .build();
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun rest(): WebClient {
    return WebClient.builder()
            .filter(ServletBearerExchangeFilterFunction())
            .build()
}
----
====

当上述 `WebClient` 用于执行请求时,Spring Security将查找当前的 `Authentication` 并提取任何 `AbstractOAuth2Token` 凭据.  然后,它将在授权请求头中传递该令牌.

例如:

====
.Java
[source,java,role="primary"]
----
this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono(String.class)
        .block()
----

.Kotlin
[source,kotlin,role="secondary"]
----
this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .retrieve()
        .bodyToMono<String>()
        .block()
----
====


将调用  `https://other-service.example.com/endpoint`, 为您添加 Bearer 令牌授权 `Authorization`  头.

在您需要覆盖此行为的地方,您可以自己提供请求头,这很简单,例如:

====
.Java
[source,java,role="primary"]
----
this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers(headers -> headers.setBearerAuth(overridingToken))
        .retrieve()
        .bodyToMono(String.class)
        .block()
----

.Kotlin
[source,kotlin,role="secondary"]
----
this.rest.get()
        .uri("https://other-service.example.com/endpoint")
        .headers{  headers -> headers.setBearerAuth(overridingToken)}
        .retrieve()
        .bodyToMono<String>()
        .block()
----
====

在这种情况下,过滤器将回退并将请求转发到 Web 过滤器链的其余部分.

[NOTE]
与 https://docs.spring.io/spring-security/site/docs/current-SNAPSHOT/api/org/springframework/security/oauth2/client/web/reactive/function/client/ServletOAuth2AuthorizedClientExchangeFilterFunction.html[OAuth 2.0 Client filter function]功能不同,此过滤器功能不会在令牌过期时尝试更新令牌.  要获得此级别的支持,请使用OAuth 2.0客户端过滤器.

==== `RestTemplate` 支持

目前尚无对 `ServletBearerExchangeFilterFunction` 的 `RestTemplate` 的专门支持,但您可以使用自己的拦截器非常简单地实现传播:

====
.Java
[source,java,role="primary"]
----
@Bean
RestTemplate rest() {
	RestTemplate rest = new RestTemplate();
	rest.getInterceptors().add((request, body, execution) -> {
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		if (authentication == null) {
			return execution.execute(request, body);
		}

		if (!(authentication.getCredentials() instanceof AbstractOAuth2Token)) {
			return execution.execute(request, body);
		}

		AbstractOAuth2Token token = (AbstractOAuth2Token) authentication.getCredentials();
	    request.getHeaders().setBearerAuth(token.getTokenValue());
	    return execution.execute(request, body);
	});
	return rest;
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Bean
fun rest(): RestTemplate {
    val rest = RestTemplate()
    rest.interceptors.add(ClientHttpRequestInterceptor { request, body, execution ->
        val authentication: Authentication? = SecurityContextHolder.getContext().authentication
        if (authentication != null) {
            execution.execute(request, body)
        }

        if (authentication!!.credentials !is AbstractOAuth2Token) {
            execution.execute(request, body)
        }

        val token: AbstractOAuth2Token = authentication.credentials as AbstractOAuth2Token
        request.headers.setBearerAuth(token.tokenValue)
        execution.execute(request, body)
    })
    return rest
}
----
====

[NOTE]
与 {security-api-url}org/springframework/security/oauth2/client/OAuth2AuthorizedClientManager.html[OAuth 2.0 授权的客户端管理器不同]， 此过滤器拦截不会尝试续订令牌， 是否应该过期.  要获得此级别的支持， 请使用 <<oauth2client,OAuth 2.0 Authorized Client Manager>> 创建拦截器.


[[oauth2resourceserver-bearertoken-failure]]
=== Bearer Token 失败

bearer token 可能由于多种原因而无效.  例如,令牌可能失效.

在这种情况下,资源服务器会抛出 `InvalidBearerTokenException`.
与其他例外一样,这会导致OAuth 2.0 bearer token 错误响应:

[source,http request]
----
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Bearer error_code="invalid_token", error_description="Unsupported algorithm of none", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"
----

此外,它以 `AuthenticationFailureBadCredentialsEvent` 的形式发布,您可以像这样: <<servlet-events,监听您的应用程序>>

====
.Java
[source,java,role="primary"]
----
@Component
public class FailureEvents {
	@EventListener
    public void onFailure(AuthenticationFailureEvent failure) {
		if (badCredentials.getAuthentication() instanceof BearerTokenAuthenticationToken) {
		    // ... handle
        }
    }
}
----

.Kotlin
[source,kotlin,role="secondary"]
----
@Component
class FailureEvents {
    @EventListener
    fun onFailure(badCredentials: AuthenticationFailureBadCredentialsEvent) {
        if (badCredentials.authentication is BearerTokenAuthenticationToken) {
            // ... handle
        }
    }
}
----
====
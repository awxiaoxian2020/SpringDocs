[[servlet-headers]]
= 安全HTTP响应头
<<headers,Security HTTP Response Headers>>可用于提高Web应用程序的安全性.  本节专门针对基于Servlet的安全HTTP响应标头提供支持.

[[servlet-headers-default]]
== 默认安全请求头

Spring Security提供了一组默认的  <<headers-default,default set of Security HTTP Response Headers>>  ,以提供安全的默认值.  虽然这些标头中的每一个均被视为最佳实践,但应注意,并非所有客户端都使用这些标头,因此鼓励进行额外的测试.

您可以自定义特定的标题.  例如,假设您希望使用默认值,但您希望为 <<servlet-headers-frame-options,X-Frame-Options>> 指定 `SAMEORIGIN`.

您可以使用以下Java配置轻松完成此操作:

.Customize Default Security Headers with Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			// ...
			.headers(headers ->
				headers
					.frameOptions(frameOptions ->
						frameOptions.sameOrigin()
					)
			);
	}
}
----
====

.Customize Default Security Headers with XML Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<frame-options policy="SAMEORIGIN" />
	</headers>
</http>
----
====

如果您不想添加默认值,并且希望对应使用的内容进行明确控制,则可以禁用默认值.  下面提供了基于Java和XML的配置示例:

如果您使用的是Spring Security的Java配置,则以下内容只会添加<<headers-cache-control,Cache Control>>.


[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
				headers
					// do not use any default headers unless explicitly listed
					.defaultsDisabled()
					.cacheControl(withDefaults())
			);
	}
}
----

以下XML将仅添加 <<headers-cache-control,Cache Control>>.

[source,xml]
----
<http>
	<!-- ... -->

	<headers defaults-disabled="true">
		<cache-control/>
	</headers>
</http>
----


如有必要,可以使用以下Java配置禁用所有HTTP安全响应头:

[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
				headers.disable()
			);
	}
}
----

如有必要,您可以使用以下XML配置禁用所有HTTP安全响应头:

[source,xml]
----
<http>
	<!-- ... -->

	<headers disabled="true" />
</http>
----

[[servlet-headers-cache-control]]
== 缓存控制

Spring Security默认包含 <<headers-cache-control,Cache Control>> 标头.

但是,如果您实际上想缓存特定的响应,则您的应用程序可以有选择地调用 https://docs.oracle.com/javaee/6/api/javax/servlet/http/HttpServletResponse.html#setHeader(java.lang.String,java.lang.String)[HttpServletResponse.setHeader(String,String)]  来覆盖Spring Security设置的标头.  这对于确保正确缓存CSS,JavaScript和图像之类的内容很有用.

使用Spring Web MVC时,通常在您的配置中完成.  有关如何执行此操作的详细信息,请参见Spring参考文档的  https://docs.spring.io/spring/docs/5.0.0.RELEASE/spring-framework-reference/web.html#mvc-config-static-resources[静态资源] 部分.

如有必要,您还可以禁用Spring Security的缓存控制HTTP响应标头.

.Cache Control Disabled with Java Configuration
====
[source,java]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			// ...
			.headers(headers ->
				headers.cacheControl(cache ->
					cache.disabled()
				)
			);
	}
}
----
====

同样,可以使用  <<nsa-cache-control,<cache-control>>>  元素将其禁用:

[[servlet-headers-content-type-options]]
== Content Type 选项

Spring Security默认包含  <<headers-content-type-options,Content-Type>> 头.  但是,您可以使用以下命令在Java配置中将其禁用:

.Content Type Options Disabled with Java Configuration
====
[source,java]
----
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			// ...
			.headers(headers ->
				headers.contentTypeOptions(contentType ->
					contentType.disabled()
				)
			);
	}
}
----
====

同样,您可以使用 <<nsa-content-type-options,<content-type-options>>> 元素将其禁用:

.Content Type Options Disabled with XML
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<content-type-options disabled="true"/>
	</headers>
</http>
----
====

[[servlet-headers-hsts]]
== HTTP Strict Transport Security (HSTS)

Spring Security默认提供严格传输安全标头.  但是,您可以显式自定义结果.  例如,以下是为HSTS显式提供Java配置的示例:

.Strict Transport Security with Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
				headers
					.httpStrictTransportSecurity(hsts ->
						hsts
							.includeSubDomains(true)
							.preload(true)
							.maxAgeInSeconds(31536000)
					)
			);
	}
}
----
====

同样,您可以使用 <<nsa-hsts,<hsts>>> 元素为HSTS显式提供XML配置,如下所示:

.Strict Transport Security with XML Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<hsts
			include-subdomains="true"
			max-age-seconds="31536000"
			preload="true" />
	</headers>
</http>
----
====

[[servlet-headers-hpkp]]
== HTTP Public Key Pinning (HPKP)

出于被动性原因,Spring Security为 <<headers-hpkp,HTTP Public Key Pinning>>  提供了servlet支持, <<headers-hpkp-deprecated,但不再推荐使用>>.

您可以使用Java配置启用HPKP标头:
.HTTP Public Key Pinning with Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
				headers
					.httpPublicKeyPinning(hpkp ->
						hpkp
							.includeSubDomains(true)
							.reportUri("https://example.net/pkp-report")
							.addSha256Pins("d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=", "E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=")
					)
			);
	}
}
----
====

同样,您可以使用  <<nsa-hpkp,<hpkp>>> 元素启用HPKP标头,如下所示:

.HTTP Public Key Pinning with XML Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<hpkp
			include-subdomains="true"
			report-uri="https://example.net/pkp-report">
			<pins>
				<pin algorithm="sha256">d6qzRu9zOECb90Uez27xWltNsj0e1Md7GkYYkVoZWmM=</pin>
				<pin algorithm="sha256">E9CZ9INDbd+2eRQozYqqbQ2yXLVKB9+xcprMF+44U1g=</pin>
			</pins>
		</hpkp>
	</headers>
</http>
----
====

[[servlet-headers-frame-options]]
== X-Frame-Options
默认情况下,Spring Security使用  <<headers-frame-options,X-Frame-Options>> 禁用iframe中的渲染.

您可以使用以下方法自定义框架选项以在Java配置中使用相同的来源:

.X-Frame-Options: SAMEORIGIN with Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
				headers
					.frameOptions(frameOptions ->
						frameOptions
							.sameOrigin()
					)
			);
	}
}
----
====

另外,您可以在XML配置中使用 <<nsa-frame-options,frame-options>>  元素:

.X-Frame-Options: SAMEORIGIN with XML Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<frame-options
		policy="SAMEORIGIN" />
	</headers>
</http>
----
====


[[servlet-headers-xss-protection]]
== X-XSS-Protection
默认情况下,Spring Security指示浏览器使用 <<headers-xss-protection,X-XSS-Protection header> 阻止反射的XSS攻击.
但是,您可以更改此默认值.  例如,以下Java配置指定Spring Security不再指示浏览器阻止内容:

.X-XSS-Protection Customization with Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
				headers
					.xssProtection(xssProtection ->
						xssProtection
							.block(false)
					)
			);
	}
}
----
====

同样,以下XML配置指定Spring Security不再指示浏览器阻止内容:

.X-XSS-Protection Customization with XML Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<xss-protection block="false"/>
	</headers>
</http>
----
====

[[servlet-headers-csp]]
== Content Security Policy (CSP)

Spring Security默认情况下不会添加  <<headers-csp,Content Security Policy>>,因为没有应用程序的上下文就无法知道合理的默认值.  Web应用程序作者必须声明安全策略以强制执行和/或监视受保护的资源.

例如,给定以下安全策略:

.Content Security Policy Example
====
[source,http]
----
Content-Security-Policy: script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/
----
====

您可以使用Java配置启用CSP标头,如下所示:

.Content Security Policy Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			// ...
			.headers(headers ->
				headers
					.contentSecurityPolicy(csp ->
						csp
							.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
					)
			);
	}
}
----
====

使用带有 <<nsa-content-security-policy,<content-security-policy>>> 元素的XML配置可以完成相同的操作,如下所示:

.Content Security Policy Java Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/" />
	</headers>
</http>
----
====

要启用CSP仅报告标题,请提供以下Java配置:

.Content Security Policy Report Only Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
		WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
				headers
					.contentSecurityPolicy(csp ->
						csp
							.policyDirectives("script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/")
							.reportOnly()
					)
			);
	}
}
----
====

使用以下方法进行XML配置可以实现相同的目的:

.Content Security Policy XML Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<content-security-policy
			policy-directives="script-src 'self' https://trustedscripts.example.com; object-src https://trustedplugins.example.com; report-uri /csp-report-endpoint/"
			report-only="true" />
	</headers>
</http>
----
====

[[servlet-headers-referrer]]
== 推荐人策略

Spring Security默认情况下不添加  <<headers-referrer,Referrer Policy>> 标头.  您可以使用Java配置启用Referrer Policy标头,如下所示:

.Referrer Policy Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) {
		http
			// ...
			.headers(headers ->
				headers
					.referrerPolicy(referrerPolicy ->
						referrerPolicy
							.policy(ReferrerPolicy.SAME_ORIGIN)
					)
			);
	}
}
----
====

您可以使用带有 <<nsa-referrer-policy,<referrer-policy>>>  元素的XML配置来启用 `Referrer-Policy` 标头,如下所示:

.Referrer Policy XML Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<referrer-policy policy="same-origin" />
	</headers>
</http>
----
====

[[servlet-headers-feature]]
== Feature Policy (功能策略)

Spring Security默认不添加  <<headers-feature,Feature Policy>>  头.  以下  `Feature-Policy`  标头:

.Feature-Policy Example
====
[source]
----
Feature-Policy: geolocation 'self'
----
====

可以使用Java配置启用功能策略标头,如下所示:

.Feature-Policy Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
				headers
					.featurePolicy("geolocation 'self'")
			);
	}
}
----
====

另外,您可以使用带有<feature-policy>元素的XML配置来启用 <<nsa-feature-policy,<feature-policy>>> 标头,如下所示:

.Feature-Policy XML Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<feature-policy policy-directives="geolocation 'self'" />
	</headers>
</http>
----
====

[[servlet-headers-clear-site-data]]
== 清除站点数据

Spring Security默认情况下不添加<<headers-clear-site-data,Clear-Site-Data>>  标头.  以下Clear-Site-Data标头:

.Clear-Site-Data Example
====
----
Clear-Site-Data: "cache", "cookies"
----
====

可以使用以下配置在注销时发送:

.Clear-Site-Data Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.logout()
				.addLogoutHandler(new HeaderWriterLogoutHandler(new ClearSiteDataHeaderWriter(CACHE, COOKIES)));
	}
}
----
====

[[servlet-headers-custom]]
== 自定义 Headers
Spring Security具有使您可以方便地将更常见的安全标头添加到您的应用程序的机制. 但是,它也提供了挂钩来启用添加自定义标头.

[[servlet-headers-static]]
=== Static Headers
有时您可能希望将不支持的自定义安全标头注入应用程序中. 例如,给定以下自定义安全标头:

[source]
----
X-Custom-Security-Header: header-value
----

可以使用Java配置将标头添加到响应中,如下所示:

.StaticHeadersWriter Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
				headers
					.addHeaderWriter(new StaticHeadersWriter("X-Custom-Security-Header","header-value"))
			);
	}
}
----
====

使用XML命名空间时,可以使用 <<nsa-header,<header>>> 元素将这些标头添加到响应中,如下所示:

.StaticHeadersWriter XML Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<header name="X-Custom-Security-Header" value="header-value"/>
	</headers>
</http>
----
====

[[servlet-headers-writer]]
=== Headers Writer
如果命名空间或Java配置不支持所需的标头,则可以创建自定义的 `HeadersWriter` 实例,甚至提供 `HeadersWriter` 的自定义实现.

让我们看一个使用 `XFrameOptionsHeaderWriter` 的自定义实例的示例.  也许您希望允许对相同来源的内容进行框架化.
如果要显式配置 `X-Frame-Options`,可以使用以下Java配置来完成:

.Headers Writer Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		http
			// ...
			.headers(headers ->
				headers
					.addHeaderWriter(new XFrameOptionsHeaderWriter(XFrameOptionsMode.SAMEORIGIN))
			);
	}
}
----
====

另外,我们可以对基于XML的配置使用 <<nsa-header-ref,ref>> 属性:

.Headers Writer XML Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<header ref="frameOptionsWriter"/>
	</headers>
</http>
<!-- Requires the c-namespace.
See https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-c-namespace
-->
<beans:bean id="frameOptionsWriter"
	class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"
	c:frameOptionsMode="SAMEORIGIN"/>
----
====

[[headers-delegatingrequestmatcherheaderwriter]]
=== DelegatingRequestMatcherHeaderWriter
有时您可能只想为某些请求编写标头.  例如,也许您只想保护登录页面免于陷害.  您可以使用 `DelegatingRequestMatcherHeaderWriter` 来实现.  使用 Java 配置时,可以使用以下方法完成:

.DelegatingRequestMatcherHeaderWriter Java Configuration
====
[source,java]
----
@EnableWebSecurity
public class WebSecurityConfig extends
WebSecurityConfigurerAdapter {

	@Override
	protected void configure(HttpSecurity http) throws Exception {
		RequestMatcher matcher = new AntPathRequestMatcher("/login");
		DelegatingRequestMatcherHeaderWriter headerWriter =
			new DelegatingRequestMatcherHeaderWriter(matcher,new XFrameOptionsHeaderWriter());
		http
			// ...
			.headers(headers ->
				headers
					.frameOptions(frameOptions ->
						frameOptions.disable()
					)
					.addHeaderWriter(headerWriter)
			);
	}
}
----
====

使用基于XML的配置可以实现相同的目的:

.DelegatingRequestMatcherHeaderWriter XML Configuration
====
[source,xml]
----
<http>
	<!-- ... -->

	<headers>
		<frame-options disabled="true"/>
		<header ref="headerWriter"/>
	</headers>
</http>

<beans:bean id="headerWriter"
	class="org.springframework.security.web.header.writers.DelegatingRequestMatcherHeaderWriter">
	<beans:constructor-arg>
		<bean class="org.springframework.security.web.util.matcher.AntPathRequestMatcher"
			c:pattern="/login"/>
	</beans:constructor-arg>
	<beans:constructor-arg>
		<beans:bean
			class="org.springframework.security.web.header.writers.frameoptions.XFrameOptionsHeaderWriter"/>
	</beans:constructor-arg>
</beans:bean>
----
====


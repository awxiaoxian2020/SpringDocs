[[test-webflux]]
= Reactive 测试支持

[[test-erms]]
== 测试 Reactive 方法安全

例如,我们可以使用与<<jc-erms, 第18.1节 "测试方法安全性">> 中相同的设置和注解来测试  <<test-method,第27章 `EnableReactiveMethodSecurity` 中>>的示例. 这是我们可以做的最小样本:

[source,java]
----
@RunWith(SpringRunner.class)
@ContextConfiguration(classes = HelloWebfluxMethodApplication.class)
public class HelloWorldMessageServiceTests {
	@Autowired
	HelloWorldMessageService messages;

	@Test
	public void messagesWhenNotAuthenticatedThenDenied() {
		StepVerifier.create(this.messages.findMessage())
			.expectError(AccessDeniedException.class)
			.verify();
	}

	@Test
	@WithMockUser
	public void messagesWhenUserThenDenied() {
		StepVerifier.create(this.messages.findMessage())
			.expectError(AccessDeniedException.class)
			.verify();
	}

	@Test
	@WithMockUser(roles = "ADMIN")
	public void messagesWhenAdminThenOk() {
		StepVerifier.create(this.messages.findMessage())
			.expectNext("Hello World!")
			.verifyComplete();
	}
}
----

[[test-webtestclient]]
== WebTestClientSupport

Spring Security提供了与 `WebTestClient` 的集成. 基本设置如下所示:

[source,java]
----
@RunWith(SpringRunner.class)
@ContextConfiguration(classes = HelloWebfluxMethodApplication.class)
public class HelloWebfluxMethodApplicationTests {
	@Autowired
	ApplicationContext context;

	WebTestClient rest;

	@Before
	public void setup() {
		this.rest = WebTestClient
			.bindToApplicationContext(this.context)
			// add Spring Security test Support
			.apply(springSecurity())
			.configureClient()
			.filter(basicAuthentication())
			.build();
	}
	// ...
}
----

=== 认证
将Spring Security支持应用于 `WebTestClient` 之后,我们可以使用注解或 `mutateWith` 支持. 例如:

[source,java]
----
@Test
public void messageWhenNotAuthenticated() throws Exception {
	this.rest
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isUnauthorized();
}

// --- WithMockUser ---

@Test
@WithMockUser
public void messageWhenWithMockUserThenForbidden() throws Exception {
	this.rest
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isEqualTo(HttpStatus.FORBIDDEN);
}

@Test
@WithMockUser(roles = "ADMIN")
public void messageWhenWithMockAdminThenOk() throws Exception {
	this.rest
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isOk()
		.expectBody(String.class).isEqualTo("Hello World!");
}

// --- mutateWith mockUser ---

@Test
public void messageWhenMutateWithMockUserThenForbidden() throws Exception {
	this.rest
		.mutateWith(mockUser())
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isEqualTo(HttpStatus.FORBIDDEN);
}

@Test
public void messageWhenMutateWithMockAdminThenOk() throws Exception {
	this.rest
		.mutateWith(mockUser().roles("ADMIN"))
		.get()
		.uri("/message")
		.exchange()
		.expectStatus().isOk()
		.expectBody(String.class).isEqualTo("Hello World!");
}
----


=== CSRF 支持

Spring Security 还为使用 `WebTestClient` 的 CSRF 提供测试支持. 例如:

[source,java]
----
this.rest
	// provide a valid CSRF token
	.mutateWith(csrf())
	.post()
	.uri("/login")
	...
----

=== 测试 Bearer 认证

为了在资源服务器上发出授权请求,您需要一个承载令牌.  如果为JWT配置了资源服务器,则这意味着需要对承载令牌进行签名,然后根据JWT规范进行编码.  所有这些都可能令人生畏,尤其是当这不是您的测试重点时.

幸运的是,您可以通过多种简单的方法来克服此困难,并使您的测试专注于授权而不是表示承载令牌.  我们现在来看其中两个:

==== `mockJwt() WebTestClientConfigurer`

第一种方法是通过 `WebTestClientConfigurer`. 其中最简单的如下所示:

[source,java]
----
client
    .mutateWith(mockJwt()).get().uri("/endpoint").exchange();
----

要做的就是创建一个模拟的 `Jwt`,将其正确地通过任何身份验证API传递,以便您的授权机制可以对其进行验证.

默认情况下,它创建的 `JWT` 具有以下特征:

[source,json]
----
{
  "headers" : { "alg" : "none" },
  "claims" : {
    "sub" : "user",
    "scope" : "read"
  }
}
----

经过测试的结果是,`Jwt` 将通过以下方式通过:

[source,java]
----
assertThat(jwt.getTokenValue()).isEqualTo("token");
assertThat(jwt.getHeaders().get("alg")).isEqualTo("none");
assertThat(jwt.getSubject()).isEqualTo("sub");
GrantedAuthority authority = jwt.getAuthorities().iterator().next();
assertThat(authority.getAuthority()).isEqualTo("read");
----

当然可以配置这些值.

可以使用其相应方法配置任何标题或声明:

[source,java]
----
client
	.mutateWith(jwt(jwt -> jwt.header("kid", "one")
		.claim("iss", "https://idp.example.org")))
	.get().uri("/endpoint").exchange();
----

[source,java]
----
client
	.mutateWith(jwt(jwt -> jwt.claims(claims -> claims.remove("scope"))))
	.get().uri("/endpoint").exchange();
----

`scope` 和 `scp` 声明在这里的处理方式与它们在普通承载令牌请求中的处理方式相同.  但是,可以通过提供测试所需的GrantedAuthority实例的列表来覆盖它:

[source,java]
----
client
	.mutateWith(jwt().authorities(new SimpleGrantedAuthority("SCOPE_messages")))
	.get().uri("/endpoint").exchange();
----

或者,如果您有一个自定义的 `Jwt`   `Collection<GrantedAuthority>` 转换器,则还可以使用它来导出授权:

[source,java]
----
client
	.mutateWith(jwt().authorities(new MyConverter()))
	.get().uri("/endpoint").exchange();
----

您还可以指定一个完整的 `Jwt`,为此 `{security-api-url}org/springframework/security/oauth2/jwt/Jwt.Builder.html[Jwt.Builder]` 非常方便:

[source,java]
----
Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .claim("scope", "read");

client
	.mutateWith(jwt(jwt))
	.get().uri("/endpoint").exchange();
----

===== `authentication()` `WebTestClientConfigurer`

第二种方法是使用 `authentication()` `Mutator`.  本质上,您可以实例化自己的 `JwtAuthenticationToken` 并在测试中提供它,如下所示:

[source,java]
----
Jwt jwt = Jwt.withTokenValue("token")
    .header("alg", "none")
    .claim("sub", "user")
    .build();
Collection<GrantedAuthority> authorities = AuthorityUtils.createAuthorityList("SCOPE_read");
JwtAuthenticationToken token = new JwtAuthenticationToken(jwt, authorities);

client
	.mutateWith(authentication(token))
	.get().uri("/endpoint").exchange();
----

请注意,作为替代方法,您还可以使用 `@MockBean` 注解来模拟 `ReactiveJwtDecoder` bean本身.
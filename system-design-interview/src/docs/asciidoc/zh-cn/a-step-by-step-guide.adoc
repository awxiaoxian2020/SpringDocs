= System Design Interviews: A step by step guide

许多软件工程师在系统设计面试（SDI）时遇到困难，主要有以下三个原因：

* SDI的非结构化特性，要求他们处理没有标准答案的开放式设计问题；
* 他们缺少开发大型可扩展系统的经验；
* 他们没有为SDI做准备。

和编码面试一样，应聘者没有有意识地为SDI做准备，大多会表现不佳，尤其是在Google、Facebook、Amazon、Microsoft等顶尖公司中。在这些公司中，表现不及平均水平的应聘者获得offer的机会很渺茫。另一方面，有良好表现的应聘者总会获得更好的offer（更高的职位和薪水），因为它展示了应聘者处理复杂系统的能力。

在这个课程中，我们将循序渐进地解决多个设计问题。首先，让我们了解以下这些步骤：

== 步骤 1: 需求说明

在我们要解决的问题的精确范围内提出问题总是一个好主意。系统设计问题大多是开放性的，他们没有一个固定的正确答案，这就是为什么面试者在一开始就说明歧义是至关重要的原因。应聘者花费足够的时间定义系统的最终目标，可以使其增加面试成功的机会。另外，由于我们只有30-40分钟来设计（假设）大型系统，因此我们应该弄清楚我们将重点放在系统的哪些部分。


让我们设计一个类似Twitter服务的实际案例来说明这个问题。在进行下一步之前，我们应该先回答下面这些问题：

* 我们服务的用户能否发布推文并关注其他人？
* 我们还应该设计去创建并展示用户的时间轴吗？
* 推文包含照片和视频吗？
* 我们只关注后端逻辑或者我们也要开发前端页面？
* 用户可以搜索推文吗？
* 我们需要显示热门话题吗？
* 对于新的或重要的推文是否要推送通知？

所有这样的问题将决定我们最终设计的外观。

== Step 2: 系统接口定义

定义系统向外暴露的API。这不仅建立了系统预期的确切目标，而且也保证我们没有错误的需求。我们类似Twitter服务的一些例子如下所示：

[source, text]
----
    postTweet(user_id,  tweet_data,  tweet_location,  user_location,  timestamp,  …)
    generateTimeline(user_id,   current_time,   user_location,   …)
    markTweetFavorite(user_id,  tweet_id,  timestamp,  …)
----

== Step 3: Back-of-the-envelope estimation
估计我们设计的系统的规模总是一个好主意。当我们将重点放在扩展、分区、负载均衡和缓存时，这将会给我们提供帮助。

* 系统预期的规模是多大（比如：新推文的数量、推文视图的数量、每秒生成的时间轴的数量等等）？
* 我们需要多大的存储空间？如果用户在他们的推文中同时包含图片和视频，我们需要有不同的账号
* 我们预期的网络带宽是多少？这对于我们如何管理服务器之间的网络传输和负载均衡很重要。


== Step 4: 定义数据模型


尽早定义数据模型将阐明数据如何在系统的不同组件之间进行传输。随后，它将指导对数据的分区和管理。候选人应该可以识别系统的不同实体，它们之间的交互方式，和数据管理的不同方面，例如存储、传输、加密等。下面是我们类似Twitter服务系统的一些实体：

[source,text]
----
User: UserID, Name, Email, DoB, CreationData, LastLogin, etc.
Tweet: TweetID, Content, TweetLocation, NumberOfLikes, TimeStamp, etc.
UserFollowo: UserdID1, UserID2
FavoriteTweets: UserID, TweetID, TimeStamp
----
我们应该使用哪种数据库？像https://en.wikipedia.org/wiki/Apache_Cassandra[Cassandra]这样的NoSQL能否满足我们的需求？或者我们应该使用类似MySQL这样的关系型数据库？我们应该使用哪种块存储来保存图片和视频？

== Step 5: 高级设计

画一个带有5-6个方框的框图，表示我们系统的核心组件。我们应该确定端到端解决实际问题所需要的足够组件。

For Twitter, at a high-level, we will need multiple application servers to serve all the read/write  requests with load balancers in front of them for traffic distributions. If we’re assuming that we will have a lot more read traffic (as compared to write), we can decide to have separate servers for handling these scenarios. On the backend, we need an efficient database that can store all the tweets and can support a huge number of reads. We will also need a distributed file storage system for storing photos and videos.


== Step 6: Detailed design
Dig deeper into two or three components; interviewer’s feedback should always guide us what parts of the system need further discussion. We should be able to present different approaches, their pros and cons, and explain why we will prefer one approach on the other. Remember there is no single answer, the only important thing is to consider tradeoffs between different options while keeping system constraints in mind.

* Since we will be storing a massive amount of data, how should we partition our data to distribute it to multiple databases? Should we try to store all the data of a user on the same database? What issue could it cause?
* How will we handle hot users who tweet a lot or follow lots of people?
* Since users’ timeline will contain the most recent (and relevant) tweets, should we try to store
our data in such a way that is optimized for scanning the latest tweets?
* How much and at which layer should we introduce cache to speed things up?
* What components need better load balancing?

== Step 7: Identifying and resolving bottlenecks
Try to discuss as many bottlenecks as possible and different approaches to mitigate them.

* Is there any single point of failure in our system? What are we doing to mitigate it?
* Do we have enough replicas of the data so that if we lose a few servers we can still serve our
users?
* Similarly, do we have enough copies of different services running such that a few failures will
not cause total system shutdown?
* How are we monitoring the performance of our service? Do we get alerts whenever critical
components fail or their performance degrades?

== Summary
In short, preparation and being organized during the interview are the keys to be successful in system design interviews. The above-mentioned steps should guide you to remain on track and cover all the different aspects while designing a system.

Let’s apply the above guidelines to design a few systems that are asked in SDIs.

[[rfc2617]]
= rfc2617 - HTTP Authentication: Basic and Digest Access Authentication

原文链接: {ietf-rfc}/ https://tools.ietf.org/html/rfc2617[RFC2617]

[NOTE]
====
本备忘录的状态

本文档为Internet社区指定了标准跟踪协议，并要求讨论并提出改进协议。请参考当前版本的“Internet官方协议标准”（STD 1）了解该协议的当前状态。本备忘录的分发是无限制的。

====

[NOTE]
====
版权声明

版权由Internet协会所有。
====

[NOTE]
====
摘要

“HTTP/1.0”包括Basic访问认证方案的规范。因为用户名和密码使用明文在网络中进行传输，因此本方案不作为用户认证的安全方法（除非结合一些外部安全系统一起使用，如SSL[5]）。该文档还提供了HTTP身份认证框架、原始的基本认证方案和基于哈希加密的方案规范，也称为“摘要访问认证”。因为，它也打算替代 https://tools.ietf.org/html/rfc2069[RFC 2069][6]。由于 https://tools.ietf.org/html/rfc2069[RFC 2069]发布以来发现的一些问题，因此移除了RFC 2069中指定的一些可选元素。为了兼容性，又添加了一些新的可选元素，并且强烈建议使用这些新的可选元素。

和Basic认证方式一样，Digest访问认证会验证通信的双方都知道的一个公钥（一个密码）；和Basic认证不同的是，它不需要以明文的方式发送密码，而这正是Basic认证最大的弱点。和大多数认证协议一样，最大的风险不是在于核心协议的本身，而是在于使用协议的策略以及使用它的过程。

====

:toc: []

[[access-authentication]]
== 1 访问认证

=== 1.1 依赖HTTP/1.1规范

该规范是HTTP/1.1规范的的补充 [2]。它使用了该文档扩充的BNF章节2.1，并且依赖该文档定义的非终端以及HTTP/1.1中的其他知识。

[[access-authentication-framework]]
=== 1.2 访问认证框架

HTTP提供一种简单的挑战应答机制，服务器可以使用它来质疑客户端的请求和客户端提供的认证信息。它使用可扩展的、不区分大小写的token来识别认证语义，然后在这个语义中使用逗号分隔的实现认证的必要参数属性-值对。

[source,text]
----
    auth-scheme    = token
    auth-param     = token "=" ( token | quoted-string )
----

服务器使用401（未经授权）的响应消息来询问用户代理的授权。此响应信息必须包含一个 `WWW-Authentication` 的响应头字段，其中至少包含一个适合的请求资源的质询。代理使用407（必须的代理认证）响应消息来质询客户端的授权，并且必须包含一个 `Proxy-Authenticate` 的响应头字段，它至少包含一个代理向请求资源的适合的询问。
[source,text]
----
    challenge   = auth-scheme 1*SP 1#auth-param
----

注意：如果 `WWW-Authentication` 或 `Proxy-Authenticate` 响应头字段中包含多个质询，或者提供了多个 `WWW-Authentication` 响应头字段，那么用户代理解析的时候一定要多加注意。因为质询的内容包含了由逗号分隔的认证参数列表。

以下是为所有认证方案定义的认证参数 `realm` :
[source, text]
----
    realm       = "realm" "=" realm-value
    realm-value = quoted-string
----

所有发出challenge的认证方案都必须有 `realm` 指令（不区分大小写）。`realm` 的值（区分大小写）和要访问的服务器的标准的根URL（abs_path为空的服务器的绝对URL地址；请参见[2]的5.1.2节）一起定义了保护空间。这些 `realm` 允许将服务器上受保护的资源划分为一组保护空间，每个保护空间有自己的认证方案和/或授权数据库。通常由源服务器指定一个字符串类型的 `realm` 值，对于认证方案来说，它可能会有特定的含义。注意，同一个认证方案使用多个 `realm` 可能会有多个challenge。

通常，用户代理希望使用源服务器对自己进行认证，但这不是必须的，在收到401（未授权）响应信息后，可以使用包含 `Authorization` 的响应头字段的请求来进行身份认证。通常，客户端希望使用代理对自己进行认证，但这不是必须的，在收到407（必需的代理认证信息）响应信息后，可以使用一个包含 `Proxy-Authentication` 的响应头字段的请求来进行认证。`Authorization` 和 `Proxy-Authentication` 的字段值由所请求资源域的客户端的认证信息组成。用户代理必须选择最合适的认证方案的challenge，并且基于该challenge向用户请求认证信息。

[source,text]
----
   credentials = auth-scheme #auth-param
----

[NOTE]
====

许多浏览器只识别Basic认证方式，并要求其成为首选的认证方案。服务器应该在最小接受的情况下，只包含Basic认证方式。

====

保护空间可以在其范围之内自动决定适用哪种凭证，如果已经有请求被授权，那么在一段时间内，该保护空间的所有其他的请求都可以使用同一个凭证，由认证方案的参数和/或者用户来指定这个时间段的大小。除非认证方案另有指定，否则单个保护空间的访问不能扩展到服务器之外。

如果源服务器不希望接收请求发送的凭据，那么它应该返回一个401（未授权）的响应信息。这个响应信息必须包含一个 `WWW-Authenticate` 的响应头字段，它至少包含一个被请求的资源的challenge（可能是新的）。如果客户端代理对请求的凭据认证失败，它应该返回一个407（必需的代理认证）的响应信息。这个响应信息必须包含一个 `Proxy-Authenticate` 响应头字段，其中包含一个适用于被请求资源的代理的challenge（可能是新的）。

HTTP协议不会限制应用程序的访问身份认证为简单的质询-响应机制。可以使用其他机制，例如在传输层使用加密，或者使用消息封装，并且使用额外的响应头字段指定认证信息。但是，该规范中没有定义这些机制。

客户端代理对由源服务器进行的用户代理身份认证必须是完全透明的。也就是说，代理必须转发未修改的 `WWW-Authenticate` 和 `Authorization` 响应头信息，并且遵守[2]中14.8章节中的规则。 `Proxy-Authenticate` 和 `Proxy-Authorization` 响应头字段都是逐跳响应头（详见[2]中13.5.1章节）。


== 2 Basic认证方案

"Basic"认证方案基于以下模型，客户端对于每一个 `realm` 必须使用用户名和密码进行认证。`realm` 的值应式是不透明的字符串，它只能在服务器上与其它 `realm` 的值进行相等比较。如果使用的用户名和密码在请求的URI的保护空间中验证通过后，那么服务器就可以为这个请求提供正常的服务。没有其他的可选参数。

对于Basic认证方式，上述框架的用法如下：

[source, text]
----
    challenge   = "Basic" realm
    credentials = "Basic" basic-credentials
----

在保护空间内的URI收到未授权的请求后，服务器可以返回如下的challenge：
[source,text]
----
    WWW-Authenticate: Basic realm="WallyWorld"
----

其中“WallyWorld”是服务器分配给请求URI的保护空间的字符串。

为了获得授权，客户端发送用户名和密码，在凭据中以base64编码，并以单个冒号分隔用户名和密码。
[source,text]
----
    basic-credentials = base64-user-pass
    base64-user-pass  = <base64 [4] 编码的用户密码, except not limited to 76 char/line>
    user-pass   = userid ":" password
    userid      = *<TEXT excluding ":">
    password    = *TEXT
----

userid区分大小写。

如果用户代理希望发送的用户名是”Aladdin“，密码是”open sesame“，那么将会使用以下响应头字段：

[source, text]
----
Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
----

客户端应该假设所有在请求URI的路径字段中的路径，或者比最后一个元素更深的路径在当前challenge的Basic realm值所指定的保护空间之内。客户端可以在请求中抢先发送相应的 `Authorization` 响应头信息来请求该保护空间的资源，而无需接收来自服务器的其他challenge。类似地，当客户端发送一个请求到代理中，它可以在 `Proxy-Authorization` 响应头字段中重用用户名和密码，无需获取来自代理服务器的其他challenge。对于Basic认证的相关安全注意事项，详见第4章。


== 3 Digest 访问认证方案
=== 3.1 介绍
==== 3.1.1 目标


